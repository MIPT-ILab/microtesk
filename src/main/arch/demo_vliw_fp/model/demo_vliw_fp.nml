/*
 * Copyright (c) 2014 ISPRAS (www.ispras.ru)
 * 
 * Institute for System Programming of Russian Academy of Sciences
 * 
 * 25 Alexander Solzhenitsyn st. Moscow 109004 Russia
 * 
 * All rights reserved.
 * 
 * demo_vliw_fp.nml, Sep 30, 2014 7:21:27 PM
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

///////////////////////////////////////////////////////////////////////////////
// Constants

let REGS = 5
let   PC = "NIA"
let   SP = "GPR[29]"

///////////////////////////////////////////////////////////////////////////////
// Types

type    INT = int(32)
type   WORD = card(32)
type  SHORT = int(16)
type  HWORD = card(16)
type  SBYTE = int(8)
type   BYTE = card(8)
type    BIT = card(1)
type  INDEX = card(REGS)
type SINGLE = float(23, 9)
type  IMM16 = int(16)
type  IMM26 = int(26)

///////////////////////////////////////////////////////////////////////////////
// Memory and Registers

reg GPR [2 ** REGS, WORD]
reg FPR [2 ** REGS, SINGLE]
mem   M [2 ** 31, BYTE]

reg NIA[WORD] // next instruction address

///////////////////////////////////////////////////////////////////////////////
// Global Variables

mem     CIA[WORD] // current instruction address
mem JMPADDR[WORD]
mem  BRANCH[WORD] 

///////////////////////////////////////////////////////////////////////////////
// Temporary Variables

var overflow_bit           [BIT]
var tmp_signed_byte        [SBYTE]
var tmp_unsigned_byte      [BYTE]
var tmp_signed_half_word   [SHORT]
var tmp_unsigned_half_word [HWORD]
var tmp_signed_word        [INT]
var tmp_unsigned_word      [WORD]

///////////////////////////////////////////////////////////////////////////////
// Addressing Modes

mode REG (r : INDEX) = GPR[r] 
  syntax = format("%d", r)
  image  = format("%5b", r)
  action = {
    if r == 0 then
      GPR[r] = coerce(WORD, 0);
    endif;
  }
  
mode FREG (r : INDEX) = FPR[r] 
  syntax = format("%d", r)
  image  = format("%5b", r)
  
///////////////////////////////////////////////////////////////////////////////
// Arithmetical Operations

op ADD (rd : REG, rs : REG, rt : REG)
  syntax = format("ADD %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000100000", rs.image, rt.image, rd.image) 
  action = {
    overflow_bit::tmp_unsigned_word = rs + rt;
    if (overflow_bit == 1) then
      // "print" ("Integer Overflow Exception");
    else
      rd = tmp_unsigned_word;
      rd.action;
    endif;
  }

op ADDI (rt : REG, rs : REG, imm : IMM16)
  syntax = format("ADDI %s, %s, %d", rt.syntax, rs.syntax, imm)
  image  = format("001000%s%s%s", rs.image, rt.image, imm)
  action = { 
    overflow_bit::tmp_unsigned_word = rs + (coerce(WORD, imm) & 0x0000ffff);
    if (overflow_bit == 1) then
      // "print" ("Integer Overflow Exception");
    else
      rt = tmp_unsigned_word;
    endif;
  }

op SUB (rd : REG, rs : REG, rt : REG)
  syntax = format("SUB %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000100010", rs.image, rt.image, rd.image) 
  action = {
    overflow_bit::tmp_unsigned_word = rs - rt;
    if (overflow_bit == 1) then
      // "print" ("Integer Overflow Exception");
    else
      rd = tmp_unsigned_word;
      rd.action;
    endif;
  }

op MUL (rd : REG, rs : REG, rt : REG)
  syntax = format("MUL %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("011100%s%s%s00000000010", rs.image, rt.image, rd.image)
  action = {
    rd = rs * rt;
    rd.action;
  }

op Arithm_Instr = ADD
                | ADDI
                | SUB
                | MUL

///////////////////////////////////////////////////////////////////////////////
// Move Operations

op MOVN (rd : REG, rs : REG, rt : REG)
  syntax = format("MOVN %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000001011", rs.image, rt.image, rd.image) 
  action = {
    if (rt != 0) then
      rd = rs;
      rd.action;
    endif;
  }

op MOVZ (rd : REG, rs : REG, rt : REG)
  syntax = format("MOVZ %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000001010", rs.image, rt.image, rd.image) 
  action = {
    if (rt == 0) then
      rd = rs;
      rd.action;
    endif;
  }

op MOVE (rd : REG, rs : REG)
  syntax = format("MOVE %s, %s", rd.syntax, rs.syntax)
  image  = format("000000%s00000%s00000100001", rd.image, rs.image)
  action = {
    rd = rs;
    rd.action;
  }

op Move_Instr = MOVN // move if not zero
              | MOVZ // move if zero    
              | MOVE // move always

///////////////////////////////////////////////////////////////////////////////
// Logical Operations

op AND (rd : REG, rs : REG, rt : REG)
  syntax = format("AND %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000100100", rs.image, rt.image, rd.image) 
  action = {
    rd = rs & rt;
    rd.action;
  }

op OR (rd : REG, rs : REG, rt : REG)
  syntax = format("OR %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000100101", rs.image, rt.image, rd.image) 
  action = {
    rd = rs | rt;
    rd.action;
  }

op XOR (rd : REG, rs : REG, rt : REG)
  syntax = format("XOR %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000100110", rs.image, rt.image, rd.image) 
  action = {
    rd = rs ^ rt;
    rd.action;
  }

op Logical_Instr = AND 
                 | OR
                 | XOR

///////////////////////////////////////////////////////////////////////////////
// Shift Operations

op SLL (rd : REG, rt : REG, sa : INDEX)
  syntax = format("SLL %s, %s, %d", rd.syntax, rt.syntax, sa)
  image  = format("00000000000%s%s%s000000", rt.image, rd.image, sa)
  action = {
    rd = rt << sa;
    rd.action;
  }

op SRA (rd : REG, rt : REG, sa : INDEX)
  syntax = format("SRA %s, %s, %d", rd.syntax, rt.syntax, sa)
  image  = format("00000000000%s%s%s000011", rt.image, rd.image, sa)
  action = {
    rd = (rt >> sa);
    rd.action;
    if (rt < 0) then
      rd = rd | (0 - (1 << (32 - sa)));
      rd.action;
    endif;
  }

op SRL (rd : REG, rt : REG, sa : INDEX)
  syntax = format("SRL %s, %s, %d", rd.syntax, rt.syntax, sa)
  image  = format("00000000000%s%s%s000010", rt.image, rd.image, sa)
  action = {
    rd = rt >> sa;
    rd.action;
    if (sa > 0) then
      rd = rd & (0x7fffffff >> (sa - 1));
      rd.action;
    endif;
  }

op SLLV (rd : REG, rs : REG, rt : REG)
  syntax = format("SLLV %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000000100", rs.image, rt.image, rd.image) 
  action = {
    rd = rt << rs<4..0>;
    rd.action;
  }

op SRAV (rd : REG, rs : REG, rt : REG)
  syntax = format("SRAV %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000000111", rs.image, rt.image, rd.image) 
  action = {
    rd = (rt >> rs<4..0>);
    rd.action;

    if ( rt < 0 ) then
      rd = rd | ( 0 - (1 << (32 - rs <4..0>)));
      rd.action;
    endif;
  }

op SRLV (rd : REG, rs : REG, rt : REG)
  syntax = format("SRLV %s, %s, %s",  rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000000110", rs.image, rt.image, rd.image) 
  action = {
    rd = rt >> rs<4..0>;
    rd.action;

    if (rs<4..0> > 0) then
      rd = rd & (0x7fffffff >> (rs<4..0> - 1));
      rd.action;
    endif;
  }

op Shift_Instr = SLL 
               | SRA 
               | SRL 
               | SLLV // shift word left logical variable
               | SRAV // shift word right arithmetic variable
               | SRLV // shift word right logical variable

op SLT (rd : REG, rs : REG, rt : REG)
  syntax = format("SLT %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%5b00000101010", rs.image, rt.image, rd.image) 
  action = {
    rd = if rs < rt then 1 else 0 endif;
    rd.action;
  }

op SLTU (rd : REG, rs : REG, rt : REG)
  syntax = format("SLTU %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%5b00000101011", rs.image, rt.image, rd.image) 
  action = {
    rd = if coerce(WORD, rs) < coerce(WORD, rt) then 1 else 0 endif;
    rd.action;
  }

op SLTI (rt : REG, rs : REG, imm : IMM16)
  syntax = format("SLTI %s, %s, %d", rt.syntax, rs.syntax, imm)
  image  = format("001010%s%s%s", rs.image, rt.image, imm)
  action = {
    rt = if rs < imm then 1 else 0 endif;
    rt.action;
  }

op SLTIU (rt : REG, rs : REG, imm : IMM16)
  syntax = format("SLTIU %s, %s, %d", rt.syntax, rs.syntax, imm)
  image  = format("001011%s%s%s", rs.image, rt.image, imm)
  action = {
    rt = if coerce(WORD, rs) < coerce (card(16), imm) then 1 else 0 endif;
    rt.action;
  }

op Set_Instr = SLT   // set on less than
             | SLTU  // set on less than unsigned
             | SLTI  // set on less than immediate
             | SLTIU // set on less than unsigned immediate	

op ALU_Instr = Arithm_Instr
             | Move_Instr
             | Logical_Instr
             | Shift_Instr
             | Set_Instr 

op ALU(x : ALU_Instr)
  syntax = x.syntax
  image  = x.image
  action = {
    CIA = NIA;

    // If condition to execute next instruction before jumping to the address.
    if BRANCH == 0 then
      NIA = NIA + 4;
    else
      NIA = JMPADDR;
      BRANCH = 0;
    endif;

    GPR[0] = 0; 
    x.action;
  }

///////////////////////////////////////////////////////////////////////////////
// Load Store Operations

op LUI (rt : REG, offset : IMM16)
  syntax = format("LUI %s, %d", rt.syntax, offset)
  image  = format("00111100000%s%s", rt.image, offset)
  action = {
    rt = offset << 16;
    rt.action;
  }

op LB (base : REG, rt : REG, offset : IMM16)
  syntax = format("LB %s, %d(%s)", rt.syntax, offset, base.syntax)
  image  = format("100000%s%s%s", base.image, rt.image, offset)
  action = {
    rt = M[base + offset];
    rt.action; 
  }

op LH (base : REG, rt : REG, offset : IMM16)
  syntax = format("LH %s, %d(%s)", rt.syntax, offset, base.syntax)
  image  = format("100001%s%s%s", base.image, rt.image, offset)
  action = {
    rt = M[base + offset + 1]::M[base + offset];
    rt.action;
  }

op LW (base : REG, rt : REG, offset : IMM16)
  syntax = format("LW %s, %d(%s)", rt.syntax, offset, base.syntax)
  image  = format("100011%s%s%s", base.image, rt.image, offset)
  action = {
    rt = M[base + offset + 3]::M[base + offset + 2]::M[base + offset + 1]::M[base + offset];
    rt.action;
  }

op Load_Instr = LUI
              | LB
              | LH
              | LW

op SB (base : REG, rt : REG, offset : IMM16)
  syntax = format("SB %s, %d(%s)", rt.syntax, offset, base.syntax)
  image  = format("101000%s%s%s", base.image, rt.image, offset)
  action = {
    M[base + offset] = rt;
  }

op SH (base : REG, rt : REG, offset : IMM16)
  syntax = format("SH %s, %d(%s)", rt.syntax , offset, base.syntax)
  image  = format("101001%s%s%s", base.image, rt.image, offset)
  action = {
     M[base + offset] = rt<0..7>;
     M[base + offset + 1] = rt<8..15>;
  }

op SW (base : REG, rt : REG, offset : IMM16)
  syntax = format("SW %s, %d(%s)", rt.syntax, offset, base.syntax)
  image  = format("101011%s%s%s", base.image, rt.image, offset)
  action = {
    M [base + offset] = rt<0..7>;
    M [base + offset + 1] = rt<8..15>;
    M [base + offset + 2] = rt<16..23>;
    M [base + offset + 3] = rt<24..31>;
  }

op Store_Instr = SB
               | SH
               | SW

op LoadStore_Instr = Load_Instr
                   | Store_Instr

op LoadStore(x : LoadStore_Instr)
  syntax = x.syntax
  image  = x.image
  action = {
    CIA = NIA;

    // If condition to execute next instruction before jumping to the address.
    if BRANCH == 0 then
      NIA = NIA + 4;
    else
      NIA = JMPADDR;
      BRANCH = 0;
    endif;

    GPR[0] = 0;
    x.action;
  }

///////////////////////////////////////////////////////////////////////////////
// Branch Operations

op B (offset : IMM16)
  syntax = format("B %d", offset)
  image  = format("0001000000000000%s", offset)
  action = {
    BRANCH = 1;
    JMPADDR = NIA + (offset << 2);
  }

op BEQ (rs : REG, rt : REG, offset : IMM16)
  syntax = format("BEQ %s, %s, %d", rs.syntax, rt.syntax, offset)
  image  = format("000100%s%s%s", rs.image, rt.image, offset)
  action = {
    if rs == rt then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 2);
    endif;
  }

op BNE (rs : REG, rt : REG, offset : IMM16)
  syntax = format("BNE %s, %s, %d", rs.syntax, rt.syntax, offset)
  image  = format("000101%s%s%s", rs.image, rt.image, offset)
  action = {
    if rs != rt then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 2);
    endif;
  }

op BEQZ (rs : REG, offset : IMM16)
  syntax = format("BEQZ %s, %d", rs.syntax, offset)
  image  = format("000100%s00000%s", rs.image, offset)
  action = {
    if rs == 0 then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 2);
    endif;
  }

op BNEZ (rs : REG, offset : IMM16)
  syntax = format("BNE %s, %d", rs.syntax, offset)
  image  = format("000101%s00000%s", rs.image, offset)
  action = {
    if rs != 0 then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 2);
    endif;
  }

op BGTZ (rs : REG, offset : IMM16)
  syntax = format("BGTZ %s, %d", rs.syntax, offset)
  image  = format("000111%s00000%s", rs.image, offset)
  action = {
    if rs > 0 then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 2);
    endif;
  }

op BGEZ (rs : REG, offset : IMM16)
  syntax = format("BGEZ %s, %d", rs.syntax, offset)	   
  image  = format("000001%s00001%s", rs.image, offset)
  action = {
    if rs >= 0 then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 2);
    endif;
  }

op BLTZ (rs : REG, offset : IMM16)
  syntax = format("BLTZ %s, %d", rs.syntax, offset)	   
  image = format("000001%s00000%s", rs.image, offset)
  action = {
    if rs < 0 then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 2);
    endif;
  }

op BLEZ (rs : REG, offset : IMM16)
  syntax = format("BLEZ %s, %d", rs.syntax, offset)
  image  = format("000110%s00000%s", rs.image, offset)
  action = {
    if rs <= 0 then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 2);
    endif;
  }

op J (target : IMM26)
  syntax = format("J %s", target)
  image  = format("000010%s", target)
  action = {
    BRANCH  = 1;
    CIA     = NIA;
    JMPADDR = (CIA & 0xF0000000) | ( target << 2);
  }

op JR (rs : REG) 
  syntax = format("JR  %s", rs.syntax)
  image  = format("000000%s000000000000000001000", rs.image)		      
  action = {
    BRANCH  = 1;
    CIA     = NIA;
    JMPADDR = rs;
  }

op Branch_Instr = B
                | BEQ
                | BNE
                | BEQZ
                | BNEZ
                | BGTZ
                | BGEZ
                | BLTZ
                | BLEZ
                | J
                | JR
          
op Branch(x : Branch_Instr)
  syntax = x.syntax
  image  = x.image
  action = {
    CIA = NIA;

    // If condition to execute next instruction before jumping to the address.
    if BRANCH == 0 then
      NIA = NIA + 4;
    else
      NIA = JMPADDR;
      BRANCH = 0;
    endif;

    GPR[0] = 0;
    x.action;
  }

///////////////////////////////////////////////////////////////////////////////
// Words Grouped by Units

op ALUWords1 (w: ALU)
  syntax = w.syntax
  image  = w.image
  action = { w.action; }

op ALUWords2 (w1: ALU, w2: ALU)
  syntax = format("%s, %s", w1.syntax, w2.syntax) 
  image  = format("%b%b", w1.image, w2.image)
  action = {
    w1.action;
    w2.action;
  }

op ALUWords3 (w1: ALU, w2: ALU, w3: ALU)
  syntax = format("%s, %s, %s", w1.syntax, w2.syntax, w3.syntax) 
  image  = format("%b%b%b", w1.image, w2.image, w3.image)
  action = {
    w1.action;
    w2.action;
    w3.action;
  }

op ALUWords = ALUWords1 | ALUWords2 | ALUWords3

op LSWords1 (w: LoadStore)
  syntax = w.syntax
  image  = w.image
  action = { w.action; }

op LSWords2 (w1: LoadStore, w2: LoadStore)
  syntax = format("%s, %s", w1.syntax, w2.syntax) 
  image  = format("%b%b", w1.image, w2.image)
  action = {
    w1.action;
    w2.action;
  }

op LSWords = LSWords1 | LSWords2

op BWords1 (w: Branch)
  syntax = w.syntax
  image  = w.image
  action = { w.action; }

op BWords2 (w1: Branch, w2: Branch)
  syntax = format("%s, %s", w1.syntax, w2.syntax) 
  image  = format("%b%b", w1.image, w2.image)
  action = {
    w1.action;
    w2.action;
  }

op BWords = BWords1 | BWords2

///////////////////////////////////////////////////////////////////////////////
// Long Word. There are three kinds of unit: ALU, Load/Store, Branch

op LongWord_ALU (alu: ALUWords)
  syntax = format("%s;", alu.syntax)
  image  = alu.image
  action = { alu.action; }

op LongWord_LS (ls: LSWords)
  syntax = format("%s;", ls.syntax)
  image  = ls.image
  action = { ls.action; }

op LongWord_B (b: BWords)
  syntax = format("%s;", b.syntax)
  image  = b.image
  action = { b.action; }

op LongWord_ALU_LS (alu: ALUWords, ls: LSWords)
  syntax = format("%s, %s;", alu.syntax, ls.syntax) 
  image  = format("%b%b", alu.image, ls.image)
  action = {
    alu.action;
    ls.action;
  }

op LongWord_ALU_B (alu: ALUWords, b: BWords)
  syntax = format("%s, %s;", alu.syntax, b.syntax) 
  image  = format("%b%b", alu.image, b.image)
  action = {
    alu.action;
    b.action;
  }

op LongWord_LS_B (ls: LSWords, b: BWords)
  syntax = format("%s, %s;", ls.syntax, b.syntax)
  image  = format("%b%b", ls.image, b.image)
  action = {
    ls.action;
    b.action;
  }

op LongWord_ALU_LS_B (alu: ALUWords, ls: LSWords, b: BWords)
  syntax = format("%s, %s, %s;", alu.syntax, ls.syntax, b.syntax)
  image  = format("%b%b%b", alu.image, ls.image, b.image)
  action = {
    alu.action;
    ls.action;
    b.action;
  }

///////////////////////////////////////////////////////////////////////////////
// Entry Point

op instruction = LongWord_ALU
               | LongWord_LS
               | LongWord_B
               | LongWord_ALU_LS
               | LongWord_ALU_B
               | LongWord_LS_B
               | LongWord_ALU_LS_B
