/*
 * Copyright (c) 2014 ISPRAS (www.ispras.ru)
 * 
 * Institute for System Programming of Russian Academy of Sciences
 * 
 * 25 Alexander Solzhenitsyn st. Moscow 109004 Russia
 * 
 * All rights reserved.
 * 
 * demo_vliw_fp.nml, Sep 30, 2014 7:21:27 PM
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

///////////////////////////////////////////////////////////////////////////////
// Constants

let REGS = 5
let   PC = "CIA"     // Program counter is in CIA 
let   SP = "GPR[29]" // Stack pointer is in GPR[29] 

///////////////////////////////////////////////////////////////////////////////
// Types

type   LONG = int(32)
type   WORD = card(32)
type  SHORT = int(16)
type  HWORD = card(16)
type  SBYTE = int(8)
type   BYTE = card(8)
type    BIT = card(1)
type  INDEX = card(REGS)
type SINGLE = float(23, 9)

type COND_CODE = card(3)

///////////////////////////////////////////////////////////////////////////////
// Memory and Registers

reg GPR [2 ** REGS, LONG]
reg FPR [2 ** REGS, SINGLE]
mem   M [2 ** 31, BYTE]

reg CIA[WORD] // Current instruction address
reg FCCR[1, LONG] // FP Condition Codes register

///////////////////////////////////////////////////////////////////////////////
// Temporary Variables (Branch-Related)

var     NIA[WORD] // Next instruction address
var JMPADDR[WORD] // Address to jump
var  BRANCH[BIT]  // Branch flag 

///////////////////////////////////////////////////////////////////////////////
// Temporary Variables (For Storing Intermediate Calculation Results)

var temp[card(33)]

///////////////////////////////////////////////////////////////////////////////
// Addressing Modes

mode R (i : INDEX) = GPR[i] 
  syntax = format("%d", i)
  image  = format("%5b", i)
  action = {
    if i == 0 then
      GPR[i] = coerce(WORD, 0);
    endif;
  }

mode F (i : INDEX) = FPR[i]
  syntax = format("%d", i)
  image  = format("%5b", i)

///////////////////////////////////////////////////////////////////////////////
// Special-Purpose Operations

op NOP()
  syntax = "NOP"
  image  = "00000000000000000000000000000000"
  action = {}

///////////////////////////////////////////////////////////////////////////////
// Arithmetical Operations

/*
  Operation ADD:

  if NotWordValue(GPR[rs]) or NotWordValue(GPR[rt]) then
    UNPREDICTABLE
  endif
  temp ← (GPR[rs]31||GPR[rs]31..0) + (GPR[rt]31||GPR[rt]31..0)
  if temp32 ≠ temp31 then
    SignalException(IntegerOverflow)
  else
    GPR[rd] ← sign_extend(temp31..0)
  endif
*/

op ADD (rd : R, rs : R, rt : R)
  syntax = format("ADD %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000100000", rs.image, rt.image, rd.image) 
  action = {
    temp = rs<31>::rs + rt<31>::rt;
    if temp<32> != temp<31> then
      // SignalException("IntegerOverflow");
    else
      rd = temp<31..0>;
    endif;
  }

/*
   Operation ADDI:

   if NotWordValue(GPR[rs]) then
     UNPREDICTABLE
   endif

   temp ← (GPR[rs]31 || GPR[rs]31..0) + sign_extend(immediate)
   if temp32 ≠ temp31 then
     SignalException(IntegerOverflow)
   else
     GPR[rt] ← sign_extend(temp31..0)
   endif
*/

op ADDI (rt : R, rs : R, imm : SHORT)
  syntax = format("ADDI %s, %s, %d", rt.syntax, rs.syntax, imm)
  image  = format("001000%s%s%s", rs.image, rt.image, imm)
  action = { 
    temp = rs<31>::rs + coerce(int(33), imm);
    if (temp<32> != temp<31>) then
      // SignalException("IntegerOverflow");
    else
      rt = temp<31..0>;
    endif;
  }

/*
   Operation SUB:

   if NotWordValue(GPR[rs]) or NotWordValue(GPR[rt]) then
     UNPREDICTABLE
   endif
   temp ← (GPR[rs]31 || GPR[rs]31..0) − (GPR[rt]31 || GPR[rt]31..0)
   if temp32 ≠ temp31 then
     SignalException(IntegerOverflow)
   else
     GPR[rd] ← sign_extend(temp31..0)
   endif
*/

op SUB (rd : R, rs : R, rt : R)
  syntax = format("SUB %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000100010", rs.image, rt.image, rd.image) 
  action = {
    temp = rs<31>::rs - rt<31>::rt;
    if temp<32> != temp<31> then
      // SignalException("IntegerOverflow");
    else
      rd = temp<31..0>;
    endif;
  }

op MUL (rd : R, rs : R, rt : R)
  syntax = format("MUL %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("011100%s%s%s00000000010", rs.image, rt.image, rd.image)
  action = {
    rd = rs * rt;
  }

///////////////////////////////////////////////////////////////////////////////
// Move Operations

op MOVN (rd : R, rs : R, rt : R)
  syntax = format("MOVN %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000001011", rs.image, rt.image, rd.image) 
  action = {
    if (rt != 0) then
      rd = rs;
    endif;
  }

op MOVZ (rd : R, rs : R, rt : R)
  syntax = format("MOVZ %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000001010", rs.image, rt.image, rd.image) 
  action = {
    if (rt == 0) then
      rd = rs;
    endif;
  }

op MOVE (rd : R, rs : R)
  syntax = format("MOVE %s, %s", rd.syntax, rs.syntax)
  image  = format("000000%s00000%s00000100001", rd.image, rs.image)
  action = {
    rd = rs;
  }

///////////////////////////////////////////////////////////////////////////////
// Logical Operations

op AND (rd : R, rs : R, rt : R)
  syntax = format("AND %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000100100", rs.image, rt.image, rd.image) 
  action = {
    rd = rs & rt;
  }

op OR (rd : R, rs : R, rt : R)
  syntax = format("OR %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000100101", rs.image, rt.image, rd.image) 
  action = {
    rd = rs | rt;
  }

op XOR (rd : R, rs : R, rt : R)
  syntax = format("XOR %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000100110", rs.image, rt.image, rd.image) 
  action = {
    rd = rs ^ rt;
  }
               
///////////////////////////////////////////////////////////////////////////////
// Comparison Operations

op SLT (rd : R, rs : R, rt : R)
  syntax = format("SLT %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%5b00000101010", rs.image, rt.image, rd.image) 
  action = {
    rd = if rs < rt then 1 else 0 endif;
  }

op SLTI (rt : R, rs : R, imm : SHORT)
  syntax = format("SLTI %s, %s, %d", rt.syntax, rs.syntax, imm)
  image  = format("001010%s%s%s", rs.image, rt.image, imm)
  action = {
    rt = if rs < imm then 1 else 0 endif;
  }

///////////////////////////////////////////////////////////////////////////////
// Load Store Operations

op LUI (rt : R, offset : SHORT)
  syntax = format("LUI %s, %d", rt.syntax, offset)
  image  = format("00111100000%s%s", rt.image, offset)
  action = {
    rt = offset << 16;
  }

op LW (base : R, rt : R, offset : SHORT)
  syntax = format("LW %s, %d(%s)", rt.syntax, offset, base.syntax)
  image  = format("100011%s%s%s", base.image, rt.image, offset)
  action = {
    rt = M[base + offset + 3]::M[base + offset + 2]::M[base + offset + 1]::M[base + offset];
  }

op SW (base : R, rt : R, offset : SHORT)
  syntax = format("SW %s, %d(%s)", rt.syntax, offset, base.syntax)
  image  = format("101011%s%s%s", base.image, rt.image, offset)
  action = {
    M [base + offset] = rt<0..7>;
    M [base + offset + 1] = rt<8..15>;
    M [base + offset + 2] = rt<16..23>;
    M [base + offset + 3] = rt<24..31>;
  }

///////////////////////////////////////////////////////////////////////////////
// Branch Operations

op B (offset : SHORT)
  syntax = format("B %d", offset)
  image  = format("0001000000000000%s", offset)
  action = {
    BRANCH = 1;
    JMPADDR = NIA + (offset << 3);
  }

op BEQ (rs : R, rt : R, offset : SHORT)
  syntax = format("BEQ %s, %s, %d", rs.syntax, rt.syntax, offset)
  image  = format("000100%s%s%s", rs.image, rt.image, offset)
  action = {
    if rs == rt then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 3);
    endif;
  }

op BNE (rs : R, rt : R, offset : SHORT)
  syntax = format("BNE %s, %s, %d", rs.syntax, rt.syntax, offset)
  image  = format("000101%s%s%s", rs.image, rt.image, offset)
  action = {
    if rs != rt then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 3);
    endif;
  }

///////////////////////////////////////////////////////////////////////////////
// Arithmetical Operations for Floating Point

op ADD_S (fd : F, fs : F, ft : F)
  syntax = format("ADD_S %s, %s, %s", fd.syntax, fs.syntax, ft.syntax)
  image  = format("01000110000%s%s%s000000", ft.image, fs.image, fd.image)
  action = {
    fd = fs + ft;
  }

op SUB_S (fd : F, fs : F, ft : F)
  syntax = format("SUB_S %s, %s, %s", fd.syntax, fs.syntax, ft.syntax)
  image  = format("01000110000%s%s%s000001", ft.image, fs.image, fd.image)
  action = {
    FPR[fd] = FPR[fs] - FPR[ft];
  }

op MUL_S (fd : F, fs : F, ft : F)
  syntax = format("MUL_S %s, %s, %s", fd.syntax, fs.syntax, ft.syntax)
  image  = format("01000110000%s%s%s000010", ft.image, fs.image, fd.image)
  action = {
    fd = fs * ft;
  }

op NEG_S (fd : F, fs : F)
  syntax = format("NEG_S %s, %s", fd.syntax, fs.syntax)
  image  = format("0100011000000000%s%s000111", fs.image, fd.image)
  action = {
    fd = -fs;
  }

op ABS_S (fd : F, fs : F)
  syntax = format("ABS_S %s, %s", fd.syntax, fs.syntax)
  image  = format("0100011000000000%s%s000101", fs.image, fd.image)
  action = {
    if (fs < 0) then 
      fd = - fs;
    else 
      fd = fs;
    endif;
  }
  
///////////////////////////////////////////////////////////////////////////////
// Comparison Operations for Floating Point

op C_EQ_S (ft : F, fs : F, cc : COND_CODE)
  syntax = format("C_EQ_S %d, %s, %s", cc, fs.syntax, ft.syntax)
  image  = format("01000110000%s%s%s00110010", ft.image, fs.image, cc) 
  action = {
    if (fs == ft) then
      FCCR<cc> = 1; 
    else
      FCCR<cc> = 0; 
    endif;
  }

op C_LT_S (ft : F, fs : F, cc : COND_CODE)
  syntax = format("C_LT_S %d, %s, %s", cc, fs.syntax, ft.syntax)
  image  = format("01000110000%s%s%s00111100", ft.image, fs.image, cc) 
  action = {
    if (fs < ft) then
      FCCR<cc> = 1; 
    else
      FCCR<cc> = 0; 
    endif;
  }

op C_LE_S (ft : F, fs : F, cc : COND_CODE)
  syntax = format("C_LE_S %d, %s, %s", cc, fs.syntax, ft.syntax)
  image  = format("01000110000%s%s%s00111110", ft.image, fs.image, cc)
  action = {
     if (fs <= ft) then
       FCCR<cc> = 1; 
     else
       FCCR<cc> = 0; 
     endif;
  }

///////////////////////////////////////////////////////////////////////////////
// Move Operations for Floating Point

op MOV_S (fd : F, fs : F)
  syntax = format("MOV_S %s, %s", fd.syntax, fs.syntax)
  image  = format("0100011000000000%s%s000110", fs.image, fd.image) 
  action = {
    fd = fs;
  }

op MTC1 (rt : R, fs : F)
  syntax = format("MTC1 %s, %s", rt.syntax, fs.syntax)
  image  = format("01000100100%s%s00000000000", rt.image, fs.image) 
  action = {
    fs = rt;    
  }

op MFC1 (rt : R, fs : F)
  syntax = format("MFC1 %s, %s", rt.syntax, fs.syntax)
  image  = format("01000100000%s%s00000000000", rt.image, fs.image) 
  action = {
    rt = fs;
  }
  
op MOVT_S (fd : F, fs : F, cc : COND_CODE)
  syntax = format("MOVT_S %s, %s", fd.syntax, fs.syntax)
  image  = format("01000110000%s01%s%s010001", cc, fs.image, fd.image) 
  action = {
    if (FCCR<cc> == 1) then
      fd = fs;    
    endif;
  }

op MOVF_S (fd : F, fs : F, cc : COND_CODE)
  syntax = format("MOVF_S %s, %s, %d", fd.syntax, fs.syntax, cc)
  image  = format("01000110000%s00%s%s010001", cc, fs.image, fd.image)
  action = {
    if (FCCR<cc> == 0) then
      fd = fs;    
    endif;
  }

op MOVN_S (fd : F, fs : F, rt : R)
  syntax = format("MOVN_S %s, %s, %s", fd.syntax, fs.syntax, rt.syntax)
  image  = format("01000110000%s%s%s010011", rt.image, fs.image, fd.image) 
  action = {
    if (rt != 0) then
      fd = fs;
    endif;
  }

op MOVZ_S (fd : F, fs : F, rt : R)
  syntax = format("MOVZ_S %s, %s, %s", fd.syntax, fs.syntax, rt.syntax)
  image  = format("01000110000%s%s%s010010", rt.image, fs.image, fd.image) 
  action = {
     if (rt == 0) then
       fd = fs;    
     endif;
  }

///////////////////////////////////////////////////////////////////////////////
// Branch Operations for Floating Point

op BC1F (cc : COND_CODE, offset : SHORT)
  syntax = format("BC1F %d, %d", cc, offset)
  image  = format("01000101000%s00%s", cc, offset)
  action = {
    if (FCCR<cc> == 0) then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 3);
    endif;
  }

op BC1T (cc : COND_CODE, offset : SHORT)
  syntax = format("BC1T %d, %s", cc, offset)
  image  = format("01000101000%s01%s", cc, offset)
  action = {
    if (FCCR<cc> == 1) then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 3);
    endif;
  }

///////////////////////////////////////////////////////////////////////////////
// Operation Groups

op ALU       = ADD  // Arithmetical operations
             | ADDI
             | SUB
             | MUL
             | MOVN // Move operations
             | MOVZ
             | MOVE
             | AND  // Logical operations
             | OR
             | XOR
             | SLT  // Comparison operations
             | SLTI

op LoadStore = LUI
             | LW
             | SW

op Branch    = B
             | BEQ
             | BNE

op FP        = ADD_S  // Arithmetical operations
             | SUB_S
             | MUL_S
             | NEG_S
             | ABS_S
             | C_EQ_S // Comparison Operations
             | C_LT_S
             | C_LE_S
             | MOV_S  // Move Operations
             | MTC1
             | MFC1
             | MOVT_S
             | MOVF_S
             | MOVN_S
             | MOVZ_S

op FPBranch  = BC1F
             | BC1T

///////////////////////////////////////////////////////////////////////////////
// Channels

// All supported operations except for NOP
op channel1 = ALU 
            | LoadStore
            | Branch
            | FP
            | FPBranch

// All supported operations except for branching operations
op channel2 = ALU 
            | LoadStore
            | FP
            | NOP

///////////////////////////////////////////////////////////////////////////////
// Very Long Instruction Word

op vliw (c1: channel1, c2: channel2)
  syntax = format("%s, %s;", c1.syntax, c2.syntax)
  image  = format("%s%s", c1.image, c2.image)
  action = {
    NIA = CIA + 8;

    GPR[0] = 0;
    c1.action;

    GPR[0] = 0;
    c2.action;

    if BRANCH == 0 then
      CIA = CIA + 8;
    else
      CIA = JMPADDR;
    endif;
  }

///////////////////////////////////////////////////////////////////////////////
// Entry Point

op instruction = vliw
