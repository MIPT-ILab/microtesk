/*
 * Copyright (c) 2014 ISPRAS (www.ispras.ru)
 * 
 * Institute for System Programming of Russian Academy of Sciences
 * 
 * 25 Alexander Solzhenitsyn st. Moscow 109004 Russia
 * 
 * All rights reserved.
 * 
 * demo_vliw_fp.nml, Sep 30, 2014 7:21:27 PM
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

///////////////////////////////////////////////////////////////////////////////
// Constants

let REGS = 5
let   PC = "NIA"     // Program counter is in NIA 
let   SP = "GPR[29]" // Stack pointer is in GPR[29] 

///////////////////////////////////////////////////////////////////////////////
// Types

type   LONG = int(32)
type   WORD = card(32)
type  SHORT = int(16)
type  HWORD = card(16)
type  SBYTE = int(8)
type   BYTE = card(8)
type    BIT = card(1)
type  INDEX = card(REGS)
type SINGLE = float(23, 9)

type COND_CODE = card(3)

///////////////////////////////////////////////////////////////////////////////
// Memory and Registers

reg GPR [2 ** REGS, LONG]
reg FPR [2 ** REGS, SINGLE]
mem   M [2 ** 31, BYTE]

reg NIA[WORD] // Next instruction address
reg FCCR[1, LONG] // FP Condition Codes register

///////////////////////////////////////////////////////////////////////////////
// Temporary Variables (Branch-Related)

var     CIA[WORD] // Current instruction address
var JMPADDR[WORD] // Address to jump
var  BRANCH[BIT]  // Branch flag 

///////////////////////////////////////////////////////////////////////////////
// Temporary Variables (For Storing Intermediate Calculation Results)

var overflow_bit           [BIT]
var tmp_signed_byte        [SBYTE]
var tmp_unsigned_byte      [BYTE]
var tmp_signed_half_word   [SHORT]
var tmp_unsigned_half_word [HWORD]
var tmp_signed_word        [LONG]
var tmp_unsigned_word      [WORD]

///////////////////////////////////////////////////////////////////////////////
// Addressing Modes

mode REG (r : INDEX) = GPR[r] 
  syntax = format("%d", r)
  image  = format("%5b", r)
  action = {
    if r == 0 then
      GPR[r] = coerce(WORD, 0);
    endif;
  }

mode FREG (r : INDEX) = FPR[r]
  syntax = format("%d", r)
  image  = format("%5b", r)

///////////////////////////////////////////////////////////////////////////////
// Special-Purpose Operations

op NOP()
  syntax = "NOP"
  image  = "00000000000000000000000000000000"
  action = {}

///////////////////////////////////////////////////////////////////////////////
// Arithmetical Operations

op ADD (rd : REG, rs : REG, rt : REG)
  syntax = format("ADD %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000100000", rs.image, rt.image, rd.image) 
  action = {
    overflow_bit::tmp_unsigned_word = rs + rt;
    if (overflow_bit == 1) then
      // "print" ("Integer Overflow Exception");
    else
      rd = tmp_unsigned_word;
    endif;
  }

op ADDI (rt : REG, rs : REG, imm : SHORT)
  syntax = format("ADDI %s, %s, %d", rt.syntax, rs.syntax, imm)
  image  = format("001000%s%s%s", rs.image, rt.image, imm)
  action = { 
    overflow_bit::tmp_unsigned_word = rs + (coerce(WORD, imm) & 0x0000ffff);
    if (overflow_bit == 1) then
      // "print" ("Integer Overflow Exception");
    else
      rt = tmp_unsigned_word;
    endif;
  }

op SUB (rd : REG, rs : REG, rt : REG)
  syntax = format("SUB %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000100010", rs.image, rt.image, rd.image) 
  action = {
    overflow_bit::tmp_unsigned_word = rs - rt;
    if (overflow_bit == 1) then
      // "print" ("Integer Overflow Exception");
    else
      rd = tmp_unsigned_word;
    endif;
  }

op MUL (rd : REG, rs : REG, rt : REG)
  syntax = format("MUL %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("011100%s%s%s00000000010", rs.image, rt.image, rd.image)
  action = {
    rd = rs * rt;
  }

///////////////////////////////////////////////////////////////////////////////
// Move Operations

op MOVN (rd : REG, rs : REG, rt : REG)
  syntax = format("MOVN %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000001011", rs.image, rt.image, rd.image) 
  action = {
    if (rt != 0) then
      rd = rs;
    endif;
  }

op MOVZ (rd : REG, rs : REG, rt : REG)
  syntax = format("MOVZ %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000001010", rs.image, rt.image, rd.image) 
  action = {
    if (rt == 0) then
      rd = rs;
    endif;
  }

op MOVE (rd : REG, rs : REG)
  syntax = format("MOVE %s, %s", rd.syntax, rs.syntax)
  image  = format("000000%s00000%s00000100001", rd.image, rs.image)
  action = {
    rd = rs;
  }

///////////////////////////////////////////////////////////////////////////////
// Logical Operations

op AND (rd : REG, rs : REG, rt : REG)
  syntax = format("AND %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000100100", rs.image, rt.image, rd.image) 
  action = {
    rd = rs & rt;
  }

op OR (rd : REG, rs : REG, rt : REG)
  syntax = format("OR %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000100101", rs.image, rt.image, rd.image) 
  action = {
    rd = rs | rt;
  }

op XOR (rd : REG, rs : REG, rt : REG)
  syntax = format("XOR %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%s00000100110", rs.image, rt.image, rd.image) 
  action = {
    rd = rs ^ rt;
  }
               
///////////////////////////////////////////////////////////////////////////////
// Comparison Operations

op SLT (rd : REG, rs : REG, rt : REG)
  syntax = format("SLT %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%5b00000101010", rs.image, rt.image, rd.image) 
  action = {
    rd = if rs < rt then 1 else 0 endif;
  }

op SLTI (rt : REG, rs : REG, imm : SHORT)
  syntax = format("SLTI %s, %s, %d", rt.syntax, rs.syntax, imm)
  image  = format("001010%s%s%s", rs.image, rt.image, imm)
  action = {
    rt = if rs < imm then 1 else 0 endif;
  }

///////////////////////////////////////////////////////////////////////////////
// Load Store Operations

op LUI (rt : REG, offset : SHORT)
  syntax = format("LUI %s, %d", rt.syntax, offset)
  image  = format("00111100000%s%s", rt.image, offset)
  action = {
    rt = offset << 16;
  }

op LW (base : REG, rt : REG, offset : SHORT)
  syntax = format("LW %s, %d(%s)", rt.syntax, offset, base.syntax)
  image  = format("100011%s%s%s", base.image, rt.image, offset)
  action = {
    rt = M[base + offset + 3]::M[base + offset + 2]::M[base + offset + 1]::M[base + offset];
  }

op SW (base : REG, rt : REG, offset : SHORT)
  syntax = format("SW %s, %d(%s)", rt.syntax, offset, base.syntax)
  image  = format("101011%s%s%s", base.image, rt.image, offset)
  action = {
    M [base + offset] = rt<0..7>;
    M [base + offset + 1] = rt<8..15>;
    M [base + offset + 2] = rt<16..23>;
    M [base + offset + 3] = rt<24..31>;
  }

///////////////////////////////////////////////////////////////////////////////
// Branch Operations

op B (offset : SHORT)
  syntax = format("B %d", offset)
  image  = format("0001000000000000%s", offset)
  action = {
    BRANCH = 1;
    JMPADDR = NIA + (offset << 3);
  }

op BEQ (rs : REG, rt : REG, offset : SHORT)
  syntax = format("BEQ %s, %s, %d", rs.syntax, rt.syntax, offset)
  image  = format("000100%s%s%s", rs.image, rt.image, offset)
  action = {
    if rs == rt then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 3);
    endif;
  }

op BNE (rs : REG, rt : REG, offset : SHORT)
  syntax = format("BNE %s, %s, %d", rs.syntax, rt.syntax, offset)
  image  = format("000101%s%s%s", rs.image, rt.image, offset)
  action = {
    if rs != rt then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 3);
    endif;
  }

///////////////////////////////////////////////////////////////////////////////
// Arithmetical Operations for Floating Point

op ADD_S (fd : FREG, fs : FREG, ft : FREG)
  syntax = format("ADD_S %s, %s, %s", fd.syntax, fs.syntax, ft.syntax)
  image  = format("01000110000%s%s%s000000", ft.image, fs.image, fd.image)
  action = {
    fd = fs + ft;
  }

op SUB_S (fd : FREG, fs : FREG, ft : FREG)
  syntax = format("SUB_S %s, %s, %s", fd.syntax, fs.syntax, ft.syntax)
  image  = format("01000110000%s%s%s000001", ft.image, fs.image, fd.image)
  action = {
    FPR[fd] = FPR[fs] - FPR[ft];
  }

op MUL_S (fd : FREG, fs : FREG, ft : FREG)
  syntax = format("MUL_S %s, %s, %s", fd.syntax, fs.syntax, ft.syntax)
  image  = format("01000110000%s%s%s000010", ft.image, fs.image, fd.image)
  action = {
    fd = fs * ft;
  }

op NEG_S (fd : FREG, fs : FREG)
  syntax = format("NEG_S %s, %s", fd.syntax, fs.syntax)
  image  = format("0100011000000000%s%s000111", fs.image, fd.image)
  action = {
    fd = -fs;
  }

op ABS_S (fd : FREG, fs : FREG)
  syntax = format("ABS_S %s, %s", fd.syntax, fs.syntax)
  image  = format("0100011000000000%s%s000101", fs.image, fd.image)
  action = {
    if (fs < 0) then 
      fd = - fs;
    else 
      fd = fs;
    endif;
  }

///////////////////////////////////////////////////////////////////////////////
// Move Operations for Floating Point

op MOV_S (fd : FREG, fs : FREG)
  syntax = format("MOV_S %s, %s", fd.syntax, fs.syntax)
  image  = format("0100011000000000%s%s000110", fs.image, fd.image) 
  action = {
    fd = fs;
  }

op MTC1 (rt : REG, fs : FREG)
  syntax = format("MTC1 %s, %s", rt.syntax, fs.syntax)
  image  = format("01000100100%s%s00000000000", rt.image, fs.image) 
  action = {
    fs = rt;    
  }

op MFC1 (rt : REG, fs : FREG)
  syntax = format("MFC1 %s, %s", rt.syntax, fs.syntax)
  image  = format("01000100000%s%s00000000000", rt.image, fs.image) 
  action = {
    rt = fs;
  }

///////////////////////////////////////////////////////////////////////////////
// Branch Operations for Floating Point

op BC1F (cc : COND_CODE, offset : SHORT)
  syntax = format("BC1F %d, %d", cc, offset)
  image  = format("01000101000%s00%s", cc, offset)
  action = {
    if (FCCR<cc> == 0) then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 3);
    endif;
  }

op BC1T (cc : COND_CODE, offset : SHORT)
  syntax = format("BC1T %d, %s", cc, offset)
  image  = format("01000101000%s01%s", cc, offset)
  action = {
    if (FCCR<cc> == 1) then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 3);
    endif;
  }

///////////////////////////////////////////////////////////////////////////////
// Operation Groups

op ALU = ADD  // Arithmetical operations
       | ADDI
       | SUB
       | MUL
       | MOVN // Move operations
       | MOVZ
       | MOVE
       | AND  // Logical operations
       | OR
       | XOR
       | SLT  // Comparison operations
       | SLTI

op LoadStore = LUI
             | LW
             | SW

op Branch = B
          | BEQ
          | BNE

op FP = ADD_S // Arithmetical operations
      | SUB_S
      | MUL_S
      | NEG_S
      | ABS_S
      | MOV_S // Move Operations
      | MTC1
      | MFC1

op FPBranch = BC1F
            | BC1T

///////////////////////////////////////////////////////////////////////////////
// Channels

// All supported operations except for NOP
op channel1 = ALU 
            | LoadStore
            | Branch
            | FP
            | FPBranch

// All supported operations except for branching operations
op channel2 = ALU 
            | LoadStore
            | FP
            | NOP

///////////////////////////////////////////////////////////////////////////////
// Very Long Instruction Word

op vliw (c1: channel1, c2: channel2)
  syntax = format("%s, %s;", c1.syntax, c2.syntax)
  image  = format("%s%s", c1.image, c2.image)
  action = {
    CIA = NIA;

    GPR[0] = 0;
    c1.action;

    GPR[0] = 0;
    c2.action;

    if BRANCH == 0 then
      NIA = NIA + 8;
    else
      NIA = JMPADDR;
    endif;
  }

///////////////////////////////////////////////////////////////////////////////
// Entry Point

op instruction = vliw
