/*
 * Copyright (c) 2014 ISPRAS (www.ispras.ru)
 * 
 * Institute for System Programming of Russian Academy of Sciences
 * 
 * 25 Alexander Solzhenitsyn st. Moscow 109004 Russia
 * 
 * All rights reserved.
 * 
 * demo.nml, Sep 30, 2014 7:21:27 PM
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

//
// TODO: change according to the customer requirements. Remove all redundant
// code. 
//

/*
  An example of a VLIW microprocessor specification based on the MIPS ISA.
*/

///////////////////////////////////////////////////////////////////////////////
// Constants

let REGS = 5
let   PC = "NIA"
let   SP = "GPR[29]"

///////////////////////////////////////////////////////////////////////////////
// Types

type QWORD = card(128)
type DWORD = card(64)
type  WORD = card(32)
type HWORD = card(16)
type  BYTE = card(8)
type   BIT = card(1)
type INDEX = card(REGS)

///////////////////////////////////////////////////////////////////////////////
// Memory and Registers

reg GPR[2 ** REGS, WORD]
mem   M[2 ** 10,   BYTE]

reg NIA[WORD] // next instruction address

///////////////////////////////////////////////////////////////////////////////
// Temporary Variables

mem     CIA[WORD]
mem JMPADDR[WORD]
mem  BRANCH[WORD] 

///////////////////////////////////////////////////////////////////////////////
// Addressing Modes

mode REG (r : INDEX) = GPR[r] 
  syntax = format("%d", r)
  image  = format("%5b", r)
  action = {
    if r == 0 then
      GPR[r] = coerce(WORD, 0);
    endif;
  }

mode IMM26 (n : int(26)) = n
  syntax = format("%d", n)
  image  = format("%26b", n)

mode IMM16 (n : int(16)) = n
  syntax = format("%d", n)
  image  = format("%16b", n)

///////////////////////////////////////////////////////////////////////////////
// ALU Operations

op ADD (rd : REG, rs : REG, rt : REG)
  syntax = format("ADD %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%5b00000100001", rs.image, rt.image, rd.image)
  action = {
    rd = rs + rt;
    rd.action;
  }

op SUB (rd : REG, rs : REG, rt : REG)
  syntax = format("SUB %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%5b00000100011", rs.image, rt.image, rd.image) 
  action = {
    rd = rs - rt;
    rd.action;
  }

op ADDI (rt : REG, rs : REG, imm : IMM16)
  syntax = format("ADDI %s, %s, %s", rt.syntax, rs.syntax, imm.syntax)
  image  = format("001001%s%5b%s", rs.image, rt.image, imm.image)
  action = {
    rt = rs + imm;
    rt.action;
  }

op Arithm_Instr = ADD  // add word
                | SUB  // subtract word 
                | ADDI // add word immediate

op MOVN (rd : REG, rs : REG, rt : REG)
  syntax = format("MOVN %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%5b00000001011", rs.image, rt.image, rd.image) 
  action = {
    if (rt != 0) then
      rd = rs;
      rd.action;
    endif;
  }

op MOVZ (rd : REG, rs : REG, rt : REG)
  syntax = format("MOVZ %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%5b00000001010", rs.image, rt.image, rd.image) 
  action = {
    if (rt == 0) then
      rd = rs;
      rd.action;
    endif;
  }

op MOVE (rd : REG, rs : REG)
  syntax = format("MOVE %s, %s", rd.syntax, rs.syntax)
  image  = format("000000%5b00000%s00000100001", rd.image, rs.image)
  action = {
    rd = rs;
    rd.action;
  }

op Move_Instr = MOVN // move conditional not zero
              | MOVZ // move conditional on zero    
              | MOVE	

op AND (rd : REG, rs : REG, rt : REG)
  syntax = format("AND %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%5b00000100100", rs.image, rt.image, rd.image) 
  action = {
    rd = rs & rt;
    rd.action;
  }

op NOR (rd : REG, rs : REG, rt : REG)
  syntax = format("NOR %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%5b00000100111", rs.image, rt.image, rd.image) 
  action = {
    rd = ~(rs | rt);
    rd.action;
  }

op OR (rd : REG, rs : REG, rt : REG)
  syntax = format("OR %s, %s, %s", rd.syntax, rs.syntax, rt.syntax )
  image  = format("000000%s%s%5b00000100101", rs.image, rt.image, rd.image) 
  action = {
    rd = rs | rt;
    rd.action;
  }

op XOR (rd : REG, rs : REG, rt : REG)
  syntax = format("XOR %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%5b00000100110", rs.image, rt.image, rd.image) 
  action = {
    rd = rs ^ rt;
    rd.action;
  }

op ANDI (rt : REG, rs : REG, imm : IMM16)
  syntax = format("ANDI %s, %s, %s", rt.syntax, rs.syntax, imm.syntax)
  image  = format("001100%s%5b%s", rs.image, rt.image, imm.image)
  action = {
    rt = (coerce(WORD, imm) & 0x0000ffff) & rs;
    rt.action;
  }

op ORI (rt : REG, rs : REG, imm : IMM16)
  syntax = format("ORI %s, %s, %s", rt.syntax, rs.syntax, imm.syntax)
  image  = format("001101%s%5b%s", rs.image, rt.image, imm.image)
  action = {
    rt = (coerce(WORD, imm) & 0x0000ffff) | rs;
    rt.action;
  }

op XORI (rt : REG, rs : REG, imm : IMM16)
  syntax = format("XORI %s, %s, %s", rt.syntax, rs.syntax, imm.syntax)
  image  = format("001110%s%5b%s", rs.image, rt.image, imm.image)
  action = {
    rt = (coerce(WORD, imm) & 0x0000ffff) ^ rs;
    rt.action;
  }

op Logical_Instr = AND  // and 
                 | NOR  // not or
                 | OR   // or
                 | XOR  // xor
                 | ANDI // and immediate
                 | ORI  // or immediate
                 | XORI // xor immediate

op SLL (rd : REG, rt : REG, sa : INDEX)
  syntax = format("SLL %s, %s, %d", rd.syntax, rt.syntax, sa)
  image  = format("00000000000%s%5b%5b000000", rt.image, rd.image, sa)
  action = {
    rd = rt << sa;
    rd.action;
  }

op SRA (rd : REG, rt : REG, sa : INDEX)
  syntax = format("SRA %s, %s, %d", rd.syntax, rt.syntax, sa)
  image  = format("00000000000%s%5b%5b000011", rt.image, rd.image, sa)
  action = {
    rd = (rt >> sa);
    rd.action;
    if (rt < 0) then
      rd = rd | (0 - (1 << (32 - sa)));
      rd.action;
    endif;
  }

op SRL (rd : REG, rt : REG, sa : INDEX)
  syntax = format("SRL %s, %s, %d", rd.syntax, rt.syntax, sa)
  image  = format("00000000000%s%5b%5b000010", rt.image, rd.image, sa)
  action = {
    rd = rt >> sa;
    rd.action;
    if (sa > 0) then
      rd = rd & (0x7fffffff >> (sa - 1));
      rd.action;
    endif;
  }

op SLLV (rd : REG, rs : REG, rt : REG)
  syntax = format("SLLV %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%5b00000000100", rs.image, rt.image, rd.image) 
  action = {
    rd = rt << rs<4..0>;
    rd.action;
  }

op SRAV (rd : REG, rs : REG, rt : REG)
  syntax = format("SRAV %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%5b00000000111", rs.image, rt.image, rd.image) 
  action = {
    rd = (rt >> rs<4..0>);
    rd.action;

    if ( rt < 0 ) then
      rd = rd | ( 0 - (1 << (32 - rs <4..0>)));
      rd.action;
    endif;
  }

op SRLV (rd : REG, rs : REG, rt : REG)
  syntax = format("SRLV %s, %s, %s",  rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%5b00000000110", rs.image, rt.image, rd.image) 
  action = {
    rd = rt >> rs<4..0>;
    rd.action;

    if (rs<4..0> > 0) then
      rd = rd & (0x7fffffff >> (rs<4..0> - 1));
      rd.action;
    endif;
  }

op Shift_Instr = SLL 
               | SRA 
               | SRL 
               | SLLV // shift word left logical variable
               | SRAV // shift word right arithmetic variable
               | SRLV // shift word right logical variable

op SLT (rd : REG, rs : REG, rt : REG)
  syntax = format("SLT %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%5b00000101010", rs.image, rt.image, rd.image) 
  action = {
    rd = if rs < rt then 1 else 0 endif;
    rd.action;
  }

op SLTU (rd : REG, rs : REG, rt : REG)
  syntax = format("SLTU %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image  = format("000000%s%s%5b00000101011", rs.image, rt.image, rd.image) 
  action = {
    rd = if coerce(WORD, rs) < coerce(WORD, rt) then 1 else 0 endif;
    rd.action;
  }

op SLTI (rt : REG, rs : REG, imm : IMM16)
  syntax = format("SLTI %s, %s, %s", rt.syntax, rs.syntax, imm.syntax)
  image  = format("001010%s%5b%s", rs.image, rt.image, imm.image)
  action = {
    rt = if rs < imm then 1 else 0 endif;
    rt.action;
  }

op SLTIU (rt : REG, rs : REG, imm : IMM16)
  syntax = format("SLTIU %s, %s, %s", rt.syntax, rs.syntax, imm.syntax)
  image  = format("001011%s%5b%s", rs.image, rt.image, imm.image)
  action = {
    rt = if coerce(WORD, rs) < coerce (card(16), imm) then 1 else 0 endif;
    rt.action;
  }

op Set_Instr = SLT   // set on less than
             | SLTU  // set on less than unsigned
             | SLTI  // set on less than immediate
             | SLTIU // set on less than unsigned immediate	

op ALU_Instr = Arithm_Instr
             | Move_Instr
             | Logical_Instr
             | Shift_Instr
             | Set_Instr 

op ALU(x : ALU_Instr)
  syntax = x.syntax
  image  = x.image
  action = {
    CIA = NIA;

    // If condition to execute next instruction before jumping to the address.
    if BRANCH == 0 then
      NIA = NIA + 4;
    else
      NIA = JMPADDR;
      BRANCH = 0;
    endif;

    GPR[0] = 0; 
    x.action;
  }

///////////////////////////////////////////////////////////////////////////////
// Load Store Operations

op LUI (rt : REG, offset : IMM16)
  syntax = format("LUI %s, %s", rt.syntax, offset.syntax)
  image  = format("00111100000%s%s", rt.image, offset.image)
  action = {
    rt = offset << 16;
    rt.action;
  }

op LB (base : REG, rt : REG, offset : IMM16)
  syntax = format("LB %s, %s(%s)", rt.syntax, offset.syntax, base.syntax)
  image  = format("100000%s%s%s", base.image, rt.image, offset.image)
  action = {
    rt = M[base + offset];
    rt.action; 
  }

op LH (base : REG, rt : REG, offset : IMM16)
  syntax = format("LH %s, %s(%s)", rt.syntax, offset.syntax, base.syntax)
  image  = format("100001%s%s%s", base.image, rt.image, offset.image)
  action = {
    rt = M[base + offset + 1]::M[base + offset];
    rt.action;
  }

op LW (base : REG, rt : REG, offset : IMM16 )
  syntax = format("LW %s, %s(%s)", rt.syntax, offset.syntax, base.syntax)
  image  = format("100011%s%s%s", base.image, rt.image, offset.image)
  action = {
    rt = M[base + offset + 3]::M[base + offset + 2]::M[base + offset + 1]::M[base + offset];
    rt.action;
  }

op Load_Instr = LUI
              | LB
              | LH
              | LW

op SB (base : REG, rt : REG, offset : IMM16)
  syntax = format("SB %s, %s(%s)", rt.syntax, offset.syntax, base.syntax)
  image  = format("101000%s%s%s", base.image, rt.image, offset.image)
  action = {
    M[base + offset] = rt;
  }

op SH (base : REG, rt : REG, offset : IMM16)
  syntax = format("SH %s, %s(%s)", rt.syntax , offset.syntax, base.syntax)
  image  = format("101001%s%s%s", base.image, rt.image, offset.image)
  action = {
     M[base + offset] = rt<0..7>;
     M[base + offset + 1] = rt<8..15>;
  }

op SW (base : REG, rt : REG, offset : IMM16)
  syntax = format("SW %s, %s(%s)", rt.syntax, offset.syntax, base.syntax)
  image  = format("101011%s%s%s", base.image, rt.image, offset.image)
  action = {
    M [base + offset] = rt<0..7>;
    M [base + offset + 1] = rt<8..15>;
    M [base + offset + 2] = rt<16..23>;
    M [base + offset + 3] = rt<24..31>;
  }

op Store_Instr = SB
               | SH
               | SW

op LoadStore_Instr = Load_Instr
                   | Store_Instr

op LoadStore(x : LoadStore_Instr)
  syntax = x.syntax
  image  = x.image
  action = {
    CIA = NIA;

    // If condition to execute next instruction before jumping to the address.
    if BRANCH == 0 then
      NIA = NIA + 4;
    else
      NIA = JMPADDR;
      BRANCH = 0;
    endif;

    GPR[0] = 0;
    x.action;
  }

///////////////////////////////////////////////////////////////////////////////
// Branch Operations

op B (offset : IMM16)
  syntax = format("B %s", offset.syntax)
  image  = format("0001000000000000%s", offset.image)
  action = {
    BRANCH = 1;
    JMPADDR = NIA + (offset << 2);
  }

op BEQ (rs : REG, rt : REG, offset : IMM16)
  syntax = format("BEQ %s, %s, %s", rs.syntax, rt.syntax, offset.syntax)
  image  = format("000100%s%s%s", rs.image, rt.image, offset.image)
  action = {
    if rs == rt then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 2);
    endif;
  }

op BNE (rs : REG, rt : REG, offset : IMM16)
  syntax = format("BNE %s, %s, %s", rs.syntax, rt.syntax, offset.syntax)
  image  = format("000101%s%s%s", rs.image, rt.image, offset.image)
  action = {
    if rs != rt then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 2);
    endif;
  }

op BEQZ (rs : REG, offset : IMM16)
  syntax = format("BEQZ %s, %s", rs.syntax, offset.syntax)
  image  = format("000100%s00000%s", rs.image, offset.image)
  action = {
    if rs == 0 then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 2);
    endif;
  }

op BNEZ (rs : REG, offset : IMM16)
  syntax = format("BNE %s, %s", rs.syntax , offset.syntax)
  image  = format("000101%s00000%s", rs.image, offset.image)
  action = {
    if rs != 0 then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 2);
    endif;
  }

op BGTZ (rs : REG, offset : IMM16)
  syntax = format("BGTZ %s, %s", rs.syntax, offset.syntax)
  image  = format("000111%s00000%s", rs.image, offset.image)
  action = {
    if rs > 0 then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 2);
    endif;
  }

op BGEZ (rs : REG, offset : IMM16)
  syntax = format("BGEZ %s, %s", rs.syntax, offset.syntax)	   
  image  = format("000001%s00001%s", rs.image, offset.image)
  action = {
    if rs >= 0 then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 2);
    endif;
  }

op BLTZ (rs : REG, offset : IMM16)
  syntax = format("BLTZ %s, %s", rs.syntax, offset.syntax)	   
  image = format("000001%s00000%s", rs.image, offset.image)
  action = {
    if rs < 0 then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 2);
    endif;
  }

op BLEZ (rs : REG, offset : IMM16)
  syntax = format("BLEZ %s, %s", rs.syntax, offset.syntax)
  image  = format("000110%s00000%s", rs.image, offset.image)
  action = {
    if rs <= 0 then
      BRANCH = 1;
      JMPADDR = NIA + (offset << 2);
    endif;
  }

op J (target : IMM26)
  syntax = format("J %s", target.syntax)
  image  = format("000010%s", target.image)
  action = {
    BRANCH  = 1;
    CIA     = NIA;
    JMPADDR = (CIA & 0xF0000000) | ( target << 2);
  }

op JR (rs : REG) 
  syntax = format("JR  %s", rs.syntax)
  image  = format("000000%s000000000000000001000", rs.image)		      
  action = {
    BRANCH  = 1;
    CIA     = NIA;
    JMPADDR = rs;
  }

op Branch_Instr = B
                | BEQ
                | BNE
                | BEQZ
                | BNEZ
                | BGTZ
                | BGEZ
                | BLTZ
                | BLEZ
                | J
                | JR
          
op Branch(x : Branch_Instr)
  syntax = x.syntax
  image  = x.image
  action = {
    CIA = NIA;

    // If condition to execute next instruction before jumping to the address.
    if BRANCH == 0 then
      NIA = NIA + 4;
    else
      NIA = JMPADDR;
      BRANCH = 0;
    endif;

    GPR[0] = 0;
    x.action;
  }

///////////////////////////////////////////////////////////////////////////////
// Words Grouped by Units

op ALUWords1 (w: ALU)
  syntax = w.syntax
  image  = w.image
  action = { w.action; }

op ALUWords2 (w1: ALU, w2: ALU)
  syntax = format("%s, %s", w1.syntax, w2.syntax) 
  image  = format("%b%b", w1.image, w2.image)
  action = {
    w1.action;
    w2.action;
  }

op ALUWords3 (w1: ALU, w2: ALU, w3: ALU)
  syntax = format("%s, %s, %s", w1.syntax, w2.syntax, w3.syntax) 
  image  = format("%b%b%b", w1.image, w2.image, w3.image)
  action = {
    w1.action;
    w2.action;
    w3.action;
  }

op ALUWords = ALUWords1 | ALUWords2 | ALUWords3

op LSWords1 (w: LoadStore)
  syntax = w.syntax
  image  = w.image
  action = { w.action; }

op LSWords2 (w1: LoadStore, w2: LoadStore)
  syntax = format("%s, %s", w1.syntax, w2.syntax) 
  image  = format("%b%b", w1.image, w2.image)
  action = {
    w1.action;
    w2.action;
  }

op LSWords = LSWords1 | LSWords2

op BWords1 (w: Branch)
  syntax = w.syntax
  image  = w.image
  action = { w.action; }

op BWords2 (w1: Branch, w2: Branch)
  syntax = format("%s, %s", w1.syntax, w2.syntax) 
  image  = format("%b%b", w1.image, w2.image)
  action = {
    w1.action;
    w2.action;
  }

op BWords = BWords1 | BWords2

///////////////////////////////////////////////////////////////////////////////
// Long Word. There are three kinds of unit: ALU, Load/Store, Branch

op LongWord_ALU (alu: ALUWords)
  syntax = format("%s;", alu.syntax)
  image  = alu.image
  action = { alu.action; }

op LongWord_LS (ls: LSWords)
  syntax = format("%s;", ls.syntax)
  image  = ls.image
  action = { ls.action; }

op LongWord_B (b: BWords)
  syntax = format("%s;", b.syntax)
  image  = b.image
  action = { b.action; }

op LongWord_ALU_LS (alu: ALUWords, ls: LSWords)
  syntax = format("%s, %s;", alu.syntax, ls.syntax) 
  image  = format("%b%b", alu.image, ls.image)
  action = {
    alu.action;
    ls.action;
  }

op LongWord_ALU_B (alu: ALUWords, b: BWords)
  syntax = format("%s, %s;", alu.syntax, b.syntax) 
  image  = format("%b%b", alu.image, b.image)
  action = {
    alu.action;
    b.action;
  }

op LongWord_LS_B (ls: LSWords, b: BWords)
  syntax = format("%s, %s;", ls.syntax, b.syntax)
  image  = format("%b%b", ls.image, b.image)
  action = {
    ls.action;
    b.action;
  }

op LongWord_ALU_LS_B (alu: ALUWords, ls: LSWords, b: BWords)
  syntax = format("%s, %s, %s;", alu.syntax, ls.syntax, b.syntax)
  image  = format("%b%b%b", alu.image, ls.image, b.image)
  action = {
    alu.action;
    ls.action;
    b.action;
  }

///////////////////////////////////////////////////////////////////////////////
// Entry Point

op instruction = LongWord_ALU
               | LongWord_LS
               | LongWord_B
               | LongWord_ALU_LS
               | LongWord_ALU_B
               | LongWord_LS_B
               | LongWord_ALU_LS_B
