/*
 * Copyright 2014 ISP RAS (http://www.ispras.ru)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

//////////////////////////////////CONSTANTS////////////////////////////////////

let REGISTER_INDEX_SIZE = 5
let PC = "CIA"

//!!!!!!!!!!!!!!!!!!!!!!!!!!
///formatting
//labels
///s

////////////////////////////////////////////////////////////////////////////////
// Types

type  BYTE = card(8)
type  WORD = int(32)
type SHORT = int(16)
type INDEX = card(5) //only 5 bits for address are required
type   BIT = card(1)

type JUMP_IMMED = card(26)

////////////////////////////////////////////////////////////////////////////////
// Registers and Memory

reg GPR [32, WORD]
reg COP0_R[32, WORD]
reg HI [WORD]
reg LO [WORD]
mem  M [2 ** 16, WORD] //32-bit 
reg CIA[WORD] //Program counter

////////////////////////////////////////////////////////////////////////////////
// Addressing Modes

mode REG (i : INDEX) = GPR[i] 
  syntax = format("$%d", i)
  image  = format("%s", i)

mode COP0 (i : INDEX) = COP0_R[i] 
  syntax = format("$%d", i)                                                                  
  image  = format("%s", i)

//////////////////////////VARIABLES////////////////////////////////////////////

mem JMPADDR[WORD] // Jump address
mem BRANCH[BIT]   //branch flag

var temp[int(33)]
var temp_jump[card(28)]
var mult_result[int(64)]
var mult_result_unsigned[card(64)]
var cia_copy[WORD]

///////////////////////////////////INSTRUCTION SET/////////////////////////////

///////////////////////////////////////////////////////////////////////////////
////ARITHMETIC


op add (rd: REG, rs: REG, rt: REG)
  syntax = format("add %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image = format("000000%s%s%s00000100000", rs.image, rt.image, rd.image)
  action = {
  // concat with greatest significant bits in each, then add
    temp = rs<31>::rs + rt<31>::rt; 
    //true, if adding led to carrying into the concatenated bit (overflow happened)
    if temp<32> != temp<31> then    
      exception("IntegerOverflow");
    else
      rd = temp<31..0>;
    endif;
  }

op addi (rt: REG, rs: REG, immed: SHORT)
  syntax = format("addi %s, %s, %d", rt.syntax, rs.syntax, immed)
  image = format("000000%s%s%d", rs.image, rt.image, immed)
  action = {
    // concat with greatest significant bits in each, then add
    temp = rs<31>::rs + coerce(int(33), immed); 
    // true, if adding led to carrying into the concatenated bit (overflow happened)
    if temp<32> != temp<31> then
      exception("IntegerOverflow");
    else
      rt = temp<31..0>;
    endif;
  }

op addu (rd: REG, rs: REG, rt: REG) //unchecked addition
  syntax = format("addu %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image = format("000000%s%s%s00000100001", rs.image, rt.image, rd.image)
  action = {
      rd = rs + rt;
  }

op addiu (rt: REG, rs: REG, immed: SHORT)
  syntax = format("addiu %s, %s, %d", rt.syntax, rs.syntax, immed)
  image = format("000000%s%s%d", rs.image, rt.image, immed)
  action = {
    rt = rs + immed;
  }

op andi (rt: REG, rs: REG, immed: SHORT)
  syntax = format("andi %s, %s, %d", rt.syntax, rs.syntax, immed)
  image = format("000000%s%s%d", rs.image, rt.image, immed)
  action = {
    rt = rs & immed;
  }

op sub (rd: REG, rs: REG, rt: REG)
  syntax = format("sub %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image = format("000000%s%s%s00000100010", rs.image, rt.image, rd.image)
  action = {
    temp = rs<31>::rs - rt<31>::rt; // concat with greatest significant bits in each, then substract
    if temp<32> != temp<31> then    // true, if substraction led to carrying into the concatenated bit (overflow happened)
      exception("IntegerOverflow");
    else
      rd = temp<31..0>;
    endif;
  }

op subu (rd: REG, rs: REG, rt: REG) //unchecked addition
  syntax = format("subu %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image = format("000000%s%s%s00000100011", rs.image, rt.image, rd.image)
  action = {

      rd = rs - rt;
  }

op mult (rs: REG, rt: REG)
  syntax = format("mult %s, %s", rs.syntax, rt.syntax)
  image = format("000000%s%s0000000000011000", rs.image, rt.image)
  action = {
    mult_result = coerce(int(64), rs) * coerce(int(64), rt);
    HI[0] = mult_result<63..32>;
    LO[0] = mult_result<31..0>;
  }

op multu (rs: REG, rt: REG)
  syntax = format("multu %s, %s", rs.syntax, rt.syntax)
  image = format("000000%s%s0000000000011001", rs.image, rt.image)
  action = {
    mult_result_unsigned = coerce(card(32), rs) * coerce(card(32), rt);
    HI[0] = mult_result_unsigned<63..32>;
    LO[0] = mult_result_unsigned<31..0>;
  }


///////////////////////////////////////////////////////////////////////////////
///////LOGICAL


op and (rd: REG, rs: REG, rt: REG)
  syntax = format("and %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image = format("000000%s%s%s00000100100", rs.image, rt.image, rd.image)
  action = {
    rd = rs & rt;
  }

op or (rd: REG, rs: REG, rt: REG)
  syntax = format("or %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image = format("000000%s%s%s00000100101", rs.image, rt.image, rd.image)
  action = {
    rd = rs | rt;
  }

op nor (rd: REG, rs: REG, rt: REG)
  syntax = format("nor %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image = format("000000%s%s%s00000100111", rs.image, rt.image, rd.image)
  action = {
    rd = ~(rs | rt);
  }

op xor (rd: REG, rs: REG, rt: REG)
  syntax = format("xor %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image = format("000000%s%s%s00000100110", rs.image, rt.image, rd.image)
  action = {
    rd = rs ^ rt;
  }

op ori (rt: REG, rs: REG, immed: SHORT)
  syntax = format("ori %s, %s, %d", rt.syntax, rs.syntax, immed)
  image = format("001101%s%s%d", rs.image, rt.image, immed)
  action = {
    rt = rs | immed;
  }

op xori (rt: REG, rs: REG, immed: SHORT)
  syntax = format("xori %s, %s, %d", rt.syntax, rs.syntax, immed)
  image = format("001110%s%s%d", rs.image, rt.image, immed)
  action = {
    rt = rs ^ immed;
  }


///////////////////////////////////////////////////////////////////////////////
//////SHIFTS


op sll (rd: REG, rt: REG, sa: card(5))
  syntax = format("sll %s, %s, %d", rd.syntax, rt.syntax, sa)
  image = format("00000000000%s%s%s000000", rt.image, rd.image, sa)
  action = {
   rd = rt << sa;
  }

op sllv (rd: REG, rt: REG, rs: REG)
  syntax = format("sllv %s, %s, %s", rd.syntax, rt.syntax, rs.syntax)
  image = format("00000000000%s%s%s000100", rt.image, rd.image, rs.image)
  action = {
   rd = rt << rs<4..0>;
  }

op sra (rd: REG, rt: REG, sa: card(5))
  syntax = format("sra %s, %s, %s", rd.syntax, rt.syntax, sa)
  image = format("00000000000%s%s%s000011", rt.image, rd.image, sa)
  action = {
   rd = coerce(int(32), rt) >> sa;
  }

op srav (rd: REG, rt: REG, rs: REG)
  syntax = format("srav %s, %s, %s", rd.syntax, rt.syntax, rs.syntax)
  image = format("00000000000%s%s%s000111", rt.image, rd.image, rs.image)
  action = {
   rd = coerce(int(32), rt) >> rs<4..0>;
  }

op srl (rd: REG, rt: REG, sa: REG)
  syntax = format("srl %s, %s, %s", rd.syntax, rt.syntax, sa.syntax)
  image = format("00000000000%s%s%s000010", rt.image, rd.image, sa.image)
  action = {
   rd = coerce(card(32), rt) >> sa;
  }

op srlv (rd: REG, rt: REG, rs: REG)
  syntax = format("srlv %s, %s, %s", rd.syntax, rt.syntax, rs.syntax)
  image = format("00000000000%s%s%s000110", rs.image, rt.image, rd.image)
  action = {
   rd = coerce(card(32), rt) >> rs<4..0>;
  }

///////////////////////////////////////////////////////////////////////////////
///MEMORY OPERATIONS


op lw (rt: REG, offset: SHORT, address: REG)
  syntax = format("lw %s, %d, %s", rt.syntax, offset, address.syntax)
  image = format("100011%s%s%s", address.image, rt.image, offset)
  action = {
    //----------!!!!!!!!!!!!!!!!!!!!
    rt = M[(address + offset) >> 2];
  }

op lui (rt: REG, immed:SHORT)
  syntax = format("lui %s, %d", rt.syntax, immed)
  image = format("001111%s%d", rt.image, immed)
  action = {
    rt = coerce(WORD, immed) << 8;
  }

op sw (rd: REG, offset: SHORT, address: REG)
  syntax = format("sw %s, %d, %s", rd.syntax, offset, address.syntax)
  image = format("101011%s%s%d", address.image, rd.image, offset)
  action = {
    M[(address + offset) >> 2] = rd;
  }

op mfhi (rd: REG)
  syntax = format("mfhi %s", rd.syntax)
  image = format("0000000000000000%s00000010000", rd.image)
  action = {
    rd = HI[0];
  }

op mflo (rd: REG)
  syntax = format("mflo %s", rd.syntax)
  image = format("0000000000000000%s00000010010", rd.image)
  action = {
    rd = LO[0];
  }

op mthi (rs: REG)
  syntax = format("mthi %s", rs.syntax)
  image = format("0000000000000000%s00000010000", rs.image)
  action = {
    HI[0] = rs;
  }

op mtlo (rs: REG)
  syntax = format("mtlo %s", rs.syntax)
  image = format("0000000000000000%s00000010010", rs.image)
  action = {
    LO[0] = rs;
  }


op swc0 (cs: COP0, offset: SHORT, address: REG)  
  syntax = format("swc0 %s, %d(%s)", cs.syntax, offset, address.syntax)
  image = format("111000%s%s%d", address.image, cs.image, offset)
  action = {
    M[(address + offset) >> 2] = cs;
  }

//-----------------------initial implementation (to be reworked)
op lwc0 (cs: COP0, offset: SHORT, address: REG)                          
  syntax = format("lwc0 %s, %d(%s)", cs.syntax, offset, address.syntax)
  image = format("110000%s%s%d", address.image, cs.image, offset)
  action = {
    cs = M[(address + offset) >> 2];
  }

//-----------------------initial implementation (to be reworked)
op mfc0 (rt: REG, cs: COP0) //move from coprocessor                      
  syntax = format("mfc0 %s, %s", rt.syntax, cs.syntax)
  image = format("01000000000%s%s00000000000", rt.image, cs.image)
  action = {
    rt = cs;
  }

//-----------------------initial implementation (to be reworked)
op mtc0 (rt: REG, cs: COP0) //move from coprocessor                      
  syntax = format("mtc0 %s, %s", rt.syntax, cs.syntax)
  image = format("01000000100%s%s00000000000", rt.image, cs.image)
  action = {
    cs = rt;
  }

///////////////////////////////////////////////////////////////////////////////
/////BRANCHING


op beq (rt: REG, rs: REG, immed: SHORT)
  syntax = format("beq %s, %s, %<label>d", rs.syntax, rt.syntax, immed)
  image = format("000100%s%s%d", rs.image, rt.image, immed)
  action = {
    if rt == rs then
      BRANCH = 1;
      JMPADDR = CIA + 4 * immed + 4;
    endif;
  }

op bgez (rs: REG, immed: SHORT)
  syntax = format("bgez %s, %<label>d", rs.syntax, immed)
  image = format("000001%s00001%d", rs.image, immed)
  action = {
    if rs >= 0 then
      BRANCH = 1;
      JMPADDR = CIA + 4 * immed + 4;
    endif;
  }

op bgezal (rs: REG, offset: SHORT)
  syntax = format("bgezal %s, %<label>d", rs.syntax, offset)
  image = format("000001%s10001%d", rs.image, offset)
  action = {
    if rs >= 0 then
      GPR[31] = CIA + 4 + 4;
      BRANCH = 1;
      JMPADDR = CIA + 4 * offset + 4;
    endif;
  }

op bgtz (rs: REG, immed: SHORT)
  syntax = format("bgtz %s, %<label>d", rs.syntax, immed)
  image = format("000111%s00000%d", rs.image, immed)
  action = {
    if rs > 0 then
      BRANCH = 1;
      JMPADDR = CIA + 4 * immed + 4;
    endif;
  }

op blez (rs: REG, immed: SHORT)
  syntax = format("blez %s, %<label>d", rs.syntax, immed)
  image = format("000110%s00000%d", rs.image, immed)
  action = {
    if rs <= 0 then
      BRANCH = 1;
      JMPADDR = CIA + 4 * immed + 4;
    endif;
  }

op bltz (rs: REG, immed: SHORT)
  syntax = format("bltz %s, %<label>d", rs.syntax, immed)
  image = format("000001%s00000%d", rs.image, immed)
  action = {
    if rs < 0 then
      BRANCH = 1;
      JMPADDR = CIA + 4 * immed + 4;
    endif;
  }

op bltzal (rs: REG, offset: SHORT)
  syntax = format("bltzal %s, %<label>d", rs.syntax, offset)
  image = format("000001%s00000%d", rs.image, offset)
  action = {
    if rs < 0 then
      GPR[31] = CIA + 4 + 4;
      BRANCH = 1;
      JMPADDR = CIA + 4 * offset + 4;
    endif;
  }

op bne (rt: REG, rs: REG, immed: SHORT)
  syntax = format("bne %s, %s, %<label>d", rt.syntax, rs.syntax, immed)
  image = format("000101%s%s%d", rt.image, rs.image, immed)
  action = {
    if rt != rs then
      BRANCH = 1;
      JMPADDR = CIA + 4 * immed + 4;
    endif;
  }

op slt (rd: REG, rs: REG, rt: REG)
  syntax = format("slt %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image = format("000000%s%s%s00000101010", rs.image, rt.image, rd.image)
  action = {
    if rs < rt then
      rd = coerce(WORD, 1);
    else
      rd = coerce(WORD, 0);
    endif;
  }

op slti (rt: REG, rs: REG, immed: SHORT)
  syntax = format("slti %s, %s, %d", rt.syntax, rs.syntax, immed)
  image = format("001010%s%s%d", rs.image, rt.image, immed)
  action = {
    if rs < immed then
      rt = coerce(WORD, 1);
    else
      rt = coerce(WORD, 0);
    endif;
  }

op sltiu (rt: REG, rs: REG, immed: SHORT)
  syntax = format("sltiu %s, %s, %d", rt.syntax, rs.syntax, immed)
  image = format("001011%s%s%d", rs.image, rt.image, immed)
  action = {
    if coerce(card(32), rs) < coerce(card(32), immed) then
      rt = coerce(WORD, 1);
    else
      rt = coerce(WORD, 0);
    endif;
  }

op sltu (rd: REG, rs: REG, rt: REG)
  syntax = format("sltu %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image = format("000000%s%s%s00000101011", rs.image, rt.image, rd.image)
  action = {
    if coerce(card(32), rs) < coerce(card(32), rt) then
      rd = coerce(WORD, 1);
    else
      rd = coerce(WORD, 0);
    endif;
  }


///////////////////////////////////////////////////////////////////////////////
//////JUMPS


op j (addr: JUMP_IMMED)
  syntax = format("j %<label>d", addr)
  image = format("000010%s", addr)
  action = {
    cia_copy = CIA + 4;                                                                    //is it correct?
    temp_jump = coerce(card(28), addr) << 2;
    BRANCH = 1;
    JMPADDR = CIA<31..28>::temp_jump;
  }

op jr (addr: REG)
  syntax = format("jr %s", addr.syntax)
  image = format("000000%s000000000000000000000", addr.image)
  action = {
    BRANCH = 1;
    JMPADDR = addr;
  }

op jal (addr: JUMP_IMMED)
  syntax = format("jal %<label>d", addr)
  image = format("000011%s", addr)
  action = {
    GPR[31] = CIA + 4 + 4;
    cia_copy = CIA + 4;                                                                    //is it correct?
    temp_jump = coerce(card(28), addr) << 2;
    BRANCH = 1;
    JMPADDR = CIA<31..28>::temp_jump;
  }

op jalr (rd: REG, rs: REG)
  syntax = format("jalr %s, %s", rs.syntax, rd.syntax)
  image = format("000000%s00000%s00000001001", rs.image, rd.image)
  action = {
    rd = CIA + 4 + 4;
    BRANCH = 1;
    JMPADDR = rs;
  }


///////////////////////////////////////////////////////////////////////////////
///////////OTHER

op syscall ()                                                                          
  syntax = format("syscall")                                                           
  image = format("0000000000000000000000000001100")                                    
  action = {
    exception("SystemCall");
  }

op cop0 (cop_fun: card(21))                                                           
  syntax = format("cop0 %s", cop_fun)
  image = format("01000000001%s", cop_fun)
  action = {
    //TO BE DEFINED
  }

op mips_break ()
  syntax = format("break")                                                           
  image = format("00000000000000000000000000001101")                         
  action = {
    exception("Breakpoint");
  }

////////////////////////////////////////////////////////////////////////////////

op Operations =  add   
                |addi  
                |addiu 
                |addu  
                |and   
                |andi  
                |beq   
                |bgez  
                |bgezal
                |bgtz
                
                |blez
                |bltz
                |bltzal
                |bne
                |mips_break
                |cop0
                |j
                |jal
                |jalr
                |jr
                
                |lui
                |lw
                |lwc0
                |mfc0
                |mfhi
                |mflo
                |mtc0
                |mthi
                |mtlo
                |mult
                
                |multu
                |nor
                |or
                |ori
                |sll
                |sllv
                |slt
                |slti
                |sltiu
                |sltu
                
                |sra
                |srav
                |srl
                |srlv
                |sub
                |subu
                |sw
                |swc0
                |syscall
                |xor
                |xori

op instruction (command: Operations)
  syntax = command.syntax
  image  = command.image
  action = {
    GPR[0] = coerce(WORD, 0);

    //such order forces to put delay slots
    if BRANCH == 0 then
      // If the flag is not set, proceeds to the next instruction 
      CIA = CIA + 4;
    else
      // Otherwise, transfers control to the jump address
      CIA = JMPADDR;
    endif;

    BRANCH = 0;
    command.action;
  }

////////////////////////////////////////////////////////////////////////////////
// Pseudo Instructions

op la(rd : REG, addr : WORD)
  syntax = format("la %s, %<label>d", rd.syntax, addr)
  image  = format("%s%s", lui(rd, addr<16..31>).image, ori(rd, rd, addr<0..15>).image)
  action = {
    instruction(lui(rd, addr<16..31>)).action;
    instruction(ori(rd, rd, addr<0..15>)).action;
  }
