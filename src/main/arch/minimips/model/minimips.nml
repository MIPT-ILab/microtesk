//////////////////////////////////CONSTANTS/////////////////////////////////////////

let REGISTER_INDEX_SIZE = 5
let DATA_WORD_SIZE = 1
let PC = "CIA"

//////////////////////////////////TYPES/////////////////////////////////////////////

type   BYTE = card(8)
type   WORD = int(32)
type  INDEX = card(3) //only 3 bits for address are required
type    BIT = card(1)

/////////////////////REGISTERS AND MEMORY//////////////////////////////////////////

reg REGISTERS [8, BYTE]
mem   M [2 ** 8, BYTE] //8-bit 
reg CIA[BYTE] //Program counter


/////////////////////////ADDRESSING MODES///////////////////////////////////////////

mode REG (i : INDEX) = REGISTERS[i] 
  syntax = format("$%d", i)
  image  = format("%5b", i) //maybe 2 bits are redundant?

//////////////////////////VARIABLES/////////////////////////////////////////////////

var JMPADDR[BYTE] // Jump address
var BRANCH[BIT]   //branch flag
var temp[card(9)]

///////////////////////////////////INSTRUCTION SET//////////////////////////////////

//ARITHMETIC
op add (rd: REG, rs: REG, rt: REG)
  syntax = format("add %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image = format("000000%s%s%s00000100000", rs.image, rt.image, rd.image)
  action = {
     
    temp = rs<7>::rs + rt<7>::rt; // concat with greatest significant bits in each, then add
    if temp<7> != temp<8> then    //true, if adding led to carrying into the concatenated bit (overflow happened)
      exception("IntegerOverflow");
    else
      rd = temp<7..0>;
    endif;


  }

op sub (rd: REG, rs: REG, rt: REG)
  syntax = format("sub %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image = format("000000%s%s%s00000100010", rs.image, rt.image, rd.image)
  action = {
    temp = rs<7>::rs - rt<7>::rt; // concat with greatest significant bits in each, then substract
    if temp<8> != temp<7> then    // true, if substraction led to carrying into the concatenated bit (overflow happened)
      exception("IntegerOverflow");
    else
      rd = temp<7..0>;
    endif;
  }

op addi (rt: REG, rs: REG, immediate: BYTE)
  syntax = format("addi %s, %s, %d", rt.syntax, rs.syntax, immediate)
  image = format("000000%s%s%d00000000", rs.image, rt.image, immediate)
  action = {
    temp = rs<7>::rs + immediate<7>::immediate; // concat with greatest significant bits in each, then add
    if temp<8> != temp<7> then             // true, if adding led to carrying into the concatenated bit (overflow happened)
      exception("IntegerOverflow");
    else
      rt = temp<7..0>;
    endif;
  }

//LOGICAL
op and (rd: REG, rs: REG, rt: REG)
  syntax = format("and %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image = format("000000%s%s%s00000100100", rs.image, rt.image, rd.image)
  action = {
     
    rd = rs & rt;

  }

op or (rd: REG, rs: REG, rt: REG)
  syntax = format("or %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image = format("000000%s%s%s00000100101", rs.image, rt.image, rd.image)
  action = {
     
    rd = rs | rt;

  }

  //MEMORY OPERATIONS
op lb (rt: REG, address: REG, offset: BYTE)
  syntax = format("lb %s, %d(%s)", rt.syntax, offset, address.syntax)
  image = format("100011%s%s%d00000000", address.image, rt.image, offset)
  action = {
     
    rt = M[address + offset * DATA_WORD_SIZE];

  }

op sb (rd: REG, address: REG, offset: BYTE)
  syntax = format("sb %s, %d(%s)", rd.syntax, offset, address.syntax)
  image = format("101011%s%s%d00000000", address.image, rd.image, offset)
  action = {

    M[address + offset * DATA_WORD_SIZE] = rd;

  }

op beq (rt: REG, rs: REG, immed: BYTE)
  syntax = format("beq %s, %s, %d", rt.syntax, rs.syntax, immed)
  image = format("000100%s%s%d00000000", rt.image, rs.image, immed)
  action = {

    if rt == rs then
      BRANCH = 1;
      JMPADDR = CIA + 4 * immed + 4;
    endif;
  }

op slt (rd: REG, rs: REG, rt: REG)
  syntax = format("slt %s, %s, %s", rd.syntax, rs.syntax, rt.syntax)
  image = format("000000%s%s%s00000101010", rs.image, rt.image, rd.image)
  action = {

    if rs < rt then
      rd = 1;
    else
      rd = 0;
    endif;
  }

op j (addr: BYTE)
  syntax = format("j %d", addr)
  image = format("000010%d000000000000000000", addr)
  action = {

    BRANCH = 1;
    JMPADDR = 4 * addr;
  }

//////////////////////////////////////////////////////////////////////////////////////

op Operations = add |
                sub |
                addi|
                and |
                or  |
                lb  | //lui
                sb  |
                beq |
                slt |
                j


op instruction (command: Operations)
  syntax = command.syntax
  image  = command.image
  action = {

    REGISTERS[0] = 0;
    BRANCH = 0;
    command.action;

    if BRANCH == 0 then
      // If the flag is not set, proceeds to the next instruction 
      CIA = CIA + 4;
    else
      // Otherwise, transfers control to the jump address
      CIA = JMPADDR;
    endif;
  }
