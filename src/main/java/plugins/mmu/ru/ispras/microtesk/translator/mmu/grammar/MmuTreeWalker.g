/*
 * Copyright 2012-2015 ISP RAS (http://www.ispras.ru)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

tree grammar MmuTreeWalker;

//==================================================================================================
// Options
//==================================================================================================

options {
  language=Java;
  tokenVocab=MmuParser;
  ASTLabelType=CommonTree;
  superClass=TreeWalkerBase;
}

@rulecatch {
catch (RecognitionException re) {
    reportError(re);
    recover(input,re);
}
}

//==================================================================================================
// Header for the Generated Java File
//==================================================================================================

@header {
/*
 * Copyright 2012-2015 ISP RAS (http://www.ispras.ru)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 *
 * WARNING: THIS FILE IS AUTOMATICALLY GENERATED. PLEASE DO NOT MODIFY IT. 
 */

package ru.ispras.microtesk.translator.mmu.grammar;

import ru.ispras.microtesk.translator.antlrex.Where;
import ru.ispras.microtesk.translator.antlrex.SemanticException;

import ru.ispras.microtesk.translator.simnml.antlrex.TreeWalkerBase;
}

//==================================================================================================
// MMU Specification
//==================================================================================================

startRule 
    : declaration*
    ;

declaration
    : address
    | buffer
    | memory
    ;

//==================================================================================================
// Address
//==================================================================================================

address
    : ^(MMU_ADDRESS ID
        (
            ^(MMU_WIDTH expr)
          | ^(MMU_SEGMENT ID expr expr)
          | ^(MMU_FORMAT ID (ID expr expr?)+)
        )*
      )
    ;

//==================================================================================================
// Buffer
//==================================================================================================

buffer
    : ^(MMU_BUFFER ID ID ID
        (
            ^(MMU_WAYS expr)
          | ^(MMU_SETS expr)
          | ^(MMU_FORMAT ID (ID expr expr?)+)
          | ^(MMU_INDEX expr)
          | ^(MMU_MATCH expr)
          | ^(MMU_POLICY ID)
        )*
      )
    ;

//==================================================================================================
// Memory
//==================================================================================================

memory
    : ^(MMU_MEMORY ID ID ID
        (
            ^(MMU_READ sequence)
          | ^(MMU_WRITE sequence)
        )*
      )
    ;

//==================================================================================================
// Common
//==================================================================================================

sequence
    : ^(SEQUENCE statement*)
    ;

statement
    : attributeCallStatement
    | assignmentStatement
    | conditionalStatement
    ;

attributeCallStatement
    :  ID
    |  ^(DOT ID ID)
    ;

assignmentStatement
    :  ^(ASSIGN location expr)
    ;

conditionalStatement
    :  ifStmt
    ;

ifStmt
    :  ^(IF expr sequence elseIfStmt* elseStmt?)
    ;

elseIfStmt
    :  ^(ELSEIF expr sequence)
    ;

elseStmt
    :  ^(ELSE sequence)
    ;

//==================================================================================================

expr
    :  numExpr[0]
    ;

numExpr [int depth]
    :  binaryExpr[depth]
    |  unaryExpr[depth]
    |  atom
    ;

binaryExpr [int depth]
    :  ^(OR            numExpr[depth+1] numExpr[depth+1])
    |  ^(AND           numExpr[depth+1] numExpr[depth+1])
    |  ^(VERT_BAR      numExpr[depth+1] numExpr[depth+1])
    |  ^(UP_ARROW      numExpr[depth+1] numExpr[depth+1])
    |  ^(AMPER         numExpr[depth+1] numExpr[depth+1])
    |  ^(EQ            numExpr[depth+1] numExpr[depth+1])
    |  ^(NEQ           numExpr[depth+1] numExpr[depth+1])
    |  ^(LEQ           numExpr[depth+1] numExpr[depth+1])
    |  ^(GEQ           numExpr[depth+1] numExpr[depth+1])
    |  ^(LEFT_BROCKET  numExpr[depth+1] numExpr[depth+1])
    |  ^(RIGHT_BROCKET numExpr[depth+1] numExpr[depth+1])
    |  ^(LEFT_SHIFT    numExpr[depth+1] numExpr[depth+1])
    |  ^(RIGHT_SHIFT   numExpr[depth+1] numExpr[depth+1])
    |  ^(ROTATE_LEFT   numExpr[depth+1] numExpr[depth+1])
    |  ^(ROTATE_RIGHT  numExpr[depth+1] numExpr[depth+1])
    |  ^(PLUS          numExpr[depth+1] numExpr[depth+1])
    |  ^(MINUS         numExpr[depth+1] numExpr[depth+1])
    |  ^(MUL           numExpr[depth+1] numExpr[depth+1])
    |  ^(DIV           numExpr[depth+1] numExpr[depth+1])
    |  ^(REM           numExpr[depth+1] numExpr[depth+1])
    |  ^(DOUBLE_STAR   numExpr[depth+1] numExpr[depth+1])
    ;

unaryExpr [int depth]
    :  ^(UPLUS  numExpr[depth+1])
    |  ^(UMINUS numExpr[depth+1])
    |  ^(TILDE  numExpr[depth+1])
    |  ^(NOT    numExpr[depth+1])
    ;

atom 
    :  constant
    |  location
    ;

constant
    : CARD_CONST
    | BINARY_CONST
    | HEX_CONST
    ;

//==================================================================================================

location 
    :  ^(LOCATION locationExpr[0])
    ;

locationExpr [int depth]
    :  ^(DOUBLE_COLON locationVal locationExpr[depth+1])
    |  locationVal
    ;

locationVal
    :  ^(LOCATION_BITFIELD locationAtom expr expr?)
    |  locationAtom
    ;

locationAtom
    :  ID
    |  ^(DOT ID ID)
    ;

//==================================================================================================
// The End
//==================================================================================================
