/*
 * Copyright 2012-2015 ISP RAS (http://www.ispras.ru)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

tree grammar MmuTreeWalker;

//==================================================================================================
// Options
//==================================================================================================

options {
  language=Java;
  tokenVocab=MmuParser;
  ASTLabelType=CommonTree;
  superClass=MmuTreeWalkerBase;
}

@rulecatch {
catch (SemanticException se) {
    reportError(se);
    recover(input,se);
}
catch (RecognitionException re) {
    reportError(re);
    recover(input,re);
}
}

//==================================================================================================
// Header for the Generated Java File
//==================================================================================================

@header {
/*
 * Copyright 2012-2015 ISP RAS (http://www.ispras.ru)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 *
 * WARNING: THIS FILE IS AUTOMATICALLY GENERATED. PLEASE DO NOT MODIFY IT. 
 */

package ru.ispras.microtesk.translator.mmu.grammar;

import static ru.ispras.microtesk.utils.PrintingUtils.trace;

import ru.ispras.fortress.expression.Node;
import ru.ispras.fortress.expression.NodeValue;

import ru.ispras.microtesk.translator.antlrex.Where;
import ru.ispras.microtesk.translator.antlrex.SemanticException;

import ru.ispras.microtesk.translator.mmu.MmuTreeWalkerBase;
import ru.ispras.microtesk.translator.mmu.MmuSymbolKind;
import ru.ispras.microtesk.translator.mmu.ir.Entry;
}

//==================================================================================================
// MMU Specification
//==================================================================================================

startRule 
    : declaration*
    ;

declaration
    : address
    | segment
    | buffer
    | mmu
    ;

//==================================================================================================
// Address
//==================================================================================================

address
    : ^(MMU_ADDRESS addressId=ID {declare($addressId, MmuSymbolKind.ADDRESS, false);} width=expr[0])
      {newAddress($addressId, $width.res);}
    ;

//==================================================================================================
// Segment
//==================================================================================================

segment
    : ^(MMU_SEGMENT segmentId=ID {declareAndPushSymbolScope($segmentId, MmuSymbolKind.SEGMENT);} 
        addressArgId=ID {declare($addressArgId, MmuSymbolKind.ARGUMENT, false);} addressArgType=ID
        ^(MMU_RANGE from=expr[0] to=expr[0])
      ) {newSegment($segmentId, $addressArgId, $addressArgType, $from.res, $to.res);}
    ; finally {popSymbolScope();}

//==================================================================================================
// Buffer
//==================================================================================================

buffer
    : ^(MMU_BUFFER bufferId=ID {declareAndPushSymbolScope($bufferId, MmuSymbolKind.BUFFER);}
        addressArgId=ID {declare($addressArgId, MmuSymbolKind.ARGUMENT, false);} addressArgType=ID
        {final BufferBuilder builder = newBufferBuilder($bufferId, $addressArgId, $addressArgType);}
        (
            ^(w=MMU_WAYS ways=expr[0]) {builder.setWays($w, $ways.res);}
          | ^(w=MMU_SETS sets=expr[0]) {builder.setSets($w, $sets.res);}
          | ^(w=MMU_ENTRY e=entry)     {builder.setEntry($w, $e.res);}
          | ^(MMU_INDEX index=expr[0]) {builder.setIndex($index.res);}
          | ^(MMU_MATCH match=expr[0]) {builder.setMatch($match.res);}
          | ^(w=MMU_POLICY policyId=ID){builder.setPolicyId($w, $policyId);}
        )*
        {builder.build();}
      )
    ; finally {popSymbolScope();}

entry returns [Entry res]
@init {final EntryBuilder builder = newEntryBuilder();}
@after {$res = builder.build();} 
    : (fieldId=ID {declare($fieldId, MmuSymbolKind.FIELD, false);}
      size=expr[0] value=expr[0]? {builder.addField($fieldId, $size.res, $value.res);})+
    ;

//==================================================================================================
// Memory
//==================================================================================================

mmu
    : ^(MMU memoryId=ID {declareAndPushSymbolScope($memoryId, MmuSymbolKind.MEMORY);}
        addressArgId=ID {declare($addressArgId, MmuSymbolKind.ARGUMENT, false);} addressArgType=ID
        dataArgId=ID {declare($dataArgId, MmuSymbolKind.DATA, false);}
        {final MemoryBuilder builder = newMemoryBuilder($memoryId, $addressArgId, $addressArgType, $dataArgId);}
        (^(MMU_VAR mmuVar))*
        (ID sequence)*
        {builder.build();}
      )
    ; finally {popSymbolScope();}

mmuVar
    : varId=ID {declare($varId, MmuSymbolKind.VAR, false);} (ID | expr[0])
    ;

//==================================================================================================
// Statements
//==================================================================================================

sequence
    : ^(SEQUENCE statement*)
    ;

statement
    : attributeCallStatement
    | assignmentStatement
    | conditionalStatement
    | functionCallStatement
    ;

attributeCallStatement
    : ID
    | ^(DOT ID ID)
    | ^(INSTANCE_CALL ^(INSTANCE ID expr[0]*) ID?)
    ;

assignmentStatement
    : ^(ASSIGN variable expr[0])
    ;

conditionalStatement
    : ifStmt
    ;

ifStmt
    : ^(IF expr[0] sequence elseIfStmt* elseStmt?)
    ;

elseIfStmt
    : ^(ELSEIF expr[0] sequence)
    ;

elseStmt
    : ^(ELSE sequence)
    ;

functionCallStatement
    :  ^(EXCEPTION STRING_CONST)
    ;

//==================================================================================================
// Expressions
//==================================================================================================

expr [int depth] returns [Node res]
@after {
$res = n;
}
    : n=atom
    | n=binaryExpr[depth+1]
    | n=unaryExpr[depth+1]
//  | ifExpr[depth+1]
    ;

ifExpr [int depth]
    : ^(IF expr[depth] expr[depth] elseIfExpr[depth]* elseExpr[depth]?)
    ;

elseIfExpr [int depth]
    : ^(ELSEIF expr[depth] expr[depth])
    ;

elseExpr [int depth]
    : ^(ELSE expr[depth])
    ;

binaryExpr [int depth] returns [Node res]
    : ^(OR            expr[depth+1] expr[depth+1])
    | ^(AND           expr[depth+1] expr[depth+1])
    | ^(VERT_BAR      expr[depth+1] expr[depth+1])
    | ^(UP_ARROW      expr[depth+1] expr[depth+1])
    | ^(AMPER         expr[depth+1] expr[depth+1])
    | ^(EQ            expr[depth+1] expr[depth+1])
    | ^(NEQ           expr[depth+1] expr[depth+1])
    | ^(LEQ           expr[depth+1] expr[depth+1])
    | ^(GEQ           expr[depth+1] expr[depth+1])
    | ^(LEFT_BROCKET  expr[depth+1] expr[depth+1])
    | ^(RIGHT_BROCKET expr[depth+1] expr[depth+1])
    | ^(LEFT_SHIFT    expr[depth+1] expr[depth+1])
    | ^(RIGHT_SHIFT   expr[depth+1] expr[depth+1])
    | ^(ROTATE_LEFT   expr[depth+1] expr[depth+1])
    | ^(ROTATE_RIGHT  expr[depth+1] expr[depth+1])
    | ^(PLUS          expr[depth+1] expr[depth+1])
    | ^(MINUS         expr[depth+1] expr[depth+1])
    | ^(MUL           expr[depth+1] expr[depth+1])
    | ^(DIV           expr[depth+1] expr[depth+1])
    | ^(REM           expr[depth+1] expr[depth+1])
    | ^(DOUBLE_STAR   expr[depth+1] expr[depth+1])
    ;

unaryExpr [int depth] returns [Node res]
    : ^(UPLUS  expr[depth+1])
    | ^(UMINUS expr[depth+1])
    | ^(TILDE  expr[depth+1])
    | ^(NOT    expr[depth+1])
    ;

atom returns [Node res]
@after {
$res = n;
}
    : n=constant 
    | n=variable
    ;

//==================================================================================================
// Constant    
//==================================================================================================

constant returns [Node res]
@init {
int radix = 10;
}
@after {
$res = NodeValue.newInteger($t.text, radix);
}
    : t=CARD_CONST   { radix = 10; }
    | t=BINARY_CONST { radix = 2; }
    | t=HEX_CONST    { radix = 16; }
    ;

//==================================================================================================
// Variable
//==================================================================================================

variable returns [Node res]
    : ^(LOCATION v=variableConcat[0]) { $res=v; }
    ;

variableConcat [int depth] returns [Node res]
    : ^(DOUBLE_COLON variableBitfield variableConcat[depth+1])
    | vb=variableBitfield { $res=vb; }
    ;

variableBitfield returns [Node res]
    : ^(LOCATION_BITFIELD variableAtom expr[0] expr[0]?)
    | va=variableAtom  { $res=va; }
    ;

variableAtom returns [Node res]
    : ID
    | ^(DOT ID ID)
    | ^(LOCATION_INDEX ID expr[0])
    | ^(INSTANCE_CALL ^(INSTANCE ID expr[0]*) ID?)
    ;

//==================================================================================================
// The End
//==================================================================================================
