/*
 * Copyright 2012-2015 ISP RAS (http://www.ispras.ru)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

parser grammar MmuParser;

//==================================================================================================
// Options
//==================================================================================================

options {
  language=Java;
  tokenVocab=MmuLexer;
  output=AST;
  superClass=ParserBase;
  backtrack=true;
}

import commonParser=CommonParser;

//==================================================================================================
// Header for the Generated Java File
//==================================================================================================

@header {
/*
 * Copyright 2012-2015 ISP RAS (http://www.ispras.ru)
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 *
 * WARNING: THIS FILE IS AUTOMATICALLY GENERATED. PLEASE DO NOT MODIFY IT. 
 */

package ru.ispras.microtesk.mmu.translator.grammar;

import ru.ispras.microtesk.translator.antlrex.ParserBase;
import ru.ispras.microtesk.translator.nml.NmlSymbolKind;
}

@members {
  boolean isInBitField() {
    return commonParser.isInBitField();
  }

  void setInBitField(boolean value) {
    commonParser.setInBitField(value);
  }
}

//==================================================================================================
// MMU Specification
//==================================================================================================

startRule 
    : declaration* EOF!
    ;

declaration
    : let
    | struct
    | address
    | segment
    | buffer
    | mmu
    ;

//==================================================================================================
// Let
//==================================================================================================

let
    : MMU_LET^ id=ID ASSIGN! expr {declare($id, NmlSymbolKind.LET_CONST, false);}
    ;

fields
    : field (COMMA! field)*
    ;

field
    : ID COLON! typeRef
    ;

typeRef
    : ID
    | expr (ASSIGN! expr)?
    ;

//==================================================================================================
// Struct
//==================================================================================================

struct
    : MMU_STRUCT^ ID LEFT_PARENTH! fields RIGHT_PARENTH!
    ;

//==================================================================================================
// Address
//==================================================================================================

address
    : MMU_ADDRESS^ ID LEFT_PARENTH! addressType RIGHT_PARENTH! (COLON! addressValue)?
    ;

addressType
    : fields -> ^(MMU_STRUCT fields)
    | ID
    ;

addressValue
    : ID (DOT! ID)*
    ;

//==================================================================================================
// Segment
//==================================================================================================

segment
    : MMU_SEGMENT^ ID nameType ASSIGN! nameType
        range
        (mmuVariable)*
        (mmuFunction)?
    ;

nameType
    : LEFT_PARENTH! ID COLON! ID RIGHT_PARENTH!
    ;

//--------------------------------------------------------------------------------------------------

range
    : MMU_RANGE^ ASSIGN! LEFT_PARENTH! expr COMMA! expr RIGHT_PARENTH!
    ;

//==================================================================================================
// Buffer
//==================================================================================================

buffer
    : MMU_BUFFER^ ID LEFT_PARENTH! ID COLON! ID RIGHT_PARENTH! (MMU_VIEWOF! ID)?
        (bufferParameter)*
    ;

bufferParameter
    : ways
    | sets
    | entry
    | index
    | match
    | policy
    | guard
    ;

//--------------------------------------------------------------------------------------------------

ways
    : MMU_WAYS^ ASSIGN! expr
    ;

//--------------------------------------------------------------------------------------------------

sets
    : MMU_SETS^ ASSIGN! expr
    ;

//--------------------------------------------------------------------------------------------------

entry
    : MMU_ENTRY^ ASSIGN! LEFT_PARENTH! fields RIGHT_PARENTH!
    ;

//--------------------------------------------------------------------------------------------------

index
    : MMU_INDEX^ ASSIGN! expr
    ;

//--------------------------------------------------------------------------------------------------

match
    : MMU_MATCH^ ASSIGN! expr
    ;

//--------------------------------------------------------------------------------------------------

policy
    : MMU_POLICY^ ASSIGN! ID
    ;

//--------------------------------------------------------------------------------------------------

guard
    : MMU_GUARD^ ASSIGN! expr
    ;

//==================================================================================================
// MMU Logic
//==================================================================================================

mmu
    : MMU^ ID LEFT_PARENTH! ID COLON! ID RIGHT_PARENTH! ASSIGN!
              LEFT_PARENTH! ID COLON! expr RIGHT_PARENTH!
        (mmuVariable)*
        (mmuFunction)*
    ;

mmuVariable
    : MMU_VAR^ ID COLON! mmuVariableType SEMI!
    ;

mmuVariableType
    : ID (DOT MMU_ENTRY)? -> ID
    | expr
    ;

mmuFunction
    : ID ASSIGN! LEFT_BRACE! sequence RIGHT_BRACE!
    ;

//==================================================================================================
// The End
//==================================================================================================
