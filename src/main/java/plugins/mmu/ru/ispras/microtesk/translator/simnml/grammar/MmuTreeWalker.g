/*======================================================================================*/
/* README SECTION                                                                       */
/*                                                                                      */
/* TODO:                                                                                */
/* - Brief description of the tree rules' structure and format                          */
/* - Instructions on how to debug and extend the rules                                  */
/* - "TODO" notes                                                                       */     
/*======================================================================================*/

tree grammar MmuTreeWalker;

/*======================================================================================*/
/* Options                                                                              */
/*======================================================================================*/

options {
  language=Java;
  tokenVocab=MmuParser;
  ASTLabelType=CommonTree;
  superClass=TreeWalkerBase;
}

@rulecatch {
catch(SemanticException se) {
    reportError(se);
    recover(input,se);
}
catch (RecognitionException re) { // Default behavior
    reportError(re);
    recover(input,re);
}
}

/*======================================================================================*/
/* Header for the generated tree walker Java class file (header comments, imports, etc).*/
/*======================================================================================*/

@header {
/*
 * Copyright (c) 2012 ISPRAS (www.ispras.ru)
 * 
 * Institute for System Programming of Russian Academy of Sciences
 * 
 * 25 Alexander Solzhenitsyn st. Moscow 109004 Russia
 * 
 * All rights reserved.
 *
 * WARNING: THIS FILE IS AUTOMATICALLY GENERATED. PLEASE DO NOT MODIFY IT. 
 */

package ru.ispras.microtesk.translator.simnml.grammar;
import ru.ispras.microtesk.translator.antlrex.SemanticException;

import ru.ispras.microtesk.translator.simnml.antlrex.TreeWalkerBase;

import ru.ispras.microtesk.translator.antlrex.Where;
import ru.ispras.microtesk.translator.antlrex.SemanticException;

import ru.ispras.microtesk.translator.simnml.antlrex.TreeWalkerBase;
import ru.ispras.microtesk.translator.simnml.ESymbolKind;
import ru.ispras.microtesk.model.api.memory.Memory;

import ru.ispras.microtesk.translator.simnml.ir.*;
import ru.ispras.microtesk.translator.simnml.ir.expression.*;
import ru.ispras.microtesk.translator.simnml.ir.location.*;
import ru.ispras.microtesk.translator.simnml.ir.shared.*;
import ru.ispras.microtesk.translator.simnml.ir.primitive.*;
import ru.ispras.microtesk.translator.simnml.ir.valueinfo.*;
}

/*======================================================================================*/
/* Members of the generated tree walker class.                                          */
/*======================================================================================*/

@members {
}

/*======================================================================================*/
/* Root Rules of Processor Specification                                                */ 
/*======================================================================================*/

startRule 
	:  bufferoraddress*
	;
	
bufferoraddress
    :  addressRule
    |  bufferRule
    ;

addressRule
@init {
System.out.println("MMu: " + $addressRule.text);
}
	:  address
	;

bufferRule 
@init {
System.out.println("MMu: " + $bufferRule.text);
}
    :  buffer
    ;
  
/*=======================================================================================*/
/* Address Rules                                                                         */
/*=======================================================================================*/
    
address
			:  ^(ADDRESS id=ID addr=constExpr)
  
{
checkNotNull($id, $addr.res, $addr.text);
//getIR().add($id.text, $addr.res);
}
			;
			
/*======================================================================================*/
/* Buffer Rules                                                                         */
/*======================================================================================*/

buffer
    		:  ^(BUFFER id=ID buf=constExpr)
{  
checkNotNull($id, $buf.res, $buf.text);
//getIR().add($id.text, $buf.res);

System.out.println("buf OK!");
}
    ;

parameter returns [Expr res]
:	as=associativity
//|	s=sets
//|	l=line
//|	in=index
//|	ma=match
//|	po=policy  
;

	
/*======================================================================================*/
/* Associativity Sets Rules                                                                     */
/*======================================================================================*/

associativity returns [Expr res]
	:  ^(id=ASSOCIATIVITY ass=constExpr) {$res = $ass.res; }
{ 
checkNotNull($id, $ass.res, $ass.text);
//getIR().add($id.text, $ass.res);

System.out.println("associativity OK!");
}
;

/*======================================================================================*/
/* Constant Rules                                                                       */
/*======================================================================================*/

constExpr returns [Expr res]
    :  e=expr[ValueInfo.Kind.NATIVE, 0]
{
checkNotNull($e.start, $e.res, $e.text);
$res = getExprFactory().evaluateConst(where($e.start), $e.res);
}
    ;
    
    
    
    
    
    
    
    
    
    
    
    
/*======================================================================================*/
/* Type Rules                                                                           */
/*======================================================================================*/

typeDef
    :  ^(TYPE id=ID te=typeExpr)
{
checkNotNull($id, $te.res, $te.text);
//getIR().add($id.text, $te.res);
}
    ;

typeExpr returns [Type res]
    :   id=ID { $res=getTypeFactory().newAlias(where($id), $id.text); }
//  |   BOOL                       // TODO: NOT SUPPORTED IN THIS VERSION
    |   ^(t=INT   n=sizeExpr) { $res=getTypeFactory().newInt(where($t), $n.res); }
    |   ^(t=CARD  n=sizeExpr) { $res=getTypeFactory().newCard(where($t), $n.res); }
    |   ^(t=FIX   n=sizeExpr m=sizeExpr)
            { $res=getTypeFactory().newFix(where($t), $n.res, $m.res); }
    |   ^(t=FLOAT n=sizeExpr m=sizeExpr)
            { $res=getTypeFactory().newFloat(where($t), $n.res, $m.res); }
//  |   ^(t=RANGE n=staticJavaExpr m=staticJavaExpr) // TODO: NOT SUPPORTED IN THIS VERSION
    ;

    
    
sizeExpr returns [Expr res]
    :  e=expr[ValueInfo.Kind.NATIVE, 0]
{
checkNotNull($e.start, $e.res, $e.text);
$res = getExprFactory().evaluateSize(where($e.start), $e.res);
}
    ;

indexExpr returns [Expr res]
    :  e=expr[ValueInfo.Kind.NATIVE, 0]
{
checkNotNull($e.start, $e.res, $e.text);
$res = getExprFactory().evaluateIndex(where($e.start), $e.res);
}
    ;

logicExpr returns [Expr res]
    :  e=expr[ValueInfo.Kind.NATIVE, 0]
{
checkNotNull($e.start, $e.res, $e.text);
$res = getExprFactory().evaluateLogic(where($e.start), $e.res);
}
    ;

dataExpr returns [Expr res]
    :  e=expr[ValueInfo.Kind.MODEL, 0]
{
checkNotNull($e.start, $e.res, $e.text);
$res = getExprFactory().evaluateData(where($e.start), $e.res);
}
    ;   

/*======================================================================================*/
/* Expression rules                                                                     */
/*======================================================================================*/

expr [ValueInfo.Kind target, int depth] returns [Expr res]
@after {$res = $e.res;}
    : e=nonNumExpr[target, depth]
    | e=numExpr[target, depth]
    ;

/*======================================================================================*/
/* Non-numeric expressions (TODO: temporary implementation)                             */
/*======================================================================================*/

nonNumExpr [ValueInfo.Kind target, int depth] returns [Expr res]
@after {$res = $e.res;}
    : e=ifExpr[target, depth]   
    ;

ifExpr [ValueInfo.Kind target, int depth] returns [Expr res]
@init  {final List<Condition> conds = new ArrayList<Condition>();}
    :  ^(op=IF cond=logicExpr e=expr[target, depth]
{
checkNotNull($cond.start, $cond.res, $cond.text);
checkNotNull($e.start, $e.res, $e.text);
conds.add(Condition.newIf($cond.res, $e.res));
}
       (eifc=elseIfExpr[target, depth]
{
checkNotNull($eifc.start, $eifc.res, $eifc.text);
conds.add($eifc.res);
})*
       (elsc=elseExpr[target, depth]
{
checkNotNull($elsc.start, $elsc.res, $elsc.text);
conds.add($elsc.res);
})?)
{
$res = getExprFactory().condition(where($op), conds);
}
    ;

elseIfExpr [ValueInfo.Kind target, int depth] returns [Condition res]
    :  ^(ELSEIF cond=logicExpr e=expr[target, depth]) {$res=Condition.newIf($cond.res, $e.res);}
    ;

elseExpr [ValueInfo.Kind target, int depth] returns [Condition res]
    :  ^(ELSE e=expr[target, depth]) {$res=Condition.newElse($e.res);}
    ;

/*======================================================================================*/
/* Numeric expressions                                                                  */
/*======================================================================================*/
    
numExpr [ValueInfo.Kind target, int depth] returns [Expr res]
@after {$res = $e.res;}
    :  e=binaryExpr[target, depth]
    |   e=unaryExpr[target, depth]
    |        e=atom
    ;

binaryExpr [ValueInfo.Kind target, int depth] returns [Expr res]
@after
{
checkNotNull($e1.start, $e1.res, $e1.text);
checkNotNull($e2.start, $e2.res, $e2.text);
$res = getExprFactory().operator(where($op), target, $op.text, $e1.res, $e2.res);
}
    :  ^(op=OR            e1=expr[target, depth + 1] e2=expr[target, depth + 1])
    |  ^(op=AND           e1=expr[target, depth + 1] e2=expr[target, depth + 1])
    |  ^(op=VERT_BAR      e1=expr[target, depth + 1] e2=expr[target, depth + 1])
    |  ^(op=UP_ARROW      e1=expr[target, depth + 1] e2=expr[target, depth + 1])
    |  ^(op=AMPER         e1=expr[target, depth + 1] e2=expr[target, depth + 1])
    |  ^(op=EQ            e1=expr[target, depth + 1] e2=expr[target, depth + 1])
    |  ^(op=NEQ           e1=expr[target, depth + 1] e2=expr[target, depth + 1])
    |  ^(op=LEQ           e1=expr[target, depth + 1] e2=expr[target, depth + 1])
    |  ^(op=GEQ           e1=expr[target, depth + 1] e2=expr[target, depth + 1])
    |  ^(op=LEFT_BROCKET  e1=expr[target, depth + 1] e2=expr[target, depth + 1])
    |  ^(op=RIGHT_BROCKET e1=expr[target, depth + 1] e2=expr[target, depth + 1])
    |  ^(op=LEFT_SHIFT    e1=expr[target, depth + 1] e2=expr[target, depth + 1])
    |  ^(op=RIGHT_SHIFT   e1=expr[target, depth + 1] e2=expr[target, depth + 1])
    |  ^(op=ROTATE_LEFT   e1=expr[target, depth + 1] e2=expr[target, depth + 1])
    |  ^(op=ROTATE_RIGHT  e1=expr[target, depth + 1] e2=expr[target, depth + 1])
    |  ^(op=PLUS          e1=expr[target, depth + 1] e2=expr[target, depth + 1])
    |  ^(op=MINUS         e1=expr[target, depth + 1] e2=expr[target, depth + 1])
    |  ^(op=MUL           e1=expr[target, depth + 1] e2=expr[target, depth + 1])
    |  ^(op=DIV           e1=expr[target, depth + 1] e2=expr[target, depth + 1])
    |  ^(op=REM           e1=expr[target, depth + 1] e2=expr[target, depth + 1])
    |  ^(op=DOUBLE_STAR   e1=expr[target, depth + 1] e2=expr[target, depth + 1])
    ;

unaryExpr [ValueInfo.Kind target, int depth] returns [Expr res]
@after
{
checkNotNull($e.start, $e.res, $e.text);
$res = getExprFactory().operator(where($op), target, $op.text, $e.res);
}
    :  ^(op=UPLUS   e=expr[target, depth + 1])
    |  ^(op=UMINUS  e=expr[target, depth + 1])
    |  ^(op=TILDE   e=expr[target, depth + 1])
    |  ^(op=NOT     e=expr[target, depth + 1])
    ;

atom returns [Expr res]
    :  ^(CONST token=ID)  {$res = getExprFactory().namedConstant(where($token), $token.text);}
    |  ^(token=LOCATION le=locationExpr[0])
{
checkNotNull($le.start, $le.res, $le.text);
$res = getExprFactory().location($le.res);
}
    |  token=CARD_CONST   {$res = getExprFactory().constant(where($token), $token.text,10);}
    |  token=BINARY_CONST {$res = getExprFactory().constant(where($token), $token.text, 2);}
    |  token=HEX_CONST    {$res = getExprFactory().constant(where($token), $token.text,16);}
    |  ^(token=COERCE te=typeExpr e=dataExpr)
{
checkNotNull($te.start, $te.res, $te.text);
checkNotNull($e.start,   $e.res,  $e.text);
$res = getExprFactory().coerce(where($token), $e.res, $te.res);
}
    ;

/*======================================================================================*/
/* Location rules (rules for accessing model memory)                                    */
/*======================================================================================*/

location returns [Location res]
    :  ^(LOCATION le=locationExpr[0] {checkNotNull($le.start, $le.res, $le.text);})
{
$res = $le.res;
}
    ;

locationExpr [int depth] returns [Location res]
    :  ^(node=DOUBLE_COLON left=locationVal right=locationExpr[depth+1])
{
checkNotNull($left.start,  $left.res,  $left.text);
checkNotNull($right.start, $right.res, $right.text);

$res = getLocationFactory().concat(where($node), $left.res, $right.res);
}
    |  value=locationVal
{
$res = $value.res;
}
    ;

locationVal returns [LocationAtom res]
    :  ^(node=LOCATION_BITFIELD la=locationAtom je1=indexExpr (je2=indexExpr)?)
{
checkNotNull($la.start, $la.res, $la.text);
checkNotNull($je1.start, $je1.res, $je1.text);

if (null == $je2.res)
    $res = getLocationFactory().bitfield(where($node), $la.res, $je1.res);
else
    $res = getLocationFactory().bitfield(where($node), $la.res, $je1.res, $je2.res);
}
    |  la=locationAtom
{
$res = $la.res;
}
    ;

locationAtom returns [LocationAtom res]
    :  ^(LOCATION_INDEX id=ID e=indexExpr)
{
checkNotNull($e.start, $e.res, $e.text);
$res = getLocationFactory().location(where($id), $id.text, $e.res);
}
    |  id=ID
{
$res = getLocationFactory().location(where($id), $id.text);
}
    ;

/*======================================================================================*/
    