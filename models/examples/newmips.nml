/*
 *         MIPS ISA Specification in Sim-nML
 *
 *           Based on materials provided by
 *        Indian Institute of Technology Kanpur
 *             Hemant Shinde (31-07-2007)
 * 
 *     http://www.cse.iitk.ac.in/users/moona/?page=stud
 * 
 * The present version is created at ISPRAS by Andrei Tatarnikov
 * in June, 2013 to adapt the original specification to limitations
 * imposed on input file format by the current version of MicroTESK.
 */

/********************************************************************************************/
/* Constants                                                                                */
/********************************************************************************************/

let REGS = 5
let byte_order = "big"
let PC = "NIA"
let SP = "GPR[29]"

/********************************************************************************************/
/* Type Declarations                                                                        */
/********************************************************************************************/

type bit            = card ( 1 )
type byte_t         = card ( 8 )
type word           = card ( 32 )
type long_t         = card ( 32 )
type signed_long    = int  ( 32 )
type address        = card ( 32 )
type index          = card ( REGS )
type breakcode      = card ( 20 )

// type flot = float ( 52 , 12 ) // NOT SUPPORTED IN THE CURRENT VERSION
// type flots = float ( 23, 9 )  // NOT SUPPORTED IN THE CURRENT VERSION

type cond_code      = card ( 3 )
type cond           = card ( 4 )

/********************************************************************************************/
/* Memory and Registers                                                                     */
/********************************************************************************************/

mem M [ 2 ** 31, byte_t ] 
reg GPR [ 2 ** REGS, signed_long ]

// lower 32 bits of multiplication result and quotient of divition result
reg LO [ 1, signed_long ] 

// next instruction address
reg NIA [ 1, long_t ] 

// reg FPR [ 2 ** REGS, flots] // NOT SUPPORTED IN THE CURRENT VERSION
// port = 2,1  

// higher 32/16 bits of multiplication result of 32*16 bit or 32*32 bit operands.. remainder                             
//  for div operations 
reg HI [ 1, signed_long ] 

/********************************************************************************************/
/* Variables                                                                                */
/********************************************************************************************/

// current instruction address
mem CIA [ 1, long_t ] 

reg FPSCR [ 1, long_t ]
reg FCCR [ 1, long_t ]


// In mips processors jmp instruction executes next instruction within the delay slot. Thus
// return address is current address plus 8
// Jmp_flag and jmp_addr are added 
//var jmp_flag [ 1, card (1) ] = 0
//var jmp_addr [ 1, long_t ]


mem tmp_signed_byte [ 1 , int (8) ]
mem tmp_unsigned_byte [ 1 , card (8) ]
mem tmp_signed_half_word [ 1 , int (16) ]
mem tmp_unsigned_half_word [ 1 , card (16) ]
mem tmp_signed_word [ 1 , int (32) ]
mem tmp_signed_word1 [ 1 , int (32) ]
mem tmp_unsigned_word [ 1 , card (32) ]
mem tmp_double_word  [ 1 , card (64) ]
// mem TMP_FLOT [ 1 , flot ]   // NOT SUPPORTED IN THE CURRENT VERSION
// mem TMP_FLOTS [ 1, flots ]  // NOT SUPPORTED IN THE CURRENT VERSION
// mem TMP2_FLOT [ 1 , flot ]  // NOT SUPPORTED IN THE CURRENT VERSION
mem TMP_SDWORD [ 1 , int ( 64 ) ]
mem overflow_bit [ 1 , bit ]

// effective address for memory access
mem EA [ 1 , address ] 
mem tmp_div [ 1 , int ( 64 ) ]
mem mulsize [ 1 , bit ]
mem multsize [ 1 , bit ]
mem divsize [ 1 , card (5) ]

// In mips processors jmp instruction executes next instruction within the delay slot. Thus
// return address is current address plus 8
// branch instr will first modify this
mem JMPADDR [ 1 , long_t ]
mem branch [ 1 , bit ]
mem signadjust [1, bit]
mem likely [ 1 , card (2) ]
 
// Aliases

// HalfWord Integer

mem tmp_signed_half_word_A0 [ 1 , int ( 8 ) ]
    alias = tmp_signed_half_word [ 8 ]

mem tmp_signed_half_word_A1 [ 1 , int ( 8 ) ]
    alias = tmp_signed_half_word [ 0 ]

// HalfWord Card

mem tmp_unsigned_half_word_A0 [ 1 , int ( 8 ) ]
    alias = tmp_unsigned_half_word [ 8 ]

mem tmp_unsigned_half_word_A1 [ 1 , int ( 8 ) ]
    alias = tmp_unsigned_half_word [ 0 ]

// Word Integers

mem tmp_signed_word_A0 [ 1 , int ( 8 ) ]
    alias = tmp_signed_word [ 24 ]
        
mem tmp_signed_word_A1 [ 1 , int ( 8 ) ]
    alias = tmp_signed_word [ 16 ]

mem tmp_signed_word_A2 [ 1 , int ( 8 ) ]
    alias = tmp_signed_word [ 8 ]

mem tmp_signed_word_A3 [ 1 , int ( 8 ) ]
    alias = tmp_signed_word [ 0 ]

// Word Card

mem tmp_unsigned_word_A0 [ 1 , int ( 8 ) ]
    alias = tmp_unsigned_word [ 24 ]
        
mem tmp_unsigned_word_A1 [ 1 , int ( 8 ) ]
    alias = tmp_unsigned_word [ 16 ]

mem tmp_unsigned_word_A2 [ 1 , int ( 8 ) ]
    alias = tmp_unsigned_word [ 8 ]

mem tmp_unsigned_word_A3 [ 1 , int ( 8 ) ]
    alias = tmp_unsigned_word [ 0 ]

// double word card 

mem tmp_double_word_A0 [ 1 , card ( 16 ) ]
    alias = tmp_double_word [ 32 ]
        
mem tmp_double_word_A1 [ 1 , card ( 16 ) ]
    alias = tmp_double_word [ 0 ]
    
// Aliases for Float Temps

// Double Presicion Float
/*
// NOT SUPPORTED IN THE CURRENT VERSION

mem TMP_FLOT_A0 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 56 ]

mem TMP_FLOT_A1 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 48 ]

mem TMP_FLOT_A2 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 40 ]

mem TMP_FLOT_A3 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 32 ]

mem TMP_FLOT_A4 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 24 ]

mem TMP_FLOT_A5 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 16 ]

mem TMP_FLOT_A6 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 8 ]

mem TMP_FLOT_A7 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 0 ]
*/

// Single Presicion Float

/*
// NOT SUPPORTED IN THE CURRENT VERSION

mem TMP_FLOTS_A0 [ 1 , int ( 8 ) ]
    alias = TMP_FLOTS [ 24 ]

mem TMP_FLOTS_A1 [ 1 , int ( 8 ) ]
    alias = TMP_FLOTS [ 16 ]

mem TMP_FLOTS_A2 [ 1 , int ( 8 ) ]
    alias = TMP_FLOTS [ 8 ]

mem TMP_FLOTS_A3 [ 1 , int ( 8 ) ]
    alias = TMP_FLOTS [ 0 ]
*/    

/********************************************************************************************/
/* Addressing Modes                                                                         */
/********************************************************************************************/

mode REG_IND_ZERO ( r : index ) = GPR [ r ]
    /* if r == 0 then
        0
     else
        GPR [ r ]
     endif
	*/
   syntax = format ( "%d", r )
   image  = format ( "%5b", r )

mode REG_IND ( r : index) = r
	syntax = format( "%d", r)
	image = format( "%5b", r)

mode IMM26 ( n : int ( 26 ) ) = n
   syntax = format ( "%d", n )
   image  = format ( "%26b", n )

mode IMM16 ( n : int ( 16 ) ) = n
   syntax = format ( "%d", n )
   image  = format ( "%16b", n )

/********************************************************************************************/
/* Non-Branch Instructions                                                                  */
/********************************************************************************************/

op non_branch_instr()

/********************************************************************************************/
/* Branch Instructions                                                                      */
/********************************************************************************************/

//////////////////////////////////////// Branch /////////////////////////////////////////////

op BGEZAL (rs : REG_IND_ZERO, offset : IMM16)
    syntax = format ( "BGEZAL %s, %s", rs.syntax, offset.syntax )	   
    image  = format ( "000001%s10001%s", rs.image, offset.image )
    action = {
        //  offset = offset << 2;
        //  NIA = CIA + offset;

        if ( rs >= 0 ) then
            branch = 1;
            tmp_signed_word=offset;
            tmp_signed_word=tmp_signed_word << 2;
            JMPADDR = NIA + tmp_signed_word;
		//  JMPADDR = NIA + ( offset << 2 );
            GPR [31] = CIA + 8;
        endif;
    }

op BGEZALL (rs : REG_IND_ZERO, offset : IMM16)
    syntax = format ( "BGEZ %s, %s", rs.syntax, offset.syntax )	   
    image  = format ( "000001%s10011%s", rs.image, offset.image )
    action = {
        //  offset = offset << 2;
        //  NIA = CIA + offset;

        if ( rs >= 0 ) then
            branch = 1;
            tmp_signed_word=offset;
            tmp_signed_word=tmp_signed_word << 2;
            JMPADDR = NIA + tmp_signed_word;
        //  JMPADDR = NIA + ( offset << 2 );
            GPR [31] = CIA + 8;
        endif;
    }   

op BLTZAL (rs : REG_IND_ZERO, offset : IMM16)
    syntax = format ( "BLTZAL %s, %s", rs.syntax, offset.syntax )	   
    image  = format ( "000001%s10000%s", rs.image, offset.image )
    action = {
        //  offset = offset << 2;
        //  NIA = CIA + offset;

        if ( rs < 0 ) then
            branch = 1;
            tmp_signed_word=offset;
            tmp_signed_word=tmp_signed_word << 2;
            JMPADDR = NIA + tmp_signed_word;
        //  JMPADDR = NIA + ( offset << 2 );
        //  GPR [31] = NIA + 4;
            GPR [31] = CIA + 8;
        endif;
    }

op BLTZALL (rs : REG_IND_ZERO, offset : IMM16)
    syntax = format ( "BLTZ %s, %s", rs.syntax, offset.syntax )	   
    image  = format ( "000001%s10010%s", rs.image, offset.image )
    action = {
    //	offset = offset << 2;
    //	NIA = CIA + offset;
		
        if ( rs < 0 ) then
            branch = 1;
            tmp_signed_word=offset;
            tmp_signed_word=tmp_signed_word << 2;
            JMPADDR = NIA + tmp_signed_word;
        //	JMPADDR = NIA + ( offset << 2 );
        //	GPR [31] = NIA + 4;
            GPR [31] = CIA + 8;
        endif;
    }  

op BAL (offset : IMM16)
    syntax = format ( "BAL %s", offset.syntax )	   
    image  = format ( "0000010000010001%s",  offset.image )
    action = {
    //	offset = offset << 2;
    //	NIA = CIA + offset;
        branch = 1;
        tmp_signed_word=offset;
        tmp_signed_word=tmp_signed_word << 2;
        JMPADDR = NIA + tmp_signed_word;
    //  JMPADDR = NIA + ( offset << 2 );
        GPR [31] = CIA + 8;
    }

op branch_to_link_instr	  =  BGEZAL  // BGEZ and link
                          |  BGEZALL // BGEZ and link likely
                          |  BLTZAL  // BLTZ and link
                          |  BLTZALL // BLTZ and link likely
                          |  BAL

op BGEZ (rs : REG_IND_ZERO, offset : IMM16)
    syntax = format ( "BGEZ %s, %s", rs.syntax, offset.syntax )	   
    image  = format ( "000001%s00001%s", rs.image, offset.image )
    action = {
    //	offset = offset << 2;
    //	NIA = NIA + ( offset << 2 );

        if ( rs >= 0 ) then
            branch = 1;
            tmp_signed_word=offset;
            tmp_signed_word=tmp_signed_word << 2;
            JMPADDR = NIA + tmp_signed_word;
            //  JMPADDR = NIA + ( offset << 2 );
        endif;
    }

op BGEZL (rs : REG_IND_ZERO , offset : IMM16)
    syntax = format ( "BGEZL %s, %s" , rs.syntax, offset.syntax )	   
    image = format ( "000001%s00011%s" , rs.image, offset.image )
    action = {
        //  if ( rs >= 0 ) then
        //  offset = offset << 2;
        //  NIA = CIA + offset;
        //  NIA = NIA + ( offset << 2 );

        if ( rs >= 0 ) then
            branch = 1;
            tmp_signed_word=offset;
            tmp_signed_word=tmp_signed_word << 2;
            JMPADDR = NIA + tmp_signed_word;
        //  JMPADDR = NIA + ( offset << 2 );
            GPR[31] = CIA + 8;
        endif;
    }

op BLTZ (rs : REG_IND_ZERO, offset : IMM16)
    syntax = format ( "BLTZ %s, %s" , rs.syntax, offset.syntax )	   
    image = format ( "000001%s00000%s" , rs.image, offset.image )
    action = {
        //  if ( rs < 0 ) then
        //  offset = offset << 2;
        //  NIA = CIA + offset;
        //  NIA = NIA + ( offset << 2 );

        if ( rs < 0 ) then
            branch = 1;
            tmp_signed_word=offset;
            tmp_signed_word=tmp_signed_word << 2;
            JMPADDR = NIA + tmp_signed_word;
            //  JMPADDR = NIA + ( offset << 2 );
        endif;
    }

op BLTZL (rs : REG_IND_ZERO, offset : IMM16)
    syntax = format ( "BLTZL %s, %s", rs.syntax, offset.syntax )	   
    image = format ( "000001%s00010%s", rs.image, offset.image )
    action = {
		//if ( rs < 0 ) then
		//	offset = offset << 2;
		//	NIA = CIA + offset;
		//	NIA = NIA + ( offset << 2 );

        if ( rs < 0 ) then
            branch = 1;
            tmp_signed_word=offset;
            tmp_signed_word=tmp_signed_word << 2;
            JMPADDR = NIA + tmp_signed_word;
        //  JMPADDR = NIA + ( offset << 2 );
            GPR[31] = CIA + 8;
        endif;
    }

op branch_to_nolink_instr  =  BGEZ  // branch on greater then or equal to zero
                           |  BGEZL // BGEZ likely
                           |  BLTZ  // branch on less than
                           |  BLTZL // BLTZ likely

op BEQ (rs : REG_IND_ZERO, rt : REG_IND_ZERO, offset : IMM16 )
    syntax = format ( "BEQ %s, %s, %s", rs.syntax, rt.syntax, offset.syntax )
    image = format ( "000100%s%s%s", rs.image, rt.image, offset.image )
    action = {
    //  offset = offset << 2;
    //  NIA = CIA + offset;

        if ( rs == rt ) then
            branch = 1;
            tmp_signed_word=offset;
            tmp_signed_word=tmp_signed_word << 2;
            JMPADDR = NIA + tmp_signed_word;
            // JMPADDR = NIA + ( offset << 2 );
        endif;
    }

op BEQL (rs : REG_IND_ZERO, rt :  REG_IND_ZERO, offset : IMM16 )
    syntax = format ( "BEQL %s, %s, %s", rs.syntax, rt.syntax, offset.syntax )
    image = format ( "010100%s%s%s", rs.image, rt.image, offset.image )
    action = {
        if ( rs <= rt ) then
        //  offset = offset << 2;
        //  NIA = CIA + offset;
            branch = 1;
            tmp_signed_word=offset;
            tmp_signed_word=tmp_signed_word << 2;
            JMPADDR = NIA + tmp_signed_word;
        //  JMPADDR = NIA + ( offset << 2 );
            GPR [31] = CIA + 8;
        endif;
    }

op BNE (rs : REG_IND_ZERO, rt : REG_IND_ZERO, offset : IMM16 )
    syntax = format ( "BNE %s, %s, %s", rs.syntax, rt.syntax, offset.syntax )
    image = format ( "000101%s%s%s", rs.image, rt.image, offset.image )
    action = {
        if ( rs != rt ) then
        //  offset = offset << 2;
        //  NIA = CIA + offset;
            branch = 1;
            tmp_signed_word=offset;
            tmp_signed_word=tmp_signed_word << 2;
            JMPADDR = NIA + tmp_signed_word;
        //  JMPADDR = NIA + ( offset << 2 );
        endif;
    }

op BNEL (rs : REG_IND_ZERO, rt : REG_IND_ZERO, offset : IMM16 )
    syntax = format ( "BNEL %s, %s, %s", rs.syntax, rt.syntax, offset.syntax )
    image  = format ( "010101%s%s%s", rs.image, rt.image, offset.image )
    action = {
        if ( rs != rt ) then
        //  offset = offset << 2;
        //  NIA = CIA + offset;
            branch = 1;
            tmp_signed_word = offset;
            tmp_signed_word = tmp_signed_word << 2;
            JMPADDR = NIA + tmp_signed_word;
        //  JMPADDR = NIA + ( offset << 2 );
            //GPR[31] = NIA + 4;
            GPR [31] = CIA + 8;
        endif;
    }

op BEQZ (rs : REG_IND_ZERO, offset : IMM16 )
    syntax = format ( "BEQZ %s, %s", rs.syntax, offset.syntax )
    image  = format ( "000100%s00000%s", rs.image, offset.image )
    action = {
        if ( rs == 0 ) then
        //  offset = offset << 2;
        //  NIA = CIA + offset;
            branch = 1;
            tmp_signed_word = offset;
            tmp_signed_word = tmp_signed_word << 2;
            JMPADDR = NIA + tmp_signed_word;
		//  JMPADDR = NIA + ( offset << 2 );
        endif;
    }

op BNEZ() 
op B()

op branch_to_eql_instr    =  BEQ  // branch on equal
                          |  BEQL // BEQ likely
                          |  BNE  // branch on not equal
                          |  BNEL // BNE likely
                          |  BEQZ
                          |  BNEZ 
                          |  B

op BGTZ()
op BGTZL()
op BLEZ()
op BLEZL()

op branch_to_grtr_instr   =  BGTZ  // branch greater than zero
                          |  BGTZL // BGTZL likely
                          |  BLEZ  // branch less or equal to than zero
                          |  BLEZL // BLEZ likely

op branch_to_instr  =  branch_to_link_instr
                    |  branch_to_nolink_instr	
                    |  branch_to_eql_instr
                    |  branch_to_grtr_instr
                    
///////////////////////////////////////// Jump //////////////////////////////////////////////

op J (target : IMM26)
    syntax = format ( "J %s", target.syntax )
    image  = format ( "000010%s", target.image )
    action = {
        branch = 1;
        CIA = NIA;
        JMPADDR = CIA & 4026531840;
        //target = target << 2;
        JMPADDR = JMPADDR | ( target << 2);
    }

op JAL (target : IMM26)
    syntax = format ( "JAL %s", target.syntax )
    image = format ( "000011%s", target.image )
    action = {
        branch = 1;
        CIA = NIA;
        JMPADDR = CIA & 4026531840;
	//  target = target << 2;
	//  NIA = NIA | target;
        JMPADDR = JMPADDR | ( target << 2) ;
        GPR [31] = CIA + 4;
    }  

op JALR (rs : REG_IND_ZERO) 
    syntax = format ( "JALR %s", rs.syntax ) 
    image  = format ( "000000%s000001111100000001001", rs.image )		      
    action = {
        branch = 1;
        CIA = NIA;
        JMPADDR = rs;
        GPR [31] = CIA + 4;
    }

op JR ( rs : REG_IND_ZERO ) 
    syntax = format ( "JR  %s", rs.syntax ) 
    image  = format ( "000000%s000000000000000001000", rs.image)		      
    action = {
        branch = 1;
        CIA = NIA;
        JMPADDR = rs;
    }

op jump_to_instr    =  J
                    |  JAL
                    |  JR
                    |  JALR

op branch_instr	    =  branch_to_instr
                    |  jump_to_instr

/********************************************************************************************/
/* Special Instructions                                                                     */ 
/********************************************************************************************/

op NOP()
    syntax = "NOP"
    image  = "00000000000000000000000000000000"
    action = {

    }

op SYSCALL()
    syntax = "SYSCALL"
    image  = "00000000000000000000000000001100"
    action = {
        // "sys_call_mips" ( GPR[2], GPR[4], GPR[5],GPR[6],GPR[7]);
	}

op CLO(rd : index, rs : REG_IND_ZERO)
    syntax = format ("CLO %d, %s", rd, rs.syntax) 
    image = format ("011100%s%5b%5b00000100001", rs.image, rd, rd)
    action = {
        tmp_signed_byte = 31;
        GPR [rd] = 32; 
        loop;
    }

    loop = {
        if tmp_signed_byte >= 0 then
          	//if ( rs < rs_signed_byte .. rs_signed_byte > == 1 ) then
            /*
            if ( rs < tmp_signed_byte .. tmp_signed_byte > == 1 ) then
                tmp_signed_byte = tmp_signed_byte - 1;
            else
                GPR [ rd ] = 31 - tmp_signed_byte;
                tmp_signed_byte = -1;
            endif;
            */
            loop;
        endif;
    }

op CLZ(rd : index, rs : REG_IND_ZERO)
    syntax = format ("CLZ %d,%s", rd, rs.syntax)
    image  = format ("011100%s%5b%5b00000100000", rs.image, rd, rd)
    action = {
        tmp_signed_byte = 31;
        GPR [rd] = 32;
        loop;
    }

    loop = {
        if tmp_signed_byte >= 0 then
            /*
            if (rs < tmp_signed_byte .. tmp_signed_byte > == 0) then
                tmp_signed_byte = tmp_signed_byte - 1;
            else
                GPR [ rd ] = 31 - tmp_signed_byte;
                tmp_signed_byte = -1;
            endif;
            */
            loop;
        endif;
    }

op SYNC()
    syntax = "SYNC"
    image  = "00000000000000000000000000001111"
    action = { }

op RDHWR (rd : index, rt :  REG_IND_ZERO)
    syntax = format ("RDHWR %s, %d", rt.syntax, rd)
    image  = format ("01111100000%s%5b00000111011", rt.image, rd)
    action = {
        // RDHWR is not a syscall but an inturrupt and easy to implement as a syscall.
        // "sys_call_mips" (5111, 3, GPR[5], GPR[6], GPR[7]);
        // rt = 0x004c94d8;
		}

op BREAK (cde : breakcode)
    syntax = format ("BREAK %d", cde)
    image  = format ("000000%20b001101", cde)
    action = { }

op TEQ (rs : REG_IND_ZERO, rt :  REG_IND_ZERO)
    syntax = format ("TEQ %s, %s" , rs.syntax , rt.syntax)
    image  = format ("000000%s%s0000000111110100", rs.image, rt.image)
    action = { }

op	special_instr   =  NOP
                    |  SYSCALL
                    |  CLO	
                    |  CLZ
                    |  SYNC
                    |  RDHWR
                    |  BREAK
                    |  TEQ

/********************************************************************************************/
/* Floating-Point Instructions                                                              */ 
/********************************************************************************************/

// NOT SUPPORTED IN THE CURRENT VERSION
//op float_instr()

/********************************************************************************************/
/* Entry Point                                                                              */
/********************************************************************************************/

// Instructions

op instr_kind    =  non_branch_instr
                 |  branch_instr
                 |  special_instr
              // |  float_instr // NOT SUPPORTED IN THE CURRENT VERSION 
              // |  dummy_instr

op instruction (x : instr_kind)
    syntax = x.syntax
    image  = x.image
    action = {
        CIA = NIA;

        // if condition to execute next instruction before jumping to the address.
        if  branch == 0 then
            NIA = CIA + 4;
        else
            NIA = JMPADDR;
            branch = 0;
        endif;

        x.action;
        GPR[0] = 0;
    }
