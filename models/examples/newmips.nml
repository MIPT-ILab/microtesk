/* 
 * MIPS Description in Sim-nML by Hemant Shinde (31-07-2007)
 * 
 * Provided by Indian Institute of Technology Kanpur
 * 
 *     http://www.cse.iitk.ac.in/users/moona/?page=stud
 * 
 * Modified at ISPRAS by Andrei Tatarnikov (June, 2013) to adapt it to limitations
 * imposed on input file format by the current version of MicroTESK.
 */
 
/********************************************************************************************/
/* Constants                                                                                */
/********************************************************************************************/

let REGS = 5
let byte_order = "big"
let PC = "NIA"
let SP = "GPR[29]"

/********************************************************************************************/
/* Type Declarations                                                                        */
/********************************************************************************************/

type bit            = card ( 1 )
type byte_t         = card ( 8 )
type word           = card ( 32 )
type long_t         = card ( 32 )
type signed_long    = int  ( 32 )
type address        = card ( 32 )
type index          = card ( REGS )
type breakcode      = card ( 20 )

// type flot = float ( 52 , 12 ) // NOT SUPPORTED IN THE CURRENT VERSION
// type flots = float ( 23, 9 )  // NOT SUPPORTED IN THE CURRENT VERSION

type cond_code      = card ( 3 )
type cond           = card ( 4 )

/********************************************************************************************/
/* Memory and Registers                                                                     */
/********************************************************************************************/

mem M [ 2 ** 31, byte_t ] 
reg GPR [ 2 ** REGS, signed_long ]

// lower 32 bits of multiplication result and quotient of divition result
reg LO [ 1, signed_long ] 

// next instruction address
reg NIA [ 1, long_t ] 

// reg FPR [ 2 ** REGS, flots] // NOT SUPPORTED IN THE CURRENT VERSION
// port = 2,1  

// higher 32/16 bits of multiplication result of 32*16 bit or 32*32 bit operands.. remainder                             
//  for div operations 
reg HI [ 1, signed_long ] 

/********************************************************************************************/
/* Variables                                                                                */
/********************************************************************************************/

// current instruction address
mem CIA [ 1, long_t ] 

reg FPSCR [ 1, long_t ]
reg FCCR [ 1, long_t ]


// In mips processors jmp instruction executes next instruction within the delay slot. Thus
// return address is current address plus 8
// Jmp_flag and jmp_addr are added 
//var jmp_flag [ 1, card (1) ] = 0
//var jmp_addr [ 1, long_t ]


mem tmp_signed_byte [ 1 , int (8) ]
mem tmp_unsigned_byte [ 1 , card (8) ]
mem tmp_signed_half_word [ 1 , int (16) ]
mem tmp_unsigned_half_word [ 1 , card (16) ]
mem tmp_signed_word [ 1 , int (32) ]
mem tmp_signed_word1 [ 1 , int (32) ]
mem tmp_unsigned_word [ 1 , card (32) ]
mem tmp_double_word  [ 1 , card (64) ]
// mem TMP_FLOT [ 1 , flot ]   // NOT SUPPORTED IN THE CURRENT VERSION
// mem TMP_FLOTS [ 1, flots ]  // NOT SUPPORTED IN THE CURRENT VERSION
// mem TMP2_FLOT [ 1 , flot ]  // NOT SUPPORTED IN THE CURRENT VERSION
mem TMP_SDWORD [ 1 , int ( 64 ) ]
mem overflow_bit [ 1 , bit ]

// effective address for memory access
mem EA [ 1 , address ] 
mem tmp_div [ 1 , int ( 64 ) ]
mem mulsize [ 1 , bit ]
mem multsize [ 1 , bit ]
mem divsize [ 1 , card (5) ]

// In mips processors jmp instruction executes next instruction within the delay slot. Thus
// return address is current address plus 8
// branch instr will first modify this
mem JMPADDR [ 1 , long_t ]
mem branch [ 1 , bit ]
mem signadjust [1, bit]
mem likely [ 1 , card (2) ]
 
// Aliases

// HalfWord Integer

mem tmp_signed_half_word_A0 [ 1 , int ( 8 ) ]
    alias = tmp_signed_half_word [ 8 ]

mem tmp_signed_half_word_A1 [ 1 , int ( 8 ) ]
    alias = tmp_signed_half_word [ 0 ]

// HalfWord Card

mem tmp_unsigned_half_word_A0 [ 1 , int ( 8 ) ]
    alias = tmp_unsigned_half_word [ 8 ]

mem tmp_unsigned_half_word_A1 [ 1 , int ( 8 ) ]
    alias = tmp_unsigned_half_word [ 0 ]

// Word Integers

mem tmp_signed_word_A0 [ 1 , int ( 8 ) ]
    alias = tmp_signed_word [ 24 ]
        
mem tmp_signed_word_A1 [ 1 , int ( 8 ) ]
    alias = tmp_signed_word [ 16 ]

mem tmp_signed_word_A2 [ 1 , int ( 8 ) ]
    alias = tmp_signed_word [ 8 ]

mem tmp_signed_word_A3 [ 1 , int ( 8 ) ]
    alias = tmp_signed_word [ 0 ]

// Word Card

mem tmp_unsigned_word_A0 [ 1 , int ( 8 ) ]
    alias = tmp_unsigned_word [ 24 ]
        
mem tmp_unsigned_word_A1 [ 1 , int ( 8 ) ]
    alias = tmp_unsigned_word [ 16 ]

mem tmp_unsigned_word_A2 [ 1 , int ( 8 ) ]
    alias = tmp_unsigned_word [ 8 ]

mem tmp_unsigned_word_A3 [ 1 , int ( 8 ) ]
    alias = tmp_unsigned_word [ 0 ]

// double word card 

mem tmp_double_word_A0 [ 1 , card ( 16 ) ]
    alias = tmp_double_word [ 32 ]
        
mem tmp_double_word_A1 [ 1 , card ( 16 ) ]
    alias = tmp_double_word [ 0 ]
    
// Aliases for Float Temps

// Double Presicion Float
/*
// NOT SUPPORTED IN THE CURRENT VERSION

mem TMP_FLOT_A0 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 56 ]

mem TMP_FLOT_A1 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 48 ]

mem TMP_FLOT_A2 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 40 ]

mem TMP_FLOT_A3 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 32 ]

mem TMP_FLOT_A4 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 24 ]

mem TMP_FLOT_A5 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 16 ]

mem TMP_FLOT_A6 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 8 ]

mem TMP_FLOT_A7 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 0 ]
*/

// Single Presicion Float

/*
// NOT SUPPORTED IN THE CURRENT VERSION

mem TMP_FLOTS_A0 [ 1 , int ( 8 ) ]
    alias = TMP_FLOTS [ 24 ]

mem TMP_FLOTS_A1 [ 1 , int ( 8 ) ]
    alias = TMP_FLOTS [ 16 ]

mem TMP_FLOTS_A2 [ 1 , int ( 8 ) ]
    alias = TMP_FLOTS [ 8 ]

mem TMP_FLOTS_A3 [ 1 , int ( 8 ) ]
    alias = TMP_FLOTS [ 0 ]
*/    

/********************************************************************************************/
/* Addressing Modes                                                                         */
/********************************************************************************************/

mode REG_IND_ZERO ( r : index ) = GPR [ r ]
    /* if r == 0 then
        0
     else
        GPR [ r ]
     endif
	*/
   syntax = format ( "%d", r )
   image  = format ( "%5b", r )

mode REG_IND ( r : index) = r
	syntax = format( "%d", r)
	image = format( "%5b", r)

mode IMM26 ( n : int ( 26 ) ) = n
   syntax = format ( "%d", n )
   image  = format ( "%26b", n )

mode IMM16 ( n : int ( 16 ) ) = n
   syntax = format ( "%d", n )
   image  = format ( "%16b", n )

/********************************************************************************************/
/* Non-Branch Instructions                                                                  */
/********************************************************************************************/

op non_branch_instr()

/********************************************************************************************/
/* Branch Instructions                                                                      */
/********************************************************************************************/

op branch_instr()

/********************************************************************************************/
/* Special Instructions                                                                     */ 
/********************************************************************************************/

op NOP()
    syntax = "NOP"
    image  = "00000000000000000000000000000000"
    action = {

    }

op SYSCALL()
    syntax = "SYSCALL"
    image  = "00000000000000000000000000001100"
    action = {
        // "sys_call_mips" ( GPR[2], GPR[4], GPR[5],GPR[6],GPR[7]);
	}

op CLO(rd : index, rs : REG_IND_ZERO)
    syntax = format ("CLO %d, %s", rd, rs.syntax) 
    image = format ("011100%s%5b%5b00000100001", rs.image, rd, rd)
    action = {
        tmp_signed_byte = 31;
        GPR [rd] = 32; 
        // loop; // TODO: SUPPORT CUSTOM ATTRIBUTES
    }
    /*
    loop  = {
        if tmp_signed_byte >= 0 then
          	//if ( rs < rs_signed_byte..rs_signed_byte > == 1 ) then
            if ( rs < tmp_signed_byte..tmp_signed_byte > == 1 ) then
                tmp_signed_byte = tmp_signed_byte - 1;
            else
                GPR [ rd ] = 31 - tmp_signed_byte;
                tmp_signed_byte = -1;
            endif;
            loop;
        endif;
    }
    */

op CLZ(rd : index, rs : REG_IND_ZERO)
    syntax = format ("CLZ %d,%s", rd, rs.syntax)
    image  = format ("011100%s%5b%5b00000100000", rs.image, rd, rd)
    action = {
        tmp_signed_byte = 31;
        GPR [rd] = 32;
        // loop; // TODO: SUPPORT CUSTOM ATTRIBUTES
    }
    /*
    loop = {
        if tmp_signed_byte >= 0 then
            if (rs < tmp_signed_byte..tmp_signed_byte > == 0) then
                tmp_signed_byte = tmp_signed_byte - 1;
            else
                GPR [ rd ] = 31 - tmp_signed_byte;
                tmp_signed_byte = -1;
            endif;
            loop;
        endif;
    }
    */

op SYNC()
    syntax = "SYNC"
    image  = "00000000000000000000000000001111"
    action = { }

op RDHWR (rd : index, rt :  REG_IND_ZERO)
    syntax = format ("RDHWR %s, %d", rt.syntax, rd)
    image  = format ("01111100000%s%5b00000111011", rt.image, rd)
    action = {
        // RDHWR is not a syscall but an inturrupt and easy to implement as a syscall.
        // "sys_call_mips" (5111, 3, GPR[5], GPR[6], GPR[7]);
        // rt = 0x004c94d8;
		}

op BREAK (cde : breakcode)
    syntax = format ("BREAK %d", cde)
    image  = format ("000000%20b001101", cde)
    action = { }

op TEQ (rs : REG_IND_ZERO, rt :  REG_IND_ZERO)
    syntax = format ("TEQ %s, %s, %s" , rs.syntax , rt.syntax , offset.syntax)
    image  = format ("000000%s%s0000000111110100", rs.image, rt.image, offset.image)
    action = { }

op	special_instr   =  NOP
                    |  SYSCALL
                    |  CLO	
                    |  CLZ
                    |  SYNC
                    |  RDHWR
                    |  BREAK
                    |  TEQ

/********************************************************************************************/
/* Floating-Point Instructions                                                              */ 
/********************************************************************************************/

// NOT SUPPORTED IN THE CURRENT VERSION
//op float_instr()

/********************************************************************************************/
/* Entry Point                                                                              */
/********************************************************************************************/

// Instructions

op instr_kind    =  non_branch_instr
                 |  branch_instr
                 |  special_instr
              // |  float_instr // NOT SUPPORTED IN THE CURRENT VERSION 
              // |  dummy_instr

op instruction (x : instr_kind)
    syntax = x.syntax
    image  = x.image
    action = {
        CIA = NIA;

        // if condition to execute next instruction before jumping to the address.
        if  branch == 0 then
            NIA = CIA + 4;
        else
            NIA = JMPADDR;
            branch = 0;
        endif;

        x.action;
        GPR[0] = 0;
    }
