
               ///////////////////////////////////////////////
              //    ARM 7 TDMI Description in Sim-nML      //
	         //        ( ARM Architecture v4 ) 		      // 
            //                    By                     //
           //      Amit Kulkarni and Nachiket Bhave     //
          //                                           //
         //          Last Modified: 04/06/2008        //
        ///////////////////////////////////////////////

//Data Types
//We need 5 bit index to address 31 GPR's
type index = card(4)

// doubleword, Word, halfword and byte
type dword = card(64)
type word = card(32)
type hword = card(16)
type byte_t = card(8)
type nibble = card(4)
type bit = card(1)
type Bit5 = card(5)
type Bit12 = card(12)
type Int24 = int(24)
//type single = float(23,9)  // NOT SUPPORTED IN THE CURRENT VERSION
//type double = float(52,12) // NOT SUPPORTED IN THE CURRENT VERSION

//Register file
reg GPR[32, word]

//Floating point registers 
//reg FREGS[32,single] // NOT SUPPORTED IN THE CURRENT VERSION

//fps register
reg FPS[1,word]

// Current Program Status Register
reg CPSR[word]

// Saved Program Status Register
reg SPSR[word]

//Coprocessor Registers
reg CP15[16, word]

//Constants

let byte_order = "little"
let PC = "GPR[15]"
let SP = "GPR[13]"
let FP = "GPR[12]"
let IP = "GPR[11]"

//Memory
mem M[2 ** 31, byte_t] 

//Variables
var amode[1,word]
var temp1[1,word]
var temp[1,word]
var shifter_carry_out[1,bit]
var ALU_OUT[1,word]
var carry[1,bit]
var X[1,bit]
var start_address[1,word]
var end_address[1,word]
var register_list[1,hword]
var address[1,word]
var target[1,word]
var tempint64[1,int(64)]
var tempcard64[1,card(64)]
var operand1[1,int(16)]
var operand2[1,int(16)]
var Result48[1,int(48)]
var op1[1,int(32)]
var op2[1,int(32)]
var sum[1,int(64)]
var cmp_tmp[1,card(32)]
var a[1,card(32)]

// Variables for floating point architecture
var sd[1,card(5)]
var sn[1,card(5)]
var sm[1,card(5)]

/********************************************************************************************/

//Immediate addressing mode
mode IMMEDIATE (r : nibble, c : byte_t) = coerce(card(32), c) >>> (r*2)
    syntax = format("#%x<<<%x*2", c, r)
    image  = format("%4b%8b", r, c)
    action = {
        if r == 0 then
            shifter_carry_out = 1;
        else
            temp = coerce(card(32), c) >>> (r*2);
            shifter_carry_out = temp<31 .. 31>;
        endif;
    }

mode REG (r : index) = r
    syntax = format("R%d", r)
    image = format("%4b", r)

/********************************************************************************************/
/* Data Processing Addressing Modes                                                         */
/********************************************************************************************/

mode LSL_IMMEDIATE (r : index, amount : Bit5) = GPR[r] << amount
/*
if (r == 15) then
    (GPR[r]+4) << amount
else
    GPR[r] << amount
endif
*/
    syntax = format("R%d , LSL #%d", r, amount)
    image = format("%5b000%4b", amount, r )
    action = {
/* TODO: the bitfield operation taking a non-constant variable is not supported yet. 
        if amount == 0 then 
            shifter_carry_out = CPSR<29 .. 29>;
        else
            shifter_carry_out = GPR[r]<32-amount .. 32-amount>;
        endif;
*/
    }

mode LSR_IMMEDIATE (r : index, amount : Bit5) = (GPR[r]) >> amount
/*if (r == 15) then
    (GPR[r]+4) >> amount
else
    GPR[r] >> amount 
endif
*/
    syntax = format("R%d , LSR #%d", r, amount)
    image  = format("%5b010%4b", amount, r)
    action = {
/* TODO: the bitfield operation taking a non-constant variable is not supported yet.
        if amount == 0 then 
            shifter_carry_out = GPR[r]<31 .. 31>;
        else
            temp = amount - 1;
            shifter_carry_out = GPR[r]<temp .. temp>;
        endif;
*/
    }

mode ASR_IMMEDIATE (r : index, amount : Bit5) = coerce(int(32),(GPR[r])) >> amount
/*if (r == 15) then
    coerce(int(32),(GPR[r]+4)) >> amount
else
    coerce(int(32),GPR[r]) >> amount
endif
*/
    syntax = format("R%d , ASR #%d", r, amount)
    image = format("%5b100%4b", amount, r)
    action = {
/* TODO: the bitfield operation taking a non-constant variable is not supported yet.
        if amount == 0 then
            if GPR[r]<31..31> == 0 then
                shifter_carry_out = GPR[r]<31 .. 31>;
            else
                shifter_carry_out = GPR[r]<31 .. 31>;
            endif;
        else
            shifter_carry_out = GPR[r]<amount-1 .. amount-1>;
        endif;
*/
    }
	
mode ROR_IMMEDIATE (r : index, amount : Bit5) = (GPR[r]) >>> amount
/*if (r == 15) then
    (GPR[r]+4) >>> amount
else
    GPR[r] >>> amount
endif
*/
    syntax = format("R%d , ROR #%d", r, amount)
    image  = format("%5b110%4b", amount, r)
    action = {
/* TODO: the bitfield operation taking a non-constant variable is not supported yet.
        if amount == 0 then
            shifter_carry_out = GPR[r]<0 .. 0>;
        else
            shifter_carry_out = GPR[r]<amount-1 .. amount-1>;
        endif;
*/
    }

// For Register specified right rotate with extend ( rotate right with carry )
mode RRX (r : index) = (coerce(card(32),CPSR<29 .. 29>) << 31) || ((GPR[r]) >> 1) 
/*if (r == 15) then 
    (coerce(card(32),CPSR<29 .. 29>) << 31) || ((GPR[r]+4) >> 1) 
else
    (coerce(card(32),CPSR<29 .. 29>) << 31) || ((GPR[r]) >> 1) 
endif
*/
    syntax = format("R%d , RRX ", r)
    image  = format("00000110%4b", r)
    action = {
        shifter_carry_out = GPR[r]<0 .. 0>;
    }

// For Register specified left shift / right shift / right shift arithmetic / right rotate by immediate 
mode REGISTER_SHIFT_IMMEDIATE =  LSL_IMMEDIATE 
                              |  LSR_IMMEDIATE 
                              |  ASR_IMMEDIATE 
                              |  ROR_IMMEDIATE 
//                            |  ROR_IMMEDIATE_ZERO
                              |  RRX

/********************************************************************************************/

mode LSR_REGISTER (r : index, amount : Bit5) = GPR[r] >> GPR[amount]
    syntax = format("R%d , LSR R%d", r, amount)
    image  = format("%4b0011%4b", amount, r)
    action = {
        if GPR[amount]<7 .. 0> == 0 then 
            shifter_carry_out = CPSR<29 .. 29>;
        else
            if GPR[amount]<7 .. 0> < 32 then
                temp = (GPR[amount]<7 .. 0>) - 1;
/* TODO: the bitfield operation taking a non-constant variable is not supported yet.
                shifter_carry_out = GPR[r]<temp .. temp>;
*/
            else
                if GPR[amount]<7 .. 0> == 32 then 
                    shifter_carry_out = GPR[r]<31 .. 31>;
                else 
                    if GPR[amount]<7 .. 0> > 32 then 
                        shifter_carry_out = 0;
                    endif;
                endif;
            endif;
        endif;
    }

mode LSL_REGISTER (r : index, amount : index) = GPR[r] << GPR[amount]
    syntax = format("R%d , LSL R%d", r, amount)
    image  = format("%4b0001%4b", amount, r)
    action = {
        if GPR[amount]<7 .. 0> == 0 then 
            shifter_carry_out = CPSR<29 .. 29>;
        else
            if GPR[amount]<7 .. 0> < 32 then
                temp = 32 - GPR[amount]<7 .. 0>;
/* TODO: the bitfield operation taking a non-constant variable is not supported yet.
                shifter_carry_out = GPR[r]<temp .. temp>;
*/
            else
                if GPR[amount]<7 .. 0> == 32 then 
                    shifter_carry_out = GPR[r]<0 .. 0>;
                else
                    if GPR[amount]<7 .. 0> > 32 then 
                        shifter_carry_out = 0;
                    endif;
                endif;
            endif;
        endif;
    }

mode ASR_REGISTER (r : index, amount : Bit5) = coerce(int(32), GPR[r]) >> GPR[amount]
    syntax = format("R%d , ASR R%d", r, amount)
    image  = format("%4b0101%4b", amount, r)
    action = {
        if GPR[amount]<7 .. 0> == 0 then 
            shifter_carry_out = CPSR<29 .. 29>;
        else
            if GPR[amount]<7 .. 0> < 32 then
                temp = (GPR[amount]<7 .. 0>) - 1; // TODO: parser issue. requires braces. needs investigation.
/* TODO: the bitfield operation taking a non-constant variable is not supported yet.
                shifter_carry_out = GPR[r]<temp .. temp>;
*/
            else
                if GPR[amount]<31 .. 31> == 0 then
                    shifter_carry_out = GPR[r]<31 .. 31>;
                else
                    shifter_carry_out = GPR[r]<31 .. 31>;
                endif;
            endif;
        endif;
    }

mode ROR_REGISTER (r : index, amount : Bit5) = GPR[r] >>> GPR[amount]<4 .. 0>
    syntax = format("R%d , ROR R%d", r, amount)
    image  = format("%4b0111%4b", amount, r)
    action = {
        if GPR[amount]<7 .. 0> == 0 then 
            shifter_carry_out = CPSR<29 .. 29>;
        else
            if GPR[amount]<4 .. 0> == 0 then 
                shifter_carry_out = GPR[r]<31 .. 31>;
            else
                temp = (GPR[amount]<4 .. 0>) - 1; // TODO: parser issue. requires braces. needs investigation.
/* TODO: the bitfield operation taking a non-constant variable is not supported yet.
                shifter_carry_out = GPR[r]<temp .. temp>;
*/
            endif;
        endif;	
	}

// For Register specified left shift / right shift / right shift arithmetic / right rotate by register 
mode REGISTER_SHIFT =  LSR_REGISTER 
                    |  LSL_REGISTER 
                    |  ASR_REGISTER 
                    |  ROR_REGISTER

/********************************************************************************************/

mode REGISTER0 () = GPR[0]
    syntax = "R0"
    image  = "000000000000"
    action = {
        shifter_carry_out = CPSR<29 .. 29>;
    }

mode REGISTER1 () = GPR[1]
    syntax = "R1"
    image  = "000000000001"
    action = {
        shifter_carry_out = CPSR<29 .. 29>;
    }

mode REGISTER2 () = GPR[2]
    syntax = "R2"
    image  = "000000000010"
    action = {
        shifter_carry_out = CPSR<29 .. 29>;
    }

mode REGISTER3 () = GPR[3]
    syntax = "R3"
    image  = "000000000011"
    action = {
        shifter_carry_out = CPSR<29 .. 29>;
    }

mode REGISTER4 () = GPR[4]
    syntax = "R4"
    image  = "000000000100"
    action = {
        shifter_carry_out = CPSR<29 .. 29>;
    }

mode REGISTER5 () = GPR[5]
    syntax = "R5"
    image  = "000000000101"
    action = {
        shifter_carry_out = CPSR<29 .. 29>;
    }

mode REGISTER6 () = GPR[6]
    syntax = "R6"
    image  = "000000000110"
    action = {
        shifter_carry_out = CPSR<29 .. 29>;
    }

mode REGISTER7 () = GPR[7]
    syntax = "R7"
    image  = "000000000111"
    action = {
        shifter_carry_out = CPSR<29 .. 29>;
    }

mode REGISTER8 () = GPR[8]
    syntax = "R8"
    image  = "000000001000"
    action = {
        shifter_carry_out = CPSR<29 .. 29>;
    }

mode REGISTER9 () = GPR[9]
    syntax = "R9"
    image  = "000000001001"
    action = {
        shifter_carry_out = CPSR<29 .. 29>;
    }

mode REGISTER10 () = GPR[10]
    syntax = "R10"
    image  = "000000001010"
    action = {
        shifter_carry_out = CPSR<29 .. 29>;
    }

mode REGISTER11 () = GPR[11]
    syntax = "R11"
    image  = "000000001011"
    action = {
        shifter_carry_out = CPSR<29 .. 29>;
    }

mode REGISTER12 () = GPR[12]
    syntax = "R12"
    image  = "000000001100"
    action = {
        shifter_carry_out = CPSR<29 .. 29>;
    }

mode REGISTER13 () = GPR[13]
    syntax = "R13"
    image  = "000000001101"
    action = {
        shifter_carry_out = CPSR<29 .. 29>;
    }

mode REGISTER14 () = GPR[14]
    syntax = "R14"
    image  = "000000001110"
    action = {
        shifter_carry_out = CPSR<29 .. 29>;
    }

mode REGISTER15 () = GPR[15]+4 
    syntax = "R15"
    image  = "000000001111"
    action = {
        shifter_carry_out = CPSR<29 .. 29>;
    }

mode DATA_PROCESSING =  REGISTER0
                     |  REGISTER1
                     |  REGISTER2
                     |  REGISTER3
                     |  REGISTER4
                     |  REGISTER5
                     |  REGISTER6
                     |  REGISTER7
                     |  REGISTER8
                     |  REGISTER9
                     |  REGISTER10
                     |  REGISTER11
                     |  REGISTER12
                     |  REGISTER13
                     |  REGISTER14
                     |  REGISTER15
                     |  REGISTER_SHIFT_IMMEDIATE 
                     |  REGISTER_SHIFT

/********************************************************************************************/
/* For S bit for Data Processing instructions                                               */
/********************************************************************************************/

mode setSon() = 0b1
    syntax = "S"
    image = "1"
    action = {
    }

mode setSoff() = 0b0
    syntax = ""
    image = "0"
    action = {
    }

mode setS = setSon | setSoff

/********************************************************************************************/
/* For Multiply instructions (X bit)                                                        */
/********************************************************************************************/

mode setXon() = 0b1
    syntax = "T"
    image = "1"
    action = {
    }

mode setXoff() = 0b0
    syntax = "B"
    image = "0"
    action = {
    }

mode setX = setXon | setXoff

/********************************************************************************************/
/* For Multiply Instructions (Y bit)                                                        */
/********************************************************************************************/

mode setYon() = 0b1
    syntax = "T"
    image = "1"
    action = {
    }

mode setYoff() = 0b0
    syntax = "B"
    image = "0"
    action = {
    }

mode setY = setYon | setYoff

/********************************************************************************************/
/* For U bit Load-Store instructions                                                        */
/********************************************************************************************/

mode setUon() = 0b1
    syntax = "+"
    image = "1"
    action = {
    }

mode setUoff() = 0b0
    syntax = "-"
    image = "0"
    action = {
    }

mode setU = setUon | setUoff

/********************************************************************************************/
/* Conditions Addressing Mode Components                                                    */
/*                                                                                          */
/* Every ARM instruction is conditionally executed and every                                */
/* instruction can supply a test field. For example "ADDEQ R1, R2, R3"                      */
/* adds R2 + R3 placing the result in R1 but only if the CPSR<30..30> flag is               */
/* set. The operation names are taken directly from the ARM manual.                         */
/*                                                                                          */
/********************************************************************************************/

mode equalcond()
    syntax = "EQ"
    image  = "0000"
    action = {
    if CPSR<30 .. 30> == 1 then
        X = 1;
    else
        X = 0;
    endif;
    }

mode notEqual()
    syntax = "NE"
    image = "0001"
    action = {
    if CPSR<30 .. 30> == 0 then
        X = 1;
    else
        X = 0;
    endif;
    }

mode unsignedHigherOrSame()
    syntax = "CS"
    image  = "0010"
    action = {
    if CPSR<29 .. 29> == 1 then
        X = 1;
    else
        X = 0;
    endif;
    }

mode unsignedLower()
    syntax = "CC"
    image  = "0011"
    action = {
    if CPSR<29 .. 29> == 0 then
        X = 1;
    else
        X = 0;
    endif;
    }

mode negative()
    syntax = "MI"
    image  = "0100"
    action = {
    if CPSR<31 .. 31> == 1 then
        X = 1;
    else
        X = 0;
    endif;
    }

mode positiveOrZero()
    syntax = "PL"
    image  = "0101"
    action = {
    if CPSR<31 .. 31> == 0 then
        X = 1;
    else
        X = 0;
    endif;
    }

mode withoverflow()
    syntax = "VS"
    image  = "0110"
    action = {
    if CPSR<28 .. 28> == 1 then
        X = 1;
    else
        X = 0;
    endif;
    }

mode noOverflow()
    syntax = "VC"
    image  = "0111"
    action = {
    if CPSR<28 .. 28> == 0 then
        X = 1;
    else
        X = 0;
    endif;
    }

mode unsignedHigher()
    syntax = "HI"
    image  = "1000"
    action = {
    if CPSR<29 .. 29> == 1 && CPSR<30 .. 30> == 0 then
        X = 1;
    else
        X = 0;
    endif;
    }

mode unsignedLowerOrSame()
    syntax = "LS"
    image  = "1001"
    action = {
    if CPSR<29 .. 29> == 0 || CPSR<30 .. 30> == 1 then
        X = 1;
    else
        X = 0;
    endif;
    }

mode greaterOrEqual()
    syntax = "GE"
    image = "1010"
    action = {
    if (CPSR<31 .. 31> == 1 && CPSR<28 .. 28> == 1) || (CPSR<31 .. 31> == 1 && CPSR<28 .. 28> == 0) then
        X = 1;
    else
        X = 0;
    endif;
    }

mode lessThan()
    syntax = "LT"
    image = "1011"
    action = {
    if (CPSR<31 .. 31> == 1 && CPSR<28 .. 28> == 0) || (CPSR<31 .. 31> == 0 & CPSR<28 .. 28> == 1) then
        X = 1;
    else
        X = 0;
    endif;
    }

mode greaterThan()
    syntax = "GT"
    image = "1100"
    action = {
    if CPSR<30 .. 30> == 0 && ((CPSR<31 .. 31> == 1 && CPSR<28 .. 28> == 1) || (CPSR<31 .. 31> == 1 && CPSR<28 .. 28> == 0)) then
        X = 1;
    else
        X = 0;
    endif;
    }

mode lessThanOrEqual()
    syntax = "LE"
    image = "1101"
    action = {
    if CPSR<30 .. 30> == 1 || ((CPSR<31 .. 31> == 1 && CPSR<28 .. 28> == 0) || (CPSR<31 .. 31> == 0 & CPSR<28 .. 28> == 1)) then
        X = 1;
    else
        X = 0;
    endif;
    }

mode blank()
    syntax = ""
    image = "1110"
    action = {
        X = 0b1;
    }

mode never()
    syntax = "NV"
    image = "1111"
    action = {
        X = 0b0;
    }

mode Condition =  equalcond 
               |  notEqual 
               |  unsignedHigherOrSame 
               |  unsignedLower
               |  negative
               |  positiveOrZero 
               |  withoverflow 
               |  noOverflow
               |  unsignedHigher 
               |  unsignedLowerOrSame 
               |  greaterOrEqual
               |  lessThan 
               |  greaterThan 
               |  lessThanOrEqual 
               |  blank
               |  never

/********************************************************************************************/
/* Branch Instructions                                                                      */
/********************************************************************************************/

op B (cond : Condition, offset : Int24)
    syntax = format("B%s %x", cond.syntax, offset)
    image  = format("%s1010%24b", cond.image, offset)
    action = {
        cond.action;
        if (X == 1) then
            GPR[15] = (GPR[15] + 4) + coerce(card(32), (coerce(int(30), offset) << 2));
        endif;
	}

op BL (cond : Condition, offset : Int24)
    syntax = format("BL%s %x", cond.syntax, offset)
    image  = format("%s1011%24b", cond.image, offset)
    action = {
        cond.action;
        if (X == 1) then
            GPR[14] = GPR[15];  
            GPR[15] = (GPR[15] + 4) + coerce(card(32), (coerce(int(30), offset) << 2));
        endif;
    }

op BX (cond : Condition, r : index)
    syntax = format("BX%s R%d", cond.syntax, r)
    image = format("%s000100100000000000000001%4b", cond.image, r)
    action = {
        cond.action;
        if ( X == 1 ) then
            CPSR<5 .. 5> = GPR[r]<0 .. 0>;
            GPR[15] = GPR[r] & 0xfffffffe;
        endif;
    }

op BLX (offset : Int24, Hbit : bit)
    syntax = format("BLX %x", offset)
    image = format("1111101%1b%24b", Hbit, offset)
    action = {
        GPR[14] = GPR[15];
        CPSR<5 .. 5> = 1;
        GPR[15] = GPR[15] + (coerce(int(30), offset) << 2) + (coerce(card(3), Hbit) << 2);
    }

op BLX2 (cond : Condition, r : index)
    syntax = format("BLX%s R%d", cond.syntax, r)
    image = format("%s000100100000000000000011%4b", cond.image, r)
    action = {
        cond.action;
        if X == 1 then
            target = GPR[r];
            GPR[14] = GPR[15];
            CPSR<5 .. 5> = target<0 .. 0>;
            GPR[15] = target & 0xfffffffe;
        endif;
    }

op branch_inst =  B
               |  BL
               |  BX
               |  BLX
               |  BLX2
    
/********************************************************************************************/
/* Multiplication Operations                                                                */
/********************************************************************************************/

op MUL (cond : Condition, sets : setS, src1 : REG, src2 : REG, src3 : REG)
    syntax = format("MUL%s%s %s, %s, %s", cond.syntax, sets.syntax, src1.syntax, src2.syntax, src3.syntax)
    image  = format("%s0000000%s%s0000%s1001%s", cond.image, sets.image, src1.image, src3.image, src2.image)
    action = {
        cond.action;
        if (X == 1) then
            GPR[src1] = (GPR[src2] * GPR[src3]);
            if (sets == 1) then
                CPSR<31 .. 31> = GPR[src1]<31 .. 31>;
                if (GPR[src1] == 0) then
                    CPSR<30 .. 30> = 1;
                else
                    CPSR<30 .. 30> = 0;
                endif;
            endif;
        endif;
    }
    
op MLA (cond : Condition, sets : setS, src1 : REG, src2 : REG, src3 : REG, src4 : REG)
    syntax = format("MLA%s%s %s, %s, %s, %s", cond.syntax, sets.syntax, src1.syntax, src2.syntax, src3.syntax, src4.syntax)
    image  = format("%s0000001%s%s%s%s1001%s", cond.image, sets.image, src1.image, src4.image, src3.image, src2.image)
    action = {
        cond.action;
        if (X == 1) then
            GPR[src1] = (GPR[src2] * GPR[src3] + GPR[src4]);
            if (sets == 1) then
                CPSR<31 .. 31> = GPR[src1]<31 .. 31>;
                if ( GPR[src1] == 0 ) then
                    CPSR<30 .. 30> = 1;
                else
                    CPSR<30 .. 30> = 0;
                endif;
            endif;
        endif;
    }
    
op SMULL (cond : Condition, sets : setS, low : REG, high : REG, src1 : REG, src2 : REG)
    syntax = format("SMULL%s%s %s, %s, %s, %s", cond.syntax, sets.syntax, low.syntax, high.syntax, src1.syntax, src1.syntax)
    image  = format("%s0000110%s%s%s%s1001%s", cond.image, sets.image, high.image, low.image, src2.image, src1.image)
    action = {
        cond.action;
        if (X == 1) then
            GPR[high]::GPR[low] = (coerce(int(64), GPR[src1]) * coerce(int(64), GPR[src2]));
            if (sets == 1) then
                CPSR<31 .. 31> = GPR[high]<31 .. 31>;
                if ((GPR[high] == 0) && (GPR[low] == 0)) then
                    CPSR<30 .. 30> = 1;
                else
                    CPSR<30 .. 30> = 0;
                endif;
            endif;
        endif;
    }

op UMULL (cond : Condition, sets : setS, low : REG, high : REG, src1 : REG, src2 : REG)
    syntax = format("SMULL%s%s %s, %s, %s, %s", cond.syntax, sets.syntax, low.syntax, high.syntax, src1.syntax, src1.syntax)
    image  = format("%s0000100%s%s%s%s1001%s", cond.image, sets.image, high.image, low.image, src2.image, src1.image)
    action = {
        cond.action;
        if (X == 1) then
            GPR[high]::GPR[low] = coerce(card(64), GPR[src1]) * coerce(card(64), GPR[src2]);
            if (sets == 1) then
                CPSR<31 .. 31> = GPR[high]<31 .. 31>;
                if ((GPR[high] == 0) && (GPR[low] == 0)) then
                    CPSR<30 .. 30> = 1;
                else
                    CPSR<30 .. 30> = 0;
                endif;
            endif;
        endif;
    }

op SMLAL (cond : Condition, sets : setS, low : REG, high : REG, src1 : REG, src2 : REG)
    syntax = format("SMULL%s%s %s, %s, %s, %s", cond.syntax, sets.syntax, low.syntax, high.syntax, src1.syntax, src1.syntax)
    image  = format("%s0000111%s%s%s%s1001%s", cond.image, sets.image, high.image, low.image, src2.image, src1.image)
    action = {
        cond.action;
        if (X == 1) then
            tempint64 = coerce(int(64), GPR[src1]) * coerce(int(64), GPR[src2]);
            carry::GPR[low] = (tempint64<31 .. 0>) + GPR[low]; // TODO: parser issue. requires braces. needs investigation. 
            GPR[high] = (tempint64<63 .. 32>) + GPR[high] + carry; // TODO: parser issue. requires braces. needs investigation.
            if (sets == 1) then
                CPSR<31 .. 31> = GPR[high]<31 .. 31>;
                if ((GPR[high] == 0) && (GPR[low] == 0)) then
                    CPSR<30 .. 30> = 1;
                else
                    CPSR<30 .. 30> = 0;
                endif;
            endif;
        endif;
    }

op UMLAL (cond : Condition, sets : setS, low : REG, high : REG, src1 : REG, src2 : REG)
    syntax = format("UMLAL%s%s %s, %s, %s, %s", cond.syntax, sets.syntax, low.syntax, high.syntax, src1.syntax, src1.syntax)
    image  = format("%s0000101%s%s%s%s1001%s", cond.image, sets.image, high.image, low.image, src2.image, src1.image)
    action = {
        cond.action;
        if (X == 1) then
            tempcard64 = coerce(card(64), GPR[src1]) * coerce(card(64), GPR[src2]);
            carry::GPR[low] = (tempcard64<31 .. 0>) + GPR[low]; // TODO: parser issue. requires braces. needs investigation.
            GPR[high] = (tempcard64<63 .. 32>) + GPR[high] + carry; // TODO: parser issue. requires braces. needs investigation. 
            if (sets == 1) then
                CPSR<31 .. 31> = GPR[high]<31 .. 31>;
                if ((GPR[high] == 0) && (GPR[low] == 0)) then
                    CPSR<30 .. 30> = 1;
                else
                    CPSR<30 .. 30> = 0;
                endif;
            endif;
        endif;
    }

op SMLAxy (cond : Condition, rd : index, rn : index, rs : index, xbit : setX, ybit : setY, rm : index)
    syntax = format("SMLA%s%s%s R%d, R%d, R%d, R%d", xbit.syntax, ybit.syntax, cond.syntax, rd, rm, rs, rn)
    image = format("%s00010000%4b%4b%4b1%s%s0%4b", cond.image, rd, rn, rs, ybit.image, xbit.image, rm)
    action = {
        cond.action;

        if (X == 1) then 
            if (xbit == 0) then 
                operand1 = coerce(int(16), GPR[rm]<15 .. 0>);
            else
                operand1 = coerce(int(16), GPR[rm]<31 .. 16>);
            endif;

            if (ybit == 0) then 
                operand2 = coerce(int(16), GPR[rs]<15 .. 0>);
            else
                operand2 = coerce(int(16), GPR[rs]<31 .. 16>);
            endif;

            carry::GPR[rd] = (operand1 * operand2) + coerce(int(32), GPR[rn]);

            if (carry == 1) then
                CPSR<27 .. 27> = 1;
            endif;

        endif;
    }

op SMLALxy (cond : Condition, rdHi : index, rdLo:index, rs : index, xbit : setX, ybit : setY, rm : index)
    syntax = format("SMLAL%s%s%s R%d, R%d, R%d, R%d", xbit.syntax, ybit.syntax, cond.syntax, rdHi, rdLo, rm, rs)
    image = format("%s00010100%4b%4b%4b1%s%s0%4b", cond.image, rdHi, rdLo, rs, ybit.image, xbit.image, rm)
    action = {
        cond.action;

        if (X == 1) then 
            if (xbit == 0) then 
                operand1 = coerce(int(16), GPR[rm]<15 .. 0>);
            else
                operand1 = coerce(int(16), GPR[rm]<31 .. 16>);
            endif;

            if (ybit == 0) then 
                operand2 = coerce(int(16), GPR[rs]<15 .. 0>);
            else
                operand2 = coerce(int(16), GPR[rs]<31 .. 16>);
            endif;

            carry::GPR[rdLo] = coerce(int(32), GPR[rdLo]) + (operand1 * operand2);

            if ((operand1 * operand2) < 0) then
                GPR[rdHi] = coerce(int(32), GPR[rdHi]) + carry + 0xffffffff;
            else
                GPR[rdHi] = coerce(int(32), GPR[rdHi]) + carry;
            endif;

        endif;
    }

op SMLAWy (cond : Condition, rd : index, rn : index, rs : index, ybit : setY, rm : index)
    syntax = format("SMLAW%s%s R%d, R%d, R%d, R%d", ybit.syntax, cond.syntax, rd, rm, rs, rn)
    image  = format("%s00010010%4b%4b%4b1%s00%4b", cond.image, rd, rn, rs, ybit.image, rm)
    action = {
        cond.action;

        if (X == 1) then 
            if (ybit == 0) then 
                operand2 = coerce(int(16), GPR[rs]<15 .. 0>);
            else
                operand2 = coerce(int(16), GPR[rs]<31 .. 16>);
            endif;

            Result48 = coerce(int(32), GPR[rm]) * operand2;

            carry::GPR[rd] = (Result48<47 .. 16>) + coerce(int(32), GPR[rn]); // TODO: parser issue. requires braces. needs investigation.

            if (carry == 1) then
                CPSR<27 .. 27> = 1;
            endif;

        endif;
    }

op SMULxy (cond : Condition, rd : index, rs : index, xbit : setX, ybit : setY, rm : index)
    syntax = format("SMUL%s%s%s R%d, R%d, R%d", cond.syntax, xbit.syntax, ybit.syntax, rd, rm, rs)
    image  = format("%s00010110%4b0000%4b1%s%s0%4b", cond.image, rd, rs, ybit.image, xbit.image, rm)
    action = {
        cond.action;

        if (X == 1) then 
            if (xbit == 0) then 
                operand1 = coerce(int(16), GPR[rm]<15 .. 0>);
            else
                operand1 = coerce(int(16), GPR[rm]<31 .. 16>);
            endif;

            if (ybit == 0) then 
                operand2 = coerce(int(16), GPR[rs]<15 .. 0>);
            else
                operand2 = coerce(int(16), GPR[rs]<31 .. 16>);
            endif;

            GPR[rd] = (operand1 * operand2);
        endif;
    }
    
op SMULWy (cond : Condition, rd : index, rs : index, ybit : setY, rm : index)
    syntax = format("SMUL%s%s R%d, R%d, R%d", cond.syntax, ybit.syntax, rd, rm, rs)
    image  = format("%s00010010%4b0000%4b1%s10%4b", cond.image, rd, rs, ybit.image, rm)
    action = {
        cond.action;

        if (X == 1) then 
            if (ybit == 0) then 
                operand2 = coerce(int(16), GPR[rs]<15 .. 0>);
            else
                operand2 = coerce(int(16), GPR[rs]<31 .. 16>);
            endif;

            Result48 = (operand1 * operand2);

            GPR[rd] = Result48<47 .. 16>;

        endif;
    }

op multiply_instructions =  MUL
                         |  MLA 
                         |  SMULL 
                         |  UMULL 
                         |  SMLAL 
                         |  UMLAL
                         |  SMLAxy
                         |  SMLALxy
                         |  SMLAWy
                         |  SMULxy
                         |  SMULWy
    
/********************************************************************************************/

op exception_generating_inst()
    syntax = "stub"
    image = "stub"
    action = {}

/********************************************************************************************/

op semaphore_instructions()
    syntax = "stub"
    image = "stub"
    action = {}

/********************************************************************************************/

op status_register_transfer_inst()
    syntax = "stub"
    image = "stub"
    action = {}

/********************************************************************************************/

op ADC(cond : Condition, sets : setS, src1 : REG, src2 : REG, src3 : DATA_PROCESSING)
    syntax = format("ADC%s%s %s, %s", cond.syntax, sets.syntax, src1.syntax, src2.syntax, src3.syntax)
    image = format("%s0000101%s%s%s%s", cond.image, sets.image, src2.image, src1.image, src3.image)
    action = {
        cond.action;
        src3.action;

        if (X == 1) then
            carry::ALU_OUT = GPR[src2] + src3 + CPSR<29 .. 29>;
            if (sets == 1 ) && (src1 == 15) then
                CPSR = SPSR;
            else if (sets == 1) then
                CPSR<31 .. 31> = ALU_OUT<31 .. 31>;
                if ALU_OUT == 0 then
                    CPSR<30 .. 30> = 1;	
                else 
                    CPSR<30 .. 30> = 0;
                endif;

                CPSR<29 .. 29> = carry;
                if (GPR[src2]<31 .. 31> == src3<31 .. 31>) && (ALU_OUT<31 .. 31> != GPR[src2]<31 .. 31>) then 
                    CPSR<28 .. 28> = 1;
                else
                    CPSR<28 .. 28> = 0;
                endif;

            endif;
            endif;

            GPR[src1] = ALU_OUT;
        endif;
    }

op ADC_IMMEDIATE(cond : Condition, sets : setS, src1 : REG, src2 : REG, src3 : IMMEDIATE)
    syntax = format("ADC%s%s %s, %s", cond.syntax, sets.syntax, src1.syntax, src2.syntax, src3.syntax)
    image = format("%s0010101%s%s%s%s", cond.image, sets.image, src2.image, src1.image, src3.image)
    action = {
        cond.action;
        src3.action;

        if (X == 1) then
            carry::ALU_OUT = GPR[src2] + src3 + CPSR<29 .. 29>;
            if (sets == 1 ) && (src1 == 15) then
                CPSR = SPSR;
            else if (sets == 1) then
                CPSR<31 .. 31> = ALU_OUT<31 .. 31>;
                if ALU_OUT == 0 then
                    CPSR<30 .. 30> = 1;
                else
                    CPSR<30 .. 30> = 0;
                endif;

                CPSR<29 .. 29> = carry;
                if (GPR[src2]<31 .. 31> == src3<31 .. 31>) && (ALU_OUT<31 .. 31> != GPR[src2]<31 .. 31>) then
                    CPSR<28 .. 28> = 1;
                else
                    CPSR<28 .. 28> = 0;
                endif;

            endif;
            endif;

            GPR[src1] = ALU_OUT;
        endif;
    }
    
op ADD(cond : Condition, sets : setS, src1 : REG, src2 : REG, src3 : DATA_PROCESSING)
    syntax = format("ADD%s%s %s, %s, %s", cond.syntax, sets.syntax, src1.syntax, src2.syntax, src3.syntax)
    image = format("%s0000100%s%s%s%s", cond.image, sets.image, src2.image, src1.image, src3.image)
    action = {
        cond.action;
        src3.action;

        if (X == 1) then
            carry::ALU_OUT = GPR[src2] + src3 ;
            if (sets == 1 ) && (src1 == 15) then
				CPSR = SPSR;
            else if (sets == 1) then
                CPSR<31 .. 31> = ALU_OUT<31 .. 31>;
                if ALU_OUT == 0 then
                    CPSR<30 .. 30> = 1;
                else
                    CPSR<30 .. 30> = 0;
                endif;

                CPSR<29 .. 29> = carry;
                if (GPR[src2]<31 .. 31> == src3<31 .. 31>) && (ALU_OUT != GPR[src2]<31 .. 31>) then 
                    CPSR<28 .. 28> = 1;
                else
                    CPSR<28 .. 28> = 0;
                endif;

            endif;
            endif;

            GPR[src1] = ALU_OUT;
        endif;
    }

op ADD_IMMEDIATE(cond : Condition, sets : setS, src1 : REG, src2 : REG, src3 : IMMEDIATE)
    syntax = format("ADD%s%s %s, %s, %s", cond.syntax, sets.syntax, src1.syntax, src2.syntax, src3.syntax)
    image = format("%s0010100%s%s%s%s", cond.image, sets.image, src2.image, src1.image, src3.image)
    action = {
        cond.action;
        src3.action;

        if (X == 1) then
            carry::ALU_OUT = GPR[src2] + src3 ;
            if (sets == 1 ) && (src1 == 15) then
                CPSR = SPSR;
            else if (sets == 1) then
                CPSR<31 .. 31> = ALU_OUT<31 .. 31>;
                if ALU_OUT == 0 then
                    CPSR<30 .. 30> = 1;
                else
                    CPSR<30 .. 30> = 0;
                endif;

                CPSR<29 .. 29> = carry;
                if (GPR[src2]<31 .. 31> == src3<31 .. 31>) && (ALU_OUT<31 .. 31> != GPR[src2]<31 .. 31>) then 
                    CPSR<28 .. 28> = 1;
                else
                    CPSR<28 .. 28> = 0;
                endif;

            endif;
            endif;

            GPR[src1] = ALU_OUT;
        endif;
    }


op data_processing_inst =  ADC
                        |  ADC_IMMEDIATE 
                        |  ADD
                        |  ADD_IMMEDIATE 
/*                      |  AND
                        |  AND_IMMEDIATE 
                        |  BIC
                        |  BIC_IMMEDIATE
                        |  CMN
                        |  CMN_IMMEDIATE
                        |  CMP
                        |  CMP_IMMEDIATE
                        |  EOR
                        |  EOR_IMMEDIATE
                        |  MOV 
                        |  MOV_IMMEDIATE
                        |  MVN 
                        |  MVN_IMMEDIATE
                        |  ORR 
                        |  ORR_IMMEDIATE
                        |  RSB 
                        |  RSB_IMMEDIATE
                        |  RSC
                        |  RSC_IMMEDIATE
                        |  SUB
                        |  SUB_IMMEDIATE 
                        |  SBC 
                        |  SBC_IMMEDIATE
                        |  TST
                        |  TST_IMMEDIATE 
                        |  TEQ
                        |  TEQ_IMMEDIATE 
*/    
    
/********************************************************************************************/
/* Load and Store Instructions                                                              */
/********************************************************************************************/

op LDR_IMMEDIATE_OFF (cond : Condition, src1 : REG, r : index, offset : Bit12, Ubit : setU)
    syntax = format("LDR%s %s, [ R%d, #%s%d ]", cond.syntax, src1.syntax, r, Ubit.syntax, offset)
    image  = format("%s0101%s001%4b%s%12b", cond.image, Ubit.image, r, src1.image, offset )
    action = {
        cond.action;

        if (r == 15) then 
            if (Ubit == 1) then
                amode =  (GPR[r] + 4) + coerce(card(32), offset);
            else
                amode = (GPR[r] + 4) - coerce(card(32), offset);
            endif; 	
        else
            if (Ubit == 1) then
                amode =  GPR[r] + coerce(card(32), offset);
            else
                amode = GPR[r] - coerce(card(32), offset);
            endif;
        endif;

        if (X == 1) then
            temp = M[amode + 3] :: M[amode + 2] :: M[amode + 1] :: M[amode];

            if (CP15[1]<22 .. 22> == 0) then 
                GPR[src1] = temp >>> (8 * amode<1 .. 0>);
            else
                GPR[src1] = temp;
            endif;

            if (src1 == 15) then 
                GPR[src1] = (GPR[src1]) & (0xfffffffc);
            endif;
        endif;
    }

op LDR_REGISTER_OFF (cond : Condition, src1 : REG, offset : index, Ubit : setU, r : index)
    syntax = format("LDR%s %s, [ R%d, %sR%d ]", cond.syntax, src1.syntax, r, Ubit.syntax, offset)
    image  = format("%s0111%s001%4b%s00000000%4b", cond.image, Ubit.image, r, src1.image, offset)
    action = {
        cond.action;

        if offset == 15 then
            if r == 15 then
                if (Ubit == 1) then
                    amode = (GPR[r] + 4) + coerce(card(32), (GPR[offset] + 4));
                else
                    amode = (GPR[r] + 4) - coerce(card(32), (GPR[offset] + 4));
                endif;
            else
                if (Ubit == 1) then
                    amode = GPR[r] + coerce(card(32), (GPR[offset] + 4));
                else
                    amode = GPR[r] - coerce(card(32), (GPR[offset] + 4));
                endif;
            endif;
        else
            if r == 15 then
                if (Ubit == 1) then
                    amode = (GPR[r] + 4) + coerce(card(32), GPR[offset]);
                else
                    amode = (GPR[r] + 4) - coerce(card(32), GPR[offset]);
                endif;
            else
                if (Ubit == 1) then
                    amode = GPR[r] + coerce(card(32), GPR[offset]);
                else
                    amode = GPR[r] - coerce(card(32), GPR[offset]);
                endif;
            endif;
        endif;

        if (X == 1) then
            temp = M[amode + 3] :: M[amode + 2] :: M[amode + 1] :: M[amode];

            if (CP15[1]<22 .. 22> == 0) then 
                GPR[src1] = temp >>> (8 * amode<1 .. 0>);
            else
                GPR[src1] = temp;
            endif;

            if (src1 == 15) then 
                GPR[src1] = (GPR[src1]) & (0xfffffffc);
            endif;
        endif;
    }

op LDR_SCALED_REGISTER_OFF(cond : Condition, src1 : REG, r : index, shift : REGISTER_SHIFT_IMMEDIATE, Ubit : setU)
    syntax = format("LDR%s %s, [ R%d, %s%s ]", cond.syntax, src1.syntax, r, Ubit.syntax, shift.syntax)
    image  = format("%s0111%s001%4b%s%s", cond.image, Ubit.image, r, src1.image, shift.image)
    action = {
        cond.action;

        if r == 15 then
            if (Ubit == 1) then
                amode = (GPR[r] + 4) + shift;
            else
                amode = (GPR[r] + 4) - shift;
            endif; 
        else
            if (Ubit == 1) then
                amode = GPR[r] + shift;
            else
                amode = GPR[r] - shift;
            endif; 	
        endif;

        if (X == 1) then
            temp = M[amode + 3] :: M[amode + 2] :: M[amode + 1] :: M[amode];

            if (CP15[1]<22 .. 22> == 0) then 
                GPR[src1] = temp >>> (8 * amode<1 .. 0>);
            else
                GPR[src1] = temp;
            endif;

            if (src1 == 15) then 
                GPR[src1] = (GPR[src1]) & (0xfffffffc);
            endif;
        endif;
    }
    
 op LDR_IMMEDIATE_PRE_INDEXED (cond : Condition, src1 : REG, r : index, offset : Bit12, Ubit : setU)
    syntax = format("LDR%s %s, [ R%d, #%s%d ]!",cond.syntax, src1.syntax, r, Ubit.syntax, offset)
    image  = format("%s0101%s011%4b%s%12b", cond.image, Ubit.image, r, src1.image, offset)
    action = {
        cond.action;

        if (Ubit == 1) then
            amode = GPR[r] + coerce(card(32), offset);
        else
            amode = GPR[r] - coerce(card(32), offset);
        endif;

        if (X == 1) then 
            if (Ubit == 1) then
                GPR[r] = GPR[r] + coerce(card(32), offset);
            else
                GPR[r] = GPR[r] - coerce(card(32), offset);
            endif;
        endif;
	
        if (X == 1) then
            temp = M[amode+3] :: M[amode+2] :: M[amode+1] :: M[amode];

            if (CP15[1]<22 .. 22> == 0) then 
                GPR[src1] = temp >>> (8 * amode<1 .. 0>);
            else
                GPR[src1] = temp;
            endif;

            if (src1 == 15) then
                GPR[src1] = (GPR[src1]) & (0xfffffffc);
            endif;
        endif;
	}

op load_store_inst =  LDR_IMMEDIATE_OFF
                   |  LDR_REGISTER_OFF
                   |  LDR_SCALED_REGISTER_OFF
                   |  LDR_IMMEDIATE_PRE_INDEXED
/*                 |  LDR_REGISTER_PRE_INDEXED
                   |  LDR_SCALED_REGISTER_PRE_INDEXED
                   |  LDR_IMMEDIATE_POST_INDEXED
                   |  LDR_REGISTER_POST_INDEXED
                   |  LDR_SCALED_REGISTER_POST_INDEXED

                   |  LDRB_IMMEDIATE_OFF
                   |  LDRB_REGISTER_OFF
                   |  LDRB_SCALED_REGISTER_OFF
                   |  LDRB_IMMEDIATE_PRE_INDEXED
                   |  LDRB_REGISTER_PRE_INDEXED
                   |  LDRB_SCALED_REGISTER_PRE_INDEXED
                   |  LDRB_IMMEDIATE_POST_INDEXED
                   |  LDRB_REGISTER_POST_INDEXED
                   |  LDRB_SCALED_REGISTER_POST_INDEXED
*//*
			|	LDRBT_IMMEDIATE_POST_INDEXED
			|	LDRBT_REGISTER_POST_INDEXED
			|	LDRBT_SCALED_REGISTER_POST_INDEXED

			|	LDRT_IMMEDIATE_POST_INDEXED
			|	LDRT_REGISTER_POST_INDEXED
			|	LDRT_SCALED_REGISTER_POST_INDEXED

			|	LDRH_MISC_IMMEDIATE_OFF
			|	LDRH_MISC_REGISTER_OFF
			|	LDRH_MISC_IMMEDIATE_PRE_INDEXED
			|	LDRH_MISC_REGISTER_PRE_INDEXED
			|	LDRH_MISC_IMMEDIATE_POST_INDEXED
			|	LDRH_MISC_REGISTER_POST_INDEXED

			|	LDRSH_MISC_IMMEDIATE_OFF
			|	LDRSH_MISC_REGISTER_OFF
			|	LDRSH_MISC_IMMEDIATE_PRE_INDEXED
			|	LDRSH_MISC_REGISTER_PRE_INDEXED
			|	LDRSH_MISC_IMMEDIATE_POST_INDEXED
			|	LDRSH_MISC_REGISTER_POST_INDEXED

			|	LDRSB_MISC_IMMEDIATE_OFF
			|	LDRSB_MISC_REGISTER_OFF
			|	LDRSB_MISC_IMMEDIATE_PRE_INDEXED
			|	LDRSB_MISC_REGISTER_PRE_INDEXED
			|	LDRSB_MISC_IMMEDIATE_POST_INDEXED
			|	LDRSB_MISC_REGISTER_POST_INDEXED 
			
			|	LDRD_MISC_IMMEDIATE_OFF
			|	LDRD_MISC_REGISTER_OFF
			|	LDRD_MISC_IMMEDIATE_PRE_INDEXED
			|	LDRD_MISC_REGISTER_PRE_INDEXED
			|	LDRD_MISC_IMMEDIATE_POST_INDEXED
			|	LDRD_MISC_REGISTER_POST_INDEXED 
			
			|	STR_IMMEDIATE_OFF
			|	STR_REGISTER_OFF
			|	STR_SCALED_REGISTER_OFF
			|	STR_IMMEDIATE_PRE_INDEXED
			|	STR_REGISTER_PRE_INDEXED
			|	STR_SCALED_REGISTER_PRE_INDEXED
			|	STR_IMMEDIATE_POST_INDEXED
			|	STR_REGISTER_POST_INDEXED
			|	STR_SCALED_REGISTER_POST_INDEXED

			|	STRB_IMMEDIATE_OFF
			|	STRB_REGISTER_OFF
			|	STRB_SCALED_REGISTER_OFF
			|	STRB_IMMEDIATE_PRE_INDEXED
			|	STRB_REGISTER_PRE_INDEXED
			|	STRB_SCALED_REGISTER_PRE_INDEXED
			|	STRB_IMMEDIATE_POST_INDEXED
			|	STRB_REGISTER_POST_INDEXED
			|	STRB_SCALED_REGISTER_POST_INDEXED

			|	STRBT_IMMEDIATE_POST_INDEXED
			|	STRBT_REGISTER_POST_INDEXED
			|	STRBT_SCALED_REGISTER_POST_INDEXED

			|	STRT_IMMEDIATE_POST_INDEXED
			|	STRT_REGISTER_POST_INDEXED
			|	STRT_SCALED_REGISTER_POST_INDEXED

			|	STRH_MISC_IMMEDIATE_OFF
			|	STRH_MISC_REGISTER_OFF
			|	STRH_MISC_IMMEDIATE_PRE_INDEXED
			|	STRH_MISC_REGISTER_PRE_INDEXED
			|	STRH_MISC_IMMEDIATE_POST_INDEXED
			|	STRH_MISC_REGISTER_POST_INDEXED

			|	STRD_MISC_IMMEDIATE_OFF
			|	STRD_MISC_REGISTER_OFF
			|	STRD_MISC_IMMEDIATE_PRE_INDEXED
			|	STRD_MISC_REGISTER_PRE_INDEXED
			|	STRD_MISC_IMMEDIATE_POST_INDEXED
			|	STRD_MISC_REGISTER_POST_INDEXED 
*/
    
/********************************************************************************************/

op load_store_multiple()
    syntax = "stub"
    image = "stub"
    action = {}

/********************************************************************************************/

op coprocessor_inst()
    syntax = "stub"
    image = "stub"
    action = {}

/********************************************************************************************/

op miscellaneous_inst()
    syntax = "stub"
    image = "stub"
    action = {}
    
/********************************************************************************************/

op saturated_addsub_inst()
    syntax = "stub"
    image = "stub"
    action = {}

/********************************************************************************************/

op preload_instruction(a1 : index, a2 : index)
    syntax = "stub"
    image = "stub"
    action = {
       if (a1 == coerce(card(32), a2)) then
          a1 = a2;
       endif;
    }


/********************************************************************************************/

op inst_type =  branch_inst
             |	multiply_instructions
//           |	exception_generating_inst
//           |	semaphore_instructions
//           |	status_register_transfer_inst
             |  data_processing_inst
             |	load_store_inst
//           |	load_store_multiple
//           |	coprocessor_inst
//           | 	miscellaneous_inst
//           |	saturated_addsub_inst
//           |	preload_instruction
//           |	floating_point_inst // NOT SUPPORTED IN THE CURRENT VERSION

op instruction (x : inst_type)
    syntax = x.syntax
    image = x.image
    action = {
        GPR[15] = GPR[15] + 4;
        x.action;
    }
