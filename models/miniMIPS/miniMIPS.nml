/************************************************************
 *
 *	     miniMIPS Description in Sim-nML		
 *	               
 ************************************************************/
	  
// Constants

let REGS = 5
let byte_order = "big"
let PC = "NIA"
let SP = "GPR[29]"

// Type declarations

type bit 			= card ( 1 )
type byte 			= card ( 8 )
type word 			= card ( 32 )
type long 			= card ( 32 )
type signed_long 	= int ( 32 )
type address 		= card ( 32 )
type index 			= card ( REGS )
type breakcode		= card ( 20 )
type flot = float ( 52 , 12 )
type flots = float ( 23, 9 )
type cond_code = card ( 3 )
type cond = card ( 4 )

// Memory and registers

mem M [ 2 ** 31 , byte ] 
reg GPR [ 2 ** REGS , signed_long ]

// Lower 32 bits of multiplication result and quotient of divition result

reg LO [ 1 , signed_long ] 

// Next instruction address

reg NIA [ 1 , long ] 

reg FPR [ 2 ** REGS , flots]

// Port = 2,1  

// Higher 32/16 bits of multiplication result of 32*16 bit or 32*32 bit operands.. remainder                             
// For div operations 

reg HI [ 1 , signed_long ] 

// Variables

// Current instruction address
mem CIA [ 1 , long ] 

reg FPSCR [ 1 , long ]
reg FCCR [ 1 , long ]


// In minimips processors jmp instruction executes next instruction within the delay slot. Thus
// return address is current address plus 8
// Jmp_flag and jmp_addr are added 
// var jmp_flag [ 1 , card (1) ] = 0
// var jmp_addr [ 1 , long ]


mem tmp_signed_byte [ 1 , int (8) ]
mem tmp_unsigned_byte [ 1 , card (8) ]
mem tmp_signed_half_word [ 1 , int (16) ]
mem tmp_unsigned_half_word [ 1 , card (16) ]
mem tmp_signed_word [ 1 , int (32) ]
mem tmp_signed_word1 [ 1 , int (32) ]
mem tmp_unsigned_word [ 1 , card (32) ]
mem tmp_double_word  [ 1 , card (64) ]
mem TMP_FLOT [ 1 , flot ]
mem TMP_FLOTS [ 1, flots ]
mem TMP2_FLOT [ 1 , flot ] 
mem TMP_SDWORD [ 1 , int ( 64 ) ]
mem overflow_bit [ 1 , bit ]

// Effective address for memory access

mem EA [ 1 , address ] 
mem tmp_div [ 1 , int ( 64 ) ]
mem mulsize [ 1 , bit ]
mem multsize [ 1 , bit ]
mem divsize [ 1 , card (5) ]

// In minimips processors jmp instruction executes next instruction within the delay slot. Thus
// return address is current address plus 8
// branch instr will first modify this

mem JMPADDR [ 1 , long ]
mem branch [ 1 , bit ]
mem signadjust [1, bit]
mem likely [ 1 , card (2) ]
 
// Aliases

// HalfWord Integer

mem tmp_signed_half_word_A0 [ 1 , int ( 8 ) ]
    alias = tmp_signed_half_word [ 8 ]

mem tmp_signed_half_word_A1 [ 1 , int ( 8 ) ]
    alias = tmp_signed_half_word [ 0 ]

// HalfWord Card

mem tmp_unsigned_half_word_A0 [ 1 , int ( 8 ) ]
    alias = tmp_unsigned_half_word [ 8 ]

mem tmp_unsigned_half_word_A1 [ 1 , int ( 8 ) ]
    alias = tmp_unsigned_half_word [ 0 ]

// Word Integers

mem tmp_signed_word_A0 [ 1 , int ( 8 ) ]
    alias = tmp_signed_word [ 24 ]
        
mem tmp_signed_word_A1 [ 1 , int ( 8 ) ]
    alias = tmp_signed_word [ 16 ]

mem tmp_signed_word_A2 [ 1 , int ( 8 ) ]
    alias = tmp_signed_word [ 8 ]

mem tmp_signed_word_A3 [ 1 , int ( 8 ) ]
    alias = tmp_signed_word [ 0 ]

// Word Card

mem tmp_unsigned_word_A0 [ 1 , int ( 8 ) ]
    alias = tmp_unsigned_word [ 24 ]
        
mem tmp_unsigned_word_A1 [ 1 , int ( 8 ) ]
    alias = tmp_unsigned_word [ 16 ]

mem tmp_unsigned_word_A2 [ 1 , int ( 8 ) ]
    alias = tmp_unsigned_word [ 8 ]

mem tmp_unsigned_word_A3 [ 1 , int ( 8 ) ]
    alias = tmp_unsigned_word [ 0 ]

// Double word card 

mem tmp_double_word_A0 [ 1 , card ( 16 ) ]
    alias = tmp_double_word [ 32 ]
        
mem tmp_double_word_A1 [ 1 , card ( 16 ) ]
    alias = tmp_double_word [ 0 ]
    
// Aliases for Float Temps

// Double Presicion Float

mem TMP_FLOT_A0 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 56 ]

mem TMP_FLOT_A1 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 48 ]

mem TMP_FLOT_A2 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 40 ]

mem TMP_FLOT_A3 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 32 ]

mem TMP_FLOT_A4 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 24 ]

mem TMP_FLOT_A5 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 16 ]

mem TMP_FLOT_A6 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 8 ]

mem TMP_FLOT_A7 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 0 ]

// Single Presicion Float

mem TMP_FLOTS_A0 [ 1 , int ( 8 ) ]
    alias = TMP_FLOTS [ 24 ]

mem TMP_FLOTS_A1 [ 1 , int ( 8 ) ]
    alias = TMP_FLOTS [ 16 ]

mem TMP_FLOTS_A2 [ 1 , int ( 8 ) ]
    alias = TMP_FLOTS [ 8 ]

mem TMP_FLOTS_A3 [ 1 , int ( 8 ) ]
    alias = TMP_FLOTS [ 0 ]


// Addressing modes

mode REG_IND_ZERO ( r : index ) = GPR [ r ]
    /* if r == 0 then
        0
     else
        GPR [ r ]
     endif
	*/
   syntax = format ( "%d", r )
   image  = format ( "%5b", r )

mode REG_IND ( r : index) = r
	syntax = format( "%d", r)
	image = format( "%5b", r)

mode IMM26 ( n : int ( 26 ) ) = n
   syntax = format ( "%d", n )
   image  = format ( "%26b", n )

mode IMM16 ( n : int ( 16 ) ) = n
   syntax = format ( "%d", n )
   image  = format ( "%16b", n )
   
// Instructions

op instruction ( x : instr_kind )
	syntax = x.syntax
	image  = x.image
	action = { 			
			
			CIA = NIA;
			// if condition to execute next instruction before jumping to the address.
			if  branch == 0 then
				NIA = CIA + 4;	
			else 
				NIA = JMPADDR;
				branch = 0;	
			endif;

			x.action; 		
			GPR[0] = 0;
			
	}


op ADD (rd : index , rs : REG_IND_ZERO , rt : REG_IND_ZERO)
    syntax = format ( "ADD %d, %s, %s" , rd, rs.syntax, rt.syntax )
    image  = format ( "000000%s%s%5b00000100000", rs.image, rt.image, rd) 
    action = { 
		overflow_bit::tmp_unsigned_word = rs + rt;
		if ( overflow_bit == 1 ) then
			"print" ("Integer Overflow Exception");
		else
			GPR [rd] = tmp_unsigned_word;
		endif;
	      }	  


op ADDU (rd : index , rs : REG_IND_ZERO , rt : REG_IND_ZERO)
    syntax = format ( "ADDU %d, %s, %s" , rd, rs.syntax, rt.syntax )
    image  = format ( "000000%s%s%5b00000100001", rs.image, rt.image, rd) 
    action = {
		GPR [rd] = rs + rt;	
   	     }	     


op ADDI (rt : index , rs : REG_IND_ZERO , immediate : IMM16 )
    syntax = format ( "ADDI %d, %s, %s" , rt , rs.syntax , immediate.syntax )
    image = format ( "001000%s%5b%s" , rs.image , rt , immediate.image )
    action = { 
		overflow_bit::tmp_unsigned_word = rs + immediate;
		if ( overflow_bit == 1 ) then
			"print" ("Integer Overflow Exception");
		else
			GPR [rt] = tmp_unsigned_word;
		endif;
	      }


op ADDIU (rt : index , rs : REG_IND_ZERO , immediate : IMM16 )
    syntax = format ( "ADDIU %d, %s, %s" , rt , rs.syntax , immediate.syntax )
    image = format ( "001001%s%5b%s" , rs.image , rt , immediate )
    action = {
		GPR [rt] = rs + immediate;
	     }    


op AND (rd : index , rs : REG_IND_ZERO , rt : REG_IND_ZERO)
    syntax = format ( "AND %d, %s, %s" ,  rd, rs.syntax, rt.syntax )
    image  = format ( "000000%s%s%5b00000100100", rs.image, rt.image, rd) 
    action = {
		GPR [rd] = rs & rt;
	     }	   

   
op ANDI (rt : index , rs : REG_IND_ZERO , immediate : IMM16 )
    syntax = format ( "ANDI %d, %s, %s" , rt , rs.syntax , immediate.syntax )
    image = format ( "001100%s%5b%s" , rs.image , rt , immediate.image )
    action = {
		tmp_signed_word = immediate & 0x0000ffff;
		GPR [rt] = tmp_signed_word & rs ;
		
	     }   


op BEQ (rs : REG_IND_ZERO , rt :  REG_IND_ZERO , offset : IMM16 )
    syntax = format ( "BEQ %s, %s, %s" , rs.syntax , rt.syntax , offset.syntax )
    image = format ( "000100%s%s%s", rs.image, rt.image, offset.image )
    action = {
		//	offset = offset << 2;
		//	NIA = CIA + offset;
		
		if ( rs == rt ) then
			branch = 1;
			tmp_signed_word=offset;
			tmp_signed_word=tmp_signed_word << 2;
			JMPADDR = NIA + tmp_signed_word;
			//JMPADDR = NIA + ( offset << 2 );
		endif;
	     }

	     
op BGEZ (rs : REG_IND_ZERO , offset : IMM16)
    syntax = format ( "BGEZ %s, %s" , rs.syntax, offset.syntax )	   
    image = format ( "000001%s00001%s" , rs.image, offset.image )
    action = {
		//	offset = offset << 2;
		//	NIA = NIA + ( offset << 2 );
		
			if ( rs >= 0 ) then
		 		branch = 1;
				tmp_signed_word=offset;
				tmp_signed_word=tmp_signed_word << 2;
				JMPADDR = NIA + tmp_signed_word;
			//	JMPADDR = NIA + ( offset << 2 );
			endif;
	     }

		    
op BGEZAL (rs : REG_IND_ZERO , offset : IMM16  )
    syntax = format ( "BGEZAL %s, %s" , rs.syntax, offset.syntax )	   
    image = format ( "000001%s10001%s" , rs.image, offset.image )
    action = {
		//	offset = offset << 2;
		//	NIA = CIA + offset;
		
		if ( rs >= 0 ) then
			branch = 1;
			tmp_signed_word=offset;
			tmp_signed_word=tmp_signed_word << 2;
			JMPADDR = NIA + tmp_signed_word;
		//	JMPADDR = NIA + ( offset << 2 );
			GPR [31] = CIA + 8;
		endif;
	     }

    
op BGTZ (rs : REG_IND_ZERO , offset : IMM16 )
    syntax = format ( "BGTZ %s, %s" , rs.syntax , offset.syntax)
    image = format ( "000111%s00000%s" , rs.image , offset.image )
    action = {
		if ( rs > 0 ) then
		//	offset = offset << 2;
		//	NIA = CIA + offset;
			branch = 1;
			tmp_signed_word=offset;
			tmp_signed_word=tmp_signed_word << 2;
			JMPADDR = NIA + tmp_signed_word;
	//		JMPADDR = NIA + ( offset << 2 );
		endif;
	     }


op BLEZ (rs : REG_IND_ZERO , offset : IMM16 )
    syntax = format ( "BLEZ %s, %s" , rs.syntax , offset.syntax)
    image = format ( "000110%s00000%s" , rs.image , offset.image )
    action = {
		if ( rs <= 0 ) then
		//	offset = offset << 2;
		//	NIA = CIA + offset;
			branch = 1;
			tmp_signed_word=offset;
			tmp_signed_word=tmp_signed_word<<2;
			JMPADDR = NIA + tmp_signed_word;
		//	JMPADDR = NIA + ( offset << 2 );
		endif;
	     }


op BLTZ (rs : REG_IND_ZERO , offset : IMM16)
    syntax = format ( "BLTZ %s, %s" , rs.syntax, offset.syntax )	   
    image = format ( "000001%s00000%s" , rs.image, offset.image )
    action = {
		//	if ( rs < 0 ) then
		//	offset = offset << 2;
		//	NIA = CIA + offset;
		//	NIA = NIA + ( offset << 2 );

			if ( rs < 0 ) then
				branch = 1;
				tmp_signed_word=offset;
				tmp_signed_word=tmp_signed_word << 2;
				JMPADDR = NIA + tmp_signed_word;
			//	JMPADDR = NIA + ( offset << 2 );
			endif;
	     }

    
op BLTZAL (rs : REG_IND_ZERO , offset : IMM16  )
    syntax = format ( "BLTZAL %s, %s" , rs.syntax, offset.syntax )	   
    image = format ( "000001%s10000%s" , rs.image, offset.image )
    action = {
		//	offset = offset << 2;
		//	NIA = CIA + offset;
		
		if ( rs < 0 ) then
			branch = 1;
			tmp_signed_word=offset;
			tmp_signed_word=tmp_signed_word << 2;
			JMPADDR = NIA + tmp_signed_word;
		//	JMPADDR = NIA + ( offset << 2 );
		//	GPR [31] = NIA + 4;
			GPR [31] = CIA + 8;
		endif;
	     }

    
op BNE (rs : REG_IND_ZERO , rt : REG_IND_ZERO , offset : IMM16 )
    syntax = format ( "BNE %s, %s, %s" , rs.syntax , rt.syntax , offset.syntax )
    image = format ( "000101%s%s%s", rs.image, rt.image, offset.image )
    action = {
		if ( rs != rt ) then
		//	offset = offset << 2;
		//	NIA = CIA + offset;
			branch = 1;
			tmp_signed_word=offset;
			tmp_signed_word=tmp_signed_word << 2;
			JMPADDR = NIA + tmp_signed_word;
		//	JMPADDR = NIA + ( offset << 2 );
		endif;
	     }
	     

op BREAK (cde : breakcode )
    syntax = format ( "BREAK %d" , cde )
    image = format ( "000000%20b001101" , cde )
    action = {
	     
		}


op J (target : IMM26)
    syntax = format ( "J %s" , target.syntax )
    image  = format ( "000010%s" , target.image )
    action = {
		branch = 1;
		CIA = NIA;
		JMPADDR = CIA & 4026531840;
		//target = target << 2;
		JMPADDR = JMPADDR | ( target << 2) ;
	      }     


op JAL (target : IMM26)
    syntax = format ( "JAL %s" , target.syntax )
    image = format ( "000011%s" , target.image )
    action = {
		branch = 1;
		CIA = NIA;
		JMPADDR = CIA & 4026531840;
	//	target = target << 2;
	//	NIA = NIA | target;
		JMPADDR = JMPADDR | ( target << 2) ;
		GPR [31] = CIA + 4;
	      }  

    
op JALR ( rs : REG_IND_ZERO ) 
    syntax = format ( "JALR %s" , rs.syntax ) 
    image  = format ( "000000%s000001111100000001001", rs.image )		      
    action = {
		branch = 1;
		CIA = NIA;
		JMPADDR = rs;
		GPR [31] = CIA + 4;
		
	    }

	    
op JR ( rs : REG_IND_ZERO ) 
    syntax = format ( "JR  %s" , rs.syntax ) 
    image  = format ( "000000%s000000000000000001000", rs.image)		      
    action = {
		branch = 1;
		CIA = NIA;
		JMPADDR = rs;
	     }
    
    
op LUI ( rt : REG_IND , offset : IMM16 )
    syntax = format ( "LUI %s, %s" , rt.syntax, offset.syntax )
    image  = format ( "00111100000%s%s" , rt.image , offset.image )
    action = {
		GPR [rt] = offset << 16;

	     }  
	         
		
op LW (base : REG_IND_ZERO , rt : REG_IND , offset : IMM16 )
    syntax = format ( "LW %s, %s(%s)" , rt.syntax , offset.syntax, base.syntax )
    image = format ( "100011%s%s%s" , base.image, rt.image, offset.image )
    action = {
		EA =  base + offset;
		tmp_signed_word_A0 = M [ EA ];
		tmp_signed_word_A1 = M [ EA + 1];
		tmp_signed_word_A2 = M [ EA + 2];
		tmp_signed_word_A3 = M [ EA + 3];
		GPR [rt] = tmp_signed_word;
	     } 


op LWC0 (base : REG_IND_ZERO , rt : REG_IND , offset : IMM16 )
    syntax = format ( "LWC0 %s, %s(%s)" , rt.syntax , offset.syntax, base.syntax )
    image = format ( "110000%s%s%s" , base.image, rt.image, offset.image )
    action = {
		EA =  base + offset;
		tmp_signed_word_A0 = M [ EA ];
		tmp_signed_word_A1 = M [ EA + 1];
		tmp_signed_word_A2 = M [ EA + 2];
		tmp_signed_word_A3 = M [ EA + 3];
		GPR [rt] = tmp_signed_word;
	     } 


op MFC0 (rt : REG_IND , fs : index)
    syntax = format ( "MFC0 %s,%d", rt.syntax, fs )
    image  = format ( "01000100000%s%5b00000000000", rt.image , fs ) 
    action = {
		GPR [ rt ] < 31 .. 0 > = FPR [ fs ] < 31 .. 0 >;
             }


op MFHI ( rd : index )
    syntax = format ( "MFHI %d" , rd )
    image  = format ( "0000000000000000%5b00000010000" , rd )
    action = {
		GPR [rd] = HI;
	     }     
    
op MFLO ( rd : index )
    syntax = format ( "MFLO %d" , rd )
    image  = format ( "0000000000000000%5b00000010010" , rd )
    action = {
		GPR [rd] = LO;
	     }     
    

op MTC0 (rt : REG_IND , fs : index)
    syntax = format ( "MTC0 %s,%d", rt.syntax, fs )
    image  = format ( "01000100100%s%5b00000000000", rt.image , fs ) 
    action = {
		FPR [ fs ] < 31 .. 0 > = GPR [ rt ] < 31 .. 0 >;
             }


op MTHI ( rs : REG_IND_ZERO )    
    syntax = format ( "MTHI %s" , rs.syntax )
    image  = format ( "000000%s000000000000000010001" , rs.image )
    action = {
		HI = rs;
	     }
	     

op MTLO ( rs : REG_IND_ZERO )    
    syntax = format ( "MTLO %s" , rs.syntax )
    image  = format ( "000000%s000000000000000010011" , rs.image )
    action = {
		LO = rs;
	     }


op MULT ( rs : REG_IND_ZERO , rt : REG_IND_ZERO )
    syntax = format ( "MULT %s, %s" , rs.syntax , rt.syntax )
    image  = format ( "000000%s%s0000000000011000" , rs.image , rt.image )
    action = {
    		
		TMP_SDWORD = rs ;

		// Following two "if"s code looks like doing nothing 
		// but the generated code doesn't contain ( 0xffffffff & S_GPR[rs] )
		// it will contain S_GPR[rs] in the assignment statement.

		if ( rs < 0 ) then 
		//	TMP_SDWORD = - TMP_SDWORD ;
		endif;

		tmp_div = rt ;
		if ( rt < 0 ) then
		//	tmp_div = - tmp_div ;
		endif;

		TMP_SDWORD = TMP_SDWORD * tmp_div ;
		 HI < 31 .. 0 > = TMP_SDWORD < 63 .. 32 > ;
		 LO < 31 .. 0 > = TMP_SDWORD < 31 .. 0 > ;
	     }    

    sizecheck = {         
		tmp_signed_word = rs;
		tmp_signed_word = tmp_signed_word & 0xffff0000;
		if ( tmp_signed_word == 0x00000000) | (tmp_signed_word == 0xffff0000 ) then
			multsize = 0;
		else
			multsize = 1;
		endif;
		}      


op MULTU ( rs : REG_IND_ZERO , rt : REG_IND_ZERO )
    syntax = format ( "MULTU %s, %s" , rs.syntax , rt.syntax )
    image  = format ( "000000%s%s0000000000011001" , rs.image , rt.image )
    action = {
		TMP_SDWORD = coerce ( card(32), rs )*coerce ( card (32), rt );
		 HI < 31 .. 0 > = TMP_SDWORD < 63 .. 32 > ;
		 LO < 31 .. 0 > = TMP_SDWORD < 31 .. 0 > ;
	     }    
    sizecheck = { 
		tmp_signed_word = rs;
		tmp_signed_word = tmp_signed_word & 0xffff0000;
		if ( tmp_signed_word == 0x00000000) then
			multsize = 0;
		else
			multsize = 1;
		endif;
		}


op NOR (rd : index , rs : REG_IND_ZERO , rt : REG_IND_ZERO)
    syntax = format ( "NOR %d, %s, %s" ,  rd, rs.syntax, rt.syntax )
    image  = format ( "000000%s%s%5b00000100111", rs.image, rt.image, rd) 
    action = {
		GPR [rd] = ~( rs | rt );
	     }    
   

op OR (rd : index , rs : REG_IND_ZERO , rt : REG_IND_ZERO)
    syntax = format ( "OR %d, %s, %s" ,  rd, rs.syntax, rt.syntax )
    image  = format ( "000000%s%s%5b00000100101", rs.image, rt.image, rd) 
    action = {
		GPR [rd] = rs | rt;
	     }       
   

op ORI (rt : index , rs : REG_IND_ZERO , immediate : IMM16 )
    syntax = format ( "ORI %d, %s, %s" , rt , rs.syntax , immediate.syntax )
    image = format ( "001101%s%5b%s" , rs.image , rt , immediate.image )
    action = {
		tmp_signed_word = immediate & 0x0000ffff;
		GPR [rt] = tmp_signed_word | rs ;
	     }  
    

op SLL (rd : index , rt :  REG_IND_ZERO , sa : index )
    syntax = format ( "SLL %d, %s, %d" , rd, rt.syntax, sa )
    image = format ( "00000000000%s%5b%5b000000" , rt.image, rd, sa )
    action = {
		GPR [rd] = rt << sa;
	     }
		
    
op SLLV (rd : index , rs : REG_IND_ZERO , rt : REG_IND_ZERO)
    syntax = format ( "SLLV %d, %s, %s" ,  rd, rs.syntax, rt.syntax )
    image  = format ( "000000%s%s%5b00000000100", rs.image, rt.image, rd) 
    action = {
		GPR [rd] = rt << rs < 4..0 >;
	     }     
   

op SLT (rd : index , rs : REG_IND_ZERO , rt : REG_IND_ZERO)
    syntax = format ( "SLT %d, %s, %s" , rd, rs.syntax, rt.syntax )
    image  = format ( "000000%s%s%5b00000101010", rs.image, rt.image, rd) 
    action = {
		if ( rs < rt ) then
			GPR [rd] = 1;
		else
			GPR [rd] = 0;   
		endif;
	     }   


op SLTI (rt : index , rs : REG_IND_ZERO , immediate : IMM16 )
    syntax = format ( "SLTI %d, %s, %s" , rt , rs.syntax , immediate.syntax )
    image = format ( "001010%s%5b%s" , rs.image , rt , immediate.image )
    action = {
		if ( rs < immediate ) then
			GPR [rt] = 1;
		else
			GPR [rt] = 0;   
		endif;
	     }


op SLTIU (rt : index , rs : REG_IND_ZERO , immediate : IMM16 )
    syntax = format ( "SLTIU %d, %s, %s" , rt , rs.syntax , immediate.syntax )
    image = format ( "001011%s%5b%s" , rs.image , rt , immediate.image )
    action = {
		if ( coerce ( word, rs ) < coerce ( card (16), immediate ) ) then
			GPR [rt] = 1;
		else
			GPR [rt] = 0;   
		endif;
	     }  


op SLTU (rd : index , rs : REG_IND_ZERO , rt : REG_IND_ZERO)
    syntax = format ( "SLTU %d, %s, %s" ,  rd, rs.syntax, rt.syntax )
    image  = format ( "000000%s%s%5b00000101011", rs.image, rt.image, rd) 
    action = {
		if ( coerce ( word, rs ) < coerce ( word, rt ) ) then
			GPR [rd] = 1;
		else
			GPR [rd] = 0;   
		endif;
	     }  


op SRA (rd : index , rt :  REG_IND_ZERO , sa : index )
    syntax = format ( "SRA %d, %s, %d" , rd, rt.syntax, sa )
    image = format ( "00000000000%s%5b%5b000011" , rt.image, rd, sa )
    action = {
		GPR [rd] = (rt >> sa);
		if ( rt < 0 ) then
		    GPR[rd] = GPR [ rd ] | ( 0 - (1<<(32 - sa)));
		endif;
    }
    

op SRAV (rd : index , rs : REG_IND_ZERO , rt : REG_IND_ZERO)
    syntax = format ( "SRAV %d, %s, %s" ,  rd, rs.syntax, rt.syntax )
    image  = format ( "000000%s%s%5b00000000111", rs.image, rt.image, rd) 
    action = {
		GPR [rd] = (rt >> rs< 4..0> ) ;
		if ( rt < 0 ) then
		    GPR[rd] = GPR [ rd ] | ( 0 - (1<<(32 - rs < 4..0 >)));
		endif;
    }    
   

op SRL (rd : index , rt :  REG_IND_ZERO , sa : index )
    syntax = format ( "SRL %d, %s, %d" , rd, rt.syntax, sa)
    image = format ( "00000000000%s%5b%5b000010" , rt.image, rd, sa )
    action = {   
		GPR [rd] = rt >> sa;
		if ( sa > 0 ) then 
		GPR [ rd ] = GPR [ rd ] & ( 0x7fffffff >> ( sa - 1 )  );
		endif;
	     }
 

op SRLV (rd : index , rs : REG_IND_ZERO , rt : REG_IND_ZERO)
    syntax = format ( "SRLV %d, %s, %s" ,  rd, rs.syntax, rt.syntax )
    image  = format ( "000000%s%s%5b00000000110", rs.image, rt.image, rd) 
    action = {
		tmp_unsigned_byte = rs < 4..0 > ;
		GPR [rd] = rt >> tmp_unsigned_byte ;
		if ( tmp_unsigned_byte > 0 ) then 
		GPR [ rd ] = GPR [ rd ] & ( 0x7fffffff >> ( tmp_unsigned_byte - 1 ) );
		endif;
	     }	


op SUB (rd : index , rs : REG_IND_ZERO , rt : REG_IND_ZERO)
    syntax = format ( "SUB %d, %s, %s" , rd, rs.syntax, rt.syntax )
    image  = format ( "000000%s%s%5b00000100010", rs.image, rt.image, rd) 
    action = { 
		overflow_bit::GPR[rd] = rs - rt;
		if ( overflow_bit == 1 ) then
			"print" ("Integer Overflow Exception");
		endif;
	      }

   
op SUBU (rd : index , rs : REG_IND_ZERO , rt : REG_IND_ZERO)
    syntax = format ( "SUBU %d, %s, %s" , rd, rs.syntax, rt.syntax )
    image  = format ( "000000%s%s%5b00000100011", rs.image, rt.image, rd) 
    action = {
		GPR [rd] = rs - rt;    
	     }   


op SW (base : REG_IND_ZERO , rt : REG_IND , offset : IMM16 )
    syntax = format ( "SW %s, %s(%s)" , rt.syntax , offset.syntax, base.syntax )
    image = format ( "101011%s%s%s" , base.image, rt.image, offset.image )
    action = {
		EA = base + offset;
		tmp_signed_word = GPR[rt];
		M [ EA ]     = tmp_signed_word_A0;
		M [ EA + 1 ] = tmp_signed_word_A1;
		M [ EA + 2 ] = tmp_signed_word_A2;
		M [ EA + 3 ] = tmp_signed_word_A3;
	     }


op SWC0 (base : REG_IND_ZERO , rt : REG_IND , offset : IMM16 )
    syntax = format ( "SWC0 %s, %s(%s)" , rt.syntax , offset.syntax, base.syntax )
    image = format ( "111000%s%s%s" , base.image, rt.image, offset.image )
    action = {
		EA = base + offset;
		tmp_signed_word = GPR[rt];
		M [ EA ]     = tmp_signed_word_A0;
		M [ EA + 1 ] = tmp_signed_word_A1;
		M [ EA + 2 ] = tmp_signed_word_A2;
		M [ EA + 3 ] = tmp_signed_word_A3;
		GPR[rt] = 1;
	     }


op SYSCALL()
	syntax = "SYSCALL"
	image = "00000000000000000000000000001100"
	action= {
			"sys_call_mips" ( GPR[2], GPR[4], GPR[5],GPR[6],GPR[7]);
	}


op XOR (rd : index , rs : REG_IND_ZERO , rt : REG_IND_ZERO)
    syntax = format ( "XOR %d, %s, %s" ,  rd, rs.syntax, rt.syntax )
    image  = format ( "000000%s%s%5b00000100110", rs.image, rt.image, rd) 
    action = {
		GPR [rd] = rs ^ rt;
	     }    


op XORI (rt : index , rs : REG_IND_ZERO , immediate : IMM16 )
    syntax = format ( "XORI %d, %s, %s" , rt , rs.syntax , immediate.syntax )
    image = format ( "001110%s%5b%s" , rs.image , rt , immediate.image )
    action = {
		tmp_signed_word = immediate & 0x0000ffff;
		GPR [rt] = tmp_signed_word ^ rs ;
	     }  

