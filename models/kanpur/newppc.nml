/************************************************************
 *
 *        PowerPc 603 description in Sim-nML
 *                        By
 *                  Subhash Chandra Y
 *             Modified By: Hemant Shinde
 *              Last Modified: 31/07/2007
 *
 *        Kindly provided by Proj. Rajat Moona
 *     from Indian Institute of Technology Kanpur
 *
 *    http://www.cse.iitk.ac.in/users/moona/?page=stud  
 ************************************************************/

// Constants

let REGS = 5
let byte_order = "big"
let PC = "NIA"
let SP = "GPR[1]"
// Type declarations

type bit = card ( 1 )
type byte = card ( 8 )
type word = card ( 32 )
type long = card ( 32 )
type slong = int ( 32 )
type address = card ( 32 )
type index = card ( REGS )
type flot = float ( 52 , 12 )
type flots = float ( 23, 9 )

// Memory and registers

// Added by Surendra
// Memory 2^30 instead of 2^32
// end

mem M [ 2 ** 30 , byte ]
reg GPR [ 2 ** REGS , slong ]
reg FPR [ 2 ** REGS , flot ]
reg CR [ 1 , long ]
reg LR [ 1 , long ]
reg XER [ 1 , long ]
reg FPSCR [ 1 , long ]
reg OLD_CIA [ 1, address ]
reg NIA [ 1 , address ]
reg CTR [ 1 , long ]
mem CQ [ 6 , long ]
mem DQ [ 5 , long ]
mem CIA [ 1 , address ]

// Some variables

mem TMP_BYTE [ 1 , byte ]
mem TMP_SBYTE [ 1 , int ( 8 ) ]
mem TMP_HWORD [ 1 , card ( 16 ) ]
mem TMP_SHWORD [ 1 , int ( 16 ) ]
mem TMP_WORD [ 1 , word ]
mem TMP_WORD1 [ 1 , word ]
mem TMP_SWORD [ 1 , int ( 32 ) ]
mem TMP_SDWORD [ 1 , int ( 64 ) ]
mem TMP_DWORD [ 1 , card ( 64 ) ]
mem TMP_FLOT [ 1 , flot ]
mem TMP_FLOTS [ 1, flots ]
mem TMP_BO [ 1 , card ( 5 ) ]
mem TMP_BI [ 1 , card ( 5 ) ]
mem TMP_BD [ 1 , int ( 14 ) ] 
// Changed by Surendra card (8) to bit

mem RESERVE [ 1 , bit ]
mem RES_ADDR [ 1 , address ]

mem OF_BIT [ 1 , bit ] 
mem EA [ 1 , address ]
mem dq_ptr [ 1 , byte ]
mem cq_ptr [ 1 , byte ]
mem wait_id [ 1 , byte ]
mem cond_ok [ 1 , bit ]
mem ctr_ok [ 1 , bit ]
mem bu_busy [ 1 , bit ]
mem instr_id [ 1 , byte ]
mem int_id [ 1 , byte ]
mem fp_id [ 1 , byte ]
mem ls_id [ 1 , byte ]
mem sr_id [ 1 , byte ]
mem is_speculated [ 1 , bit ]
mem speculated [ 6 , bit ]
mem dq_spec [ 6 , bit ]
mem cq_spec [ 5 , bit ]
mem taken [ 1 , bit ]
mem fetch_id1 [ 1 , byte ]
mem fetch_id2 [ 1 , byte ]
mem dispatch_id1 [ 1 , byte ]
mem dispatch_id2 [ 1 , byte ]

// Aliases for Intger Temps

// HalfWord Integer

mem TMP_SHWORD_A0 [ 1 , int ( 8 ) ]
    alias = TMP_SHWORD [ 8 ]

mem TMP_SHWORD_A1 [ 1 , int ( 8 ) ]
    alias = TMP_SHWORD [ 0 ]

// Word Integers

mem TMP_SWORD_A0 [ 1 , int ( 8 ) ]
    alias = TMP_SWORD [ 24 ]
	
mem TMP_SWORD_A1 [ 1 , int ( 8 ) ]
    alias = TMP_SWORD [ 16 ]

mem TMP_SWORD_A2 [ 1 , int ( 8 ) ]
    alias = TMP_SWORD [ 8 ]

mem TMP_SWORD_A3 [ 1 , int ( 8 ) ]
    alias = TMP_SWORD [ 0 ]

// Aliases for Float Temps

// Double Presicion Float

mem TMP_FLOT_A0 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 56 ]

mem TMP_FLOT_A1 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 48 ]

mem TMP_FLOT_A2 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 40 ]

mem TMP_FLOT_A3 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 32 ]

mem TMP_FLOT_A4 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 24 ]

mem TMP_FLOT_A5 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 16 ]

mem TMP_FLOT_A6 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 8 ]

mem TMP_FLOT_A7 [ 1 , int ( 8 ) ]
    alias = TMP_FLOT [ 0 ]

// Single Presicion Float

mem TMP_FLOTS_A0 [ 1 , int ( 8 ) ]
    alias = TMP_FLOTS [ 24 ]

mem TMP_FLOTS_A1 [ 1 , int ( 8 ) ]
    alias = TMP_FLOTS [ 16 ]

mem TMP_FLOTS_A2 [ 1 , int ( 8 ) ]
    alias = TMP_FLOTS [ 8 ]

mem TMP_FLOTS_A3 [ 1 , int ( 8 ) ]
    alias = TMP_FLOTS [ 0 ]

// Addressing Modes

mode REG_IND_ZERO ( r : index ) =
     if r == 0 then
        0
     else
        GPR [ r ]
     endif
   syntax = format ( "%d", r )
   image  = format ( "%5b", r )

mode REG_IND ( r : index ) = GPR [ r ]
   syntax = format ( "%d", r )
   image  = format ( "%5b", r )

mode FREG_IND ( r : index ) = FPR [ r ]
   syntax = format ( "%d", r )
   image  = format ( "%5b", r )

mode IMM24 ( n : int ( 24 ) ) = n
   syntax = format ( "%d", n )
   image  = format ( "%24b", n )

mode IMM16 ( n : int ( 16 ) ) = n
   syntax = format ( "%d", n )
   image  = format ( "%16b", n )

mode LS_COUNT ( NB : card ( 5 ) ) =
     if NB == 0 then 
        32
     else
        NB
     endif
   syntax = format ( "%d", NB )
   image  = format ( "%5b", NB )

mode IADDR ( d : int ( 16 ) ) = d
   syntax = format ( "%d", d )
   image  = format ( "%16b", d )

mode SIMM ( n : int ( 14 ) ) = n
   syntax = format ( "%d", n )
   image  = format ( "%14b", n )

mode UIMM16 ( n : card ( 16 ) ) = n
   syntax = format ( "%d", n )
   image  = format ( "%16b", n )

// Resources 

resource fetch_unit1, fetch_unit2, branch_unit, dispatch_unit1, dispatch_unit2,
         ls_unit, int_unit, fp_unit, fp_pstage1, fp_pstage2, fp_pstage3, completion_unit1, 
         completion_unit2, sys_reg_unit

// Exceptions

//exception branch_error	// Change by Surendra to avoid this obselete feature
// Each line of code containing "branch_error" is commented out

// Instructions

op init ()
   action = { 

               instr_id = 5; 
               is_speculated = 0; 
               bu_busy = 0;
               dq_ptr = 0;
               cq_ptr = 0;
               wait_id = 0;
               //"sethandler" ( branch_error , bhandler );
   
            }
   bhandler = {

           // Flushing of Dispatch Queue

                 if speculated [ DQ [ 0 ] ] then
                    dq_ptr = 0;
                 else
                    if speculated [ DQ [ 1 ] ] then
                       dq_ptr = 1;
                    else
                       if speculated [ DQ [ 2 ] ] then
                          dq_ptr = 2;
                       else
                          if speculated [ DQ [ 3 ] ] then
                             dq_ptr = 3;
                          else
                             if speculated [ DQ [ 4 ] ] then
                                dq_ptr = 4;
                             else
                                if speculated [ DQ [ 5 ] ] then
                                   dq_ptr = 5;
                                endif;
                             endif;
                          endif;
                       endif;
                    endif;
                 endif;
                  
           // Flushing of Completion Queue

                 if speculated [ CQ [ 0 ] ] then
                    cq_ptr = 0;
                 else
                    if speculated [ CQ [ 1 ] ] then
                       cq_ptr = 1;
                    else
                       if speculated [ CQ [ 2 ] ] then
                          cq_ptr = 2;
                       else
                          if speculated [ CQ [ 3 ] ] then
                             cq_ptr = 3;
                          else
                             if speculated [ CQ [ 4 ] ] then
                                cq_ptr = 4;
                             endif;
                          endif;
                       endif;
                    endif;
                 endif;

                 if wait_id > cq_ptr then
                    wait_id = cq_ptr;
                 endif;

           // Aborting speculated instructions 

                 if dq_spec [ 0 ] then
                    "abort" ( DQ [ 0 ] );
                 endif;
                 if dq_spec [ 1 ] then
                    "abort" ( DQ [ 1 ] );
                 endif;
                 if dq_spec [ 2 ] then
                    "abort" ( DQ [ 2 ] );
                 endif;
                 if dq_spec [ 3 ] then
                    "abort" ( DQ [ 3 ] );
                 endif;
                 if dq_spec [ 4 ] then
                    "abort" ( DQ [ 4 ] );
                 endif;
                 if dq_spec [ 5 ] then
                    "abort" ( DQ [ 5 ] );
                 endif;

                 if cq_spec [ 0 ] then
                    "abort" ( CQ [ 0 ] );
                 endif;
                 if cq_spec [ 1 ] then
                    "abort" ( DQ [ 1 ] );
                 endif;
                 if cq_spec [ 2 ] then
                    "abort" ( CQ [ 2 ] );
                 endif;
                 if cq_spec [ 3 ] then
                    "abort" ( CQ [ 3 ] );
                 endif;
                 if cq_spec [ 4 ] then
                    "abort" ( CQ [ 4 ] );
                 endif;

              }


op instruction ( x : instr_action )
   uses   = ( { bu_busy == 0 } fetch_unit1 : preact1 #{1}  | { bu_busy == 0 } fetch_unit2 : preact2 #{1} )  , x.uses
   syntax = x.syntax
   image  = x.image
   action = { 
 			  CIA = NIA;
			  NIA = CIA + 4;
   			  x.action; 
			}

   preact1 = {

                CIA = NIA;
                NIA = CIA + 4;

                if instr_id == 5 then
                   instr_id = 0;
                else
                   instr_id = instr_id + 1;
                endif;

                speculated [ instr_id ] = is_speculated;

                fetch_id1 = instr_id;

            }

   preact2 = {

                CIA = NIA;
                NIA = CIA + 4;

                if instr_id == 5 then
                   instr_id = 0;
                else
                   instr_id = instr_id + 1;
                endif;

                speculated [ instr_id ] = is_speculated;

                fetch_id2 = instr_id;

            }

op instr_action =   branch_instr 
                  | non_branch_instr
				  | new_impl_instr

// Branch Instructions

op branch_instr ( x : branch_instr_action )
   uses    = { is_speculated == 0 } branch_unit : preact, x.uses, branch_unit : postact
   image   = x.image
   syntax  = x.syntax
   action  = { x.action; }
   preact  = { bu_busy = 1; }
   postact = { bu_busy = 0; }
                

op branch_instr_action =   branch_uncond 
                         | branch_cond

op branch_cond =          branch_cond_mem
                        | branch_cond_reg

// Unconditional Branch Instructions

op branch_uncond =   branch_rel
                   | branch_abs
                   | call_uncond

op call_uncond =     branch_link
                   | branch_link_abs

op branch_rel ( BRANCH_ADDR : IMM24 )
   uses   = CIA, (branch_unit & NIA #{1}  : action)
   syntax = format ( "b %s", BRANCH_ADDR.syntax )
   image  = format ( "010010%24b00", BRANCH_ADDR.image )
   action = {
               TMP_SWORD = BRANCH_ADDR;
               NIA = CIA + ( TMP_SWORD << 2 );
            }

op branch_abs ( BRANCH_ADDR : IMM24 )
   uses   = (branch_unit & NIA #{1}  : action)
   syntax = format ( "ba %s", BRANCH_ADDR.syntax )
   image  = format ( "010010%24b10", BRANCH_ADDR.image )
   action = {
               TMP_SWORD = BRANCH_ADDR;
               NIA = ( TMP_SWORD << 2 );
            }
			   
op branch_link ( BRANCH_ADDR : IMM24 )
   uses   = CIA, (branch_unit & NIA #{1}  : action)
   syntax = format ( "bl %s", BRANCH_ADDR.syntax )
   image  = format ( "010010%24b01", BRANCH_ADDR.image )
   action = {
                TMP_SWORD = BRANCH_ADDR;
                NIA = CIA + ( TMP_SWORD << 2 );
                LR  = CIA + 4;
             }

op branch_link_abs ( BRANCH_ADDR : IMM24 )
   uses   = CIA, (branch_unit & NIA #{1}  : action)
   syntax = format ( "bla %s", BRANCH_ADDR.syntax )
   image  = format ( "010010%24b11", BRANCH_ADDR.image )
   action = {
               TMP_SWORD = BRANCH_ADDR;
               NIA = ( TMP_SWORD << 2 );
               LR  = CIA + 4;
            }

// Conditional Branch Instructions

op branch_cond_mem ( x : bran_cond_action )
//   uses   = if "is_blocked" ( CR ) then x.uses else y.uses endif
/*   uses = if "is_blocked" ( CR ) then
             branch_unit : preact_spec
          else
            branch_unit & CTR
          endif, x.uses,
          if is_speculated == 1 then
             CR < TMP_BI..TMP_BI >
          endif	 	commented by nitin*/
// Previously it is x.uses : clear
 
   syntax = x.syntax
   image  = x.image
   action = { 
               if is_speculated == 0 then

                  TMP_BO = x.BO_VAL;
                  TMP_BI = x.BI_VAL;
                  TMP_BD = x.BD_VAL;

                  if !TMP_BO < 2..2 > then
                     CTR = CTR - 1;
                  endif;

                  cond_ok = ( TMP_BO < 4..4 > | ( CR < (31-TMP_BI)..(31-TMP_BI) > ^ ~TMP_BO < 3..3 > ) );

                  ctr_ok = ( TMP_BO < 2..2 > | ( ( CTR != 0 ) ^ TMP_BO < 1..1 > ) );

                  if cond_ok & ctr_ok then
                     taken = 1 ;
                  else
                     taken = 0;
                  endif;

               else

                  cond_ok = ( TMP_BO < 4..4 > | ( CR < (31-TMP_BI)..(31-TMP_BI) > ^ ~TMP_BO < 3..3 > ) );

                  ctr_ok = ( TMP_BO < 2..2 > | ( ( CTR != 0 ) ^ TMP_BO < 1..1 > ) );

                  if taken && !( cond_ok && ctr_ok ) then
                     taken = 0;
                     bu_busy = 1;
                     CIA = OLD_CIA;
                     NIA = CIA + 4;
                     //"raise" ( branch_error );
                     bu_busy = 0;
                  else
                     if !taken && ( cond_ok && ctr_ok ) then  // Speculation is incorrect
                        taken = 1;
                        bu_busy = 1;
                        CIA = OLD_CIA;

                        if !TMP_BO < 2..2 > then
                           CTR = CTR - 1;
                        endif;

//                        x.uses; // Is this correct ? Have to see it later
                        //"raise" ( branch_error );
                        bu_busy = 0;
                     endif;
                  endif;

                  speculated [ 0 ] = 0;
                  speculated [ 1 ] = 0;
                  speculated [ 2 ] = 0;
                  speculated [ 3 ] = 0;
                  speculated [ 4 ] = 0;
                  speculated [ 5 ] = 0;
                  dq_spec [ 0 ] = 0;
                  dq_spec [ 1 ] = 0;
                  dq_spec [ 2 ] = 0;
                  dq_spec [ 3 ] = 0;
                  dq_spec [ 4 ] = 0;
                  dq_spec [ 5 ] = 0;
                  cq_spec [ 0 ] = 0;
                  cq_spec [ 1 ] = 0;
                  cq_spec [ 2 ] = 0;
                  cq_spec [ 3 ] = 0;
                  cq_spec [ 4 ] = 0;

                  is_speculated = 0;

               endif;

               x.action; 

		    } 

   clear  = { bu_busy = 0; }
   preact_spec = {
               OLD_CIA = CIA;
               is_speculated = 1;
               taken = 0;

               TMP_BO = x.BO_VAL;
               TMP_BI = x.BI_VAL;
               TMP_BD = x.BD_VAL;

               if TMP_BO < 4..4 > then
                  if !TMP_BD < 0..0 > then    // Speculated taken
                     taken = 1;
                  endif;
               else
                  if TMP_BD < 0..0 > then
                     taken = 1;    // Speculated taken
                  endif;
               endif;
            }

// Conditional Branch Instructions

op bran_cond_action =   bran_cond_rel
                      | bran_cond_abs
                      | bran_cond_link
                      | bran_cond_link_abs

op bran_cond_rel ( BO : card ( 5 ), BI : card ( 5 ), BD : SIMM )
   uses   = CIA, (branch_unit & NIA #{1}  : action)
   syntax = format ( "bc %d,%d,%s", BO, BI, BD.syntax )
   image  = format ( "010000%5b%5b%14b00", BO, BI, BD.image )
   action = {
               if taken then
                  TMP_SWORD = BD;
                  NIA = CIA + ( TMP_SWORD << 2 );
               endif;
            }
    BO_VAL = BO
    BI_VAL = BI
    BD_VAL = BD

op bran_cond_abs ( BO : card ( 5 ), BI : card ( 5 ), BD : SIMM )
   uses   = (branch_unit & NIA #{1}  : action)
   syntax = format ( "bca %d,%d,%s", BO, BI, BD.syntax )
   image  = format ( "010000%5b%5b%14b10", BO, BI, BD.image )
   action = {

			   if taken then
                  TMP_SWORD = BD;
			      NIA = ( TMP_SWORD << 2 );
			   endif;
		    }
    BO_VAL = BO
    BI_VAL = BI
    BD_VAL = BD

op bran_cond_link ( BO : card ( 5 ), BI : card ( 5 ), BD : SIMM )
   uses   = CIA, (branch_unit  & NIA #{1}  : action)
   syntax = format ( "bcl %d,%d,%s", BO, BI, BD.syntax )
   image  = format ( "010000%5b%5b%14b01", BO, BI, BD.image )
   action = {
               if taken then
                  TMP_SWORD = BD;
                  NIA = CIA + ( TMP_SWORD << 2 );
               endif;

               LR = CIA + 4;
            }
    BO_VAL = BO
    BI_VAL = BI
    BD_VAL = BD

op bran_cond_link_abs ( BO : card ( 5 ), BI : card ( 5 ), BD : SIMM )
   uses   = CIA, (branch_unit & NIA #{1}  : action)
   syntax = format ( "bcla %d,%d,%s", BO, BI, BD.syntax )
   image  = format ( "010000%5b%5b%14b11", BO, BI, BD.image )
   action = {
               if taken then
                  TMP_SWORD = BD;
                  NIA = ( TMP_SWORD << 2 );
               endif;

               LR = CIA + 4;
            }
    BO_VAL = BO
    BI_VAL = BI
    BD_VAL = BD

// Branch Conditonal with Registers CTR and LR

op branch_cond_reg ( x : bran_cond_reg_action )
/*   uses = if "is_blocked" ( CR ) then
             branch_unit : preact_spec
          else
             branch_unit
          endif,
          x.uses,
          if is_speculated == 1 then
             CR < TMP_BI..TMP_BI >
          endif		nitin*/
// Above has changed to CR from  CR < y.BI_VAL..y.BI_VAL > for temporarly
// Perviuosly it is x.uses : clear

   syntax = x.syntax
   image  = x.image
   action = { 
              if is_speculated == 0 then

                 TMP_BO = x.BO_VAL;
                 TMP_BI = x.BI_VAL;

                 cond_ok = ( TMP_BO < 4..4 > | ( CR < (31-TMP_BI)..(31-TMP_BI) > ^ ~TMP_BO < 3..3 > ) );

                 ctr_ok = ( TMP_BO < 2..2 > | ( ( CTR != 0 ) ^ TMP_BO < 1..1 > ) );

                 if cond_ok then
                    taken = 1 ;
                 else
                    taken = 0;
                 endif;

              else
                    
                 cond_ok = ( TMP_BO < 4..4 > | ( CR < (31-TMP_BI)..(31-TMP_BI) > ^ ~TMP_BO < 3..3 > ) );

                 ctr_ok = ( TMP_BO < 2..2 > | ( ( CTR != 0 ) ^ TMP_BO < 1..1 > ) );

                 if taken && !cond_ok then
                    taken = 0;
                    bu_busy = 1;
                    CIA = OLD_CIA;
                    NIA = CIA + 4;
                    //"raise" ( branch_error );
                    bu_busy = 0;
                 else
                    if !taken && cond_ok then  // Speculation is incorrect
                       taken = 1;
                       is_speculated = 0;
                       bu_busy = 1;
                       CIA = OLD_CIA;
//                       x.uses;    have to see it later.
                       //"raise" ( branch_error );
                       bu_busy = 0;
                    endif;
                 endif;

                 speculated [ 0 ] = 0;
                 speculated [ 1 ] = 0;
                 speculated [ 2 ] = 0;
                 speculated [ 3 ] = 0;
                 speculated [ 4 ] = 0;
                 speculated [ 5 ] = 0;
                 dq_spec [ 0 ] = 0;
                 dq_spec [ 1 ] = 0;
                 dq_spec [ 2 ] = 0;
                 dq_spec [ 3 ] = 0;
                 dq_spec [ 4 ] = 0;
                 dq_spec [ 5 ] = 0;
                 cq_spec [ 0 ] = 0;
                 cq_spec [ 1 ] = 0;
                 cq_spec [ 2 ] = 0;
                 cq_spec [ 3 ] = 0;
                 cq_spec [ 4 ] = 0;

                 is_speculated = 0;

               endif;
                  
               x.action; 
            } 

   clear  = { bu_busy = 0; }

   preact_spec = {
               OLD_CIA = CIA;
               is_speculated = 1;
               taken = 0;

               TMP_BO = x.BO_VAL;
               TMP_BI = x.BI_VAL;

               if TMP_BO < 4..4 > then
                  taken = 1;
               endif;
            }

// Branch Conditional on LR and CTR

op bran_cond_reg_action =   bran_cond_ctr
                          | bran_cond_lr

op bran_cond_ctr =   branch_cond_ctr
                   | branch_cond_ctr_link


op branch_cond_ctr ( BO : card ( 5 ), BI : card ( 5 ) )
   uses   = branch_unit #{1}  : action
   syntax = format ( "bcctr %d,%d", BO, BI )
   image  = format ( "010011%5b%5b0000010000100000", BO, BI )
   action = {
               if taken then
                  NIA = ( CTR & 0xfffffffc );
               endif;
            }
    BO_VAL = BO
    BI_VAL = BI

op branch_cond_ctr_link ( BO : card ( 5 ), BI : card ( 5 ) )
   uses   = branch_unit #{1}  : action
   syntax = format ( "bcctrl %d,%d", BO, BI )
   image  = format ( "010011%5b%5b0000010000100001", BO, BI )
   action = {
               if taken then
                  NIA = ( CTR & 0xfffffffc );
               endif;

               LR = ( CIA + 4 );
            }
    BO_VAL = BO
    BI_VAL = BI

op bran_cond_lr =   branch_cond_lr
                  | branch_cond_lr_link

op branch_cond_lr ( BO : card ( 5 ), BI : card ( 5 ) )
   uses   = branch_unit #{1}  : action
   syntax = format ( "bclr %d,%d", BO, BI)
   image  = format ( "010011%5b%5b0000000000100000", BO, BI )
   action = {
               if !is_speculated then
                  if !BO < 2..2 > then
                     CTR = CTR - 1;
                  endif;
               endif;

               if taken && ctr_ok then
                  NIA = ( LR & 0xfffffffc );
               endif;
            } 
    BO_VAL = BO
    BI_VAL = BI

op branch_cond_lr_link ( BO : card ( 5 ), BI : card ( 5 ) )
   uses   = branch_unit #{1}  : action
   syntax = format ( "bclrl %d,%d", BO, BI )
   image  = format ( "010011%5b%5b0000000000100001", BO, BI )
   action = {
               if !is_speculated then
                  if !BO < 2..2 > then
                     CTR = CTR - 1;
                  endif;
               endif;

               if taken && ctr_ok then
                  NIA = ( LR & 0xfffffffc );
               endif;
  
               LR = ( CIA + 4 );
            } 
    BO_VAL = BO
    BI_VAL = BI

// Non Branch Instructions

op non_branch_instr ( x : non_branch_instr_action )
   uses  = ( { dq_ptr < 6 } fetch_unit1 : fu_act1 | { dq_ptr < 6 } fetch_unit2 : fu_act2 ), 
             DQ, 
           ( { cq_ptr < 5 } dispatch_unit1 : du_act | { cq_ptr < 5 } dispatch_unit2 : du_act ), 
             x.uses, ( completion_unit1 : cu_act | completion_unit2 : cu_act )

   action = { x.action; }
   syntax = x.syntax
   image  = x.image

   fu_act1 = {

                DQ [ dq_ptr ] = fetch_id1;
                dq_spec [ dq_ptr ] = speculated [ fetch_id1 ];
                dq_ptr = dq_ptr + 1;

             }
   fu_act2 = {

                DQ [ dq_ptr ] = fetch_id2;
                dq_spec [ dq_ptr ] = speculated [ fetch_id2 ];
                dq_ptr = dq_ptr + 1;

             }
   du_act  = {

                CQ [ cq_ptr ] = DQ [ 0 ];
                cq_spec [ cq_ptr ] = dq_spec [ 0 ];
                cq_ptr = cq_ptr + 1;

                DQ [ 0 ] = DQ [ 1 ];
                DQ [ 1 ] = DQ [ 2 ];
                DQ [ 2 ] = DQ [ 3 ];
                DQ [ 3 ] = DQ [ 4 ];
                DQ [ 4 ] = DQ [ 5 ];

                dq_spec [ 0 ] = dq_spec [ 1 ];
                dq_spec [ 1 ] = dq_spec [ 2 ];
                dq_spec [ 2 ] = dq_spec [ 3 ];
                dq_spec [ 3 ] = dq_spec [ 4 ];
                dq_spec [ 4 ] = dq_spec [ 5 ];

                dq_ptr = dq_ptr - 1;
                
             }
   cu_act = {
   
                //action;	not allowed anymore. commented by nitin

                CQ [ 0 ] = CQ [ 1 ];
                CQ [ 1 ] = CQ [ 2 ];
                CQ [ 2 ] = CQ [ 3 ];
                CQ [ 3 ] = CQ [ 4 ];

                cq_spec [ 0 ] = cq_spec [ 1 ];
                cq_spec [ 1 ] = cq_spec [ 2 ];
                cq_spec [ 2 ] = cq_spec [ 3 ];
                cq_spec [ 3 ] = cq_spec [ 4 ];

                cq_ptr = cq_ptr - 1;
               	wait_id = wait_id - 1;

            }

op non_branch_instr_action =   load_store_instr
                             | int_instr
                             | fp_instr
                             | flow_control_instr
                             | proce_control_instr

// Newly implemented instructions by Surendra
 
op new_impl_instr = 	  n_op
						 	| sys_call
							| mffs
							| mffs_cr_update
							| mtfsf
							| mtfsf_cr_update
							| mtfsb0
							| mtfsb0_cr_update
							| mtfsb1
							| mtfsb1_cr_update
							| lw_arx
							| stwcx
							| dcbst
							| dcbtst
							| eieio
							| dcbz
							| sync
							| isync
							| icbi
							| tw
	
// No operation	

op n_op ( )
	syntax = "nop"
	image  = "01100000000000000000000000000000"
	action = {
					// Nothing
				}

// System Call

op sys_call ( )
   uses   = sys_reg_unit #{3}
   syntax = "sc"
   image  = "01000100000000000000000000000010"
   action = {
					"sys_call" (GPR[0], GPR[3], GPR[4], GPR[5], GPR[6], GPR[7], GPR[8]);
            }

op dcbst(ra : REG_IND, rb : REG_IND_ZERO)
	syntax = "dcbst"
	image = format("01111100000%s%s00001101100", ra.image, rb.image)
	action = {
	//		"print"("DCBST executed \n");
	}

op dcbtst(ra : REG_IND, rb : REG_IND_ZERO)
	syntax = "dcbtst"
	image = format("01111100000%s%s00111101100", ra.image, rb.image)
	action = {
	//		"print"("DCBTST executed \n");
	}

op eieio()
	syntax = "eieio"
	image = "01111100000000000000011010101100"
	action = {
	//	"print"("eieio executed \n");
	}

op dcbz(ra : REG_IND, rb : REG_IND_ZERO)
	syntax = "dcbz"
	image = format("01111100000%s%s11111101100", ra.image, rb.image)
	action = {
	//	"print"("DCBZ executed \n");
	}

op isync()
	synatx = "isync"
	image = "01001100000000000000000100101100"
	action = {
	//	"print"("ISYNC executed \n");
	}

op sync()
	syntax = "sync"
	image = "01111100000000000000010010101100"
	action = {
	//	"print"("SYNC executed \n");
	}

op icbi(ra : REG_IND, rb : REG_IND_ZERO)
	syntax = "icbi"
	image = format("01111100000%s%s11110101100", ra.image, rb.image)
	action = {
	//	"print"("ICBI executed \n");
	}

op lw_arx(rd : index, ra : REG_IND_ZERO, rb : REG_IND)
	syntax = format("lwarx %d,%s,%s", rd, ra.syntax, rb.syntax)
	image = format("011111%5b%s%s00000101000", rd, ra.image, rb.image)
	action = {
		EA = ra + rb;
		RESERVE = 1;
		RES_ADDR = EA;
		TMP_SWORD_A0 = M [ EA ];
      TMP_SWORD_A1 = M [ EA + 1 ];
      TMP_SWORD_A2 = M [ EA + 2 ];
      TMP_SWORD_A3 = M [ EA + 3 ];
		GPR [ rd ] = TMP_SWORD;


	}

op stwcx(rs : REG_IND, ra : REG_IND_ZERO, rb : REG_IND)
	syntax = format("stwcx. %s, %s, %s", rs.syntax, ra.syntax, rb.syntax)
	image = format("011111%s%s%s00100101101", rs.image, ra.image, rb.image)
	action = {
		EA = ra + rb;
		if RESERVE then
       	TMP_SWORD = GPR [ rs ];
       	M [ EA ] = TMP_SWORD_A0;
       	M [ EA + 1 ] = TMP_SWORD_A1;
       	M [ EA + 2 ] = TMP_SWORD_A2;
       	M [ EA + 3 ] = TMP_SWORD_A3;
			RESERVE = 0;
			CR < 31..29 > = 0b001;
			CR < 28..28 > = XER < 31..31 >;
		else
			CR < 31..29 > = 0b000;
			CR < 28..28 > = XER < 31..31 >;
		endif;
	}

op tw()
	syntax = "tw"
	image = "01111100000000000000000000001000"
	action = {
		"print"("TW executed \n");
	}

op mffs(rd : index)
	syntax = format("mffs %d", rd)
	image = format("111111%5b000000000010010001110", rd)
	action = {
		FPR [rd] = FPSCR;
		//"print"("MFFS executed \n");
	}
	

op mffs_cr_update(rd : index)
	syntax = format("mffs. %d", rd)
	image = format("111111%5b000000000010010001111", rd)
	action = {
		FPR [rd] = FPSCR;
		CR < 27..24> = FPSCR < 31..28 >;
		//"print"("MFFS_CR executed \n");
	}

op mtfsf(FM : card(8), ra : FREG_IND)
	syntax = format("mtfsf %d %s", FM, ra.syntax)
	image = format("1111110%8b0%5b10110001110", FM, ra.image)
	action = {
		FPSCR < (4*FM)+3..(4*FM) > = ra < 31..0 >;	
		//"print"("MTFSF executed \n");
	}

op mtfsf_cr_update(FM : card(8), ra : FREG_IND)
	syntax = format("mtfsf. %d %s", FM, ra.syntax)
	image = format("1111110%8b0%5b10110001111", FM, ra.image)
	action = {
		FPSCR < (4*FM)+3..(4*FM) > = ra < 31..0 >;	
		CR < 27..24> = FPSCR < 31..28 >;
		//"print"("MTFSF executed \n");
	}

op mtfsb0(crbd : index)
	syntax = format("mtfsb0 %d", crbd)
	image = format("111111%5b000000000000010001100", crbd)
	action = {
		FPSCR < crbd..crbd > = 0;
		//"print"("MTFSB0 executed \n");
	}

op mtfsb0_cr_update(crbd : index)
	syntax = format("mtfsb0. %d", crbd)
	image = format("111111%5b000000000000010001100", crbd)
	action = {
		FPSCR < crbd..crbd > = 0;
		CR < 27..24> = FPSCR < 31..28 >;
		//"print"("MTFSB0_CR_UPDATE executed \n");
	}

op mtfsb1(crbd : index)
	syntax = format("mtfsb1 %d", crbd)
	image = format("111111%5b000000000000001001100", crbd)
	action = {
		FPSCR < crbd..crbd > = 1;
		//"print"("MTFSB1 executed \n");
	}

op mtfsb1_cr_update(crbd : index)
	syntax = format("mtfsb1. %d", crbd)
	image = format("111111%5b000000000000001001101", crbd)
	action = {
		FPSCR < crbd..crbd > = 1;
		CR < 27..24> = FPSCR < 31..28 >;
		//"print"("MTFSB1_CR_UPDATE executed \n");
	}

// Load and Store Instructions

op load_store_instr ( x : load_store_instr_action )
   uses = { wait_id < cq_ptr } ls_unit : preact, x.uses, 
          { speculated [ ls_id ] == 0 & ls_id == CQ [ 0 ] } ls_unit
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   preact = {

               ls_id = CQ [ wait_id ];
               wait_id = wait_id + 1;

            }

op load_store_instr_action =   int_load
                             | int_store
                             | fp_load
                             | fp_store

// Integer Load Instructions

op int_load =   int_load_byte
              | int_load_half_word
              | int_load_word
              | int_load_byte_rev   // New
              | int_load_multiple   // New
              | int_load_string     // New

// Integer Load Byte Insteructions

op int_load_byte =   lb_zero
                   | lb_zero_indexed
                   | lb_zero_update
                   | lb_zero_update_indexed

op lb_zero ( rd : index, ra : REG_IND_ZERO, d : IADDR )
   uses = ls_unit #{1} , GPR [ rd ] #{1}  
   syntax = format ( "lbz %d,%s(%s)", rd, d.syntax, ra.syntax )
   image  = format ( "100010%5b%s%16b", rd, ra.image, d.image )
   action = {

               EA = ra + d;
              // TMP_BYTE = M [ EA ];
              // GPR [ rd ] = TMP_BYTE;
							 GPR [ rd ]<7..0> = M [ EA ];
               GPR [ rd ] = ( 0x000000ff & GPR [ rd ] );

            }

               
op lb_zero_indexed ( rd : index, ra : REG_IND_ZERO, rb : REG_IND )
   uses = ls_unit #{1} , GPR [ rd ] #{1}  
   syntax = format ( "lbzx %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00010101110", rd, ra.image, rb.image )
   action = {

               EA = ra + rb;
               //TMP_BYTE = M [ EA ];
               //GPR [ rd ] = TMP_BYTE;
								 GPR [ rd ]<7..0> = M [ EA ];
						
               GPR [ rd ] = ( 0x000000ff & GPR [ rd ] );

            }

op lb_zero_update ( rd : index, ra : index, d : IADDR )
   uses = ls_unit #{1} , (GPR [ rd ] & GPR [ ra ] #{1})  
   syntax = format ( "lbzu %d,%s(%d)", rd, d.syntax, ra )
   image  = format ( "100011%5b%5b%16b", rd, ra, d.image )
   action = {

               EA = GPR [ ra ] + d;
              // TMP_BYTE = M [ EA ];
              // GPR [ rd ] = TMP_BYTE;

								 GPR [ rd ]<7..0> = M [ EA ];
               GPR [ rd ] = ( 0x000000ff & GPR [ rd ] );
               GPR [ ra ] = EA;

            }

op lb_zero_update_indexed ( rd : index, ra : index, rb : REG_IND )
   uses = ls_unit #{1} , (GPR [ rd ] & GPR [ ra ] #{1}) 
   syntax = format ( "lbzux %d,%d,%s", rd, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s00011101110", rd, ra, rb.image )
   action = {

               EA = GPR [ ra ] + rb;
               //TMP_BYTE = M [ EA ];
               //GPR [ rd ] = TMP_BYTE;
							 GPR [ rd ]<7..0> = M [ EA ];
               GPR [ rd ] = ( 0x000000ff & GPR [ rd ] );
               GPR [ ra ] = EA;

            }

// Interger Load Half Word Insteructions

op int_load_half_word =   lhw_zero
                        | lhw_zero_indexed
                        | lhw_zero_update
                        | lhw_zero_update_indexed
                        | lhw_alg
                        | lhw_alg_indexed
                        | lhw_alg_update
                        | lhw_alg_update_indexed

op lhw_zero ( rd : index, ra : REG_IND_ZERO, d : IADDR )
   uses = ls_unit #{1} , GPR [ rd ] #{1}  
   syntax = format ( "lhz %d,%s(%s)", rd, d.syntax, ra.syntax )
   image  = format ( "101000%5b%s%16b", rd, ra.image, d.image )
   action = {

               EA = ra + d;
               GPR [ rd ] = 0;
             
               //TMP_SHWORD_A0 = M [ EA ];
               //TMP_SHWORD_A1 = M [ EA + 1 ];

               //GPR [ rd ] = TMP_SHWORD;

								GPR [ rd ]<15..0> = M [ EA + 1 ] :: M [ EA ];

               GPR [ rd ] = (GPR [ rd ] & 0x0000ffff);

            }

               
op lhw_zero_indexed ( rd : index, ra : REG_IND_ZERO, rb : REG_IND )
   uses = ls_unit #{1} , GPR [ rd ] #{1}  
   syntax = format ( "lhzx %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s01000101110", rd, ra.image, rb.image )
   action = {

               EA = ra + rb;
               GPR [ rd ] = 0;
             
               //TMP_SHWORD_A0 = M [ EA ];
               //TMP_SHWORD_A1 = M [ EA + 1 ];

               //GPR [ rd ] = TMP_SHWORD;

								GPR [ rd ]<15..0> = M [ EA + 1] :: M [ EA ];


               GPR [ rd ] = (GPR [ rd ] & 0x0000ffff);
            }

op lhw_zero_update ( rd : index, ra : index, d : IADDR )
   uses = ls_unit #{1} , (GPR [ rd ] & GPR [ ra ] #{1})  
   syntax = format ( "lhzu %d,%s(%d)", rd, d.syntax, ra )
   image  = format ( "101001%5b%5b%16b", rd, ra, d.image )
   action = {

               EA = GPR [ ra ] + d;
               GPR [ rd ] = 0;
             
               //TMP_SHWORD_A0 = M [ EA ];
               //TMP_SHWORD_A1 = M [ EA + 1 ];

               //GPR [ rd ] = TMP_SHWORD;
							
							 GPR [ rd ]<15..0> = M [ EA + 1] :: M [ EA ];

               GPR [ ra ] = EA;

               GPR [ rd ] = (GPR [ rd ] & 0x0000ffff);
            }

op lhw_zero_update_indexed ( rd : index, ra : index, rb : REG_IND )
   uses = ls_unit #{1} , (GPR [ rd ] & GPR [ ra ] #{1})
   syntax = format ( "lhzux %d,%d,%s", rd, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s01001101110", rd, ra, rb.image )
   action = {

               EA = GPR [ ra ] + rb;
               GPR [ rd ] = 0;
             
               //TMP_SHWORD_A0 = M [ EA ];
               //TMP_SHWORD_A1 = M [ EA + 1 ];

               //GPR [ rd ] = TMP_SHWORD;

							
							 GPR [ rd ]<15..0> = M [ EA + 1] :: M [ EA ]; 
               GPR [ ra ] = EA;

               GPR [ rd ] = (GPR [ rd ] & 0x0000ffff);

            }

op lhw_alg ( rd : index, ra : REG_IND_ZERO, d : IADDR )
   uses = ls_unit #{1} , GPR [ rd ] #{1}  
   syntax = format ( "lha %d,%s(%s)", rd, d.syntax, ra.syntax )
   image  = format ( "101010%5b%s%16b", rd, ra.image, d.image )
   action = {

               EA = ra + d;
               GPR [ rd ] = 0;
               TMP_BYTE = M [ EA ];
             
              // TMP_SHWORD_A0 = M [ EA ];
              // TMP_SHWORD_A1 = M [ EA + 1 ];

               //GPR [ rd ] = TMP_SHWORD;
							 GPR [ rd ]<15..0> = M [ EA + 1] :: M [ EA ];

               GPR [ rd ] = (GPR [ rd ] & 0x0000ffff);

               if TMP_BYTE < 7..7 > then
                  GPR [ rd ] =  0xffff0000 | GPR [ rd ];
               endif;
                  
            }

               
op lhw_alg_indexed ( rd : index, ra : REG_IND_ZERO, rb : REG_IND )
   uses = ls_unit #{1} , GPR [ rd ] #{1}  
   syntax = format ( "lhax %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s01010101110", rd, ra.image, rb.image )
   action = {

               EA = ra + rb;
               GPR [ rd ] = 0;
               TMP_BYTE = M [ EA ];
             
               //TMP_SHWORD_A0 = M [ EA ];
               //TMP_SHWORD_A1 = M [ EA + 1 ];

               //GPR [ rd ] = TMP_SHWORD;
								GPR [ rd ]<15..0> = M [ EA + 1] :: M [ EA ];

               GPR [ rd ] = (GPR [ rd ] & 0x0000ffff);

               if TMP_BYTE < 7..7 > then
                  GPR [ rd ] =  0xffff0000 | GPR [ rd ];
               endif;

            }

op lhw_alg_update ( rd : index, ra : index, d : IADDR )
   uses = ls_unit #{1} , (GPR [ rd ] & GPR [ ra ] #{1})
   syntax = format ( "lhau %d,%s(%d)", rd, d.syntax, ra )
   image  = format ( "101011%5b%5b%16b", rd, ra, d.image )
   action = {

               EA = GPR [ ra ] + d;
               GPR [ rd ] = 0;
               TMP_BYTE = M [ EA ];
             
              // TMP_SHWORD_A0 = M [ EA ];
              // TMP_SHWORD_A1 = M [ EA + 1 ];

               //GPR [ rd ] = TMP_SHWORD;
								GPR [ rd ]<15..0> = M [ EA + 1] :: M [ EA ];

               GPR [ rd ] = (GPR [ rd ] & 0x0000ffff);

               if TMP_BYTE < 7..7 > then
                  GPR [ rd ] =  0xffff0000 | GPR [ rd ];
               endif;

               GPR [ ra ] = EA;

            }

op lhw_alg_update_indexed ( rd : index, ra : index, rb : REG_IND )
   uses = ls_unit #{1} , (GPR [ rd ] & GPR [ ra ] #{1})
   syntax = format ( "lhaux %d,%d,%s", rd, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s01011101110", rd, ra, rb.image )
   action = {

               EA = GPR [ ra ] + rb;
               GPR [ rd ] = 0;
               TMP_BYTE = M [ EA ];
             
               //TMP_SHWORD_A0 = M [ EA ];
               //TMP_SHWORD_A1 = M [ EA + 1 ];

               //GPR [ rd ] = TMP_SHWORD;
								GPR [ rd ]<15..0> = M [ EA + 1] :: M [ EA ];

								

               GPR [ rd ] = (GPR [ rd ] & 0x0000ffff);

               if TMP_BYTE < 7..7 > then
                  GPR [ rd ] =  0xffff0000 | GPR [ rd ];
               endif;

               GPR [ ra ] = EA;

            }

// Interger Load Word Instructions

op int_load_word =   lw_zero
                   | lw_zero_indexed
                   | lw_zero_update
                   | lw_zero_update_indexed

op lw_zero ( rd : index, ra : REG_IND_ZERO, d : IADDR )
   uses = ls_unit #{1} , GPR [ rd ] #{1}  
   syntax = format ( "lwz %d,%s(%s)", rd, d.syntax, ra.syntax )
   image  = format ( "100000%5b%s%16b", rd, ra.image, d.image )
   action = {

               EA = ra + d;
               GPR [ rd ] = 0;

               //TMP_SWORD_A0 = M [ EA ];
               //TMP_SWORD_A1 = M [ EA + 1 ];
               //TMP_SWORD_A2 = M [ EA + 2 ];
               //TMP_SWORD_A3 = M [ EA + 3 ];

               //GPR [ rd ] = TMP_SWORD;

								GPR [ rd ]<31..0> = M [EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ];

            }

               
op lw_zero_indexed ( rd : index, ra : REG_IND_ZERO, rb : REG_IND )
   uses = ls_unit #{1} , GPR [ rd ] #{1}  
   syntax = format ( "lwzx %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00000101110", rd, ra.image, rb.image )
   action = {

               EA = ra + rb;
               GPR [ rd ] = 0;

              // TMP_SWORD_A0 = M [ EA ];
              // TMP_SWORD_A1 = M [ EA + 1 ];
              // TMP_SWORD_A2 = M [ EA + 2 ];
               //TMP_SWORD_A3 = M [ EA + 3 ];

               //GPR [ rd ] = TMP_SWORD;
							 GPR [ rd ]<31..0> = M [EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ];

            }

op lw_zero_update ( rd : index, ra : index, d : IADDR )
   uses = (ls_unit & GPR [ rd ] #{1}) , GPR [ ra ] #{1}  
   syntax = format ( "lwzu %d,%s(%d)", rd, d.syntax, ra )
   image  = format ( "100001%5b%5b%16b", rd, ra, d.image )
   action = {

               EA = GPR [ ra ] + d;
               GPR [ rd ] = 0;

              // TMP_SWORD_A0 = M [ EA ];
              // TMP_SWORD_A1 = M [ EA + 1 ];
              // TMP_SWORD_A2 = M [ EA + 2 ];
               //TMP_SWORD_A3 = M [ EA + 3 ];

               //GPR [ rd ] = TMP_SWORD;
							 GPR [ rd ]<31..0> = M [EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ];

               GPR [ ra ] = EA;

            }

op lw_zero_update_indexed ( rd : index, ra : index, rb : REG_IND )
   uses = (ls_unit & GPR [ rd ] #{1}) , GPR [ ra ] #{1}  
   syntax = format ( "lwzux %d,%d,%s", rd, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s00001101110", rd, ra, rb.image )
   action = {

               EA = GPR [ ra ] + rb;
               GPR [ rd ] = 0;

               //TMP_SWORD_A0 = M [ EA ];
               //TMP_SWORD_A1 = M [ EA + 1 ];
               //TMP_SWORD_A2 = M [ EA + 2 ];
               //TMP_SWORD_A3 = M [ EA + 3 ];

               //GPR [ rd ] = TMP_SWORD;
							 GPR [ rd ]<31..0> = M [EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ];

               GPR [ ra ] = EA;

            }

// Integer Load with Byte reversal Instructions

op int_load_byte_rev =   lhw_br_index
                       | lw_br_index

op lhw_br_index ( rd : index, ra : REG_IND_ZERO, rb : REG_IND )
   uses   = ls_unit #{1} , GPR [ rd ] #{1} 
   syntax = format ( "lhbrx %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s11000101100", rd, ra.image, rb.image )
   action = {

               EA = ra + rb;
               GPR [ rd ] = 0;

               GPR [ rd ]<15..8> = M [ EA + 1 ];
               GPR [ rd ]<7..0> =  M [ EA ];

               //GPR [ rd ] = TMP_SHWORD;
			
							 //GPR [ rd ]<15..0> = M [ EA ] :: M [ EA + 1];				
               GPR [ rd ] = (GPR [ rd ] & 0x0000ffff);

            }

op lw_br_index ( rd : index, ra : REG_IND_ZERO, rb : REG_IND )
   uses   = ls_unit #{1} , GPR [ rd ] #{1} 
   syntax = format ( "lwbrx %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10000101100", rd, ra.image, rb.image )
   action = {

               EA = ra + rb;
               GPR [ rd ] = 0;

               GPR [ rd ]<31..24> = M [ EA + 3 ];
               GPR [ rd ]<23..16> = M [ EA + 2 ];
               GPR [ rd ]<15..8>  = M [ EA + 1 ];
               GPR [ rd ]<7..0>   = M [ EA ];

               //GPR [ rd ] = TMP_SWORD;

							 //GPR [ rd ]<31..0> = M [ EA ] :: M [ EA + 1] :: M [ EA + 2] :: M [ EA + 3];

            }

// Integer Load Multiple Instructions

op int_load_multiple ( rd : index, ra : REG_IND_ZERO, d : IMM16 )
//   uses   = ls_unit : preact #{ 2 + ( 32 - rd ) }		commented by nitin: preact not defined
   syntax = format ( "lmw %d,%s(%s)", rd , d.syntax, ra.syntax )
   image  = format ( "101110%5b%s%s", rd, ra.image, d.image )
   action = {

               EA = ra + d;
               TMP_BYTE =  rd;
               recurs;

            }
    recurs = {

                if TMP_BYTE <= 31 then
                   
                  // TMP_SWORD_A0 = M [ EA ];
                  // TMP_SWORD_A1 = M [ EA + 1 ];
                  // TMP_SWORD_A2 = M [ EA + 2 ];
                  // TMP_SWORD_A3 = M [ EA + 3 ];

                  // GPR [ TMP_BYTE ] = TMP_SWORD;

									 GPR [ TMP_BYTE ]<31..0> = M [ EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ];

                   TMP_BYTE = TMP_BYTE + 1;
                   EA = EA + 4;
                   recurs;
                endif; 
 
             } 
               
// Integer Load Stirng Instructions

op int_load_string =   lstw_imm
                     | lstw_index

op lstw_imm ( rd : index, ra : REG_IND_ZERO, NB : LS_COUNT )
   uses   = ls_unit #{ 2 + NB }
   syntax = format ( "lswi %d,%s,%s", rd, ra.syntax, NB.syntax )
   image  = format ( "011111%5b%s%5b10010101010", rd, ra.image, NB.image )
   action = {

               TMP_WORD = rd - 1;
               TMP_BYTE = 32;
               EA = ra;
			   TMP_SHWORD = NB;
               recurs;

            }
   recurs = {

               if TMP_SHWORD >= 0 then

                  if TMP_BYTE == 32 then
                     TMP_WORD = ( TMP_WORD + 1 ) % 32;
                     GPR [ TMP_WORD ] = 0;
                     TMP_BYTE = 0;
                  endif;

                  TMP_WORD1 = M [ EA ];
                  TMP_WORD1 = TMP_WORD1 << (31 - TMP_BYTE + 7);
                  TMP_WORD1 = TMP_WORD1 & ( 0x000000ff << (31 - TMP_BYTE + 7));
                  GPR [ TMP_WORD ] = GPR [ TMP_WORD ] | TMP_WORD1;

                  TMP_BYTE = TMP_BYTE + 8;
                  EA = EA + 1;
                  TMP_SHWORD = TMP_SHWORD - 1;
                  recurs;

               endif;

           }

op lstw_index ( rd : index, ra : REG_IND_ZERO, rb : REG_IND )
   uses   = ls_unit #{ 2 + XER < 0..6 > }
   syntax = format ( "lswx %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10000101010", rd, ra.image, rb.image )
   action = {

               TMP_WORD = rd - 1;
               TMP_SBYTE = XER < 6..0 >;
               TMP_BYTE = 32;
               EA = ra + rb;
               recurs;

            }
   recurs = {

               if TMP_SBYTE >= 0 then

                  if TMP_BYTE == 32 then
                     TMP_WORD = ( TMP_WORD + 1 ) % 32;
                     GPR [ TMP_WORD ] = 0;
                     TMP_BYTE = 0;
                  endif;

                  TMP_WORD1 = M [ EA ];
                  TMP_WORD1 = TMP_WORD1 << (31 - TMP_BYTE + 7);
                  TMP_WORD1 = TMP_WORD1 & ( 0x000000ff << (31 - TMP_BYTE + 7));
                  GPR [ TMP_WORD ] = GPR [ TMP_WORD ] | TMP_WORD1;

                  TMP_BYTE = TMP_BYTE + 8;
                  EA = EA + 1;
                  TMP_SBYTE = TMP_SBYTE - 1;
                  recurs;

               endif;

           }
                  
                  

// Integer Store Instructions

op int_store =   int_store_byte
               | int_store_half_word 
               | int_store_word 
               | int_store_byte_rev   // New
               | int_store_multiple   // New
               | int_store_string     // New

// Integer Store Byte Instructions

op int_store_byte =   st_byte
                    | st_byte_indexed
                    | st_byte_update
                    | st_byte_update_indexed

op st_byte ( rs : index, ra : REG_IND_ZERO, d : IADDR )
   uses = ls_unit #{2}  
   syntax = format ( "stb %d,%s(%s)", rs, d.syntax, ra.syntax )
   image  = format ( "100110%5b%s%16b", rs, ra.image, d.image )
   action = {

               EA = ra + d;

               //TMP_SWORD = GPR [ rs ];

               //M [ EA ] = TMP_SWORD_A3;
						
								 M [ EA ] = GPR [ rs ]<7..0> ;	

            }

               
op st_byte_indexed ( rs : index, ra : REG_IND_ZERO, rb : REG_IND )
   uses = ls_unit #{2}  
   syntax = format ( "stbx %d,%s,%s", rs, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00110101110", rs, ra.image, rb.image )
   action = {

               EA = ra + rb;

               //TMP_SWORD = GPR [ rs ];

               //M [ EA ] = TMP_SWORD_A3;

								M [ EA ]	= GPR [ rs ]<7..0> ;

            }

op st_byte_update ( rs : index, ra : index, d : IADDR )
   uses = ls_unit #{2}  
   syntax = format ( "stbu %d,%s(%d)", rs, d.syntax, ra )
   image  = format ( "100111%5b%5b%16b", rs, ra, d.image )
   action = {

               if ra == 0 then
                  EA = d;
               else
                  EA = GPR [ ra ] + d;
               endif;

               //TMP_SWORD = GPR [ rs ];

               //M [ EA ] = TMP_SWORD_A3;

								M [ EA ]	= GPR [ rs ]<7..0> ;

               GPR [ ra ] = EA;

            }

op st_byte_update_indexed ( rs : index, ra : index, rb : REG_IND )
   uses = ls_unit #{2}  
   syntax = format ( "stbux %d,%d,%s", rs, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s00111101110", rs, ra, rb.image )
   action = {

               if ra == 0 then
                  EA = rb;
               else
                  EA = GPR [ ra ] + rb;
               endif;

               //TMP_SWORD = GPR [ rs ];

               //M [ EA ] = TMP_SWORD_A3;

								M [ EA ]	= GPR [ rs ]<7..0> ;

               GPR [ ra ] = EA;

            }

// Integer Store Half Word Instructions

op int_store_half_word =   st_half_word
                         | st_half_word_indexed
                         | st_half_word_update
                         | st_half_word_update_indexed

op st_half_word ( rs : index, ra : REG_IND_ZERO, d : IADDR )
   uses = ls_unit #{2}  
   syntax = format ( "sth %d,%s(%s)", rs, d.syntax, ra.syntax )
   image  = format ( "101100%5b%s%16b", rs, ra.image, d.image )
   action = {

               EA = ra + d;

               //TMP_SWORD = GPR [ rs ];

               //M [ EA ] = TMP_SWORD_A2;
               //M [ EA + 1 ] = TMP_SWORD_A3;

							 M [ EA + 1 ] :: M [ EA ] = GPR [ rs ]<15..0> ;

            }

               
op st_half_word_indexed ( rs : index, ra : REG_IND_ZERO, rb : REG_IND )
   uses = ls_unit #{2}  
   syntax = format ( "sthx %d,%s,%s", rs, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s01100101110", rs, ra.image, rb.image )
   action = {

               EA = ra + rb;

               //TMP_SWORD = GPR [ rs ];

               //M [ EA ] = TMP_SWORD_A2;
               //M [ EA + 1 ] = TMP_SWORD_A3;

							 M [ EA + 1 ] :: M [ EA ] = GPR [ rs ]<15..0> ;


            }

op st_half_word_update ( rs : index, ra : index, d : IADDR )
   uses = ls_unit #{2}  
   syntax = format ( "sthu %d,%s(%d)", rs, d.syntax, ra )
   image  = format ( "101101%5b%5b%16b", rs, ra, d.image )
   action = {

               if ra == 0 then
                  EA = d;
               else
                  EA = GPR [ ra ] + d;
               endif;

               //TMP_SWORD = GPR [ rs ];

               //M [ EA ] = TMP_SWORD_A2;
               //M [ EA + 1 ] = TMP_SWORD_A3;

							 M [ EA + 1 ] :: M [ EA ] = GPR [ rs ]<15..0> ;

               GPR [ ra ] = EA;

            }

op st_half_word_update_indexed ( rs : index, ra : index, rb : REG_IND )
   uses = ls_unit #{2}  
   syntax = format ( "sthux %d,%d,%s", rs, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s01101101110", rs, ra, rb.image )
   action = {

               if ra == 0 then
                  EA = rb;
               else
                  EA = GPR [ ra ] + rb;
               endif;

              // TMP_SWORD = GPR [ rs ];

               //M [ EA ] = TMP_SWORD_A2;
               //M [ EA + 1 ] = TMP_SWORD_A3;

							 M [ EA + 1 ] :: M [ EA ] = GPR [ rs ]<15..0> ;

               GPR [ ra ] = EA;

            }

// Integer Store Word Instructions

op int_store_word =   st_word
                    | st_word_indexed
                    | st_word_update
                    | st_word_update_indexed

op st_word ( rs : index, ra : REG_IND_ZERO, d : IADDR )
   uses = ls_unit #{2}  
   syntax = format ( "stw %d,%s(%s)", rs, d.syntax, ra.syntax )
   image  = format ( "100100%5b%s%16b", rs, ra.image, d.image )
   action = {

               EA = ra + d;

               //TMP_SWORD = GPR [ rs ];

               //M [ EA ] = TMP_SWORD_A0;
               //M [ EA + 1 ] = TMP_SWORD_A1;
               //M [ EA + 2 ] = TMP_SWORD_A2;
               //M [ EA + 3 ] = TMP_SWORD_A3;

								M [ EA + 3] :: M [ EA + 2] :: M [EA + 1] :: M [ EA ] = GPR [ rs ]<31..0> ; 			

            }

               
op st_word_indexed ( rs : index, ra : REG_IND_ZERO, rb : REG_IND )
   uses = ls_unit #{2}  
   syntax = format ( "stwx %d,%s,%s", rs, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00100101110", rs, ra.image, rb.image )
   action = {

               EA = ra + rb;

	             //TMP_SWORD = GPR [ rs ];

               //M [ EA ] = TMP_SWORD_A0;
               //M [ EA + 1 ] = TMP_SWORD_A1;
               //M [ EA + 2 ] = TMP_SWORD_A2;
               //M [ EA + 3 ] = TMP_SWORD_A3;

								M [ EA + 3] :: M [ EA + 2] :: M [EA + 1] :: M [ EA ] = GPR [ rs ]<31..0> ; 			

            }

op st_word_update ( rs : index, ra : index, d : IADDR )
   uses = ls_unit #{2}  
   syntax = format ( "stwu %d,%s(%d)", rs, d.syntax, ra )
   image  = format ( "100101%5b%5b%16b", rs, ra, d.image )
   action = {

               if ra == 0 then
                  EA = d;
               else
                  EA = GPR [ ra ] + d;
               endif;

             //  TMP_SWORD = GPR [ rs ];

             //  M [ EA ] = TMP_SWORD_A0;
             //  M [ EA + 1 ] = TMP_SWORD_A1;
             //  M [ EA + 2 ] = TMP_SWORD_A2;
             //  M [ EA + 3 ] = TMP_SWORD_A3;

							 M [ EA + 3] :: M [ EA + 2] :: M [EA + 1] :: M [ EA ] = GPR [ rs ]<31..0> ; 			
               GPR [ ra ] = EA;

            }

op st_word_update_indexed ( rs : index, ra : index, rb : REG_IND )
   uses = ls_unit #{2}  
   syntax = format ( "stwux %d,%d,%s", rs, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s00101101110", rs, ra, rb.image )
   action = {

               if ra == 0 then
                  EA = rb;
               else
                  EA = GPR [ ra ] + rb;
               endif;

              // TMP_SWORD = GPR [ rs ];

              // M [ EA ] = TMP_SWORD_A0;
              // M [ EA + 1 ] = TMP_SWORD_A1;
              // M [ EA + 2 ] = TMP_SWORD_A2;
              // M [ EA + 3 ] = TMP_SWORD_A3;
							
								M [ EA + 3] :: M [ EA + 2] :: M [EA + 1] :: M [ EA ] = GPR [ rs ]<31..0> ; 			

               GPR [ ra ] = EA;

            }

// Integer Store with Byte reversal Instructions

op int_store_byte_rev =   sthw_br_index
                        | stw_br_index

op sthw_br_index ( rs : index, ra : REG_IND_ZERO, rb : REG_IND )
   uses   = ls_unit #{1} , GPR [ rs ] #{1} 
   syntax = format ( "sthbrx %d,%s,%s", rs, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s11100101100", rs, ra.image, rb.image )
   action = {

               EA = ra + rb;
               //TMP_SHWORD = GPR [ rs ];

               M [ EA ]  = GPR [ rs ]<7..0>; 
               M [ EA + 1 ]  = GPR [ rs ]<15..8>; 

								//M [ EA ] :: M [ EA + 1] = GPR [ rs ]<15..0>;	

            }

op stw_br_index ( rs : index, ra : REG_IND_ZERO, rb : REG_IND )
   uses   = ls_unit #{1} , GPR [ rs ] #{1} 
   syntax = format ( "stwbrx %d,%s,%s", rs, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10100101100", rs, ra.image, rb.image )
   action = {

               EA = ra + rb;
               //TMP_SWORD = GPR [ rs ];

               M [ EA ] = GPR [ rs ]<7..0>;
               M [ EA + 1 ] = GPR [ rs ]<15..8>;
               M [ EA + 2 ] = GPR [ rs ]<23..16>;
               M [ EA + 3 ] =  GPR [ rs ]<31..24>;

							 //M [ EA ] :: M [ EA + 1] :: M [ EA + 2] :: M [ EA + 3 ] = GPR [ rs ]<31..0>;

            }

// Integer Store Multiple Instructions

op int_store_multiple ( rs : index, ra : REG_IND_ZERO, d : IMM16 )
//   uses   = ls_unit : preact #{ 1 + ( 32 - rs ) }		commented by nitin: preact not defined
   syntax = format ( "stmw %d,%s(%s)", rs, d.syntax, ra.syntax )
   image  = format ( "101111%5b%s%s", rs, ra.image, d.image )
   action = {

               EA = ra + d;
               TMP_WORD = rs;
               recurs;

            }
    recurs = {

                if TMP_WORD <= 31 then
                  // TMP_SWORD = GPR [ TMP_WORD ];
                   //M [ EA ] = TMP_SWORD_A0;
                   //M [ EA + 1 ] = TMP_SWORD_A1;
                   //M [ EA + 2 ] = TMP_SWORD_A2;
                   //M [ EA + 3 ] = TMP_SWORD_A3;

								   M [ EA + 3] :: M [ EA + 2] :: M [EA + 1] :: M [ EA ] = GPR [ TMP_WORD ]<31..0> ; 			
                   TMP_WORD = TMP_WORD + 1;
                   EA = EA + 4;
                   recurs;
                endif; 
 
             } 
               
// Integer Store Stirng Instructions

op int_store_string =   ststw_imm
                      | ststw_index

op ststw_imm ( rs : index, ra : REG_IND_ZERO, NB : LS_COUNT )
   uses   = ls_unit #{ 1 + NB }
   syntax = format ( "stswi %d,%s,%s", rs, ra.syntax, NB.syntax )
   image  = format ( "011111%5b%s%5b10110101010", rs, ra.image, NB.image )
   action = {

               TMP_WORD = rs - 1;
               TMP_BYTE = 0;
               EA = ra;
			   	TMP_SWORD = NB;
               recurs;

            }
   recurs = {

               if TMP_SWORD >= 0 then

                  if TMP_BYTE == 0 then
                     TMP_WORD = ( TMP_WORD + 1 ) % 32;
                  endif;
						// Changed by Surendra +7 to -7
                  M [ EA ] = GPR [ TMP_WORD ] < (31-TMP_BYTE)..((31-TMP_BYTE)-7) >;
                  TMP_BYTE = TMP_BYTE + 8;

                  if TMP_BYTE == 32 then
                     TMP_BYTE = 0;
                  endif;

                  EA = EA + 1;
                  TMP_SWORD = TMP_SWORD - 1;
                  recurs;

               endif;

           }

op ststw_index ( rs : index, ra : REG_IND_ZERO, rb : REG_IND )
   uses   = ls_unit #{ 1 + XER < 0..6 > }
   syntax = format ( "stswx %d,%s,%s", rs, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10100101010", rs, ra.image, rb.image )
   action = {

               TMP_WORD = rs - 1;
               TMP_SBYTE = XER < 6..0 >;
               TMP_BYTE = 0;
               EA = ra + rb;
               recurs;

            }
   recurs = {

               if TMP_SBYTE >= 0 then

                  if TMP_BYTE == 0 then
                     TMP_WORD = ( TMP_WORD + 1 ) % 32;
                  endif;
						// Changed by Surendra +7 to -7
                  M [ EA ] = GPR [ TMP_WORD ] < (31-TMP_BYTE)..((31-TMP_BYTE)-7) >;
                  TMP_BYTE = TMP_BYTE + 8;

                  if TMP_BYTE == 32 then
                     TMP_BYTE = 0;
                  endif;

                  EA = EA + 1;
                  TMP_SBYTE = TMP_SBYTE - 1;
                  recurs;

               endif;

           }

// Floating Point Load Instructions

op fp_load =   fp_load_double
             | fp_load_single

// Floating Point Load Single Precision Instructions

op fp_load_single =   l_single
                    | l_single_indexed
                    | l_single_update
                    | l_single_update_indexed

op l_single ( frd : index, ra : REG_IND_ZERO, d : IADDR )
   uses = ls_unit #{1} 
   syntax = format ( "lfs %d,%s(%s)", frd, d.syntax, ra.syntax )
   image  = format ( "110000%5b%s%16b", frd, ra.image, d.image )
   action = {

               EA = ra + d;

              // TMP_FLOTS_A3 = M [ EA + 3 ];
              // TMP_FLOTS_A2 = M [ EA + 2 ];
              // TMP_FLOTS_A1 = M [ EA + 1 ];
              // TMP_FLOTS_A0 = M [ EA ];

			  			// FPR [ frd ] = TMP_FLOTS;

								TMP_FLOTS = M[ EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ];
								FPR [ frd ] = TMP_FLOTS;

            }

op l_single_indexed ( frd : index, ra : REG_IND_ZERO, rb : REG_IND )
   uses = ls_unit #{1} 
   syntax = format ( "lfsx %d,%s,%s", frd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10000101110", frd, ra.image, rb.image )
   action = {

               EA = ra + rb;

              // TMP_FLOTS_A0 = M [ EA ];
              // TMP_FLOTS_A1 = M [ EA + 1 ];
              // TMP_FLOTS_A2 = M [ EA + 2 ];
              // TMP_FLOTS_A3 = M [ EA + 3 ];

               //FPR [ frd ] = TMP_FLOTS;
								
								TMP_FLOTS = M[ EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ];
								FPR [ frd ] = TMP_FLOTS;

            }

op l_single_update ( frd : index, ra : index, d : IADDR )
   uses = ls_unit #{1} 
   syntax = format ( "lfsu %d,%s(%d)", frd, d.syntax, ra )
   image  = format ( "110001%5b%5b%16b", frd, ra, d.image )
   action = {

               if ra == 0 then
                  EA = d;
               else
                  EA = GPR [ ra ] + d;
               endif;

               //TMP_FLOTS_A0 = M [ EA ];
               //TMP_FLOTS_A1 = M [ EA + 1 ];
               //TMP_FLOTS_A2 = M [ EA + 2 ];
               //TMP_FLOTS_A3 = M [ EA + 3 ];

               //FPR [ frd ] = TMP_FLOTS;

							// FPR [ frd ]<31..0> = M[ EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ];
							TMP_FLOTS = M[ EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ];
							FPR [ frd ] = TMP_FLOTS;

               GPR [ ra ] = EA;

            }

op l_single_update_indexed ( frd : index, ra : index, rb : REG_IND )
   uses = ls_unit #{1} 
   syntax = format ( "lfsux %d,%d,%s", frd, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s10001101110", frd, ra, rb.image )
   action = {

               if ra == 0 then
                  EA = rb;
               else
                  EA = GPR [ ra ] + rb;
               endif;

               //TMP_FLOTS_A0 = M [ EA ];
               //TMP_FLOTS_A1 = M [ EA + 1 ];
               //TMP_FLOTS_A2 = M [ EA + 2 ];
               //TMP_FLOTS_A3 = M [ EA + 3 ];

               //FPR [ frd ] = TMP_FLOTS;

							 //FPR [ frd ]<31..0> = M[ EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ];
							TMP_FLOTS = M[ EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ];
							FPR [ frd ] = TMP_FLOTS;

               GPR [ ra ] = EA;

            }

// Floating Point Load Double Precision Instructions

op fp_load_double =   l_double
                    | l_double_indexed
                    | l_double_update
                    | l_double_update_indexed

op l_double ( frd : index, ra : REG_IND_ZERO, d : IADDR )
   uses = ls_unit #{1} 
   syntax = format ( "lfd %d,%s(%s)", frd, d.syntax, ra.syntax )
   image  = format ( "110010%5b%s%16b", frd, ra.image, d.image )
   action = {

               EA = ra + d;

			  // TMP_FLOT_A0 = M [ EA ];
			  // TMP_FLOT_A1 = M [ EA + 1 ];
			  // TMP_FLOT_A2 = M [ EA + 2 ];
			  // TMP_FLOT_A3 = M [ EA + 3 ];
			  // TMP_FLOT_A4 = M [ EA + 4 ];
			  // TMP_FLOT_A5 = M [ EA + 5 ];
			  // TMP_FLOT_A6 = M [ EA + 6 ];
			  // TMP_FLOT_A7 = M [ EA + 7 ];

          //     FPR [ frd ] = TMP_FLOT;

				FPR [ frd ] = M [ EA + 7] :: M [ EA + 6] :: M [EA + 5] :: M [ EA + 4] :: M[ EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ];

            }

op l_double_indexed ( frd : index, ra : REG_IND_ZERO, rb : REG_IND )
   uses = ls_unit #{1} 
   syntax = format ( "lfdx %d,%s,%s", frd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10010101110", frd, ra.image, rb.image )
   action = {

               EA = ra + rb;

			 //  TMP_FLOT_A0 = M [ EA ];
			 //  TMP_FLOT_A1 = M [ EA + 1 ];
			 //  TMP_FLOT_A2 = M [ EA + 2 ];
			 //  TMP_FLOT_A3 = M [ EA + 3 ];
			 //  TMP_FLOT_A4 = M [ EA + 4 ];
			 //  TMP_FLOT_A5 = M [ EA + 5 ];
			 //  TMP_FLOT_A6 = M [ EA + 6 ];
			 //  TMP_FLOT_A7 = M [ EA + 7 ];

         //      FPR [ frd ] = TMP_FLOT;
				FPR [ frd ] = M [ EA + 7] :: M [ EA + 6] :: M [EA + 5] :: M [ EA + 4] :: M[ EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ];

            }

op l_double_update ( frd : index, ra : index, d : IADDR )
   uses = ls_unit #{1} 
   syntax = format ( "lfdu %d,%s(%d)", frd, d.syntax, ra )
   image  = format ( "110011%5b%5b%16b", frd, ra, d.image )
   action = {

               if ra == 0 then
                  EA = d;
               else
                  EA = GPR [ ra ] + d;
               endif;

			   //TMP_FLOT_A0 = M [ EA ];
			   //TMP_FLOT_A1 = M [ EA + 1 ];
			   //TMP_FLOT_A2 = M [ EA + 2 ];
			   //TMP_FLOT_A3 = M [ EA + 3 ];
			   //TMP_FLOT_A4 = M [ EA + 4 ];
			   //TMP_FLOT_A5 = M [ EA + 5 ];
			  //TMP_FLOT_A6 = M [ EA + 6 ];
			  // TMP_FLOT_A7 = M [ EA + 7 ];

          //     FPR [ frd ] = TMP_FLOT;

				FPR [ frd ] = M [ EA + 7] :: M [ EA + 6] :: M [EA + 5] :: M [ EA + 4] :: M[ EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ];
               GPR [ ra ] = EA;

            }

op l_double_update_indexed ( frd : index, ra : index, rb : REG_IND )
   uses = ls_unit #{1} 
   syntax = format ( "lfdux %d,%d,%s", frd, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s10011101110", frd, ra, rb.image )
   action = {

               if ra == 0 then
                  EA = rb;
               else
                  EA = GPR [ ra ] + rb;
               endif;

			 //  TMP_FLOT_A0 = M [ EA ];
			 // TMP_FLOT_A1 = M [ EA + 1 ];
			 //  TMP_FLOT_A2 = M [ EA + 2 ];
			 //  TMP_FLOT_A3 = M [ EA + 3 ];
			  // TMP_FLOT_A4 = M [ EA + 4 ];
			 //  TMP_FLOT_A5 = M [ EA + 5 ];
			 //  TMP_FLOT_A6 = M [ EA + 6 ];
			 //  TMP_FLOT_A7 = M [ EA + 7 ];

         //      FPR [ frd ] = TMP_FLOT;

				FPR [ frd ] = M [ EA + 7] :: M [ EA + 6] :: M [EA + 5] :: M [ EA + 4] :: M[ EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ];

               GPR [ ra ] = EA;

            }

// Floating Point Store Instructions

op fp_store =   fp_store_double
              | fp_store_single

// Floating Point Store Single Precision Instructions

op fp_store_single =   st_single
                     | st_single_indexed
                     | st_single_update
                     | st_single_update_indexed

op st_single ( frs : index, ra : REG_IND_ZERO, d : IADDR )
   uses = ls_unit #{2} 
   syntax = format ( "stfs %d,%s(%s)", frs, d.syntax, ra.syntax )
   image  = format ( "110100%5b%s%16b", frs, ra.image, d.image )
   action = {

               EA = ra + d;
              TMP_FLOTS = FPR [ frs ];

             //  M [ EA ] = TMP_FLOTS_A0;
             //  M [ EA + 1 ] = TMP_FLOTS_A1;
             //  M [ EA + 2 ] = TMP_FLOTS_A2;
             //  M [ EA + 3 ] = TMP_FLOTS_A3;
			           M[ EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ]  = TMP_FLOTS;

            }

op st_single_indexed ( frs : index, ra : REG_IND_ZERO, rb : REG_IND )
   uses = ls_unit #{2} 
   syntax = format ( "stfsx %d,%s,%s", frs, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10100101110", frs, ra.image, rb.image )
   action = {

               EA = ra + rb;
               TMP_FLOTS = FPR [ frs ];

              // M [ EA ] = TMP_FLOTS_A0;
              // M [ EA + 1 ] = TMP_FLOTS_A1;
              // M [ EA + 2 ] = TMP_FLOTS_A2;
              //M [ EA + 3 ] = TMP_FLOTS_A3;
			         M[ EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ]  = TMP_FLOTS ;
            }

op st_single_update ( frs : index, ra : index, d : IADDR )
   uses = ls_unit #{2} 
   syntax = format ( "stfsu %d,%s(%d)", frs, d.syntax, ra )
   image  = format ( "110101%5b%5b%16b", frs, ra, d.image )
   action = {

               if ra == 0 then
                  EA = d;
               else
                  EA = GPR [ ra ] + d;
               endif;

               TMP_FLOTS = FPR [ frs ];

              // M [ EA ] = TMP_FLOTS_A0;
              // M [ EA + 1 ] = TMP_FLOTS_A1;
              // M [ EA + 2 ] = TMP_FLOTS_A2;
              // M [ EA + 3 ] = TMP_FLOTS_A3;
			         
							M[ EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ]  = TMP_FLOTS ;

               GPR [ ra ] = EA;

            }

op st_single_update_indexed ( frs : index, ra : index, rb : REG_IND )
   uses = ls_unit #{2} 
   syntax = format ( "stfsux %d,%d,%s", frs, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s10101101110", frs, ra, rb.image )
   action = {

               if ra == 0 then
                  EA = rb;
               else
                  EA = GPR [ ra ] + rb;
               endif;

               TMP_FLOTS = FPR [ frs ];

               //M [ EA ] = TMP_FLOTS_A0;
               //M [ EA + 1 ] = TMP_FLOTS_A1;
               //M [ EA + 2 ] = TMP_FLOTS_A2;
               //M [ EA + 3 ] = TMP_FLOTS_A3;
							
							 M[ EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ]  = TMP_FLOTS ;

               GPR [ ra ] = EA;

            }

// Floating point Store Double precision Instructions

op fp_store_double =   st_double
                     | st_double_indexed
                     | st_double_update
                     | st_double_update_indexed

op st_double ( frs : index, ra : REG_IND_ZERO, d : IADDR )
   uses = ls_unit #{1} 
   syntax = format ( "stfd %d,%s(%s)", frs, d.syntax, ra.syntax )
   image  = format ( "110110%5b%s%16b", frs, ra.image, d.image )
   action = {

               EA = ra + d;

			   //TMP_FLOT = FPR [ frs ];

			   //M [ EA ] = TMP_FLOT_A0;
			   //M [ EA + 1 ] = TMP_FLOT_A1;
			   //M [ EA + 2 ] = TMP_FLOT_A2;
			  // M [ EA + 3 ] = TMP_FLOT_A3;
			  // M [ EA + 4 ] = TMP_FLOT_A4;
			  // M [ EA + 5 ] = TMP_FLOT_A5;
			  // M [ EA + 6 ] = TMP_FLOT_A6;
			   //M [ EA + 7 ] = TMP_FLOT_A7;

			
					 M [ EA + 7] :: M [ EA + 6] :: M [ EA + 5] :: M [ EA + 4] :: M[ EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ]  = FPR [ frs ]< 63..0 > ;

            }

op st_double_indexed ( frs : index, ra : REG_IND_ZERO, rb : REG_IND )
   uses = ls_unit #{1} 
   syntax = format ( "stfdx %d,%s,%s", frs, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10110101110", frs, ra.image, rb.image )
   action = {

               EA = ra + rb;
			   //TMP_FLOT = FPR [ frs ];

			   //M [ EA ] = TMP_FLOT_A0;
			   //M [ EA + 1 ] = TMP_FLOT_A1;
			   //M [ EA + 2 ] = TMP_FLOT_A2;
			   //M [ EA + 3 ] = TMP_FLOT_A3;
			   //M [ EA + 4 ] = TMP_FLOT_A4;
			   //M [ EA + 5 ] = TMP_FLOT_A5;
			   //M [ EA + 6 ] = TMP_FLOT_A6;
			   //M [ EA + 7 ] = TMP_FLOT_A7;

					 M [ EA + 7] :: M [ EA + 6] :: M [ EA + 5] :: M [ EA + 4] :: M[ EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ]  = FPR [ frs ]< 63..0 > ;
            }

op st_double_update ( frs : index, ra : index, d : IADDR )
   uses = ls_unit #{1} 
   syntax = format ( "stfdu %d,%s(%d)", frs, d.syntax, ra )
   image  = format ( "110111%5b%5b%16b", frs, ra, d.image )
   action = {
					// Changed by Surendra ra == 0 handled
					if ra == 0 then
						EA = d;
					else
               	EA = GPR [ ra ] + d;
					endif;
               GPR [ ra ] = EA;

			   //TMP_FLOT = FPR [ frs ];

			  // M [ EA ] = TMP_FLOT_A0;
			  // M [ EA + 1 ] = TMP_FLOT_A1;
			  // M [ EA + 2 ] = TMP_FLOT_A2;
			  // M [ EA + 3 ] = TMP_FLOT_A3;
			  // M [ EA + 4 ] = TMP_FLOT_A4;
			  // M [ EA + 5 ] = TMP_FLOT_A5;
			  // M [ EA + 6 ] = TMP_FLOT_A6;
			  // M [ EA + 7 ] = TMP_FLOT_A7;

					 M [ EA + 7] :: M [ EA + 6] :: M [ EA + 5] :: M [ EA + 4] :: M[ EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ]  = FPR [ frs ]< 63..0 > ;

          }

op st_double_update_indexed ( frs : index, ra : index, rb : REG_IND )
   uses = ls_unit #{1} 
   syntax = format ( "stfdux %d,%d,%s", frs, ra, rb.syntax )
   image  = format ( "011111%5b%5b%s10111101110", frs, ra, rb.image )
   action = {

					// Changed by Surendra ra == 0 handled
					if ra == 0 then
						EA = rb;
					else
               	EA = GPR [ ra ] + rb;
					endif;
               GPR [ ra ] = EA;

			 //  TMP_FLOT = FPR [ frs ];

			 //  M [ EA ] = TMP_FLOT_A0;
			 //  M [ EA + 1 ] = TMP_FLOT_A1;
			 //  M [ EA + 2 ] = TMP_FLOT_A2;
			 //  M [ EA + 3 ] = TMP_FLOT_A3;
			 //  M [ EA + 4 ] = TMP_FLOT_A4;
			 //  M [ EA + 5 ] = TMP_FLOT_A5;
			 //  M [ EA + 6 ] = TMP_FLOT_A6;
			 //  M [ EA + 7 ] = TMP_FLOT_A7;
 
            
					 M [ EA + 7] :: M [ EA + 6] :: M [ EA + 5] :: M [ EA + 4] :: M[ EA + 3] :: M [ EA + 2] :: M [ EA + 1] :: M [ EA ]  = FPR [ frs ]< 63..0 > ;
			}

// Integer Instructions

op int_instr ( x : int_instr_action )
   uses   = { wait_id < cq_ptr } int_unit : preact, x.uses, 
            { speculated [ int_id ] == 0 & int_id == CQ [ 0 ] } int_unit
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   preact = {

               int_id = CQ [ wait_id ];
               wait_id = wait_id + 1;

            }

op int_instr_action =   int_arithmetic
                      | int_compare
                      | int_logical
                      | int_rotate_shift
                
// Integer Arithmetic Instructions

op int_arithmetic =   int_add
                    | int_subtract
                    | int_multiply
                    | int_divide
                    | int_negate

// Integer Add Instructions

op int_add =   add
             | add_immediate
             | add_carry
             | add_extended
             | add_mone_extended
             | add_zero_extended
                  
op add =   simple_add
         | add_cr_update
         | add_overflow_enable
         | add_crup_overen

// Add Instructions

op simple_add ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "add %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s01000010100", rd, ra.image, rb.image )
   action = {

               GPR [ rd ] = ra + rb;

            }

op add_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "add. %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s01000010101", rd, ra.image, rb.image )
   action = {

               GPR [ rd ] = ra + rb;
					
					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

op add_overflow_enable ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "addo %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s11000010100", rd, ra.image, rb.image )
   action = {

               //if FPSCR < 6..6 > then
                  OF_BIT :: GPR [ rd ] = ra + rb; // ? is this a overflow
						if OF_BIT ^ GPR [rd] < 31..31 > then
							XER < 30..30 > = 1;
						endif;
                  if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;

            }

op add_crup_overen ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "addo. %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s11000010101", rd, ra.image, rb.image )
   action = {

               //if FPSCR < 6..6 > then
                  OF_BIT :: GPR [ rd ] = ra + rb; // ? is this a overflow
						if OF_BIT ^ GPR [rd] < 31..31 > then
							XER < 30..30 > = 1;
						endif;
                  if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;

					// Added by Surendra
					CR < 31..29 > = 0;
					//

               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// Add Immediate Instructions

op add_immediate =   add_imm
                   | add_imm_shifted
                   | add_imm_carry
                   | add_imm_carry_record
// I am changing here 
op add_imm ( rd : index, ra : REG_IND_ZERO, da : IMM16 )
   uses   = int_unit #{1} 
   syntax = format ( "addi %d,%s,%s", rd, ra.syntax, da.syntax)
   image  = format ( "001110%5b%s%s", rd, ra.image, da.image)
   action = {

               GPR [ rd ] = ra + da;
        
            }

op add_imm_shifted ( rd : index, ra : REG_IND_ZERO, da : IMM16 ) 
   uses   = int_unit #{1} 
   syntax = format ( "addis %d,%s,%s", rd, ra.syntax, da.syntax)
   image  = format ( "001111%5b%s%s", rd, ra.image, da.image)
   action = {

               TMP_SWORD = da;
               GPR [ rd ] = ra + ( TMP_SWORD << 16 );
        
            }

op add_imm_carry ( rd : index, ra : REG_IND, imm : IMM16 )
   uses   = int_unit #{1} 
   syntax = format ( "addic %d,%s,%s", rd, ra.syntax, imm.syntax )
   image  = format ( "001100%5b%s%s", rd, ra.image, imm.image )
   action = {
               OF_BIT :: GPR [ rd ] = ra + imm; // Set carry bit
               XER < 29..29 > = OF_BIT;

            }

op add_imm_carry_record ( rd : index, ra : REG_IND, imm : IMM16 )
   uses   = int_unit #{1} 
   syntax = format ( "addic. %d,%s,%s", rd, ra.syntax, imm.syntax )
   image  = format ( "001101%5b%s%s", rd, ra.image, imm.image )
   action = {
 
               OF_BIT :: GPR [ rd ] = ra + imm; // Set Carry bit
               XER < 29..29 > = OF_BIT;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// Add with carry Instructions

op add_carry =   add_carrying
               | add_carry_cr_update
               | add_carry_overflow
               | add_carry_overflow_cr_update

op add_carrying ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "addc %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00000010100", rd, ra.image, rb.image )
   action = {
 
                  OF_BIT :: GPR [ rd ] = ra + rb; // ? is this a overflow
                  XER < 29..29 > = OF_BIT;

            }

op add_carry_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "addc. %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00000010101", rd, ra.image, rb.image )
   action = {
 
                  OF_BIT :: GPR [ rd ] = ra + rb; // ? is this a overflow
                  XER < 29..29 > = OF_BIT;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

op add_carry_overflow ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "addco %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10000010100", rd, ra.image, rb.image )
   action = {
 					
					// Changed by Surendra
					// FPSCR not clear, removed
					// OV and SO handling added
               //if FPSCR < 6..6 > then

                  OF_BIT :: GPR [ rd ] = ra + rb; // ? is this a overflow
                  XER < 29..29 > = OF_BIT;

						if OF_BIT ^ GPR [rd] < 31..31> then
							XER < 30..30 > =1;
						endif;

                  if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;
               //else
               //   GPR [ rd ] = ra + rb;
               //endif;

            }

op add_carry_overflow_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "addco. %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10000010101", rd, ra.image, rb.image )
   action = {
 

					// Changed by Surendra
					// FPSCR not clear, removed
					// OV and SO handling added
               //if FPSCR < 6..6 > then

                  OF_BIT :: GPR [ rd ] = ra + rb; // ? is this a overflow
                  XER < 29..29 > = OF_BIT;

						if OF_BIT ^ GPR [rd] < 31..31 > then
							XER < 30..30 > =1;
						endif;

                  if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;

               //else
               //   GPR [ rd ] = ra + rb;

               //endif;
					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// Add extended Instructions

op add_extended =   add_extend
                  | add_extend_cr_update
                  | add_extend_overflow
                  | add_extd_overflow_cr_upd

op add_extend ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "adde %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00100010100", rd, ra.image, rb.image )
   action = {

                  OF_BIT :: GPR [ rd ] = ra + rb + XER < 29..29 >; // ? is this a overflow
                  XER < 29..29 > = OF_BIT;

            }

op add_extend_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "adde. %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00100010101", rd, ra.image, rb.image )
   action = {

                  OF_BIT :: GPR [ rd ] = ra + rb + XER < 29..29 >; // ? is this a overflow
                  XER < 29..29 > = OF_BIT;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

op add_extend_overflow ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "addeo %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10100010100", rd, ra.image, rb.image )
   action = {

               //if FPSCR < 6..6 > then
                  OF_BIT :: GPR [ rd ] = ra + rb + XER < 29..29 >; // ? is this a overflow
                  XER < 29..29 > = OF_BIT;

						if OF_BIT & GPR [rd] < 31..31 > then
							XER < 30..30 > = 1;
						endif;

                  if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;

            }

op add_extd_overflow_cr_upd ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "addeo. %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10100010101", rd, ra.image, rb.image )
   action = {

               //if FPSCR < 6..6 > then
                  OF_BIT :: GPR [ rd ] = ra + rb + XER < 29..29 >; // ? is this a overflow
                  XER < 29..29 > = OF_BIT;

						if OF_BIT & GPR [rd] < 31..31 > then
							XER < 30..30 > = 1;
						endif;

                  if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// Add minus one Instructions

op add_mone_extended =   add_me
                       | add_me_cr_update
                       | add_me_overflow
                       | add_me_overflow_cr_update

op add_me ( rd : index, ra : REG_IND)
   uses   = int_unit #{1} 
   syntax = format ( "addme %d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000000111010100", rd, ra.image )
   action = {
            
                  OF_BIT :: GPR [ rd ] = ra + 0xffffffff + XER < 29..29 >; 
                  XER < 29..29 > = OF_BIT;

            }

op add_me_cr_update ( rd : index, ra : REG_IND)
   uses   = int_unit #{1} 
   syntax = format ( "addme. %d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000000111010101", rd, ra.image )
   action = {
            
                  OF_BIT :: GPR [ rd ] = ra + 0xffffffff + XER < 29..29 >; 
                  XER < 29..29 > = OF_BIT;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

op add_me_overflow ( rd : index, ra : REG_IND)
   uses   = int_unit #{1} 
   syntax = format ( "addmeo %d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000010111010100", rd, ra.image )
   action = {
            
               //if FPSCR < 6..6 > then
                  OF_BIT :: GPR [ rd ] = ra + 0xffffffff + XER < 29..29 >; 
                  XER < 29..29 > = OF_BIT;

                  if OF_BIT ^ GPR [rd] < 31..31 > then
                     XER < 30..30 > = 1;
                  endif;
						if XER < 30..30 > then
							XER < 31..31 > = 1;
						endif;

            }

op add_me_overflow_cr_update ( rd : index, ra : REG_IND)
   uses   = int_unit #{1} 
   syntax = format ( "addmeo. %d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000010111010101", rd, ra.image )
   action = {
            

               //if FPSCR < 6..6 > then
                  OF_BIT :: GPR [ rd ] = ra + 0xffffffff + XER < 29..29 >; 
                  XER < 29..29 > = OF_BIT;

                  if OF_BIT ^ GPR [rd] < 31..31 > then
                     XER < 30..30 > = 1;
                  endif;
						if XER < 30..30 > then
							XER < 31..31 > = 1;
						endif;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// Add zero extended Instructions

op add_zero_extended =   add_ze
                       | add_ze_cr_update
                       | add_ze_overflow
                       | add_ze_overflow_cr_update

op add_ze ( rd : index, ra : REG_IND)
   uses   = int_unit #{1} 
   syntax = format ( "addze %d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000000110010100", rd, ra.image )
   action = {
            
                  OF_BIT :: GPR [ rd ] = ra + XER < 29..29 >; 
                  XER < 29..29 > = OF_BIT;

            }

op add_ze_cr_update ( rd : index, ra : REG_IND)
   uses   = int_unit #{1} 
   syntax = format ( "addze. %d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000000110010101", rd, ra.image )
   action = {
            
                  OF_BIT :: GPR [ rd ] = ra + XER < 29..29 >; 
                  XER < 29..29 > = OF_BIT;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

op add_ze_overflow ( rd : index, ra : REG_IND)
   uses   = int_unit #{1} 
   syntax = format ( "addzeo %d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000010110010100", rd, ra.image )
   action = {
            
               //if FPSCR < 6..6 > then
                  OF_BIT :: GPR [ rd ] = ra + XER < 29..29 >; 
                  XER < 29..29 > = OF_BIT;

                  if OF_BIT ^ GPR [rd] < 31..31 > then
                     XER < 30..30 > = 1;
                  endif;
					
						if XER < 30..30 > then
							XER < 31..31 > = 1;
               	endif;

            }

op add_ze_overflow_cr_update ( rd : index, ra : REG_IND)
   uses   = int_unit #{1} 
   syntax = format ( "addzeo. %d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000010110010101", rd, ra.image )
   action = {
            

               //if FPSCR < 6..6 > then
                  OF_BIT :: GPR [ rd ] = ra + XER < 29..29 >; 
                  XER < 29..29 > = OF_BIT;

                  if OF_BIT ^ GPR [rd] < 31..31 > then
                     XER < 30..30 > = 1;
                  endif;
					
						if XER < 30..30 > then
							XER < 31..31 > = 1;
               	endif;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// Integer Subtract Instructions

op int_subtract =   sub_from
                  | sub_imm_carry_rec
                  | sub_carry
                  | sub_extended
                  | sub_mone_extended
                  | sub_zero_extended

op sub_from =   sub
              | sub_cr_update
              | sub_overflow_enable
              | sub_crup_overen

// Subtract Instructions

op sub ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "subf %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00001010000", rd, ra.image, rb.image )
   action = {

               GPR [ rd ] = ~ra + rb + 1;

            }

op sub_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "subf. %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00001010001", rd, ra.image, rb.image )
   action = {

               GPR [ rd ] = ~ra + rb + 1;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

op sub_overflow_enable ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "subfo %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10001010000", rd, ra.image, rb.image )
   action = {

               //if FPSCR < 6..6 > then

                  OF_BIT :: GPR [ rd ] = ~ra + rb + 1; // ? is this a overflow
                  if OF_BIT ^ GPR [ rd ] < 31..31 > then 
							XER < 30..30 > = 1;	
						endif;
                  if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;

            }

op sub_crup_overen ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "subfo. %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10001010001", rd, ra.image, rb.image )
   action = {

                  OF_BIT :: GPR [ rd ] = ~ra + rb + 1; // ? is this a overflow
                  if OF_BIT ^ GPR [ rd ] < 31..31 > then 
							XER < 30..30 > = 1;	
						endif;
                  if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// Subtract Immediate Instruction

op sub_imm_carry_rec ( rd : index, ra : REG_IND, imm : IMM16 )
   uses   = int_unit #{1} 
   syntax = format ( "subfic %d,%s,%s", rd, ra.syntax, imm.syntax )
   image  = format ( "001000%5b%s%s", rd, ra.image, imm.image )
   action = {
 
               OF_BIT :: GPR [ rd ] = ~ra + 1 + imm; // Set carry bit
               XER < 29..29 > = OF_BIT;

            }

// Subtract with carry Instructions

op sub_carry =   sub_carrying
               | sub_carry_cr_update
               | sub_carry_overflow
               | sub_carry_overflow_cr_update

op sub_carrying ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "subfc %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00000010000", rd, ra.image, rb.image )
   action = {
 
               OF_BIT::GPR [ rd ] = ~ra + rb + 1;
					XER <29..29> = OF_BIT;

            }

op sub_carry_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "subfc. %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00000010001", rd, ra.image, rb.image )
   action = {
 
               OF_BIT::GPR [ rd ] = ~ra + rb + 1; 
					XER <29..29> = OF_BIT;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

op sub_carry_overflow ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "subfco %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10000010000", rd, ra.image, rb.image )
   action = {
 
              // if FPSCR < 6..6 > then
                  OF_BIT :: GPR [ rd ] = ~ra + rb + 1; // ? is this a overflow
                  XER < 29..29 > = OF_BIT;
						if OF_BIT ^ GPR [rd] < 31..31> then
							XER < 30..30 > = 1;
						endif;
                  if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;

            }

op sub_carry_overflow_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "subfco. %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10000010001", rd, ra.image, rb.image )
   action = {
 
                  OF_BIT :: GPR [ rd ] = ~ra + rb + 1; // ? is this a overflow
                  XER < 29..29 > = OF_BIT;
						if OF_BIT ^ GPR [rd] < 31..31> then
							XER < 30..30 > = 1;
						endif;
                  if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// Subtract extended Instructions

op sub_extended =   sub_extend
                  | sub_extend_cr_update
                  | sub_extend_overflow
                  | sub_extd_overflow_cr_upd

op sub_extend ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "subfe %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00100010000", rd, ra.image, rb.image )
   action = {

               OF_BIT::GPR [ rd ] = ~ra + rb + XER < 29..29 >;
					XER < 29..29 > = OF_BIT;

            }

op sub_extend_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "subfe. %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00100010001", rd, ra.image, rb.image )
   action = {

               OF_BIT::GPR [ rd ] = ~ra + rb + XER < 29..29 >;
					XER < 29..29 > = OF_BIT;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

op sub_extend_overflow ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "subfeo %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10100010000", rd, ra.image, rb.image )
   action = {

               //if FPSCR < 6..6 > then
                  OF_BIT :: GPR [ rd ] = ~ra + rb + XER < 29..29 >; 
						XER < 29..29 > = OF_BIT;

                  if OF_BIT ^ GPR [rd] < 31..31 > then
                  	XER < 30..30 > = OF_BIT;
						endif;

						if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;

            }

op sub_extd_overflow_cr_upd ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "subfeo. %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10100010001", rd, ra.image, rb.image )
   action = {

                  OF_BIT :: GPR [ rd ] = ~ra + rb + XER < 29..29 >; 
						XER < 29..29 > = OF_BIT;

                  if OF_BIT ^ GPR [rd] < 31..31 > then
                  	XER < 30..30 > = OF_BIT;
						endif;

						if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// Subtract minus one Instructions

op sub_mone_extended =   sub_me
                       | sub_me_cr_update
                       | sub_me_overflow
                       | sub_me_overflow_cr_update

op sub_me ( rd : index, ra : REG_IND)
   uses   = int_unit #{1} 
   syntax = format ( "subfme %d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000000111010000", rd, ra.image )
   action = {
            
               OF_BIT::GPR [ rd ] = ~ra + XER < 29..29 > + 0xffffffff;
					XER < 29..29 > = OF_BIT;

            }

op sub_me_cr_update ( rd : index, ra : REG_IND)
   uses   = int_unit #{1} 
   syntax = format ( "subfme. %d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000000111010001", rd, ra.image )
   action = {
            
               OF_BIT::GPR [ rd ] = ~ra + XER < 29..29 > + 0xffffffff;
					XER < 29..29 > = OF_BIT;


					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

op sub_me_overflow ( rd : index, ra : REG_IND)
   uses   = int_unit #{1} 
   syntax = format ( "subfmeo %d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000010111010000", rd, ra.image )
   action = {
            
               OF_BIT::GPR [ rd ] = ~ra + XER < 29..29 > + 0xffffffff;
					XER < 29..29 > = OF_BIT;

                  if OF_BIT ^ GPR [rd] < 31..31 > then
                  	XER < 30..30 > = OF_BIT;
						endif;

						if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;


            }

op sub_me_overflow_cr_update ( rd : index, ra : REG_IND)
   uses   = int_unit #{1} 
   syntax = format ( "subfmeo. %d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000010111010001", rd, ra.image )
   action = {
            
               OF_BIT::GPR [ rd ] = ~ra + XER < 29..29 > + 0xffffffff;
					XER < 29..29 > = OF_BIT;

                  if OF_BIT ^ GPR [rd] < 31..31 > then
                  	XER < 30..30 > = OF_BIT;
						endif;

						if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// Subtract zero extended Instructions

op sub_zero_extended =   sub_ze
                       | sub_ze_cr_update
                       | sub_ze_overflow
                       | sub_ze_overflow_cr_update

op sub_ze ( rd : index, ra : REG_IND)
   uses   = int_unit #{1} 
   syntax = format ( "subfze %d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000000110010000", rd, ra.image )
   action = {
            
               OF_BIT::GPR [ rd ] = ~ra + XER < 29..29 >;
					XER < 29..29 > = OF_BIT;
            }

op sub_ze_cr_update ( rd : index, ra : REG_IND)
   uses   = int_unit #{1} 
   syntax = format ( "subfze. %d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000000110010001", rd, ra.image )
   action = {
            
               OF_BIT::GPR [ rd ] = ~ra + XER < 29..29 >;
					XER < 29..29 > = OF_BIT;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

op sub_ze_overflow ( rd : index, ra : REG_IND)
   uses   = int_unit #{1} 
   syntax = format ( "subfzeo %d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000010110010000", rd, ra.image )
   action = {
            
               OF_BIT::GPR [ rd ] = ~ra + XER < 29..29 >;
					XER < 29..29 > = OF_BIT;

                  if OF_BIT ^ GPR [rd] < 31..31 > then
                  	XER < 30..30 > = OF_BIT;
						endif;

						if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;
            }

op sub_ze_overflow_cr_update ( rd : index, ra : REG_IND)
   uses   = int_unit #{1} 
   syntax = format ( "subfzeo. %d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000010110010001", rd, ra.image )
   action = {
            

               OF_BIT::GPR [ rd ] = ~ra + XER < 29..29 >;
					XER < 29..29 > = OF_BIT;

                  if OF_BIT ^ GPR [rd] < 31..31 > then
                  	XER < 30..30 > = OF_BIT;
						endif;

						if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// Integer Multiply Instructions

op int_multiply =   mult_low
                  | mult_low_imm
                  | mult_high
                  | mult_high_unsig

// Multiply Low Instructions

op mult_low =   mult_lw
              | mult_lw_cr_update
              | mult_lw_overflow
              | mult_lw_overflow_cr_upd

op mult_lw ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "mullw %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00111010110", rd, ra.image, rb.image )
   action = {
   
               GPR [ rd ] = ra * rb;

            } 

op mult_lw_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "mullw. %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00111010111", rd, ra.image, rb.image )
   action = {
      
               GPR [ rd ] = ra * rb;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

op mult_lw_overflow ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "mullwo %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10111010110", rd, ra.image, rb.image )
   action = {

               if FPSCR < 6..6 > then
                  OF_BIT :: GPR [ rd ] = ra * rb; // ? is this a overflow
                  XER < 30..30 > = OF_BIT;

       // How do I set carry bit here

                  if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;
               else
                  GPR [ rd ] = ra * rb;
               endif;

            }

op mult_lw_overflow_cr_upd ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "mullwo. %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s10111010111", rd, ra.image, rb.image )
   action = {

               if FPSCR < 6..6 > then
                  OF_BIT :: GPR [ rd ] = ra * rb; // ? is this a overflow
                  XER < 30..30 > = OF_BIT;

       // How do I set carry bit here

                  if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;
               else
                  GPR [ rd ] = ra * rb;
               endif;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// Multiply Low Immediate

op mult_low_imm ( rd : index, ra : REG_IND, imm : IMM16 )
   uses   = int_unit #{1} 
   syntax = format ( "mulli %d,%s,%s", rd, ra.syntax, imm.syntax )
   image  = format ( "000111%5b%s%s", rd, ra.image, imm.image )
   action = {

               GPR [ rd ] = ra * imm;

            }

// Multiply High Word

op mult_high =   mult_hi
               | mult_hi_cr_update

op mult_hi ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "mulhw %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00010010110", rd, ra.image, rb.image )
   action = {

					// Added BY Surendra TMP_DWORD changed to TMP_SDWORD
               TMP_SDWORD = ra * rb;
               GPR [ rd ] = TMP_SDWORD < 63..32 >;

            } 

op mult_hi_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "mulhw. %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00010010111", rd, ra.image, rb.image )
   action = {

               TMP_SDWORD = ra * rb;

               GPR [ rd ] = TMP_SDWORD < 63..32 >;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            } 

// Multiply High word unsigned

op mult_high_unsig =   mult_hi_us
                     | mult_hi_us_cr_update

op mult_hi_us ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "mulhwu %d,%s,%s", rd , ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00000010110", rd, ra.image, rb.image)
   action = {

               TMP_DWORD = coerce ( card ( 32 ) , ra ) * coerce ( card ( 32 ) , rb );

               GPR [ rd ] = TMP_DWORD < 63..32 >;

            }
// Added by Surendra No CR update
op mult_hi_us_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "mulhwu. %d,%s,%s", rd , ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s00000010111", rd, ra.image, rb.image)
   action = {

               TMP_DWORD = coerce ( card ( 32 ) , ra ) * coerce ( card ( 32 ) , rb );

               GPR [ rd ] = TMP_DWORD < 63..32 >;

					 // Added by Surendra
               CR < 31..29 > = 0;
               //
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;


            }

// Integer Divide Instructions

op int_divide =   div_word
                | div_word_unsig

op div_word =   divw
              | divw_cr_update
              | divw_overflow
              | divw_overflow_cr_upd

op divw ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{37} 
   syntax = format ( "divw %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s01111010110", rd, ra.image, rb.image )
   action = {

               GPR [ rd ] = ra / rb;

            }

op divw_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{37} 
   syntax = format ( "divw. %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s01111010111", rd, ra.image, rb.image )
   action = {

               GPR [ rd ] = ra / rb;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

op divw_overflow ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{37} 
   syntax = format ( "divwo %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s11111010110", rd, ra.image, rb.image )
   action = {

               if FPSCR < 6..6 > then
                  OF_BIT :: GPR [ rd ] = ra / rb; // ? is this a overflow
                  XER < 30..30 > = OF_BIT;

       // How do I set carry bit here

                  if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;
               else
                  GPR [ rd ] = ra / rb;
               endif;

            }

op divw_overflow_cr_upd ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{37} 
   syntax = format ( "divwo. %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s11111010111", rd, ra.image, rb.image )
   action = {

               if FPSCR < 6..6 > then
                  OF_BIT :: GPR [ rd ] = ra / rb; // ? is this a overflow
                  XER < 30..30 > = OF_BIT;

       // How do I set carry bit here

                  if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;
               else
                  GPR [ rd ] = ra / rb;
               endif;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// Divide word unsigned

op div_word_unsig =   divwus
                    | divwus_cr_update
                    | divwus_overflow
                    | divwus_overflow_cr_upd

 
op divwus ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{37} 
   syntax = format ( "divwu %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s01110010110", rd, ra.image, rb.image )
   action = {

               GPR [ rd ] = coerce ( card ( 32 ) , ra ) / coerce ( card ( 32 ) , rb );

            }

op divwus_cr_update ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{37} 
   syntax = format ( "divwu. %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s01110010111", rd, ra.image, rb.image )
   action = {

               GPR [ rd ] = coerce ( card ( 32 ) , ra ) / coerce ( card ( 32 ) , rb );

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

op divwus_overflow ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{37} 
   syntax = format ( "divwuo %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s11110010110", rd, ra.image, rb.image )
   action = {

               if FPSCR < 6..6 > then
                  OF_BIT :: GPR [ rd ] = 
                      coerce ( card ( 32 ) , ra ) / coerce ( card ( 32 ) , rb ); // ? is this a overflow
                  XER < 30..30 > = OF_BIT;

       // How do I set carry bit here

                  if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;
               else
                  GPR [ rd ] = coerce ( card ( 32 ) , ra ) / coerce ( card ( 32 ) , rb );
               endif;

            }

op divwus_overflow_cr_upd ( rd : index, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{37} 
   syntax = format ( "divwuo. %d,%s,%s", rd, ra.syntax, rb.syntax )
   image  = format ( "011111%5b%s%s11110010111", rd, ra.image, rb.image )
   action = {

               if FPSCR < 6..6 > then
                  OF_BIT :: GPR [ rd ] = 
                      coerce ( card ( 32 ) , ra ) / coerce ( card ( 32 ) , rb ); // ? is this a overflow
                  XER < 30..30 > = OF_BIT;

       // How do I set carry bit here

                  if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;
               else
                  GPR [ rd ] = coerce ( card ( 32 ) , ra ) / coerce ( card ( 32 ) , rb );
               endif;

               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// Integer Negate Instructions

op int_negate =   neg
                | neg_cr_update
                | neg_overflow
                | neg_overflow_cr_upd

op neg ( rd : index, ra : REG_IND)
   uses   = int_unit #{1} 
   syntax = format ( "neg %d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000000011010000", rd, ra.image )
   action = {

               GPR [ rd ] = ~ra + 1;

            }

op neg_cr_update ( rd : index, ra : REG_IND)
   uses   = int_unit #{1} 
   syntax = format ( "neg. %d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000000011010001", rd, ra.image )
   action = {

               GPR [ rd ] = ~ra + 1;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

op neg_overflow ( rd : index, ra : REG_IND)
   uses   = int_unit #{1} 
   syntax = format ( "nego %d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000010011010000", rd, ra.image )
   action = {

               if FPSCR < 6..6 > then
                  OF_BIT :: GPR [ rd ] = ~ra + 1; // ? is this a overflow
                  XER < 30..30 > = OF_BIT;

       // How do I set carry bit here

                  if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;
               else
                  GPR [ rd ] = ~ra + 1;
               endif;

            }

op neg_overflow_cr_upd ( rd : index, ra : REG_IND)
   uses   = int_unit #{1} 
   syntax = format ( "nego. %d,%s", rd, ra.syntax )
   image  = format ( "011111%5b%s0000010011010001", rd, ra.image )
   action = {

               if FPSCR < 6..6 > then
                  OF_BIT :: GPR [ rd ] = ~ra + 1; // ? is this a overflow
                  XER < 30..30 > = OF_BIT;

       // How do I set carry bit here

                  if XER < 30..30 > then
                     XER < 31..31 > = 1;
                  endif;
               else
                  GPR [ rd ] = ra + 1;
               endif;

               if GPR [ rd ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ rd ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// Integer Compare Instructions

op int_compare =   cmp_imm
                 | cmp
                 | cmp_log_imm
                 | cmp_log

op cmp_imm ( crfd : card ( 3 ), l : bit, ra : REG_IND, imm : IMM16 )
   uses   = int_unit #{1} 
   syntax = format ( "cmpi %d,%d,%s,%s", crfd, l, ra.syntax, imm.syntax )
   image  = format ( "001011%3b0%1b%s%s", crfd, l, ra.image, imm.image )
   action = {

               if ra < imm then
                  TMP_BYTE = 0b100;
               else
                  if ra > imm then
                     TMP_BYTE = 0b010;
                  else
                     TMP_BYTE = 0b001;
                  endif;
               endif;

               TMP_BYTE = TMP_BYTE << 1; 

               if XER < 31..31 > then
                  TMP_BYTE = TMP_BYTE | 0x01;
               endif;

               CR < (31-(4*crfd))..(31-(4*crfd)-3) > = TMP_BYTE & 0x0f;

            }

op cmp ( crfd : card ( 3 ), l : bit, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "cmp %d,%d,%s,%s", crfd, l, ra.syntax, rb.syntax )
   image  = format ( "011111%3b0%1b%s%s00000000000", crfd, l, ra.image, rb.image)
   action = {

               if ra < rb then
                  TMP_BYTE = 0b100;
               else
                  if ra > rb then
                     TMP_BYTE = 0b010;
                  else
                     TMP_BYTE = 0b001;
                  endif;
               endif;

               TMP_BYTE = TMP_BYTE << 1;

               if XER < 31..31 > then
                  TMP_BYTE = TMP_BYTE | 0x01;
               endif;

               CR < (31-(4*crfd))..(31-(4*crfd)-3) > = TMP_BYTE & 0x0f;

            }


op cmp_log_imm ( crfd : card ( 3 ), l : bit, ra : REG_IND, imm : UIMM16 )
   uses   = int_unit #{1} 
   syntax = format ( "cmpli %d,%d,%s,%s", crfd, l, ra.syntax, imm.syntax )
   image  = format ( "001010%3b0%1b%s%s", crfd, l, ra.image, imm.image )
   action = {

               TMP_WORD = imm;
               if coerce ( card ( 32 ) , ra ) < ( TMP_WORD ) then
                  TMP_BYTE = 0b100;
               else
                  if coerce ( card ( 32 ) , ra ) > ( TMP_WORD ) then
                     TMP_BYTE = 0b010;
                  else
                     TMP_BYTE = 0b001;
                  endif;
               endif;

               TMP_BYTE = TMP_BYTE << 1;

               if XER < 31..31 > then
                  TMP_BYTE = TMP_BYTE | 0x01;
               endif;

               CR < (31-(4*crfd))..(31-(4*crfd)-3) > = TMP_BYTE & 0x0f;

            }

op cmp_log ( crfd : card ( 3 ), l : bit, ra : REG_IND, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "cmpl %d,%d,%s,%s", crfd, l, ra.syntax, rb.syntax )
   image  = format ( "011111%3b0%1b%s%s00001000000", crfd, l, ra.image, rb.image)
   action = {

               if coerce ( card ( 32 ) , ra ) < coerce ( card ( 32 ) , rb ) then
                  TMP_BYTE = 0b100;
               else
                  if coerce ( card ( 32 ) , ra ) > coerce ( card ( 32 ) , rb ) then
                     TMP_BYTE = 0b010;
                  else
                     TMP_BYTE = 0b001;
                  endif;
               endif;

               TMP_BYTE = TMP_BYTE << 1;

               if XER < 31..31 > then
                  TMP_BYTE = TMP_BYTE | 0x01;
               endif;

               CR < (31-(4*crfd))..(31-(4*crfd)-3) > = TMP_BYTE & 0x0f;

            }

// Integer Logical Instructions

op int_logical =   or_instr
                 | and_instr
                 | xor_instr
                 | nor_instr
                 | nand_instr
                 | equivalent_instr
                 | extended_sign_instr
                 | count_lead_zeros_instr

// OR Instructions

op or_instr =   simple_or
              | or_imm
              | or_imm_shift
              | or_comp
   
op simple_or =  or
              | or_cr_update

op or ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "or %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s01101111000", rs.image, ra, rb.image )
   action = {

               GPR [ ra ] = rs | rb;

            }   

op or_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "or. %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s01101111001", rs.image, ra, rb.image )
   action = {

               GPR [ ra ] = rs | rb;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ ra ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ ra ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }   

op or_imm ( rs : REG_IND, ra : index, imm : UIMM16 )
   uses   = int_unit #{1} 
   syntax = format ( "ori %d,%s,%s", ra, rs.syntax, imm.syntax )
   image  = format ( "011000%s%5b%s", rs.image, ra, imm.image )
   action = {

               TMP_WORD = imm;
               TMP_WORD = TMP_WORD & 0x0000ffff;
               GPR [ ra ] = rs | TMP_WORD;

            }

op or_imm_shift ( rs : REG_IND, ra : index, imm : UIMM16 )
   uses   = int_unit #{1} 
   syntax = format ( "oris %d,%s,%s", ra, rs.syntax, imm.syntax )
   image  = format ( "011001%s%5b%s", rs.image, ra, imm.image )
   action = {

               TMP_WORD = imm;
               TMP_WORD = TMP_WORD << 16;
               GPR [ ra ] = rs | TMP_WORD;

            }

op or_comp =   orc
             | orc_cr_update

op orc ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "orc %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s01100111000", rs.image, ra, rb.image )
   action = {

               GPR [ ra ] = rs | ( ~rb );

            }

op orc_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "orc. %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s01100111001", rs.image, ra, rb.image )
   action = {

               GPR [ ra ] = rs | ( ~rb );

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ ra ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ ra ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// AND Instructions

op and_instr =   simple_and
               | and_imm
               | and_imm_shift
               | and_comp

op simple_and =   and
                | and_cr_update

op and ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "and %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s00000111000", rs.image, ra, rb.image )
   action = {

               GPR [ ra ] = rs & rb;

            }

op and_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "and. %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s00000111001", rs.image, ra, rb.image )
   action = {

               GPR [ ra ] = rs & rb;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ ra ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ ra ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

op and_imm ( rs : REG_IND, ra : index, imm : UIMM16 )
   uses   = int_unit #{1} 
   syntax = format ( "andi. %d,%s,%s", ra, rs.syntax, imm.syntax )
   image  = format ( "011100%s%5b%s", rs.image, ra, imm.image )
   action = {

               TMP_WORD = imm;
               TMP_WORD = TMP_WORD & 0x0000ffff;

               GPR [ ra ] = rs & TMP_WORD;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ ra ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ ra ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

op and_imm_shift ( rs : REG_IND, ra : index, imm : UIMM16 )
   uses   = int_unit #{1} 
   syntax = format ( "andis. %d,%s,%s", ra, rs.syntax, imm.syntax )
   image  = format ( "011101%s%5b%s", rs.image, ra, imm.image )
   action = {

               TMP_WORD = imm;
               TMP_WORD = TMP_WORD & 0x0000ffff;
			   TMP_WORD = TMP_WORD << 16;

               GPR [ ra ] = rs & TMP_WORD;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ ra ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ ra ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }


op and_comp =   andc
              | andc_cr_update 

op andc ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "andc %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s00001111000", rs.image, ra, rb.image )
   action = {

               GPR [ ra ] = rs & ( ~rb );

            }

op andc_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "andc. %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s00001111001", rs.image, ra, rb.image )
   action = {

               GPR [ ra ] = rs & ( ~rb );

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ ra ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ ra ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// XOR Instructions

op xor_instr =   simple_xor
               | xor_imm
               | xor_imm_shift

op simple_xor =   xor
                | xor_cr_update

op xor ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "xor %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s01001111000", rs.image, ra, rb.image )
   action = {

               GPR [ ra ] = rs ^ rb;

            }

op xor_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "xor. %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s01001111001", rs.image, ra, rb.image )
   action = {

               GPR [ ra ] = rs ^ rb;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ ra ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ ra ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

op xor_imm ( rs : REG_IND, ra : index, imm : UIMM16 )
   uses   = int_unit #{1} 
   syntax = format ( "xori %d,%s,%s", ra, rs.syntax, imm.syntax )
   image  = format ( "011010%s%5b%s", rs.image, ra, imm.image )
   action = {

               TMP_WORD = imm;
               TMP_WORD = TMP_WORD & 0x0000ffff;

               GPR [ ra ] = rs ^ TMP_WORD;

            }

op xor_imm_shift ( rs : REG_IND, ra : index, imm : UIMM16 )
   uses   = int_unit #{1} 
   syntax = format ( "xoris %d,%s,%s", ra, rs.syntax, imm.syntax )
   image  = format ( "011011%s%5b%s", rs.image, ra, imm.image )
   action = {

               TMP_WORD = imm;
               TMP_WORD = TMP_WORD << 16;
               GPR [ ra ] = rs ^ TMP_WORD;

            }

// NOR Instructions

op nor_instr =   nor
               | nor_cr_update

op nor ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "nor %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s00011111000", rs.image, ra, rb.image )
   action = {

               GPR [ ra ] = ~( rs | rb );

            }

op nor_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "nor. %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s00011111001", rs.image, ra, rb.image )
   action = {

               GPR [ ra ] = ~( rs | rb );

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ ra ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ ra ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// NAND Instructions

op nand_instr =   nand
                | nand_cr_update

op nand ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "nand %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s01110111000", rs.image, ra, rb.image )
   action = {

               GPR [ ra ] = ~( rs & rb );

            }

op nand_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "nand. %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s01110111001", rs.image, ra, rb.image )
   action = {

               GPR [ ra ] = ~( rs & rb );

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ ra ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ ra ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// Equivalent Instructions

op equivalent_instr =   eqv
                      | eqv_cr_update


op eqv ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "eqv %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s01000111000", rs.image, ra, rb.image )
   action = {

               GPR [ ra ] = ~( rs ^ rb );

            }

op eqv_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "eqv. %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s01000111001", rs.image, ra, rb.image )
   action = {

               GPR [ ra ] = ~( rs ^ rb );

					// Added by Surendra
					CR < 29..31 > = 0;
					//
               if GPR [ ra ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ ra ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// Extended sign Instructions

op extended_sign_instr =   ext_sign_byte
                         | ext_sign_hword

op ext_sign_byte =   extsb
                   | extsb_cr_update

op extsb ( rs : index, ra : index )
   uses   = int_unit #{1} 
   syntax = format ( "extsb %d,%d", ra, rs )
   image  = format ( "011111%5b%5b0000011101110100", rs, ra )
   action = {

               TMP_SBYTE = GPR [ rs ] < 7..0 >;
               GPR [ ra ] = TMP_SBYTE;

            }

op extsb_cr_update ( rs : index, ra : index )
   uses   = int_unit #{1} 
   syntax = format ( "extsb. %d,%d", ra, rs )
   image  = format ( "011111%5b%5b0000011101110101", rs, ra )
   action = {

               TMP_SBYTE = GPR [ rs ] < 7..0 >;
               GPR [ ra ] = TMP_SBYTE;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ ra ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ ra ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

op ext_sign_hword =   extsh
                    | extsh_cr_update

op extsh ( rs : index, ra : index )
   uses   = int_unit #{1} 
   syntax = format ( "extsh %d,%d", ra, rs )
   image  = format ( "011111%5b%5b0000011100110100", rs, ra )
   action = {

               TMP_SHWORD = GPR [ rs ] < 15..0 >;
               GPR [ ra ] = TMP_SHWORD;

            }

op extsh_cr_update ( rs : index, ra : index )
   uses   = int_unit #{1} 
   syntax = format ( "extsh. %d,%d", ra, rs )
   image  = format ( "011111%5b%5b0000011100110101", rs,ra )
   action = {

               TMP_SHWORD = GPR [ rs ] < 15..0 >;
               GPR [ ra ] = TMP_SHWORD;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ ra ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ ra ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// Count Leading zeros Instruction

op count_lead_zeros_instr =   cntlzw
                            | cntlzw_cr_update

op cntlzw ( rs : REG_IND, ra : index )
   uses   = int_unit #{1}
   syntax = format ( "cntlzw %d, %s", ra, rs.syntax )
   image  = format ( "011111%s%5b0000000000110100", rs.image, ra )
   action = {
               TMP_SBYTE = 31;
               loop;
            }
   loop   = {
               if TMP_SBYTE >= 0 then
                  if !rs <TMP_SBYTE..TMP_SBYTE> then
                     TMP_SBYTE = TMP_SBYTE - 1;
                  else
                     GPR [ ra ] = 31 - TMP_SBYTE;
                     TMP_SBYTE = -1;
                  endif;
                  loop;
               endif;
             }
                
op cntlzw_cr_update ( rs : REG_IND, ra : index )
   uses   = int_unit #{1}
   syntax = format ( "cntlzw. %d, %s", ra, rs.syntax )
   image  = format ( "011111%s%5b0000000000110101", rs.image, ra )
   action = {
               TMP_SBYTE = 31;
               loop;
            }
   loop   = {
               if TMP_SBYTE >= 0 then
                  if !rs <TMP_SBYTE..TMP_SBYTE> then
                     TMP_SBYTE = TMP_SBYTE - 1;
                  else
                     GPR [ ra ] = 31 - TMP_SBYTE;
                     TMP_SBYTE = -1;
                  endif;
                  loop;
					// Added by Surendra
					else
					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ ra ] < 31..31 > then
                  CR < 31..31 > = 0;
               else
                  if GPR [ ra ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;
               endif;
             }


// Integer Rotate and shift Instructions

op int_rotate_shift =   int_rotate
                      | int_shift

// Roatate Instructions

op int_rotate =   rot_lw_imm_and_mask
                | rot_lw_and_mask
                | rot_lw_imm_mask_ins

op rot_lw_imm_and_mask =   rlwinm
                         | rlwinm_cr_update

op rlwinm ( rs : REG_IND, ra : index, sh : index, mb : index, me : index )
   uses   = int_unit #{1} 
   syntax = format ( "rlwinm %d,%s,%d,%d,%d", ra, rs.syntax, sh, mb, me )
   image  = format ( "010101%s%5b%5b%5b%5b0", rs.image, ra, sh, mb, me )
   action = {

               // TMP_WORD = 0;
               // TMP_WORD < (31-me)..(31-mb) > = ~TMP_WORD < (31-me)..(31-mb) >;
               // Changed by Surendra
					TMP_WORD = (( 1 << (31-mb) ) - ( 1 << (31-me))) | (1 << (31-mb));
               GPR [ ra ] = ( ( rs <<< sh ) & TMP_WORD );

            }  

op rlwinm_cr_update ( rs : REG_IND, ra : index, sh : index, mb : index, me : index )
   uses   = int_unit #{1} 
   syntax = format ( "rlwinm. %d,%s,%d,%d,%d", ra, rs.syntax, sh, mb, me )
   image  = format ( "010101%s%5b%5b%5b%5b1", rs.image, ra, sh, mb, me )
   action = {

               // TMP_WORD = 0;
               // TMP_WORD < (31-me)..(31-mb) > = ~TMP_WORD < (31-me)..(31-mb) >;
               // Changed by Surendra
					TMP_WORD = (( 1 << (31-mb) ) - ( 1 << (31-me))) | (1 << (31-mb));
               
               GPR [ ra ] = ( ( rs <<< sh ) & TMP_WORD );
					// Added by Surendra
					CR < 31..29 > = 0;
					//

               if GPR [ ra ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ ra ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }  

op rot_lw_and_mask =   rlwnm
                     | rlwnm_cr_update

op rlwnm ( rs : REG_IND, ra : index, rb : index, mb : index, me : index )
   uses   = int_unit #{1} 
   syntax = format ( "rlwnm %d,%s,%d,%d,%d", ra, rs.syntax, rb, mb, me )
   image  = format ( "010111%s%5b%5b%5b%5b0", rs.image, ra, rb, mb, me )
   action = {

               // TMP_WORD = 0;
               // TMP_WORD < (31-me)..(31-mb) > = ~TMP_WORD < (31-me)..(31-mb) >;
               // Changed by Surendra
					TMP_WORD = (( 1 << (31-mb) ) - ( 1 << (31-me))) | (1 << (31-mb));
               
               GPR [ ra ] = ( ( rs <<< coerce ( card ( 5 ), GPR [ rb ] < 4..0 > ) ) & TMP_WORD );

            }  

op rlwnm_cr_update ( rs : REG_IND, ra : index, rb : index, mb : index, me : index )
   uses   = int_unit #{1} 
   syntax = format ( "rlwnm. %d,%s,%d,%d,%d", ra, rs.syntax, rb, mb, me )
   image  = format ( "010111%s%5b%5b%5b%5b1", rs.image, ra, rb, mb, me )
   action = {

               // TMP_WORD = 0;
               // TMP_WORD < (31-me)..(31-mb) > = ~TMP_WORD < (31-me)..(31-mb) >;
               // Changed by Surendra
					TMP_WORD = (( 1 << (31-mb) ) - ( 1 << (31-me))) | (1 << (31-mb));
               
               GPR [ ra ] = ( ( rs <<< coerce ( card ( 5 ), GPR [ rb ] < 4..0 > ) ) & TMP_WORD );

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ ra ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ ra ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }  

op rot_lw_imm_mask_ins =   rlwimi
                         | rlwimi_cr_update

op rlwimi ( rs : REG_IND, ra : index, sh : index, mb : index, me : index )
   uses   = int_unit #{1} 
   syntax = format ( "rlwimi %d,%s,%d,%d,%d", ra, rs.syntax, sh, mb, me )
   image  = format ( "010100%s%5b%5b%5b%5b0", rs.image, ra, sh, mb, me )
   action = {

               // TMP_WORD = 0;
               // TMP_WORD < (31-me)..(31-mb) > = ~TMP_WORD < (31-me)..(31-mb) >;
               // Changed by Surendra
					TMP_WORD = (( 1 << (31-mb) ) - ( 1 << (31-me))) | (1 << (31-mb));
               
               GPR [ ra ] = ( ( rs <<< sh ) & TMP_WORD ) | ( GPR [ ra ] & ~TMP_WORD );

            }  

op rlwimi_cr_update ( rs : REG_IND, ra : index, sh : index, mb : index, me : index )
   uses   = int_unit #{1} 
   syntax = format ( "rlwimi. %d,%s,%d,%d,%d", ra, rs.syntax, sh, mb, me )
   image  = format ( "010100%s%5b%5b%5b%5b1", rs.image, ra, sh, mb, me )
   action = {

               // TMP_WORD = 0;
               // TMP_WORD < (31-me)..(31-mb) > = ~TMP_WORD < (31-me)..(31-mb) >;
               // Changed by Surendra
					TMP_WORD = (( 1 << (31-mb) ) - ( 1 << (31-me))) | (1 << (31-mb));
               
               GPR [ ra ] = ( ( rs <<< sh ) & TMP_WORD ) | ( GPR [ ra ] & ~TMP_WORD );

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ ra ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ ra ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }  

// Shift Instructions

op int_shift =   shift_left_word
               | shift_right_word
               | shift_right_alg_wimm
               | shift_right_alg_w

op shift_left_word =   slw
                     | slw_cr_update

op slw ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "slw %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s00000110000", rs.image, ra, rb.image )
   action = {

					// Changed by Surendra 5 to 15
               if ~rb < 15..15 > then
                  GPR [ ra ] = ( rs << coerce ( card ( 5 ), rb < 4..0 > ) ); 
               else
                  GPR [ ra ] = 0;
               endif;

            }

op slw_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "slw. %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s00000110001", rs.image, ra, rb.image )
   action = {

					// Changed by Surendra 5 to 15
               if ~rb < 15..15 > then
                  GPR [ ra ] = ( rs << coerce ( card ( 5 ), rb < 4..0 > ) ); 
               else
                  GPR [ ra ] = 0;
               endif;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ ra ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ ra ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

op shift_right_word =   srw
                      | srw_cr_update

op srw ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "srw %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s10000110000", rs.image, ra, rb.image )
   action = {

               if ~rb < 5..5 > then
                  GPR [ ra ] = ( coerce (card(32), rs) >> coerce ( card ( 5 ), rb < 4..0 > ) ); 
               else
                  GPR [ ra ] = 0;
               endif;

            }

op srw_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "srw. %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s10000110001", rs.image, ra, rb.image )
   action = {

               if ~rb < 5..5 > then
                  GPR [ ra ] = ( coerce (card(32), rs) >> coerce ( card ( 5 ), rb < 4..0 > ) ); 
               else
                  GPR [ ra ] = 0;
               endif;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ ra ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ ra ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

op shift_right_alg_wimm =   srawi
                          | srawi_cr_update

op srawi ( rs : REG_IND, ra : index, sh : index )
   uses   = int_unit #{1} 
   syntax = format ( "srawi %d,%s,%d", ra, rs.syntax, sh )
   image  = format ( "011111%s%5b%5b11001110000", rs.image, ra, sh )
   action = {

               TMP_SWORD = ( rs >> sh ); 
               GPR [ ra ] = TMP_SWORD;

					// Added by Surendra
					XER < 29..29 > = 0;
					if sh == 0 then
						XER < 29..29 > = 0;
               else 
						if rs < 0 && rs < sh..0 > then
                  	XER < 29..29 > = 1;
						endif;
               endif;

            }
               
op srawi_cr_update ( rs : REG_IND, ra : index, sh : index )
   uses   = int_unit #{1} 
   syntax = format ( "srawi. %d,%s,%d", ra, rs.syntax, sh )
   image  = format ( "011111%s%5b%5b11001110001", rs.image, ra, sh )
   action = {

               TMP_SWORD = ( rs >> sh ); // Really need this?
               GPR [ ra ] = TMP_SWORD;     

					// Added by Surendra	
						XER < 29..29 > = 0;
					if sh == 0 then
						XER < 29..29 > = 0;
               else 
						if rs < 0 && rs < sh..0 > then
                  	XER < 29..29 > = 1;
						endif;
               endif;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ ra ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ ra ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

op shift_right_alg_w =   sraw
                       | sraw_cr_update

op sraw ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "sraw %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s11000110000", rs.image, ra, rb.image )
   action = {

               if ~rb < 5..5 > then
                  TMP_SWORD = ( rs >> rb < 4..0 > );
                  GPR [ ra ] = TMP_SWORD;
               else
                  if rs < 31..31 > then
                     GPR [ ra ] = ~0;
                  else
                     GPR [ ra ] = 0;
                  endif;
               endif;

					// Added by Surendra
					TMP_BYTE = rb < 4..0 >;
					XER < 29..29 > = 0;
					if rb <4..0>  == 0 then
						XER < 29..29 > = 0;
               else 
						if rs < 0 && rs < TMP_BYTE..0 > then
                  	XER < 29..29 > = 1;
						endif;
               endif;

            }
               
op sraw_cr_update ( rs : REG_IND, ra : index, rb : REG_IND )
   uses   = int_unit #{1} 
   syntax = format ( "sraw. %d,%s,%s", ra, rs.syntax, rb.syntax )
   image  = format ( "011111%s%5b%s11000110001", rs.image, ra, rb.image )
   action = {

               if ~rb < 5..5 > then
                  TMP_SWORD = ( rs >> rb < 4..0 > );
                  GPR [ ra ] = TMP_SWORD;
               else
                  if rs < 31..31 > then
                     GPR [ ra ] = ~0;
                  else
                     GPR [ ra ] = 0;
                  endif;
               endif;

					// Added by Surendra
					TMP_BYTE = rb < 4..0 >;
					XER < 29..29 > = 0;
					if rb <4..0> == 0 then
						XER < 29..29 > = 0;
               else 
						if rs < 0 && rs < TMP_BYTE..0 > then
                  	XER < 29..29 > = 1;
						endif;
               endif;

					// Added by Surendra
					CR < 31..29 > = 0;
					//
               if GPR [ ra ] < 31..31 > then
                  CR < 31..31 > = 1;
               else
                  if GPR [ ra ] == 0 then
                     CR < 29..29 > = 1;
                  else
                     CR < 30..30 > = 1;
                  endif;
               endif;

               CR < 28..28 > = XER < 31..31 >;

            }

// Floating point Instructions

op fp_instr ( x : fp_instr_action )
   uses = { wait_id < cq_ptr } fp_unit : preact, x.uses, 
          { speculated [ fp_id ] == 0 & fp_id == CQ [ 0 ] } fp_unit
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   preact = {

               fp_id = CQ [ wait_id ];
               wait_id = wait_id + 1;

            }

op fp_instr_action =   fp_arithmetic
                     | fp_mult_add_instr
                     | fp_compare
                     | fp_move
                     | fp_round
							| fp_convert

// Floating piont arithmetic Instructions

op fp_arithmetic =   fp_add
                   | fp_subtract
                   | fp_multiply
                   | fp_divide

// Floating point add Instructions

op fp_add =   fp_add_double
            | fp_add_dbl_cr_update
            | fp_add_single
            | fp_add_sgl_cr_update

op fp_add_double ( frd : index, fra : index, frb : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fadd %d,%d,%d", frd, fra, frb )
   image  = format ( "111111%5b%5b%5b00000101010", frd, fra, frb )
   action = {

               FPR [ frd ] = FPR [ fra ] + FPR [ frb ];

            }
   
op fp_add_dbl_cr_update ( frd : index, fra : index, frb : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fadd. %d,%d,%d", frd, fra, frb )
   image  = format ( "111111%5b%5b%5b00000101011", frd, fra, frb )
   action = {

               FPR [ frd ] = FPR [ fra ] + FPR [ frb ];

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;

            }

op fp_add_single ( frd : index, fra : index, frb : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fadds %d,%d,%d", frd, fra, frb )
   image  = format ( "111011%5b%5b%5b00000101010", frd, fra, frb )
   action = {

               FPR [ frd ] = FPR [ fra ] + FPR [ frb ];

            }
   
op fp_add_sgl_cr_update ( frd : index, fra : index, frb : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fadds. %d,%d,%d", frd, fra, frb )
   image  = format ( "111011%5b%5b%5b00000101011", frd, fra, frb )
   action = {

               FPR [ frd ] = FPR [ fra ] + FPR [ frb ];

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;

            }

// Floating point Subtract Instructions

op fp_subtract =   fp_sub_double
                 | fp_sub_dbl_cr_update
                 | fp_sub_single
                 | fp_sub_sgl_cr_update 

op fp_sub_double ( frd : index, fra : index, frb : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fsub %d,%d,%d", frd, fra, frb )
   image  = format ( "111111%5b%5b%5b00000101000", frd, fra, frb )
   action = {
 
               FPR [ frd ] = FPR [ fra ] - FPR [ frb ];

            }

op fp_sub_dbl_cr_update ( frd : index, fra : index, frb : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fsub. %d,%d,%d", frd, fra, frb )
   image  = format ( "111111%5b%5b%5b00000101001", frd, fra, frb )
   action = {
 
               FPR [ frd ] = FPR [ fra ] - FPR [ frb ];

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;

            }

op fp_sub_single ( frd : index, fra : index, frb : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fsubs %d,%d,%d", frd, fra, frb )
   image  = format ( "111011%5b%5b%5b00000101000", frd, fra, frb )
   action = {
 
               FPR [ frd ] = FPR [ fra ] - FPR [ frb ];

            }

op fp_sub_sgl_cr_update ( frd : index, fra : index, frb : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fsubs. %d,%d,%d", frd, fra, frb )
   image  = format ( "111011%5b%5b%5b00000101001", frd, fra, frb )
   action = {
 
               FPR [ frd ] = FPR [ fra ] - FPR [ frb ];

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;

            }

// Floating point Multiply Instructions

op fp_multiply =   fp_mult_double
                 | fp_mult_dbl_cr_update
                 | fp_mult_single
                 | fp_mult_sgl_cr_update

op fp_mult_double ( frd : index, fra : index, frc : index )
   uses   = fp_pstage1 #{2} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fmul %d,%d,%d", frd, fra, frc )
   image  = format ( "111111%5b%5b00000%5b110010", frd, fra, frc )
   action = {

               FPR [ frd ] = FPR [ fra ] * FPR [ frc ];

            }

op fp_mult_dbl_cr_update ( frd : index, fra : index, frc : index )
   uses   = fp_pstage1 #{2} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fmul. %d,%d,%d", frd, fra, frc )
   image  = format ( "111111%5b%5b00000%5b110011", frd, fra, frc )
   action = {

               FPR [ frd ] = FPR [ fra ] * FPR [ frc ];

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;

            }

op fp_mult_single ( frd : index, fra : index, frc : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fmuls %d,%d,%d", frd, fra, frc )
   image  = format ( "111011%5b%5b00000%5b110010", frd, fra, frc )
   action = {

               FPR [ frd ] = FPR [ fra ] * FPR [ frc ];

            }

op fp_mult_sgl_cr_update ( frd : index, fra : index, frc : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fmuls. %d,%d,%d", frd, fra, frc )
   image  = format ( "111011%5b%5b00000%5b110011", frd, fra, frc )
   action = {

               FPR [ frd ] = FPR [ fra ] * FPR [ frc ];

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;

            }

// Floating point Divide Instructions

op fp_divide =   fp_div_double
               | fp_div_dbl_cr_update
               | fp_div_single
               | fp_div_sgl_cr_update
         
op fp_div_double ( frd : index, fra : index, frb : index )
   uses   = fp_unit #{33} 
   syntax = format ( "fdiv %d,%d,%d", frd, fra, frb )
   image  = format ( "111111%5b%5b%5b00000100100", frd, fra, frb )
   action = {

               FPR [ frd ] = FPR [ fra ] / FPR [ frb ];

            }

op fp_div_dbl_cr_update ( frd : index, fra : index, frb : index )
   uses   = fp_unit #{33} 
   syntax = format ( "fdiv. %d,%d,%d", frd, fra, frb )
   image  = format ( "111111%5b%5b%5b00000100101", frd, fra, frb )
   action = {

               FPR [ frd ] = FPR [ fra ] / FPR [ frb ];

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;

            }

op fp_div_single ( frd : index, fra : index, frb : index )
   uses   = fp_unit #{18} 
   syntax = format ( "fdivs %d,%d,%d", frd, fra, frb )
   image  = format ( "111011%5b%5b%5b00000100100", frd, fra, frb )
   action = {

               FPR [ frd ] = FPR [ fra ] / FPR [ frb ];

            }

op fp_div_sgl_cr_update ( frd : index, fra : index, frb : index )
   uses   = fp_unit #{18} 
   syntax = format ( "fdivs. %d,%d,%d", frd, fra, frb )
   image  = format ( "111011%5b%5b%5b00000100101", frd, fra, frb )
   action = {

               FPR [ frd ] = FPR [ fra ] / FPR [ frb ];

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;

            }

// Floating Multiply Add Instructions

op fp_mult_add_instr =   fp_mult_add
                       | fp_mult_sub

op fp_mult_add =   fp_mult_add_dbl
                 | fp_mult_addd_cr_upd
                 | fp_mult_add_sgl
                 | fp_mult_adds_cr_upd
                 | fp_mult_nadd_dbl
                 | fp_mult_naddd_cr_upd
                 | fp_mult_nadd_sgl
                 | fp_mult_nadds_cr_upd

op fp_mult_sub =   fp_mult_sub_dbl
                 | fp_mult_subd_cr_upd
                 | fp_mult_sub_sgl
                 | fp_mult_subs_cr_upd
                 | fp_mult_nsub_dbl
                 | fp_mult_nsubd_cr_upd
                 | fp_mult_nsub_sgl
                 | fp_mult_nsubs_cr_upd


op fp_mult_add_dbl ( frd : index, fra : index, frb : index, frc : index )
   uses   = fp_pstage1 #{2} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fmadd %d,%d,%d,%d", frd, fra, frc, frb )
   image  = format ( "111111%5b%5b%5b%5b111010", frd, fra, frb, frc )
   action = {

               FPR [ frd ] = ( FPR [ fra ] * FPR [ frc ] ) + FPR [ frb ];

            }

op fp_mult_addd_cr_upd ( frd : index, fra : index, frb : index, frc : index )
   uses   = fp_pstage1 #{2} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fmadd. %d,%d,%d,%d", frd, fra, frc, frb )
   image  = format ( "111111%5b%5b%5b%5b111011", frd, fra, frb, frc )
   action = {

               FPR [ frd ] = ( FPR [ fra ] * FPR [ frc ] ) + FPR [ frb ];

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;

            }

op fp_mult_add_sgl ( frd : index, fra : index, frb : index, frc : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fmadds %d,%d,%d,%d", frd, fra, frc, frb )
   image  = format ( "111011%5b%5b%5b%5b111010", frd, fra, frb, frc )
   action = {

               FPR [ frd ] = ( FPR [ fra ] * FPR [ frc ] ) + FPR [ frb ];

            }

op fp_mult_adds_cr_upd ( frd : index, fra : index, frb : index, frc : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fmadds. %d,%d,%d,%d", frd, fra, frc, frb )
   image  = format ( "111011%5b%5b%5b%5b111011", frd, fra, frb, frc )
   action = {

               FPR [ frd ] = ( FPR [ fra ] * FPR [ frc ] ) + FPR [ frb ];

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;

            }

op fp_mult_nadd_dbl ( frd : index, fra : index, frb : index, frc : index )
   uses   = fp_pstage1 #{2} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fnmadd %d,%d,%d,%d", frd, fra, frc, frb )
   image  = format ( "111111%5b%5b%5b%5b111110", frd, fra, frb, frc )
   action = {

               FPR [ frd ] = -( ( FPR [ fra ] * FPR [ frc ] ) + FPR [ frb ] );

            }

op fp_mult_naddd_cr_upd ( frd : index, fra : index, frb : index, frc : index )
   uses   = fp_pstage1 #{2} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fnmadd. %d,%d,%d,%d", frd, fra, frc, frb )
   image  = format ( "111111%5b%5b%5b%5b111111", frd, fra, frb, frc )
   action = {

               FPR [ frd ] = -( ( FPR [ fra ] * FPR [ frc ] ) + FPR [ frb ] );

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;

            }

op fp_mult_nadd_sgl ( frd : index, fra : index, frb : index, frc : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fnmadds %d,%d,%d,%d", frd, fra, frc, frb )
   image  = format ( "111011%5b%5b%5b%5b111110", frd, fra, frb, frc )
   action = {

               FPR [ frd ] = -( ( FPR [ fra ] * FPR [ frc ] ) + FPR [ frb ] );

            }

op fp_mult_nadds_cr_upd ( frd : index, fra : index, frb : index, frc : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fnmadds. %d,%d,%d,%d", frd, fra, frc, frb )
   image  = format ( "111011%5b%5b%5b%5b111111", frd, fra, frb, frc )
   action = {

               FPR [ frd ] = -( ( FPR [ fra ] * FPR [ frc ] ) + FPR [ frb ] );

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;

            }


op fp_mult_sub_dbl ( frd : index, fra : index, frb : index, frc : index )
   uses   = fp_pstage1 #{2} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fmsub %d,%d,%d,%d", frd, fra, frc, frb )
   image  = format ( "111111%5b%5b%5b%5b111000", frd, fra, frb, frc )
   action = {

               FPR [ frd ] = ( FPR [ fra ] * FPR [ frc ] ) - FPR [ frb ];

            }

op fp_mult_subd_cr_upd ( frd : index, fra : index, frb : index, frc : index )
   uses   = fp_pstage1 #{2} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fmsub. %d,%d,%d,%d", frd, fra, frc, frb )
   image  = format ( "111111%5b%5b%5b%5b111001", frd, fra, frb, frc )
   action = {

               FPR [ frd ] = ( FPR [ fra ] * FPR [ frc ] ) - FPR [ frb ];

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;

            }

op fp_mult_sub_sgl ( frd : index, fra : index, frb : index, frc : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fmsubs %d,%d,%d,%d", frd, fra, frc, frb )
   image  = format ( "111011%5b%5b%5b%5b111000", frd, fra, frb, frc )
   action = {

               FPR [ frd ] = ( FPR [ fra ] * FPR [ frc ] ) - FPR [ frb ];

            }

op fp_mult_subs_cr_upd ( frd : index, fra : index, frb : index, frc : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fmsubs. %d,%d,%d,%d", frd, fra, frc, frb )
   image  = format ( "111011%5b%5b%5b%5b111001", frd, fra, frb, frc )
   action = {

               FPR [ frd ] = ( FPR [ fra ] * FPR [ frc ] ) - FPR [ frb ];

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;

            }

op fp_mult_nsub_dbl ( frd : index, fra : index, frb : index, frc : index )
   uses   = fp_pstage1 #{2} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fnmsub %d,%d,%d,%d", frd, fra, frc, frb )
   image  = format ( "111111%5b%5b%5b%5b111100", frd, fra, frb, frc )
   action = {

               FPR [ frd ] = -( ( FPR [ fra ] * FPR [ frc ] ) - FPR [ frb ] );

            }

op fp_mult_nsubd_cr_upd ( frd : index, fra : index, frb : index, frc : index )
   uses   = fp_pstage1 #{2} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fnmsub. %d,%d,%d,%d", frd, fra, frc, frb )
   image  = format ( "111111%5b%5b%5b%5b111101", frd, fra, frb, frc )
   action = {

               FPR [ frd ] = -( ( FPR [ fra ] * FPR [ frc ] ) - FPR [ frb ] );

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;

            }

op fp_mult_nsub_sgl ( frd : index, fra : index, frb : index, frc : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fnmsubs %d,%d,%d,%d", frd, fra, frc, frb )
   image  = format ( "111011%5b%5b%5b%5b111100", frd, fra, frb, frc )
   action = {

               FPR [ frd ] = -( ( FPR [ fra ] * FPR [ frc ] ) - FPR [ frb ] );

            }

op fp_mult_nsubs_cr_upd ( frd : index, fra : index, frb : index, frc : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fnmsubs. %d,%d,%d,%d", frd, fra, frc, frb )
   image  = format ( "111011%5b%5b%5b%5b111101", frd, fra, frb, frc )
   action = {

               FPR [ frd ] = -( ( FPR [ fra ] * FPR [ frc ] ) - FPR [ frb ] );

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;

            }


// Floating point Compare Instructions

op fp_compare =   fp_cmp_ord
                | fp_cmp_unord

op fp_cmp_ord ( crfd : card ( 3 ), fra : index, frb : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fcmpo %d,%d,%d", crfd, fra, frb )
   image  = format ( "111111%3b00%5b%5b00001000000", crfd, fra, frb )
   action = {

               if FPR [ fra ] < FPR [ frb ] then
                  TMP_BYTE = 0b1000;
               else
                  if FPR [ fra ] > FPR [ frb ] then
                     TMP_BYTE = 0b0100;
                  else
                     TMP_BYTE = 0b0010;
                  endif;
               endif; 

               CR < (31-(4*crfd))..(31-(4*crfd)-3) > =  TMP_BYTE <3..0>; 

            }

op fp_cmp_unord ( crfd : card ( 3 ), fra : index, frb : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fcmpu %d,%d,%d", crfd, fra, frb )
   image  = format ( "111111%3b00%5b%5b00000000000", crfd, fra, frb )
   action = {

               if FPR [ fra ] < FPR [ frb ] then
                  TMP_BYTE = 0b1000;
               else
                  if FPR [ fra ] > FPR [ frb ] then
                     TMP_BYTE = 0b0100;
                  else
                     TMP_BYTE = 0b0010;
                  endif;
               endif; 

               CR < (31-(4*crfd))..(31-(4*crfd)-3) > =  TMP_BYTE <3..0>; 

            }

// Floating point move Instructions

op fp_move =   fp_mov_reg
             | fp_neg
             | fp_abs_val
             | fp_neg_abs_val

op fp_mov_reg =   fmr
                | fmr_cr_update

op fmr ( frd : index, frb : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fmr %d,%d", frd, frb )
   image  = format ( "111111%5b00000%5b00010010000", frd, frb )
   action = {

               FPR [ frd ] = FPR [ frb ];

            }

op fmr_cr_update ( frd : index, frb : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fmr. %d,%d", frd, frb )
   image  = format ( "111111%5b00000%5b00010010001", frd, frb )
   action = {

               FPR [ frd ] = FPR [ frb ];

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;

            }

op fp_neg =   fneg
            | fneg_cr_update

op fneg ( frd : index, frb : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fneg %d,%d", frd, frb )
   image  = format ( "111111%5b00000%5b00001010000", frd, frb )
   action = {

               FPR [ frd ] < 31..31 > = ~FPR [ frb ] < 31..31 >;
               FPR [ frd ] < 30..0 > = FPR [ frb ] < 30..0 >;

            }

op fneg_cr_update ( frd : index, frb : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fneg. %d,%d", frd, frb )
   image  = format ( "111111%5b00000%5b00001010001", frd, frb )
   action = {

               FPR [ frd ] < 31..31 > = ~FPR [ frb ] < 31..31 >;
               FPR [ frd ] < 30..0 > = FPR [ frb ] < 30..0 >;

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;

            }

op fp_abs_val =   fabs
                | fabs_cr_update

op fabs ( frd : index, frb : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fabs %d,%d", frd, frb )
   image  = format ( "111111%5b00000%5b01000010000", frd, frb )
   action = {

               FPR [ frd ] < 31..31 > = 0;
               FPR [ frd ] < 30..0 > = FPR [ frb ] < 30..0 >;

            }

op fabs_cr_update ( frd : index, frb : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fabs. %d,%d", frd, frb )
   image  = format ( "111111%5b00000%5b01000010001", frd, frb )
   action = {

               FPR [ frd ] < 31..31 > = 0;
               FPR [ frd ] < 30..0 > = FPR [ frb ] < 30..0 >;

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;

            }

op fp_neg_abs_val =   fnabs
                    | fnabs_cr_update

op fnabs ( frd : index, frb : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fnabs %d,%d", frd, frb )
   image  = format ( "111111%5b00000%5b00100010000", frd, frb )
   action = {

               FPR [ frd ] < 31..31 > = 1;
               FPR [ frd ] < 30..0 > = FPR [ frb ] < 30..0 >;

            }

op fnabs_cr_update ( frd : index, frb : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "fnabs. %d,%d", frd, frb )
   image  = format ( "111111%5b00000%5b00100010001", frd, frb )
   action = {

               FPR [ frd ] < 31..31 > = 1;
               FPR [ frd ] < 30..0 > = FPR [ frb ] < 30..0 >;

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;

            }

// Floating point round instructions.

op fp_round =   frsp
              | frsp_cr_update

// Floating point round to single precision.

op frsp ( frd : index, frb : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "frsp %d,%d", frd, frb )
   image  = format ( "111111%5b00000%5b00000011000", frd, frb )
   action = {
               TMP_FLOTS = FPR [ frb ]; // use the host machine conversion.
               FPR [ frd ] = TMP_FLOTS;
			}

op frsp_cr_update ( frd : index, frb : index )
   uses   = fp_pstage1 #{1} , fp_pstage2 #{1} , fp_pstage3 #{1} 
   syntax = format ( "frsp. %d,%d", frd, frb )
   image  = format ( "111111%5b00000%5b00000011001", frd, frb )
   action = {
               TMP_FLOTS = FPR [ frb ]; // use the host machine conversion.
               FPR [ frd ] = TMP_FLOTS;

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;
			}

// Floating point covert to integer instructions

op fp_convert =   fp_convert_nzero
					 | fp_convert_nzero_cr_update
					 | fp_convert_zero
					 | fp_convert_zero_cr_update

op fp_convert_nzero( frd : index, frb : index )
	syntax = format ( "fctiw %d,%d", frd, frb )
	image = format ( "111111%5b00000%5b00000011100", frd, frb )
	action = {
					//if FPR [frb] > ((-1)&0x7fffffff) then
					//	FPR [frd] < 0..31 > = 0x7fffffff;
					//else
					//	if FPR [frb] < ((-1)&0x80000000) then
					//		FPR [frd] < 0..31 > = 0x80000000;
					//	else
							TMP_SWORD = coerce(int(32) , FPR [frb]);
							FPR [frd] < 31..0 > = TMP_SWORD;
					//	endif;
					//endif;
	}

op fp_convert_nzero_cr_update( frd : index, frb : index )
	syntax = format ( "fctiw. %d,%d", frd, frb )
	image = format ( "111111%5b00000%5b00000011101", frd, frb )
	action = {
					//if FPR [frb] > ((-1)&0x7fffffff) then
					//	FPR [frd] < 0..31 > = 0x7fffffff;
					//else
					//	if FPR [frb] < ((-1)&0x80000000) then
					//		FPR [frd] < 0..31 > = 0x80000000;
					//	else
							TMP_SWORD = coerce(int(32) , FPR [frb]);
							FPR [frd] < 31..0 > = TMP_SWORD;
					//	endif;
					//endif;

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;
	}

op fp_convert_zero( frd : index, frb : index )
	syntax = format ( "fctiwz %d,%d", frd, frb )
	image = format ( "111111%5b00000%5b00000011110", frd, frb )
	action = {
					//if FPR [frb] > ((-1)&0x7fffffff) then
					//	FPR [frd] < 0..31 > = 0x7fffffff;
					//else
					//	if FPR [frb] < ((-1)&0x80000000) then
					//		FPR [frd] < 0..31 > = 0x80000000;
					//	else
							TMP_SWORD = coerce(int(32) , FPR [frb]);
							FPR [frd] < 31..0 > = TMP_SWORD;
					//	endif;
					//endif;
	}

op fp_convert_zero_cr_update( frd : index, frb : index )
	syntax = format ( "fctiwz. %d,%d", frd, frb )
	image = format ( "111111%5b00000%5b00000011111", frd, frb )
	action = {
					//if FPR [frb] > ((-1)&0x7fffffff) then
					//	FPR [frd] < 0..31 > = 0x7fffffff;
					//else
					//	if FPR [frb] < ((-1)&0x80000000) then
					//		FPR [frd] < 0..31 > = 0x80000000;
					//	else
							TMP_SWORD = coerce(int(32) , FPR [frb]);
							FPR [frd] < 31..0 > = TMP_SWORD;
					//	endif;
					//endif;

               CR < 27..27 > = FPSCR < 31..31 >;
               CR < 26..26 > = FPSCR < 30..30 >;
               CR < 25..25 > = FPSCR < 29..29 >;
               CR < 24..24 > = FPSCR < 28..28 >;
	}

// Flow control Instructions

op flow_control_instr ( x : cond_reg_log )
   uses = { wait_id < cq_ptr } sys_reg_unit : preact, x.uses, 
          { speculated [ sr_id ] == 0 & sr_id == CQ [ 0 ] } sys_reg_unit
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   preact = {

               sr_id = CQ [ wait_id ];
               wait_id = wait_id + 1;

            }

// Condition Register Logic Instructions

op cond_reg_log =   cr_and
                  | cr_or
                  | cr_xor
                  | cr_nand
                  | cr_nor
                  | cr_eqv
                  | cr_and_comp
                  | cr_or_comp
                  | mov_cr_field
                  | mov_to_cr_field
                  | mov_to_cr_xer

op cr_and ( crbd : index, crba : index, crbb : index)
   uses   = sys_reg_unit #{1} 
   syntax = format ( "crand %d,%d,%d", crbd, crba, crbb )
   image  = format ( "010011%5b%5b%5b01000000010", crbd, crba, crbb )
   action = {

               CR < (31-crbd)..(31-crbd) > = CR < (31-crba)..(31-crba) > &
                                             CR < (31-crbb)..(31-crbb) >;

            }

op cr_or ( crbd : index, crba : index, crbb : index)
   uses   = sys_reg_unit #{1} 
   syntax = format ( "cror %d,%d,%d", crbd, crba, crbb )
   image  = format ( "010011%5b%5b%5b01110000010", crbd, crba, crbb )
   action = {

               CR < (31-crbd)..(31-crbd) > = CR < (31-crba)..(31-crba) > |
                                             CR < (31-crbb)..(31-crbb) >;

            }

op cr_xor ( crbd : index, crba : index, crbb : index)
   uses   = sys_reg_unit #{1} 
   syntax = format ( "crxor %d,%d,%d", crbd, crba, crbb )
   image  = format ( "010011%5b%5b%5b00110000010", crbd, crba, crbb )
   action = {

               CR < (31-crbd)..(31-crbd) > = CR < (31-crba)..(31-crba) > ^
                                             CR < (31-crbb)..(31-crbb) >;

            }

op cr_nand ( crbd : index, crba : index, crbb : index)
   uses   = sys_reg_unit #{1} 
   syntax = format ( "crnand %d,%d,%d", crbd, crba, crbb )
   image  = format ( "010011%5b%5b%5b00111000010", crbd, crba, crbb )
   action = {

               CR < (31-crbd)..(31-crbd) > = ~( CR < (31-crba)..(31-crba) > &
                                             CR < (31-crbb)..(31-crbb) > );

            }

op cr_nor ( crbd : index, crba : index, crbb : index)
   uses   = sys_reg_unit #{1} 
   syntax = format ( "crnor %d,%d,%d", crbd, crba, crbb )
   image  = format ( "010011%5b%5b%5b00001000010", crbd, crba, crbb )
   action = {

               CR < (31-crbd)..(31-crbd) > = ~( CR < (31-crba)..(31-crba) > |
                                             CR < (31-crbb)..(31-crbb) > );

            }

op cr_eqv ( crbd : index, crba : index, crbb : index)
   uses   = sys_reg_unit #{1} 
   syntax = format ( "creqv %d,%d,%d", crbd, crba, crbb )
   image  = format ( "010011%5b%5b%5b01001000010", crbd, crba, crbb )
   action = {

               CR < (31-crbd)..(31-crbd) > = ~( CR < (31-crba)..(31-crba) > ^
                                             CR < (31-crbb)..(31-crbb) > );

            }

op cr_and_comp ( crbd : index, crba : index, crbb : index)
   uses   = sys_reg_unit #{1} 
   syntax = format ( "crandc %d,%d,%d", crbd, crba, crbb )
   image  = format ( "010011%5b%5b%5b00100000010", crbd, crba, crbb )
   action = {

               CR < (31-crbd)..(31-crbd) > = CR < (31-crba)..(31-crba) > &
                                             ~CR < (31-crbb)..(31-crbb) >;

            }

op cr_or_comp ( crbd : index, crba : index, crbb : index)
   uses   = sys_reg_unit #{1} 
   syntax = format ( "crorc %d,%d,%d", crbd, crba, crbb )
   image  = format ( "010011%5b%5b%5b01101000010", crbd, crba, crbb )
   action = {

               CR < (31-crbd)..(31-crbd) > = CR < (31-crba)..(31-crba) > |
                                             ~CR < (31-crbb)..(31-crbb) >;

            }

op mov_cr_field ( crfd : card ( 3 ), crfs : card ( 3 ) )
   uses   = sys_reg_unit #{1} 
   syntax = format ( "mcrf %d,%d", crfd, crfs )
   image  = format ( "010011%3b00%3b000000000000000000", crfd, crfs )
   action = {
					// Changed by Surendra
               CR < (31-4*crfd)..((31-4*crfd)-3) > =  
                         CR < (31-4*crfs)..((31-4*crfs)-3) >; 

            }

op mov_to_cr_field ( rs : REG_IND, crm : card ( 8 ) )
   uses   = sys_reg_unit #{1} 
   syntax = format ( "mtcrf %d,%s", crm, rs.syntax )
   image  = format ( "011111%s0%8b000100100000", rs.image, crm )
   action = {
               TMP_WORD = 0;
		// 0x00ff changed to 0xf
               TMP_BYTE = 0x0f;
		// Modified by Surendra for correctness
               if crm <7..7> then
                  TMP_WORD = TMP_WORD | TMP_BYTE;
               endif;
               TMP_WORD = TMP_WORD << 4;
               if crm <6..6> then
                  TMP_WORD = TMP_WORD | TMP_BYTE;
               endif;
               TMP_WORD = TMP_WORD << 4;
               if crm <5..5> then
                  TMP_WORD = TMP_WORD | TMP_BYTE;
               endif;
               TMP_WORD = TMP_WORD << 4;
               if crm <4..4> then
                  TMP_WORD = TMP_WORD | TMP_BYTE;
               endif;
               TMP_WORD = TMP_WORD << 4;
               if crm <3..3> then
                  TMP_WORD = TMP_WORD | TMP_BYTE;
               endif;
               TMP_WORD = TMP_WORD << 4;
               if crm <2..2> then
                  TMP_WORD = TMP_WORD | TMP_BYTE;
               endif;
               TMP_WORD = TMP_WORD << 4;
               if crm <1..1> then
                  TMP_WORD = TMP_WORD | TMP_BYTE;
               endif;
               TMP_WORD = TMP_WORD << 4;
               if crm <0..0> then
                  TMP_WORD = TMP_WORD | TMP_BYTE;
               endif;
               
               CR = (rs & TMP_WORD) | (CR & ~TMP_WORD);

             }

op mov_to_cr_xer ( crfd : card ( 3 ) )
   uses   = sys_reg_unit #{1}
   syntax = format ( "mcrxr %d", crfd )
   image  = format ( "011111%3b00000000000010000000000", crfd )
   action = {	
					// Changed by Surendra
               CR <(31-4*crfd)..((31-4*crfd)-3)> = XER <31..28>;
               XER <31..28> = 0;
            }

// Processor Control Instructions

op proce_control_instr ( x : proce_con_instr_action )
   uses = { wait_id < cq_ptr } sys_reg_unit : preact, x.uses, 
          { speculated [ sr_id ] == 0 & sr_id == CQ [ 0 ] } sys_reg_unit
   syntax = x.syntax
   image  = x.image
   action = { x.action; }
   preact = {

               sr_id = CQ [ wait_id ];
               wait_id = wait_id + 1;

            }

op proce_con_instr_action =   mov_from_cr
                            | mov_to_spr
                            | mov_from_spr

op mov_from_cr ( rd : index )
   uses   = sys_reg_unit #{1}
   syntax = format ( "mfcr %d", rd )
   image  = format ( "011111%5b000000000000000100110", rd )
   action = {
              GPR [ rd ] = CR;
            }

op mov_to_spr ( rs : index, spr : card ( 10 ) )
   uses   = sys_reg_unit #{2}
   syntax = format ( "mtspr %d,%d", spr, rs )
   image  = format ( "011111%5b%10b01110100110", rs, spr )
   action = {

              TMP_HWORD = spr;
              TMP_WORD = TMP_HWORD < 4..0 >;
				  // Changed by Surendra 4 to 5
              TMP_WORD = TMP_WORD << 5;
              TMP_WORD = TMP_WORD | (TMP_HWORD < 9..5 > & 0x0000001f);

              if TMP_WORD > 9 then
                 "print" ( "This is only user level instruction set implimentation." );
              else
                 if TMP_WORD == 1 then
                    XER = GPR [ rs ];
                 else
                    if TMP_WORD == 8 then
                       LR = GPR [ rs ];
                    else
                       if TMP_WORD == 9 then
                          CTR = GPR [ rs ];
                       endif;
                    endif;
                 endif;
               endif;

             }

op mov_from_spr ( rd : index, spr : card ( 10 ) )
   uses   = sys_reg_unit #{3}
   syntax = format ( "mfspr %d,%d", rd, spr )
   image  = format ( "011111%5b%10b01010100110", rd, spr )
   action = {

              TMP_HWORD = spr;
              TMP_WORD = TMP_HWORD < 4..0 >;
              TMP_WORD = TMP_WORD << 5;
              TMP_WORD = TMP_WORD | (TMP_HWORD < 9..5 > & 0x0000001f);

              if TMP_WORD > 9 then
                 "print" ( "This is only user level instruction set implimentation." );
              else
                 if TMP_WORD == 1 then
                    GPR [ rd ] = XER;
                 else
                    if TMP_WORD == 8 then
                       GPR [ rd ] = LR;
                    else
                       if TMP_WORD == 9 then
                          GPR [ rd ] = CTR;
                       endif;
                    endif;
                 endif;
               endif;

             }

// End PowerPc603 Description
