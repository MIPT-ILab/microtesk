Buildfile: F:\SVN\MicroTESK\microtesk\microtesk\build.xml

init.project:

init.properties:

init.buildbase:

get.buildbase:
      [get] Getting: http://forge.ispras.ru/repo/buildbase/distributions/buildbase.zip
      [get] To: F:\SVN\MicroTESK\microtesk\microtesk\tools\buildbase\buildbase.zip
      [get] Not modified - so not downloaded
    [unzip] Expanding: F:\SVN\MicroTESK\microtesk\microtesk\tools\buildbase\buildbase.zip into F:\SVN\MicroTESK\microtesk\microtesk\tools\buildbase

init.ivy:

get.ivy:

setup.ivy:

get.dependencies:
[ivy:resolve] :: Ivy 2.1.0 - 20090925235825 :: http://ant.apache.org/ivy/ ::
[ivy:resolve] :: loading settings :: file = F:\SVN\MicroTESK\microtesk\microtesk\ivyconf.xml
[ivy:resolve] :: resolving dependencies :: unitesk#microtesk;working@kamkin
[ivy:resolve] 	confs: [runtime, build]
[ivy:resolve] 	found junit#junit;4.11 in forge
[ivy:resolve] 	found hamcrest#hamcrest-core;1.3 in forge
[ivy:resolve] 	found z3#z3;4.3 in forge
[ivy:resolve] :: resolution report :: resolve 91ms :: artifacts dl 6ms
	---------------------------------------------------------------------
	|                  |            modules            ||   artifacts   |
	|       conf       | number| search|dwnlded|evicted|| number|dwnlded|
	---------------------------------------------------------------------
	|      runtime     |   0   |   0   |   0   |   0   ||   0   |   0   |
	|       build      |   3   |   0   |   0   |   0   ||   5   |   0   |
	---------------------------------------------------------------------
[ivy:retrieve] :: retrieving :: unitesk#microtesk
[ivy:retrieve] 	confs: [runtime]
[ivy:retrieve] 	0 artifacts copied, 0 already retrieved (0kB/3ms)
[ivy:retrieve] :: retrieving :: unitesk#microtesk
[ivy:retrieve] 	confs: [build]
[ivy:retrieve] 	0 artifacts copied, 5 already retrieved (0kB/3ms)

setup:

init:

javac.test:

unpack.z3.windows:
    [unzip] Expanding: F:\SVN\MicroTESK\microtesk\microtesk\tools\z3-windows.zip into F:\SVN\MicroTESK\microtesk\microtesk\tools\z3-tmp
     [move] Moving 18 files to F:\SVN\MicroTESK\microtesk\microtesk\dist\tools\z3\windows\z3
   [delete] Deleting directory F:\SVN\MicroTESK\microtesk\microtesk\tools\z3-tmp

unpack.z3.unix:

unpack.z3.mac:

unpack.z3:

test:
    [junit] Running ru.ispras.microtesk.model.api.LargeAddressTestCase
    [junit] Testsuite: ru.ispras.microtesk.model.api.LargeAddressTestCase
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,061 sec
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,061 sec
    [junit] 
    [junit] Testcase: test took 0,04 sec
    [junit] Running ru.ispras.microtesk.model.api.data.BigShiftTestCase
    [junit] Testsuite: ru.ispras.microtesk.model.api.data.BigShiftTestCase
    [junit] Data [type=Type.CARD(64), value=1111000011110001000011111111000011011110101011011011111011101111]
    [junit] Data [type=Type.CARD(64), value=0000000000000000000000000000000000000000000000000000000000100001]
    [junit] Data [type=Type.CARD(64), value=1011110101011011011111011101111000000000000000000000000000000000]
    [junit] Data [type=Type.CARD(64), value=0000000000000000000000000000000001111000011110001000011111111000]
    [junit] Data [type=Type.CARD(64), value=1011110101011011011111011101111111100001111000100001111111100001]
    [junit] Data [type=Type.CARD(64), value=0110111101010110110111110111011111111000011110001000011111111000]
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,013 sec
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,013 sec
    [junit] ------------- Standard Output ---------------
    [junit] Data [type=Type.CARD(64), value=1111000011110001000011111111000011011110101011011011111011101111]
    [junit] Data [type=Type.CARD(64), value=0000000000000000000000000000000000000000000000000000000000100001]
    [junit] Data [type=Type.CARD(64), value=1011110101011011011111011101111000000000000000000000000000000000]
    [junit] Data [type=Type.CARD(64), value=0000000000000000000000000000000001111000011110001000011111111000]
    [junit] Data [type=Type.CARD(64), value=1011110101011011011111011101111111100001111000100001111111100001]
    [junit] Data [type=Type.CARD(64), value=0110111101010110110111110111011111111000011110001000011111111000]
    [junit] ------------- ---------------- ---------------
    [junit] 
    [junit] Testcase: test took 0,005 sec
    [junit] Running ru.ispras.microtesk.model.api.data.BitRotateTestCase
    [junit] Testsuite: ru.ispras.microtesk.model.api.data.BitRotateTestCase
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,007 sec
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,007 sec
    [junit] 
    [junit] Testcase: test took 0,001 sec
    [junit] Running ru.ispras.microtesk.model.api.data.Concat64TestCase
    [junit] Testsuite: ru.ispras.microtesk.model.api.data.Concat64TestCase
    [junit] temp =77777777FFFFFFFF
    [junit] rtemp=FFFFFFFF77777777
    [junit] temp =FFFFFFFF77777777
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,011 sec
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,011 sec
    [junit] ------------- Standard Output ---------------
    [junit] temp =77777777FFFFFFFF
    [junit] rtemp=FFFFFFFF77777777
    [junit] temp =FFFFFFFF77777777
    [junit] ------------- ---------------- ---------------
    [junit] 
    [junit] Testcase: test took 0,004 sec
    [junit] Running ru.ispras.microtesk.model.api.data.SignificantBitsLostTestCase
    [junit] Testsuite: ru.ispras.microtesk.model.api.data.SignificantBitsLostTestCase
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,007 sec
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,007 sec
    [junit] 
    [junit] Testcase: test took 0,001 sec
    [junit] Running ru.ispras.microtesk.model.api.memory.MemoryAliasTestCase
    [junit] Testsuite: ru.ispras.microtesk.model.api.memory.MemoryAliasTestCase
    [junit] DEADBEEF
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,007 sec
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,007 sec
    [junit] ------------- Standard Output ---------------
    [junit] DEADBEEF
    [junit] ------------- ---------------- ---------------
    [junit] 
    [junit] Testcase: test took 0,001 sec
    [junit] Running ru.ispras.microtesk.model.api.memory.MemoryAllocatorTestCase
    [junit] Testsuite: ru.ispras.microtesk.model.api.memory.MemoryAllocatorTestCase
    [junit] MemoryAllocator [memory=MemoryStorage [regionBitSize=32, regionCount=128, addressBitSize=7], addressableUnitBitSize=8, addressableUnitsInRegion=4]
    [junit] -------------------------------------------------------
    [junit] 000: deadbeef 001: 0f0f0f0f 002: ffffffff 003: 534554ff 
    [junit] 004: 00000054 005: deadbeef 006: baadf00d 007: c001c0de 
    [junit] 008: f00d00ff 009: 00000000 010: 00000000 011: 00000000 
    [junit] 012: 00000000 013: 00000000 014: 00000000 015: 00000000 
    [junit] 016: 00000000 017: 00000000 018: 00000000 019: 00000000 
    [junit] 020: 00000000 021: 00000000 022: 00000000 023: 00000000 
    [junit] 024: 00000000 025: 00000000 026: 00000000 027: 00000000 
    [junit] 028: 00000000 029: 00000000 030: 00000000 031: 00000000 
    [junit] 032: 00000000 033: 00000000 034: 00000000 035: 00000000 
    [junit] 036: 00000000 037: 00000000 038: 00000000 039: 00000000 
    [junit] 040: 00000000 041: 00000000 042: 00000000 043: 00000000 
    [junit] 044: 00000000 045: 00000000 046: 00000000 047: 00000000 
    [junit] 048: 00000000 049: 00000000 050: 00000000 051: 00000000 
    [junit] 052: 00000000 053: 00000000 054: 00000000 055: 00000000 
    [junit] 056: 00000000 057: 00000000 058: 00000000 059: 00000000 
    [junit] 060: 00000000 061: 00000000 062: 00000000 063: 00000000 
    [junit] 064: 00000000 065: 00000000 066: 00000000 067: 00000000 
    [junit] 068: 00000000 069: 00000000 070: 00000000 071: 00000000 
    [junit] 072: 00000000 073: 00000000 074: 00000000 075: 00000000 
    [junit] 076: 00000000 077: 00000000 078: 00000000 079: 00000000 
    [junit] 080: 00000000 081: 00000000 082: 00000000 083: 00000000 
    [junit] 084: 00000000 085: 00000000 086: 00000000 087: 00000000 
    [junit] 088: 00000000 089: 00000000 090: 00000000 091: 00000000 
    [junit] 092: 00000000 093: 00000000 094: 00000000 095: 00000000 
    [junit] 096: 00000000 097: 00000000 098: 00000000 099: 00000000 
    [junit] 100: 00000000 101: 00000000 102: 00000000 103: 00000000 
    [junit] 104: 00000000 105: 00000000 106: 00000000 107: 00000000 
    [junit] 108: 00000000 109: 00000000 110: 00000000 111: 00000000 
    [junit] 112: 00000000 113: 00000000 114: 00000000 115: 00000000 
    [junit] 116: 00000000 117: 00000000 118: 00000000 119: 00000000 
    [junit] 120: 00000000 121: 00000000 122: 00000000 123: 00000000 
    [junit] 124: 00000000 125: 00000000 126: 00000000 127: 00000000 
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,026 sec
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,026 sec
    [junit] ------------- Standard Output ---------------
    [junit] MemoryAllocator [memory=MemoryStorage [regionBitSize=32, regionCount=128, addressBitSize=7], addressableUnitBitSize=8, addressableUnitsInRegion=4]
    [junit] -------------------------------------------------------
    [junit] 000: deadbeef 001: 0f0f0f0f 002: ffffffff 003: 534554ff 
    [junit] 004: 00000054 005: deadbeef 006: baadf00d 007: c001c0de 
    [junit] 008: f00d00ff 009: 00000000 010: 00000000 011: 00000000 
    [junit] 012: 00000000 013: 00000000 014: 00000000 015: 00000000 
    [junit] 016: 00000000 017: 00000000 018: 00000000 019: 00000000 
    [junit] 020: 00000000 021: 00000000 022: 00000000 023: 00000000 
    [junit] 024: 00000000 025: 00000000 026: 00000000 027: 00000000 
    [junit] 028: 00000000 029: 00000000 030: 00000000 031: 00000000 
    [junit] 032: 00000000 033: 00000000 034: 00000000 035: 00000000 
    [junit] 036: 00000000 037: 00000000 038: 00000000 039: 00000000 
    [junit] 040: 00000000 041: 00000000 042: 00000000 043: 00000000 
    [junit] 044: 00000000 045: 00000000 046: 00000000 047: 00000000 
    [junit] 048: 00000000 049: 00000000 050: 00000000 051: 00000000 
    [junit] 052: 00000000 053: 00000000 054: 00000000 055: 00000000 
    [junit] 056: 00000000 057: 00000000 058: 00000000 059: 00000000 
    [junit] 060: 00000000 061: 00000000 062: 00000000 063: 00000000 
    [junit] 064: 00000000 065: 00000000 066: 00000000 067: 00000000 
    [junit] 068: 00000000 069: 00000000 070: 00000000 071: 00000000 
    [junit] 072: 00000000 073: 00000000 074: 00000000 075: 00000000 
    [junit] 076: 00000000 077: 00000000 078: 00000000 079: 00000000 
    [junit] 080: 00000000 081: 00000000 082: 00000000 083: 00000000 
    [junit] 084: 00000000 085: 00000000 086: 00000000 087: 00000000 
    [junit] 088: 00000000 089: 00000000 090: 00000000 091: 00000000 
    [junit] 092: 00000000 093: 00000000 094: 00000000 095: 00000000 
    [junit] 096: 00000000 097: 00000000 098: 00000000 099: 00000000 
    [junit] 100: 00000000 101: 00000000 102: 00000000 103: 00000000 
    [junit] 104: 00000000 105: 00000000 106: 00000000 107: 00000000 
    [junit] 108: 00000000 109: 00000000 110: 00000000 111: 00000000 
    [junit] 112: 00000000 113: 00000000 114: 00000000 115: 00000000 
    [junit] 116: 00000000 117: 00000000 118: 00000000 119: 00000000 
    [junit] 120: 00000000 121: 00000000 122: 00000000 123: 00000000 
    [junit] 124: 00000000 125: 00000000 126: 00000000 127: 00000000 
    [junit] ------------- ---------------- ---------------
    [junit] 
    [junit] Testcase: test took 0,02 sec
    [junit] Running ru.ispras.microtesk.model.api.memory.MemoryLocationTestCase
    [junit] Testsuite: ru.ispras.microtesk.model.api.memory.MemoryLocationTestCase
    [junit] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,073 sec
    [junit] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,073 sec
    [junit] 
    [junit] Testcase: test2 took 0 sec
    [junit] Testcase: testRandom took 0,067 sec
    [junit] Running ru.ispras.microtesk.model.api.memory.MemoryStorageTestCase
    [junit] Testsuite: ru.ispras.microtesk.model.api.memory.MemoryStorageTestCase
    [junit] Test: regions = 1 (1), region size = 3, address size = 1
    [junit] Test: regions = 1 (1), region size = 5, address size = 1
    [junit] Test: regions = 1 (1), region size = 7, address size = 1
    [junit] Test: regions = 1 (1), region size = 10, address size = 1
    [junit] Test: regions = 1 (1), region size = 12, address size = 1
    [junit] Test: regions = 1 (1), region size = 14, address size = 1
    [junit] Test: regions = 1 (1), region size = 18, address size = 1
    [junit] Test: regions = 1 (1), region size = 24, address size = 1
    [junit] Test: regions = 1 (1), region size = 26, address size = 1
    [junit] Test: regions = 1 (1), region size = 28, address size = 1
    [junit] Test: regions = 1 (1), region size = 1, address size = 1
    [junit] Test: regions = 1 (1), region size = 2, address size = 1
    [junit] Test: regions = 1 (1), region size = 4, address size = 1
    [junit] Test: regions = 1 (1), region size = 8, address size = 1
    [junit] Test: regions = 1 (1), region size = 16, address size = 1
    [junit] Test: regions = 1 (1), region size = 32, address size = 1
    [junit] Test: regions = 1 (1), region size = 64, address size = 1
    [junit] Test: regions = 1 (1), region size = 128, address size = 1
    [junit] Test: regions = 1 (1), region size = 256, address size = 1
    [junit] Test: regions = 2 (2), region size = 3, address size = 1
    [junit] Test: regions = 2 (2), region size = 5, address size = 1
    [junit] Test: regions = 2 (2), region size = 7, address size = 1
    [junit] Test: regions = 2 (2), region size = 10, address size = 1
    [junit] Test: regions = 2 (2), region size = 12, address size = 1
    [junit] Test: regions = 2 (2), region size = 14, address size = 1
    [junit] Test: regions = 2 (2), region size = 18, address size = 1
    [junit] Test: regions = 2 (2), region size = 24, address size = 1
    [junit] Test: regions = 2 (2), region size = 26, address size = 1
    [junit] Test: regions = 2 (2), region size = 28, address size = 1
    [junit] Test: regions = 2 (2), region size = 1, address size = 1
    [junit] Test: regions = 2 (2), region size = 2, address size = 1
    [junit] Test: regions = 2 (2), region size = 4, address size = 1
    [junit] Test: regions = 2 (2), region size = 8, address size = 1
    [junit] Test: regions = 2 (2), region size = 16, address size = 1
    [junit] Test: regions = 2 (2), region size = 32, address size = 1
    [junit] Test: regions = 2 (2), region size = 64, address size = 1
    [junit] Test: regions = 2 (2), region size = 128, address size = 1
    [junit] Test: regions = 2 (2), region size = 256, address size = 1
    [junit] Test: regions = 4 (4), region size = 3, address size = 2
    [junit] Test: regions = 4 (4), region size = 5, address size = 2
    [junit] Test: regions = 4 (4), region size = 7, address size = 2
    [junit] Test: regions = 4 (4), region size = 10, address size = 2
    [junit] Test: regions = 4 (4), region size = 12, address size = 2
    [junit] Test: regions = 4 (4), region size = 14, address size = 2
    [junit] Test: regions = 4 (4), region size = 18, address size = 2
    [junit] Test: regions = 4 (4), region size = 24, address size = 2
    [junit] Test: regions = 4 (4), region size = 26, address size = 2
    [junit] Test: regions = 4 (4), region size = 28, address size = 2
    [junit] Test: regions = 4 (4), region size = 1, address size = 2
    [junit] Test: regions = 4 (4), region size = 2, address size = 2
    [junit] Test: regions = 4 (4), region size = 4, address size = 2
    [junit] Test: regions = 4 (4), region size = 8, address size = 2
    [junit] Test: regions = 4 (4), region size = 16, address size = 2
    [junit] Test: regions = 4 (4), region size = 32, address size = 2
    [junit] Test: regions = 4 (4), region size = 64, address size = 2
    [junit] Test: regions = 4 (4), region size = 128, address size = 2
    [junit] Test: regions = 4 (4), region size = 256, address size = 2
    [junit] Test: regions = 8 (8), region size = 3, address size = 3
    [junit] Test: regions = 8 (8), region size = 5, address size = 3
    [junit] Test: regions = 8 (8), region size = 7, address size = 3
    [junit] Test: regions = 8 (8), region size = 10, address size = 3
    [junit] Test: regions = 8 (8), region size = 12, address size = 3
    [junit] Test: regions = 8 (8), region size = 14, address size = 3
    [junit] Test: regions = 8 (8), region size = 18, address size = 3
    [junit] Test: regions = 8 (8), region size = 24, address size = 3
    [junit] Test: regions = 8 (8), region size = 26, address size = 3
    [junit] Test: regions = 8 (8), region size = 28, address size = 3
    [junit] Test: regions = 8 (8), region size = 1, address size = 3
    [junit] Test: regions = 8 (8), region size = 2, address size = 3
    [junit] Test: regions = 8 (8), region size = 4, address size = 3
    [junit] Test: regions = 8 (8), region size = 8, address size = 3
    [junit] Test: regions = 8 (8), region size = 16, address size = 3
    [junit] Test: regions = 8 (8), region size = 32, address size = 3
    [junit] Test: regions = 8 (8), region size = 64, address size = 3
    [junit] Test: regions = 8 (8), region size = 128, address size = 3
    [junit] Test: regions = 8 (8), region size = 256, address size = 3
    [junit] Test: regions = 16 (10), region size = 3, address size = 4
    [junit] Test: regions = 16 (10), region size = 5, address size = 4
    [junit] Test: regions = 16 (10), region size = 7, address size = 4
    [junit] Test: regions = 16 (10), region size = 10, address size = 4
    [junit] Test: regions = 16 (10), region size = 12, address size = 4
    [junit] Test: regions = 16 (10), region size = 14, address size = 4
    [junit] Test: regions = 16 (10), region size = 18, address size = 4
    [junit] Test: regions = 16 (10), region size = 24, address size = 4
    [junit] Test: regions = 16 (10), region size = 26, address size = 4
    [junit] Test: regions = 16 (10), region size = 28, address size = 4
    [junit] Test: regions = 16 (10), region size = 1, address size = 4
    [junit] Test: regions = 16 (10), region size = 2, address size = 4
    [junit] Test: regions = 16 (10), region size = 4, address size = 4
    [junit] Test: regions = 16 (10), region size = 8, address size = 4
    [junit] Test: regions = 16 (10), region size = 16, address size = 4
    [junit] Test: regions = 16 (10), region size = 32, address size = 4
    [junit] Test: regions = 16 (10), region size = 64, address size = 4
    [junit] Test: regions = 16 (10), region size = 128, address size = 4
    [junit] Test: regions = 16 (10), region size = 256, address size = 4
    [junit] Test: regions = 32 (20), region size = 3, address size = 5
    [junit] Test: regions = 32 (20), region size = 5, address size = 5
    [junit] Test: regions = 32 (20), region size = 7, address size = 5
    [junit] Test: regions = 32 (20), region size = 10, address size = 5
    [junit] Test: regions = 32 (20), region size = 12, address size = 5
    [junit] Test: regions = 32 (20), region size = 14, address size = 5
    [junit] Test: regions = 32 (20), region size = 18, address size = 5
    [junit] Test: regions = 32 (20), region size = 24, address size = 5
    [junit] Test: regions = 32 (20), region size = 26, address size = 5
    [junit] Test: regions = 32 (20), region size = 28, address size = 5
    [junit] Test: regions = 32 (20), region size = 1, address size = 5
    [junit] Test: regions = 32 (20), region size = 2, address size = 5
    [junit] Test: regions = 32 (20), region size = 4, address size = 5
    [junit] Test: regions = 32 (20), region size = 8, address size = 5
    [junit] Test: regions = 32 (20), region size = 16, address size = 5
    [junit] Test: regions = 32 (20), region size = 32, address size = 5
    [junit] Test: regions = 32 (20), region size = 64, address size = 5
    [junit] Test: regions = 32 (20), region size = 128, address size = 5
    [junit] Test: regions = 32 (20), region size = 256, address size = 5
    [junit] Test: regions = 64 (40), region size = 3, address size = 6
    [junit] Test: regions = 64 (40), region size = 5, address size = 6
    [junit] Test: regions = 64 (40), region size = 7, address size = 6
    [junit] Test: regions = 64 (40), region size = 10, address size = 6
    [junit] Test: regions = 64 (40), region size = 12, address size = 6
    [junit] Test: regions = 64 (40), region size = 14, address size = 6
    [junit] Test: regions = 64 (40), region size = 18, address size = 6
    [junit] Test: regions = 64 (40), region size = 24, address size = 6
    [junit] Test: regions = 64 (40), region size = 26, address size = 6
    [junit] Test: regions = 64 (40), region size = 28, address size = 6
    [junit] Test: regions = 64 (40), region size = 1, address size = 6
    [junit] Test: regions = 64 (40), region size = 2, address size = 6
    [junit] Test: regions = 64 (40), region size = 4, address size = 6
    [junit] Test: regions = 64 (40), region size = 8, address size = 6
    [junit] Test: regions = 64 (40), region size = 16, address size = 6
    [junit] Test: regions = 64 (40), region size = 32, address size = 6
    [junit] Test: regions = 64 (40), region size = 64, address size = 6
    [junit] Test: regions = 64 (40), region size = 128, address size = 6
    [junit] Test: regions = 64 (40), region size = 256, address size = 6
    [junit] Test: regions = 128 (80), region size = 3, address size = 7
    [junit] Test: regions = 128 (80), region size = 5, address size = 7
    [junit] Test: regions = 128 (80), region size = 7, address size = 7
    [junit] Test: regions = 128 (80), region size = 10, address size = 7
    [junit] Test: regions = 128 (80), region size = 12, address size = 7
    [junit] Test: regions = 128 (80), region size = 14, address size = 7
    [junit] Test: regions = 128 (80), region size = 18, address size = 7
    [junit] Test: regions = 128 (80), region size = 24, address size = 7
    [junit] Test: regions = 128 (80), region size = 26, address size = 7
    [junit] Test: regions = 128 (80), region size = 28, address size = 7
    [junit] Test: regions = 128 (80), region size = 1, address size = 7
    [junit] Test: regions = 128 (80), region size = 2, address size = 7
    [junit] Test: regions = 128 (80), region size = 4, address size = 7
    [junit] Test: regions = 128 (80), region size = 8, address size = 7
    [junit] Test: regions = 128 (80), region size = 16, address size = 7
    [junit] Test: regions = 128 (80), region size = 32, address size = 7
    [junit] Test: regions = 128 (80), region size = 64, address size = 7
    [junit] Test: regions = 128 (80), region size = 128, address size = 7
    [junit] Test: regions = 128 (80), region size = 256, address size = 7
    [junit] Test: regions = 256 (100), region size = 3, address size = 8
    [junit] Test: regions = 256 (100), region size = 5, address size = 8
    [junit] Test: regions = 256 (100), region size = 7, address size = 8
    [junit] Test: regions = 256 (100), region size = 10, address size = 8
    [junit] Test: regions = 256 (100), region size = 12, address size = 8
    [junit] Test: regions = 256 (100), region size = 14, address size = 8
    [junit] Test: regions = 256 (100), region size = 18, address size = 8
    [junit] Test: regions = 256 (100), region size = 24, address size = 8
    [junit] Test: regions = 256 (100), region size = 26, address size = 8
    [junit] Test: regions = 256 (100), region size = 28, address size = 8
    [junit] Test: regions = 256 (100), region size = 1, address size = 8
    [junit] Test: regions = 256 (100), region size = 2, address size = 8
    [junit] Test: regions = 256 (100), region size = 4, address size = 8
    [junit] Test: regions = 256 (100), region size = 8, address size = 8
    [junit] Test: regions = 256 (100), region size = 16, address size = 8
    [junit] Test: regions = 256 (100), region size = 32, address size = 8
    [junit] Test: regions = 256 (100), region size = 64, address size = 8
    [junit] Test: regions = 256 (100), region size = 128, address size = 8
    [junit] Test: regions = 256 (100), region size = 256, address size = 8
    [junit] Test: regions = 512 (200), region size = 3, address size = 9
    [junit] Test: regions = 512 (200), region size = 5, address size = 9
    [junit] Test: regions = 512 (200), region size = 7, address size = 9
    [junit] Test: regions = 512 (200), region size = 10, address size = 9
    [junit] Test: regions = 512 (200), region size = 12, address size = 9
    [junit] Test: regions = 512 (200), region size = 14, address size = 9
    [junit] Test: regions = 512 (200), region size = 18, address size = 9
    [junit] Test: regions = 512 (200), region size = 24, address size = 9
    [junit] Test: regions = 512 (200), region size = 26, address size = 9
    [junit] Test: regions = 512 (200), region size = 28, address size = 9
    [junit] Test: regions = 512 (200), region size = 1, address size = 9
    [junit] Test: regions = 512 (200), region size = 2, address size = 9
    [junit] Test: regions = 512 (200), region size = 4, address size = 9
    [junit] Test: regions = 512 (200), region size = 8, address size = 9
    [junit] Test: regions = 512 (200), region size = 16, address size = 9
    [junit] Test: regions = 512 (200), region size = 32, address size = 9
    [junit] Test: regions = 512 (200), region size = 64, address size = 9
    [junit] Test: regions = 512 (200), region size = 128, address size = 9
    [junit] Test: regions = 512 (200), region size = 256, address size = 9
    [junit] Test: regions = 1024 (400), region size = 3, address size = 10
    [junit] Test: regions = 1024 (400), region size = 5, address size = 10
    [junit] Test: regions = 1024 (400), region size = 7, address size = 10
    [junit] Test: regions = 1024 (400), region size = 10, address size = 10
    [junit] Test: regions = 1024 (400), region size = 12, address size = 10
    [junit] Test: regions = 1024 (400), region size = 14, address size = 10
    [junit] Test: regions = 1024 (400), region size = 18, address size = 10
    [junit] Test: regions = 1024 (400), region size = 24, address size = 10
    [junit] Test: regions = 1024 (400), region size = 26, address size = 10
    [junit] Test: regions = 1024 (400), region size = 28, address size = 10
    [junit] Test: regions = 1024 (400), region size = 1, address size = 10
    [junit] Test: regions = 1024 (400), region size = 2, address size = 10
    [junit] Test: regions = 1024 (400), region size = 4, address size = 10
    [junit] Test: regions = 1024 (400), region size = 8, address size = 10
    [junit] Test: regions = 1024 (400), region size = 16, address size = 10
    [junit] Test: regions = 1024 (400), region size = 32, address size = 10
    [junit] Test: regions = 1024 (400), region size = 64, address size = 10
    [junit] Test: regions = 1024 (400), region size = 128, address size = 10
    [junit] Test: regions = 1024 (400), region size = 256, address size = 10
    [junit] Test: regions = 2048 (800), region size = 3, address size = 11
    [junit] Test: regions = 2048 (800), region size = 5, address size = 11
    [junit] Test: regions = 2048 (800), region size = 7, address size = 11
    [junit] Test: regions = 2048 (800), region size = 10, address size = 11
    [junit] Test: regions = 2048 (800), region size = 12, address size = 11
    [junit] Test: regions = 2048 (800), region size = 14, address size = 11
    [junit] Test: regions = 2048 (800), region size = 18, address size = 11
    [junit] Test: regions = 2048 (800), region size = 24, address size = 11
    [junit] Test: regions = 2048 (800), region size = 26, address size = 11
    [junit] Test: regions = 2048 (800), region size = 28, address size = 11
    [junit] Test: regions = 2048 (800), region size = 1, address size = 11
    [junit] Test: regions = 2048 (800), region size = 2, address size = 11
    [junit] Test: regions = 2048 (800), region size = 4, address size = 11
    [junit] Test: regions = 2048 (800), region size = 8, address size = 11
    [junit] Test: regions = 2048 (800), region size = 16, address size = 11
    [junit] Test: regions = 2048 (800), region size = 32, address size = 11
    [junit] Test: regions = 2048 (800), region size = 64, address size = 11
    [junit] Test: regions = 2048 (800), region size = 128, address size = 11
    [junit] Test: regions = 2048 (800), region size = 256, address size = 11
    [junit] Test: regions = 4096 (1000), region size = 3, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 5, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 7, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 10, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 12, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 14, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 18, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 24, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 26, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 28, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 1, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 2, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 4, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 8, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 16, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 32, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 64, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 128, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 256, address size = 12
    [junit] Test: regions = 8192 (2000), region size = 3, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 5, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 7, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 10, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 12, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 14, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 18, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 24, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 26, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 28, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 1, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 2, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 4, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 8, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 16, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 32, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 64, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 128, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 256, address size = 13
    [junit] Test: regions = 16384 (4000), region size = 3, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 5, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 7, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 10, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 12, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 14, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 18, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 24, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 26, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 28, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 1, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 2, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 4, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 8, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 16, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 32, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 64, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 128, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 256, address size = 14
    [junit] Test: regions = 32768 (8000), region size = 3, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 5, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 7, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 10, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 12, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 14, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 18, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 24, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 26, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 28, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 1, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 2, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 4, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 8, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 16, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 32, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 64, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 128, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 256, address size = 15
    [junit] Test: regions = 65536 (10000), region size = 3, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 5, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 7, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 10, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 12, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 14, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 18, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 24, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 26, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 28, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 1, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 2, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 4, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 8, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 16, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 32, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 64, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 128, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 256, address size = 16
    [junit] Test: regions = 131072 (20000), region size = 3, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 5, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 7, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 10, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 12, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 14, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 18, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 24, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 26, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 28, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 1, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 2, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 4, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 8, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 16, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 32, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 64, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 128, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 256, address size = 17
    [junit] Test: regions = 262144 (40000), region size = 3, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 5, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 7, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 10, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 12, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 14, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 18, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 24, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 26, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 28, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 1, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 2, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 4, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 8, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 16, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 32, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 64, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 128, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 256, address size = 18
    [junit] Test: regions = 524288 (80000), region size = 3, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 5, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 7, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 10, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 12, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 14, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 18, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 24, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 26, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 28, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 1, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 2, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 4, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 8, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 16, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 32, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 64, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 128, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 256, address size = 19
    [junit] Test: regions = 1048576 (100000), region size = 3, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 5, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 7, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 10, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 12, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 14, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 18, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 24, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 26, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 28, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 1, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 2, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 4, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 8, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 16, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 32, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 64, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 128, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 256, address size = 20
    [junit] Test: regions = 2097152 (200000), region size = 3, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 5, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 7, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 10, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 12, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 14, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 18, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 24, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 26, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 28, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 1, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 2, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 4, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 8, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 16, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 32, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 64, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 128, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 256, address size = 21
    [junit] Test: regions = 4194304 (400000), region size = 3, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 5, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 7, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 10, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 12, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 14, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 18, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 24, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 26, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 28, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 1, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 2, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 4, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 8, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 16, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 32, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 64, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 128, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 256, address size = 22
    [junit] Test: regions = 8388608 (800000), region size = 3, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 5, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 7, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 10, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 12, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 14, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 18, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 24, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 26, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 28, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 1, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 2, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 4, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 8, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 16, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 32, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 64, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 128, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 256, address size = 23
    [junit] Test: regions = 16777216 (1000000), region size = 3, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 5, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 7, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 10, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 12, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 14, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 18, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 24, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 26, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 28, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 1, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 2, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 4, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 8, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 16, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 32, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 64, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 128, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 256, address size = 24
    [junit] Test: regions = 33554432 (2000000), region size = 3, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 5, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 7, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 10, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 12, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 14, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 18, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 24, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 26, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 28, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 1, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 2, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 4, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 8, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 16, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 32, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 64, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 128, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 256, address size = 25
    [junit] Test: regions = 67108864 (4000000), region size = 3, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 5, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 7, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 10, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 12, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 14, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 18, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 24, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 26, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 28, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 1, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 2, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 4, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 8, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 16, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 32, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 64, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 128, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 256, address size = 26
    [junit] Test: regions = 134217728 (8000000), region size = 3, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 5, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 7, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 10, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 12, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 14, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 18, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 24, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 26, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 28, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 1, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 2, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 4, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 8, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 16, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 32, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 64, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 128, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 256, address size = 27
    [junit] Test: regions = 268435456 (10000000), region size = 3, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 5, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 7, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 10, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 12, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 14, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 18, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 24, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 26, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 28, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 1, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 2, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 4, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 8, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 16, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 32, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 64, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 128, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 256, address size = 28
    [junit] Test: regions = 536870912 (20000000), region size = 3, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 5, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 7, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 10, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 12, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 14, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 18, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 24, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 26, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 28, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 1, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 2, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 4, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 8, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 16, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 32, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 64, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 128, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 256, address size = 29
    [junit] Test: regions = 1073741824 (40000000), region size = 3, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 5, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 7, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 10, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 12, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 14, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 18, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 24, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 26, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 28, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 1, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 2, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 4, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 8, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 16, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 32, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 64, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 128, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 256, address size = 30
    [junit] Test: regions = 2147483648 (80000000), region size = 3, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 5, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 7, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 10, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 12, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 14, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 18, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 24, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 26, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 28, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 1, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 2, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 4, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 8, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 16, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 32, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 64, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 128, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 256, address size = 31
    [junit] Test: regions = 4294967296 (100000000), region size = 3, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 5, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 7, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 10, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 12, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 14, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 18, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 24, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 26, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 28, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 1, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 2, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 4, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 8, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 16, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 32, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 64, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 128, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 256, address size = 32
    [junit] Test: regions = 8589934592 (200000000), region size = 3, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 5, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 7, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 10, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 12, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 14, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 18, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 24, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 26, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 28, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 1, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 2, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 4, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 8, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 16, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 32, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 64, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 128, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 256, address size = 33
    [junit] Test: regions = 17179869184 (400000000), region size = 3, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 5, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 7, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 10, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 12, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 14, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 18, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 24, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 26, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 28, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 1, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 2, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 4, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 8, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 16, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 32, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 64, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 128, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 256, address size = 34
    [junit] Test: regions = 34359738368 (800000000), region size = 3, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 5, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 7, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 10, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 12, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 14, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 18, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 24, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 26, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 28, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 1, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 2, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 4, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 8, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 16, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 32, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 64, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 128, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 256, address size = 35
    [junit] Test: regions = 68719476736 (1000000000), region size = 3, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 5, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 7, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 10, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 12, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 14, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 18, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 24, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 26, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 28, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 1, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 2, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 4, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 8, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 16, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 32, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 64, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 128, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 256, address size = 36
    [junit] Test: regions = 137438953472 (2000000000), region size = 3, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 5, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 7, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 10, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 12, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 14, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 18, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 24, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 26, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 28, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 1, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 2, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 4, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 8, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 16, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 32, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 64, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 128, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 256, address size = 37
    [junit] Test: regions = 274877906944 (4000000000), region size = 3, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 5, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 7, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 10, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 12, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 14, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 18, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 24, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 26, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 28, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 1, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 2, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 4, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 8, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 16, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 32, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 64, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 128, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 256, address size = 38
    [junit] Test: regions = 549755813888 (8000000000), region size = 3, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 5, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 7, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 10, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 12, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 14, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 18, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 24, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 26, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 28, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 1, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 2, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 4, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 8, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 16, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 32, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 64, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 128, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 256, address size = 39
    [junit] Test: regions = 1099511627776 (10000000000), region size = 3, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 5, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 7, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 10, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 12, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 14, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 18, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 24, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 26, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 28, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 1, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 2, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 4, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 8, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 16, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 32, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 64, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 128, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 256, address size = 40
    [junit] Test: regions = 2199023255552 (20000000000), region size = 3, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 5, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 7, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 10, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 12, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 14, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 18, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 24, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 26, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 28, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 1, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 2, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 4, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 8, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 16, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 32, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 64, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 128, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 256, address size = 41
    [junit] Test: regions = 4398046511104 (40000000000), region size = 3, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 5, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 7, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 10, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 12, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 14, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 18, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 24, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 26, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 28, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 1, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 2, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 4, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 8, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 16, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 32, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 64, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 128, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 256, address size = 42
    [junit] Test: regions = 8796093022208 (80000000000), region size = 3, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 5, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 7, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 10, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 12, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 14, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 18, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 24, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 26, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 28, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 1, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 2, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 4, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 8, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 16, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 32, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 64, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 128, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 256, address size = 43
    [junit] Test: regions = 17592186044416 (100000000000), region size = 3, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 5, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 7, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 10, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 12, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 14, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 18, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 24, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 26, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 28, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 1, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 2, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 4, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 8, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 16, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 32, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 64, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 128, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 256, address size = 44
    [junit] Test: regions = 35184372088832 (200000000000), region size = 3, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 5, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 7, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 10, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 12, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 14, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 18, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 24, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 26, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 28, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 1, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 2, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 4, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 8, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 16, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 32, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 64, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 128, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 256, address size = 45
    [junit] Test: regions = 70368744177664 (400000000000), region size = 3, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 5, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 7, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 10, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 12, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 14, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 18, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 24, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 26, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 28, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 1, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 2, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 4, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 8, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 16, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 32, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 64, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 128, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 256, address size = 46
    [junit] Test: regions = 140737488355328 (800000000000), region size = 3, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 5, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 7, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 10, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 12, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 14, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 18, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 24, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 26, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 28, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 1, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 2, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 4, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 8, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 16, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 32, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 64, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 128, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 256, address size = 47
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 3, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 5, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 7, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 10, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 12, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 14, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 18, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 24, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 26, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 28, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 1, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 2, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 4, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 8, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 16, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 32, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 64, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 128, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 256, address size = 48
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 3, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 5, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 7, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 10, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 12, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 14, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 18, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 24, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 26, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 28, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 1, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 2, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 4, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 8, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 16, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 32, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 64, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 128, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 256, address size = 49
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 3, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 5, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 7, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 10, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 12, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 14, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 18, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 24, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 26, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 28, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 1, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 2, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 4, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 8, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 16, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 32, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 64, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 128, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 256, address size = 50
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 3, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 5, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 7, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 10, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 12, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 14, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 18, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 24, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 26, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 28, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 1, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 2, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 4, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 8, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 16, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 32, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 64, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 128, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 256, address size = 51
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 3, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 5, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 7, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 10, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 12, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 14, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 18, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 24, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 26, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 28, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 1, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 2, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 4, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 8, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 16, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 32, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 64, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 128, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 256, address size = 52
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 3, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 5, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 7, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 10, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 12, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 14, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 18, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 24, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 26, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 28, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 1, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 2, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 4, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 8, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 16, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 32, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 64, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 128, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 256, address size = 53
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 3, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 5, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 7, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 10, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 12, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 14, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 18, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 24, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 26, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 28, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 1, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 2, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 4, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 8, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 16, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 32, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 64, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 128, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 256, address size = 54
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 3, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 5, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 7, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 10, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 12, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 14, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 18, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 24, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 26, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 28, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 1, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 2, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 4, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 8, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 16, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 32, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 64, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 128, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 256, address size = 55
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 3, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 5, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 7, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 10, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 12, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 14, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 18, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 24, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 26, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 28, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 1, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 2, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 4, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 8, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 16, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 32, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 64, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 128, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 256, address size = 56
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 3, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 5, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 7, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 10, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 12, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 14, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 18, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 24, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 26, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 28, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 1, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 2, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 4, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 8, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 16, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 32, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 64, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 128, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 256, address size = 57
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 3, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 5, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 7, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 10, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 12, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 14, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 18, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 24, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 26, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 28, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 1, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 2, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 4, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 8, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 16, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 32, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 64, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 128, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 256, address size = 58
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 3, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 5, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 7, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 10, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 12, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 14, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 18, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 24, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 26, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 28, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 1, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 2, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 4, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 8, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 16, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 32, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 64, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 128, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 256, address size = 59
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 3, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 5, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 7, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 10, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 12, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 14, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 18, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 24, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 26, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 28, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 1, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 2, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 4, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 8, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 16, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 32, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 64, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 128, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 256, address size = 60
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 3, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 5, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 7, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 10, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 12, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 14, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 18, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 24, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 26, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 28, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 1, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 2, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 4, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 8, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 16, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 32, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 64, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 128, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 256, address size = 61
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 3, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 5, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 7, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 10, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 12, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 14, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 18, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 24, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 26, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 28, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 1, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 2, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 4, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 8, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 16, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 32, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 64, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 128, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 256, address size = 62
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 3, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 5, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 7, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 10, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 12, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 14, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 18, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 24, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 26, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 28, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 1, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 2, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 4, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 8, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 16, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 32, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 64, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 128, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 256, address size = 63
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 3, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 5, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 7, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 10, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 12, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 14, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 18, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 24, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 26, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 28, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 1, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 2, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 4, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 8, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 16, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 32, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 64, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 128, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 256, address size = 64
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 12,607 sec
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 12,607 sec
    [junit] ------------- Standard Output ---------------
    [junit] Test: regions = 1 (1), region size = 3, address size = 1
    [junit] Test: regions = 1 (1), region size = 5, address size = 1
    [junit] Test: regions = 1 (1), region size = 7, address size = 1
    [junit] Test: regions = 1 (1), region size = 10, address size = 1
    [junit] Test: regions = 1 (1), region size = 12, address size = 1
    [junit] Test: regions = 1 (1), region size = 14, address size = 1
    [junit] Test: regions = 1 (1), region size = 18, address size = 1
    [junit] Test: regions = 1 (1), region size = 24, address size = 1
    [junit] Test: regions = 1 (1), region size = 26, address size = 1
    [junit] Test: regions = 1 (1), region size = 28, address size = 1
    [junit] Test: regions = 1 (1), region size = 1, address size = 1
    [junit] Test: regions = 1 (1), region size = 2, address size = 1
    [junit] Test: regions = 1 (1), region size = 4, address size = 1
    [junit] Test: regions = 1 (1), region size = 8, address size = 1
    [junit] Test: regions = 1 (1), region size = 16, address size = 1
    [junit] Test: regions = 1 (1), region size = 32, address size = 1
    [junit] Test: regions = 1 (1), region size = 64, address size = 1
    [junit] Test: regions = 1 (1), region size = 128, address size = 1
    [junit] Test: regions = 1 (1), region size = 256, address size = 1
    [junit] Test: regions = 2 (2), region size = 3, address size = 1
    [junit] Test: regions = 2 (2), region size = 5, address size = 1
    [junit] Test: regions = 2 (2), region size = 7, address size = 1
    [junit] Test: regions = 2 (2), region size = 10, address size = 1
    [junit] Test: regions = 2 (2), region size = 12, address size = 1
    [junit] Test: regions = 2 (2), region size = 14, address size = 1
    [junit] Test: regions = 2 (2), region size = 18, address size = 1
    [junit] Test: regions = 2 (2), region size = 24, address size = 1
    [junit] Test: regions = 2 (2), region size = 26, address size = 1
    [junit] Test: regions = 2 (2), region size = 28, address size = 1
    [junit] Test: regions = 2 (2), region size = 1, address size = 1
    [junit] Test: regions = 2 (2), region size = 2, address size = 1
    [junit] Test: regions = 2 (2), region size = 4, address size = 1
    [junit] Test: regions = 2 (2), region size = 8, address size = 1
    [junit] Test: regions = 2 (2), region size = 16, address size = 1
    [junit] Test: regions = 2 (2), region size = 32, address size = 1
    [junit] Test: regions = 2 (2), region size = 64, address size = 1
    [junit] Test: regions = 2 (2), region size = 128, address size = 1
    [junit] Test: regions = 2 (2), region size = 256, address size = 1
    [junit] Test: regions = 4 (4), region size = 3, address size = 2
    [junit] Test: regions = 4 (4), region size = 5, address size = 2
    [junit] Test: regions = 4 (4), region size = 7, address size = 2
    [junit] Test: regions = 4 (4), region size = 10, address size = 2
    [junit] Test: regions = 4 (4), region size = 12, address size = 2
    [junit] Test: regions = 4 (4), region size = 14, address size = 2
    [junit] Test: regions = 4 (4), region size = 18, address size = 2
    [junit] Test: regions = 4 (4), region size = 24, address size = 2
    [junit] Test: regions = 4 (4), region size = 26, address size = 2
    [junit] Test: regions = 4 (4), region size = 28, address size = 2
    [junit] Test: regions = 4 (4), region size = 1, address size = 2
    [junit] Test: regions = 4 (4), region size = 2, address size = 2
    [junit] Test: regions = 4 (4), region size = 4, address size = 2
    [junit] Test: regions = 4 (4), region size = 8, address size = 2
    [junit] Test: regions = 4 (4), region size = 16, address size = 2
    [junit] Test: regions = 4 (4), region size = 32, address size = 2
    [junit] Test: regions = 4 (4), region size = 64, address size = 2
    [junit] Test: regions = 4 (4), region size = 128, address size = 2
    [junit] Test: regions = 4 (4), region size = 256, address size = 2
    [junit] Test: regions = 8 (8), region size = 3, address size = 3
    [junit] Test: regions = 8 (8), region size = 5, address size = 3
    [junit] Test: regions = 8 (8), region size = 7, address size = 3
    [junit] Test: regions = 8 (8), region size = 10, address size = 3
    [junit] Test: regions = 8 (8), region size = 12, address size = 3
    [junit] Test: regions = 8 (8), region size = 14, address size = 3
    [junit] Test: regions = 8 (8), region size = 18, address size = 3
    [junit] Test: regions = 8 (8), region size = 24, address size = 3
    [junit] Test: regions = 8 (8), region size = 26, address size = 3
    [junit] Test: regions = 8 (8), region size = 28, address size = 3
    [junit] Test: regions = 8 (8), region size = 1, address size = 3
    [junit] Test: regions = 8 (8), region size = 2, address size = 3
    [junit] Test: regions = 8 (8), region size = 4, address size = 3
    [junit] Test: regions = 8 (8), region size = 8, address size = 3
    [junit] Test: regions = 8 (8), region size = 16, address size = 3
    [junit] Test: regions = 8 (8), region size = 32, address size = 3
    [junit] Test: regions = 8 (8), region size = 64, address size = 3
    [junit] Test: regions = 8 (8), region size = 128, address size = 3
    [junit] Test: regions = 8 (8), region size = 256, address size = 3
    [junit] Test: regions = 16 (10), region size = 3, address size = 4
    [junit] Test: regions = 16 (10), region size = 5, address size = 4
    [junit] Test: regions = 16 (10), region size = 7, address size = 4
    [junit] Test: regions = 16 (10), region size = 10, address size = 4
    [junit] Test: regions = 16 (10), region size = 12, address size = 4
    [junit] Test: regions = 16 (10), region size = 14, address size = 4
    [junit] Test: regions = 16 (10), region size = 18, address size = 4
    [junit] Test: regions = 16 (10), region size = 24, address size = 4
    [junit] Test: regions = 16 (10), region size = 26, address size = 4
    [junit] Test: regions = 16 (10), region size = 28, address size = 4
    [junit] Test: regions = 16 (10), region size = 1, address size = 4
    [junit] Test: regions = 16 (10), region size = 2, address size = 4
    [junit] Test: regions = 16 (10), region size = 4, address size = 4
    [junit] Test: regions = 16 (10), region size = 8, address size = 4
    [junit] Test: regions = 16 (10), region size = 16, address size = 4
    [junit] Test: regions = 16 (10), region size = 32, address size = 4
    [junit] Test: regions = 16 (10), region size = 64, address size = 4
    [junit] Test: regions = 16 (10), region size = 128, address size = 4
    [junit] Test: regions = 16 (10), region size = 256, address size = 4
    [junit] Test: regions = 32 (20), region size = 3, address size = 5
    [junit] Test: regions = 32 (20), region size = 5, address size = 5
    [junit] Test: regions = 32 (20), region size = 7, address size = 5
    [junit] Test: regions = 32 (20), region size = 10, address size = 5
    [junit] Test: regions = 32 (20), region size = 12, address size = 5
    [junit] Test: regions = 32 (20), region size = 14, address size = 5
    [junit] Test: regions = 32 (20), region size = 18, address size = 5
    [junit] Test: regions = 32 (20), region size = 24, address size = 5
    [junit] Test: regions = 32 (20), region size = 26, address size = 5
    [junit] Test: regions = 32 (20), region size = 28, address size = 5
    [junit] Test: regions = 32 (20), region size = 1, address size = 5
    [junit] Test: regions = 32 (20), region size = 2, address size = 5
    [junit] Test: regions = 32 (20), region size = 4, address size = 5
    [junit] Test: regions = 32 (20), region size = 8, address size = 5
    [junit] Test: regions = 32 (20), region size = 16, address size = 5
    [junit] Test: regions = 32 (20), region size = 32, address size = 5
    [junit] Test: regions = 32 (20), region size = 64, address size = 5
    [junit] Test: regions = 32 (20), region size = 128, address size = 5
    [junit] Test: regions = 32 (20), region size = 256, address size = 5
    [junit] Test: regions = 64 (40), region size = 3, address size = 6
    [junit] Test: regions = 64 (40), region size = 5, address size = 6
    [junit] Test: regions = 64 (40), region size = 7, address size = 6
    [junit] Test: regions = 64 (40), region size = 10, address size = 6
    [junit] Test: regions = 64 (40), region size = 12, address size = 6
    [junit] Test: regions = 64 (40), region size = 14, address size = 6
    [junit] Test: regions = 64 (40), region size = 18, address size = 6
    [junit] Test: regions = 64 (40), region size = 24, address size = 6
    [junit] Test: regions = 64 (40), region size = 26, address size = 6
    [junit] Test: regions = 64 (40), region size = 28, address size = 6
    [junit] Test: regions = 64 (40), region size = 1, address size = 6
    [junit] Test: regions = 64 (40), region size = 2, address size = 6
    [junit] Test: regions = 64 (40), region size = 4, address size = 6
    [junit] Test: regions = 64 (40), region size = 8, address size = 6
    [junit] Test: regions = 64 (40), region size = 16, address size = 6
    [junit] Test: regions = 64 (40), region size = 32, address size = 6
    [junit] Test: regions = 64 (40), region size = 64, address size = 6
    [junit] Test: regions = 64 (40), region size = 128, address size = 6
    [junit] Test: regions = 64 (40), region size = 256, address size = 6
    [junit] Test: regions = 128 (80), region size = 3, address size = 7
    [junit] Test: regions = 128 (80), region size = 5, address size = 7
    [junit] Test: regions = 128 (80), region size = 7, address size = 7
    [junit] Test: regions = 128 (80), region size = 10, address size = 7
    [junit] Test: regions = 128 (80), region size = 12, address size = 7
    [junit] Test: regions = 128 (80), region size = 14, address size = 7
    [junit] Test: regions = 128 (80), region size = 18, address size = 7
    [junit] Test: regions = 128 (80), region size = 24, address size = 7
    [junit] Test: regions = 128 (80), region size = 26, address size = 7
    [junit] Test: regions = 128 (80), region size = 28, address size = 7
    [junit] Test: regions = 128 (80), region size = 1, address size = 7
    [junit] Test: regions = 128 (80), region size = 2, address size = 7
    [junit] Test: regions = 128 (80), region size = 4, address size = 7
    [junit] Test: regions = 128 (80), region size = 8, address size = 7
    [junit] Test: regions = 128 (80), region size = 16, address size = 7
    [junit] Test: regions = 128 (80), region size = 32, address size = 7
    [junit] Test: regions = 128 (80), region size = 64, address size = 7
    [junit] Test: regions = 128 (80), region size = 128, address size = 7
    [junit] Test: regions = 128 (80), region size = 256, address size = 7
    [junit] Test: regions = 256 (100), region size = 3, address size = 8
    [junit] Test: regions = 256 (100), region size = 5, address size = 8
    [junit] Test: regions = 256 (100), region size = 7, address size = 8
    [junit] Test: regions = 256 (100), region size = 10, address size = 8
    [junit] Test: regions = 256 (100), region size = 12, address size = 8
    [junit] Test: regions = 256 (100), region size = 14, address size = 8
    [junit] Test: regions = 256 (100), region size = 18, address size = 8
    [junit] Test: regions = 256 (100), region size = 24, address size = 8
    [junit] Test: regions = 256 (100), region size = 26, address size = 8
    [junit] Test: regions = 256 (100), region size = 28, address size = 8
    [junit] Test: regions = 256 (100), region size = 1, address size = 8
    [junit] Test: regions = 256 (100), region size = 2, address size = 8
    [junit] Test: regions = 256 (100), region size = 4, address size = 8
    [junit] Test: regions = 256 (100), region size = 8, address size = 8
    [junit] Test: regions = 256 (100), region size = 16, address size = 8
    [junit] Test: regions = 256 (100), region size = 32, address size = 8
    [junit] Test: regions = 256 (100), region size = 64, address size = 8
    [junit] Test: regions = 256 (100), region size = 128, address size = 8
    [junit] Test: regions = 256 (100), region size = 256, address size = 8
    [junit] Test: regions = 512 (200), region size = 3, address size = 9
    [junit] Test: regions = 512 (200), region size = 5, address size = 9
    [junit] Test: regions = 512 (200), region size = 7, address size = 9
    [junit] Test: regions = 512 (200), region size = 10, address size = 9
    [junit] Test: regions = 512 (200), region size = 12, address size = 9
    [junit] Test: regions = 512 (200), region size = 14, address size = 9
    [junit] Test: regions = 512 (200), region size = 18, address size = 9
    [junit] Test: regions = 512 (200), region size = 24, address size = 9
    [junit] Test: regions = 512 (200), region size = 26, address size = 9
    [junit] Test: regions = 512 (200), region size = 28, address size = 9
    [junit] Test: regions = 512 (200), region size = 1, address size = 9
    [junit] Test: regions = 512 (200), region size = 2, address size = 9
    [junit] Test: regions = 512 (200), region size = 4, address size = 9
    [junit] Test: regions = 512 (200), region size = 8, address size = 9
    [junit] Test: regions = 512 (200), region size = 16, address size = 9
    [junit] Test: regions = 512 (200), region size = 32, address size = 9
    [junit] Test: regions = 512 (200), region size = 64, address size = 9
    [junit] Test: regions = 512 (200), region size = 128, address size = 9
    [junit] Test: regions = 512 (200), region size = 256, address size = 9
    [junit] Test: regions = 1024 (400), region size = 3, address size = 10
    [junit] Test: regions = 1024 (400), region size = 5, address size = 10
    [junit] Test: regions = 1024 (400), region size = 7, address size = 10
    [junit] Test: regions = 1024 (400), region size = 10, address size = 10
    [junit] Test: regions = 1024 (400), region size = 12, address size = 10
    [junit] Test: regions = 1024 (400), region size = 14, address size = 10
    [junit] Test: regions = 1024 (400), region size = 18, address size = 10
    [junit] Test: regions = 1024 (400), region size = 24, address size = 10
    [junit] Test: regions = 1024 (400), region size = 26, address size = 10
    [junit] Test: regions = 1024 (400), region size = 28, address size = 10
    [junit] Test: regions = 1024 (400), region size = 1, address size = 10
    [junit] Test: regions = 1024 (400), region size = 2, address size = 10
    [junit] Test: regions = 1024 (400), region size = 4, address size = 10
    [junit] Test: regions = 1024 (400), region size = 8, address size = 10
    [junit] Test: regions = 1024 (400), region size = 16, address size = 10
    [junit] Test: regions = 1024 (400), region size = 32, address size = 10
    [junit] Test: regions = 1024 (400), region size = 64, address size = 10
    [junit] Test: regions = 1024 (400), region size = 128, address size = 10
    [junit] Test: regions = 1024 (400), region size = 256, address size = 10
    [junit] Test: regions = 2048 (800), region size = 3, address size = 11
    [junit] Test: regions = 2048 (800), region size = 5, address size = 11
    [junit] Test: regions = 2048 (800), region size = 7, address size = 11
    [junit] Test: regions = 2048 (800), region size = 10, address size = 11
    [junit] Test: regions = 2048 (800), region size = 12, address size = 11
    [junit] Test: regions = 2048 (800), region size = 14, address size = 11
    [junit] Test: regions = 2048 (800), region size = 18, address size = 11
    [junit] Test: regions = 2048 (800), region size = 24, address size = 11
    [junit] Test: regions = 2048 (800), region size = 26, address size = 11
    [junit] Test: regions = 2048 (800), region size = 28, address size = 11
    [junit] Test: regions = 2048 (800), region size = 1, address size = 11
    [junit] Test: regions = 2048 (800), region size = 2, address size = 11
    [junit] Test: regions = 2048 (800), region size = 4, address size = 11
    [junit] Test: regions = 2048 (800), region size = 8, address size = 11
    [junit] Test: regions = 2048 (800), region size = 16, address size = 11
    [junit] Test: regions = 2048 (800), region size = 32, address size = 11
    [junit] Test: regions = 2048 (800), region size = 64, address size = 11
    [junit] Test: regions = 2048 (800), region size = 128, address size = 11
    [junit] Test: regions = 2048 (800), region size = 256, address size = 11
    [junit] Test: regions = 4096 (1000), region size = 3, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 5, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 7, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 10, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 12, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 14, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 18, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 24, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 26, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 28, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 1, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 2, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 4, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 8, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 16, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 32, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 64, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 128, address size = 12
    [junit] Test: regions = 4096 (1000), region size = 256, address size = 12
    [junit] Test: regions = 8192 (2000), region size = 3, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 5, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 7, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 10, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 12, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 14, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 18, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 24, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 26, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 28, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 1, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 2, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 4, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 8, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 16, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 32, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 64, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 128, address size = 13
    [junit] Test: regions = 8192 (2000), region size = 256, address size = 13
    [junit] Test: regions = 16384 (4000), region size = 3, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 5, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 7, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 10, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 12, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 14, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 18, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 24, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 26, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 28, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 1, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 2, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 4, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 8, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 16, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 32, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 64, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 128, address size = 14
    [junit] Test: regions = 16384 (4000), region size = 256, address size = 14
    [junit] Test: regions = 32768 (8000), region size = 3, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 5, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 7, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 10, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 12, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 14, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 18, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 24, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 26, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 28, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 1, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 2, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 4, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 8, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 16, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 32, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 64, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 128, address size = 15
    [junit] Test: regions = 32768 (8000), region size = 256, address size = 15
    [junit] Test: regions = 65536 (10000), region size = 3, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 5, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 7, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 10, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 12, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 14, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 18, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 24, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 26, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 28, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 1, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 2, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 4, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 8, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 16, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 32, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 64, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 128, address size = 16
    [junit] Test: regions = 65536 (10000), region size = 256, address size = 16
    [junit] Test: regions = 131072 (20000), region size = 3, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 5, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 7, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 10, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 12, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 14, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 18, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 24, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 26, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 28, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 1, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 2, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 4, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 8, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 16, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 32, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 64, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 128, address size = 17
    [junit] Test: regions = 131072 (20000), region size = 256, address size = 17
    [junit] Test: regions = 262144 (40000), region size = 3, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 5, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 7, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 10, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 12, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 14, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 18, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 24, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 26, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 28, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 1, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 2, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 4, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 8, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 16, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 32, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 64, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 128, address size = 18
    [junit] Test: regions = 262144 (40000), region size = 256, address size = 18
    [junit] Test: regions = 524288 (80000), region size = 3, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 5, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 7, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 10, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 12, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 14, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 18, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 24, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 26, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 28, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 1, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 2, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 4, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 8, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 16, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 32, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 64, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 128, address size = 19
    [junit] Test: regions = 524288 (80000), region size = 256, address size = 19
    [junit] Test: regions = 1048576 (100000), region size = 3, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 5, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 7, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 10, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 12, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 14, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 18, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 24, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 26, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 28, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 1, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 2, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 4, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 8, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 16, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 32, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 64, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 128, address size = 20
    [junit] Test: regions = 1048576 (100000), region size = 256, address size = 20
    [junit] Test: regions = 2097152 (200000), region size = 3, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 5, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 7, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 10, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 12, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 14, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 18, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 24, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 26, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 28, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 1, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 2, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 4, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 8, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 16, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 32, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 64, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 128, address size = 21
    [junit] Test: regions = 2097152 (200000), region size = 256, address size = 21
    [junit] Test: regions = 4194304 (400000), region size = 3, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 5, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 7, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 10, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 12, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 14, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 18, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 24, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 26, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 28, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 1, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 2, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 4, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 8, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 16, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 32, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 64, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 128, address size = 22
    [junit] Test: regions = 4194304 (400000), region size = 256, address size = 22
    [junit] Test: regions = 8388608 (800000), region size = 3, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 5, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 7, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 10, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 12, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 14, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 18, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 24, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 26, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 28, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 1, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 2, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 4, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 8, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 16, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 32, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 64, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 128, address size = 23
    [junit] Test: regions = 8388608 (800000), region size = 256, address size = 23
    [junit] Test: regions = 16777216 (1000000), region size = 3, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 5, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 7, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 10, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 12, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 14, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 18, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 24, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 26, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 28, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 1, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 2, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 4, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 8, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 16, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 32, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 64, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 128, address size = 24
    [junit] Test: regions = 16777216 (1000000), region size = 256, address size = 24
    [junit] Test: regions = 33554432 (2000000), region size = 3, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 5, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 7, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 10, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 12, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 14, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 18, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 24, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 26, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 28, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 1, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 2, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 4, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 8, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 16, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 32, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 64, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 128, address size = 25
    [junit] Test: regions = 33554432 (2000000), region size = 256, address size = 25
    [junit] Test: regions = 67108864 (4000000), region size = 3, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 5, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 7, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 10, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 12, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 14, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 18, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 24, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 26, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 28, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 1, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 2, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 4, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 8, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 16, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 32, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 64, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 128, address size = 26
    [junit] Test: regions = 67108864 (4000000), region size = 256, address size = 26
    [junit] Test: regions = 134217728 (8000000), region size = 3, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 5, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 7, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 10, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 12, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 14, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 18, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 24, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 26, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 28, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 1, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 2, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 4, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 8, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 16, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 32, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 64, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 128, address size = 27
    [junit] Test: regions = 134217728 (8000000), region size = 256, address size = 27
    [junit] Test: regions = 268435456 (10000000), region size = 3, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 5, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 7, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 10, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 12, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 14, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 18, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 24, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 26, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 28, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 1, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 2, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 4, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 8, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 16, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 32, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 64, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 128, address size = 28
    [junit] Test: regions = 268435456 (10000000), region size = 256, address size = 28
    [junit] Test: regions = 536870912 (20000000), region size = 3, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 5, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 7, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 10, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 12, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 14, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 18, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 24, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 26, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 28, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 1, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 2, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 4, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 8, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 16, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 32, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 64, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 128, address size = 29
    [junit] Test: regions = 536870912 (20000000), region size = 256, address size = 29
    [junit] Test: regions = 1073741824 (40000000), region size = 3, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 5, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 7, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 10, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 12, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 14, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 18, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 24, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 26, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 28, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 1, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 2, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 4, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 8, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 16, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 32, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 64, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 128, address size = 30
    [junit] Test: regions = 1073741824 (40000000), region size = 256, address size = 30
    [junit] Test: regions = 2147483648 (80000000), region size = 3, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 5, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 7, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 10, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 12, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 14, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 18, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 24, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 26, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 28, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 1, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 2, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 4, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 8, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 16, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 32, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 64, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 128, address size = 31
    [junit] Test: regions = 2147483648 (80000000), region size = 256, address size = 31
    [junit] Test: regions = 4294967296 (100000000), region size = 3, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 5, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 7, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 10, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 12, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 14, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 18, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 24, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 26, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 28, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 1, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 2, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 4, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 8, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 16, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 32, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 64, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 128, address size = 32
    [junit] Test: regions = 4294967296 (100000000), region size = 256, address size = 32
    [junit] Test: regions = 8589934592 (200000000), region size = 3, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 5, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 7, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 10, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 12, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 14, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 18, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 24, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 26, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 28, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 1, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 2, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 4, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 8, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 16, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 32, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 64, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 128, address size = 33
    [junit] Test: regions = 8589934592 (200000000), region size = 256, address size = 33
    [junit] Test: regions = 17179869184 (400000000), region size = 3, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 5, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 7, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 10, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 12, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 14, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 18, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 24, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 26, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 28, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 1, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 2, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 4, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 8, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 16, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 32, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 64, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 128, address size = 34
    [junit] Test: regions = 17179869184 (400000000), region size = 256, address size = 34
    [junit] Test: regions = 34359738368 (800000000), region size = 3, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 5, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 7, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 10, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 12, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 14, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 18, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 24, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 26, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 28, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 1, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 2, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 4, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 8, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 16, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 32, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 64, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 128, address size = 35
    [junit] Test: regions = 34359738368 (800000000), region size = 256, address size = 35
    [junit] Test: regions = 68719476736 (1000000000), region size = 3, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 5, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 7, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 10, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 12, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 14, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 18, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 24, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 26, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 28, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 1, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 2, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 4, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 8, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 16, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 32, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 64, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 128, address size = 36
    [junit] Test: regions = 68719476736 (1000000000), region size = 256, address size = 36
    [junit] Test: regions = 137438953472 (2000000000), region size = 3, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 5, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 7, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 10, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 12, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 14, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 18, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 24, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 26, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 28, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 1, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 2, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 4, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 8, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 16, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 32, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 64, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 128, address size = 37
    [junit] Test: regions = 137438953472 (2000000000), region size = 256, address size = 37
    [junit] Test: regions = 274877906944 (4000000000), region size = 3, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 5, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 7, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 10, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 12, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 14, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 18, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 24, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 26, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 28, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 1, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 2, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 4, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 8, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 16, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 32, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 64, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 128, address size = 38
    [junit] Test: regions = 274877906944 (4000000000), region size = 256, address size = 38
    [junit] Test: regions = 549755813888 (8000000000), region size = 3, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 5, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 7, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 10, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 12, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 14, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 18, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 24, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 26, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 28, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 1, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 2, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 4, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 8, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 16, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 32, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 64, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 128, address size = 39
    [junit] Test: regions = 549755813888 (8000000000), region size = 256, address size = 39
    [junit] Test: regions = 1099511627776 (10000000000), region size = 3, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 5, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 7, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 10, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 12, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 14, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 18, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 24, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 26, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 28, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 1, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 2, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 4, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 8, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 16, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 32, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 64, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 128, address size = 40
    [junit] Test: regions = 1099511627776 (10000000000), region size = 256, address size = 40
    [junit] Test: regions = 2199023255552 (20000000000), region size = 3, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 5, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 7, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 10, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 12, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 14, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 18, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 24, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 26, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 28, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 1, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 2, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 4, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 8, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 16, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 32, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 64, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 128, address size = 41
    [junit] Test: regions = 2199023255552 (20000000000), region size = 256, address size = 41
    [junit] Test: regions = 4398046511104 (40000000000), region size = 3, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 5, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 7, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 10, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 12, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 14, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 18, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 24, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 26, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 28, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 1, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 2, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 4, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 8, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 16, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 32, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 64, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 128, address size = 42
    [junit] Test: regions = 4398046511104 (40000000000), region size = 256, address size = 42
    [junit] Test: regions = 8796093022208 (80000000000), region size = 3, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 5, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 7, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 10, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 12, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 14, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 18, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 24, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 26, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 28, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 1, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 2, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 4, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 8, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 16, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 32, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 64, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 128, address size = 43
    [junit] Test: regions = 8796093022208 (80000000000), region size = 256, address size = 43
    [junit] Test: regions = 17592186044416 (100000000000), region size = 3, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 5, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 7, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 10, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 12, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 14, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 18, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 24, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 26, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 28, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 1, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 2, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 4, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 8, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 16, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 32, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 64, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 128, address size = 44
    [junit] Test: regions = 17592186044416 (100000000000), region size = 256, address size = 44
    [junit] Test: regions = 35184372088832 (200000000000), region size = 3, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 5, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 7, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 10, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 12, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 14, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 18, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 24, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 26, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 28, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 1, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 2, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 4, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 8, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 16, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 32, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 64, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 128, address size = 45
    [junit] Test: regions = 35184372088832 (200000000000), region size = 256, address size = 45
    [junit] Test: regions = 70368744177664 (400000000000), region size = 3, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 5, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 7, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 10, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 12, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 14, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 18, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 24, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 26, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 28, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 1, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 2, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 4, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 8, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 16, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 32, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 64, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 128, address size = 46
    [junit] Test: regions = 70368744177664 (400000000000), region size = 256, address size = 46
    [junit] Test: regions = 140737488355328 (800000000000), region size = 3, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 5, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 7, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 10, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 12, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 14, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 18, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 24, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 26, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 28, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 1, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 2, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 4, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 8, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 16, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 32, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 64, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 128, address size = 47
    [junit] Test: regions = 140737488355328 (800000000000), region size = 256, address size = 47
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 3, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 5, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 7, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 10, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 12, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 14, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 18, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 24, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 26, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 28, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 1, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 2, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 4, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 8, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 16, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 32, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 64, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 128, address size = 48
    [junit] Test: regions = 281474976710656 (1000000000000), region size = 256, address size = 48
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 3, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 5, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 7, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 10, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 12, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 14, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 18, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 24, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 26, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 28, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 1, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 2, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 4, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 8, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 16, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 32, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 64, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 128, address size = 49
    [junit] Test: regions = 562949953421312 (2000000000000), region size = 256, address size = 49
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 3, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 5, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 7, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 10, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 12, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 14, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 18, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 24, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 26, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 28, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 1, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 2, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 4, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 8, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 16, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 32, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 64, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 128, address size = 50
    [junit] Test: regions = 1125899906842624 (4000000000000), region size = 256, address size = 50
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 3, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 5, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 7, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 10, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 12, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 14, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 18, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 24, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 26, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 28, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 1, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 2, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 4, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 8, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 16, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 32, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 64, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 128, address size = 51
    [junit] Test: regions = 2251799813685248 (8000000000000), region size = 256, address size = 51
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 3, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 5, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 7, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 10, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 12, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 14, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 18, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 24, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 26, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 28, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 1, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 2, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 4, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 8, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 16, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 32, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 64, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 128, address size = 52
    [junit] Test: regions = 4503599627370496 (10000000000000), region size = 256, address size = 52
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 3, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 5, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 7, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 10, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 12, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 14, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 18, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 24, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 26, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 28, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 1, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 2, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 4, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 8, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 16, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 32, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 64, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 128, address size = 53
    [junit] Test: regions = 9007199254740992 (20000000000000), region size = 256, address size = 53
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 3, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 5, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 7, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 10, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 12, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 14, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 18, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 24, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 26, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 28, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 1, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 2, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 4, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 8, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 16, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 32, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 64, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 128, address size = 54
    [junit] Test: regions = 18014398509481984 (40000000000000), region size = 256, address size = 54
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 3, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 5, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 7, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 10, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 12, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 14, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 18, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 24, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 26, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 28, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 1, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 2, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 4, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 8, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 16, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 32, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 64, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 128, address size = 55
    [junit] Test: regions = 36028797018963968 (80000000000000), region size = 256, address size = 55
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 3, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 5, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 7, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 10, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 12, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 14, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 18, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 24, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 26, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 28, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 1, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 2, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 4, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 8, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 16, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 32, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 64, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 128, address size = 56
    [junit] Test: regions = 72057594037927936 (100000000000000), region size = 256, address size = 56
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 3, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 5, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 7, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 10, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 12, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 14, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 18, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 24, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 26, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 28, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 1, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 2, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 4, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 8, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 16, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 32, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 64, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 128, address size = 57
    [junit] Test: regions = 144115188075855872 (200000000000000), region size = 256, address size = 57
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 3, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 5, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 7, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 10, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 12, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 14, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 18, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 24, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 26, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 28, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 1, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 2, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 4, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 8, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 16, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 32, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 64, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 128, address size = 58
    [junit] Test: regions = 288230376151711744 (400000000000000), region size = 256, address size = 58
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 3, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 5, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 7, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 10, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 12, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 14, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 18, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 24, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 26, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 28, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 1, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 2, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 4, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 8, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 16, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 32, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 64, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 128, address size = 59
    [junit] Test: regions = 576460752303423488 (800000000000000), region size = 256, address size = 59
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 3, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 5, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 7, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 10, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 12, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 14, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 18, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 24, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 26, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 28, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 1, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 2, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 4, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 8, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 16, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 32, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 64, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 128, address size = 60
    [junit] Test: regions = 1152921504606846976 (1000000000000000), region size = 256, address size = 60
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 3, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 5, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 7, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 10, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 12, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 14, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 18, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 24, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 26, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 28, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 1, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 2, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 4, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 8, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 16, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 32, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 64, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 128, address size = 61
    [junit] Test: regions = 2305843009213693952 (2000000000000000), region size = 256, address size = 61
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 3, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 5, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 7, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 10, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 12, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 14, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 18, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 24, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 26, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 28, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 1, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 2, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 4, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 8, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 16, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 32, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 64, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 128, address size = 62
    [junit] Test: regions = 4611686018427387904 (4000000000000000), region size = 256, address size = 62
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 3, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 5, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 7, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 10, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 12, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 14, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 18, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 24, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 26, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 28, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 1, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 2, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 4, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 8, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 16, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 32, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 64, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 128, address size = 63
    [junit] Test: regions = 9223372036854775808 (8000000000000000), region size = 256, address size = 63
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 3, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 5, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 7, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 10, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 12, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 14, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 18, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 24, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 26, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 28, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 1, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 2, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 4, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 8, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 16, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 32, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 64, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 128, address size = 64
    [junit] Test: regions = 18446744073709551616 (10000000000000000), region size = 256, address size = 64
    [junit] ------------- ---------------- ---------------
    [junit] 
    [junit] Testcase: test took 12,601 sec
    [junit] Running ru.ispras.microtesk.test.LabelManagerTestCase
    [junit] Testsuite: ru.ispras.microtesk.test.LabelManagerTestCase
    [junit] Warning: Label x_1 at 5 was chosen, while there are other equally possible choices: x_1 at 10, x_1 at 15.
    [junit] Warning: Label x_1 at 5 was chosen, while there are other equally possible choices: x_1 at 10, x_1 at 15.
    [junit] Warning: Label x_1 at 5 was chosen, while there are other equally possible choices: x_1 at 10, x_1 at 15.
    [junit] Tests run: 7, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,01 sec
    [junit] Tests run: 7, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,01 sec
    [junit] ------------- Standard Output ---------------
    [junit] Warning: Label x_1 at 5 was chosen, while there are other equally possible choices: x_1 at 10, x_1 at 15.
    [junit] Warning: Label x_1 at 5 was chosen, while there are other equally possible choices: x_1 at 10, x_1 at 15.
    [junit] Warning: Label x_1 at 5 was chosen, while there are other equally possible choices: x_1 at 10, x_1 at 15.
    [junit] ------------- ---------------- ---------------
    [junit] 
    [junit] Testcase: testChooseCurrent took 0,003 sec
    [junit] Testcase: testSingleChoice took 0 sec
    [junit] Testcase: testChooseSibling took 0 sec
    [junit] Testcase: testChooseParent took 0,001 sec
    [junit] Testcase: testNoChoice took 0 sec
    [junit] Testcase: testChooseChild took 0 sec
    [junit] Testcase: testChooseCurrentAmbiguos took 0,001 sec
    [junit] Running ru.ispras.microtesk.test.block.BlockTestCase
    [junit] Testsuite: ru.ispras.microtesk.test.block.BlockTestCase
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,004 sec
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,004 sec
    [junit] 
    [junit] Testcase: test took 0 sec
    [junit] Running ru.ispras.microtesk.test.sequence.compositor.CompositorTestCase
    [junit] Testsuite: ru.ispras.microtesk.test.sequence.compositor.CompositorTestCase
    [junit] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,009 sec
    [junit] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,009 sec
    [junit] 
    [junit] Testcase: runNestingTest took 0,002 sec
    [junit] Testcase: runOverlappingTest took 0,001 sec
    [junit] Testcase: runCatenationTest took 0 sec
    [junit] Testcase: runRotationTest took 0 sec
    [junit] Testcase: runRandomTest took 0,002 sec
    [junit] Running ru.ispras.microtesk.test.template.BlockIdTestCase
    [junit] Testsuite: ru.ispras.microtesk.test.template.BlockIdTestCase
    [junit] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,005 sec
    [junit] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,005 sec
    [junit] 
    [junit] Testcase: testParentChild took 0 sec
    [junit] Testcase: testDistance took 0 sec
    [junit] Testcase: testEquals took 0 sec
    [junit] Running ru.ispras.microtesk.translator.nml.GeneralTestCase
    [junit] Testsuite: ru.ispras.microtesk.translator.nml.GeneralTestCase
    [junit] Translating: ./src/test/nml/general.nml
    [junit] Model name: general
    [junit] Included: ./src/test/nml/general.nml
    [junit] ru.ispras.microtesk.translator.nml.ir.IR@37b84bea
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,447 sec
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,447 sec
    [junit] ------------- Standard Output ---------------
    [junit] Translating: ./src/test/nml/general.nml
    [junit] Model name: general
    [junit] Included: ./src/test/nml/general.nml
    [junit] ru.ispras.microtesk.translator.nml.ir.IR@37b84bea
    [junit] ------------- ---------------- ---------------
    [junit] 
    [junit] Testcase: test took 0,444 sec
    [junit] Running ru.ispras.microtesk.translator.nml.LargeAddrTestCase
    [junit] Testsuite: ru.ispras.microtesk.translator.nml.LargeAddrTestCase
    [junit] Translating: ./src/test/nml/large_addr.nml
    [junit] Model name: large_addr
    [junit] Included: ./src/test/nml/large_addr.nml
    [junit] ru.ispras.microtesk.translator.nml.ir.IR@abefcf6
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,176 sec
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,176 sec
    [junit] ------------- Standard Output ---------------
    [junit] Translating: ./src/test/nml/large_addr.nml
    [junit] Model name: large_addr
    [junit] Included: ./src/test/nml/large_addr.nml
    [junit] ru.ispras.microtesk.translator.nml.ir.IR@abefcf6
    [junit] ------------- ---------------- ---------------
    [junit] 
    [junit] Testcase: test took 0,174 sec
    [junit] Running ru.ispras.microtesk.model.api.mmu.MmuTestCase
    [junit] Testsuite: ru.ispras.microtesk.model.api.mmu.MmuTestCase
    [junit] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,005 sec
    [junit] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,005 sec
    [junit] 
    [junit] Testcase: testLRU took 0,003 sec
    [junit] Testcase: testFIFO took 0 sec
    [junit] Testcase: testPLRU took 0 sec
    [junit] Testcase: testRandom took 0 sec
    [junit] Running ru.ispras.microtesk.translator.mmu.GeneralTestCase
    [junit] Testsuite: ru.ispras.microtesk.translator.mmu.GeneralTestCase
    [junit] Translating: ./src/test/mmu/general.mmu
    [junit] Model name: general
    [junit] 
    [junit] Mmu Ir:
    [junit]  addresses={VA=address VA[type [size=64, fields={}]], PA=address PA[type [size=36, fields={}]]}
    [junit]  segments={USEG=segment USEG(va: VA=type [size=64, fields={}]) range = (0x0, 0x7FFFFFFF), XUSEG=segment XUSEG(va: VA=type [size=64, fields={}]) range = (0x80000000, 0xFFFFFFFFFF), SUSEG=segment SUSEG(va: VA=type [size=64, fields={}]) range = (0x0, 0x7FFFFFFF), XSUSEG=segment XSUSEG(va: VA=type [size=64, fields={}]) range = (0x80000000, 0xFFFFFFFFFF), XSSEG=segment XSSEG(va: VA=type [size=64, fields={}]) range = (0x4000000000000000, 0x400000FFFFFFFFFF), CSSEG=segment CSSEG(va: VA=type [size=64, fields={}]) range = (0xFFFFFFFFC0000000, 0xFFFFFFFFDFFFFFFF), KUSEG=segment KUSEG(va: VA=type [size=64, fields={}]) range = (0x0, 0x7FFFFFFF), XKUSEG=segment XKUSEG(va: VA=type [size=64, fields={}]) range = (0x80000000, 0xFFFFFFFFFF), XKSSEG=segment XKSSEG(va: VA=type [size=64, fields={}]) range = (0x4000000000000000, 0x400000FFFFFFFFFF), XKSEG=segment XKSEG(va: VA=type [size=64, fields={}]) range = (0xC000000000000000, 0xC00000FF7FFFFFFF), CKSSEG=segment CKSSEG(va: VA=type [size=64, fields={}]) range = (0xFFFFFFFFC0000000, 0xFFFFFFFFDFFFFFFF), CKSEG3=segment CKSEG3(va: VA=type [size=64, fields={}]) range = (0xFFFFFFFFE0000000, 0xFFFFFFFFFFFFFFFF)}
    [junit]  buffers={JTLB=buffer JTLB(va: VA=type [size=64, fields={}]) = {ways=64, sets=1, entry=type [size=24, fields={ASID=field ASID(8, [0..7]), VPN2=field VPN2(27, [8..34]), R=field R(2, [35..36]), G0=field G0(1, [37..37]), V0=field V0(1, [38..38]), D0=field D0(1, [39..39]), C0=field C0(3, [40..42]), PFN0=field PFN0(24, [43..66]), G1=field G1(1, [67..67]), V1=field V1(1, [68..68]), D1=field D1(1, [69..69]), C1=field C1(3, [70..72]), PFN1=field PFN1(24, [73..96])}], index=0, match=(EQ entry.VPN2 (BVEXTRACT 39 13 va)), policy=NONE}, DTLB=buffer DTLB(va: VA=type [size=64, fields={}]) = {ways=4, sets=1, entry=type [size=24, fields={ASID=field ASID(8, [0..7]), VPN2=field VPN2(27, [8..34]), R=field R(2, [35..36]), G0=field G0(1, [37..37]), V0=field V0(1, [38..38]), D0=field D0(1, [39..39]), C0=field C0(3, [40..42]), PFN0=field PFN0(24, [43..66]), G1=field G1(1, [67..67]), V1=field V1(1, [68..68]), D1=field D1(1, [69..69]), C1=field C1(3, [70..72]), PFN1=field PFN1(24, [73..96])}], index=0, match=(EQ entry.VPN2 (BVEXTRACT 39 13 va)), policy=PLRU}, L1=buffer L1(pa: PA=type [size=36, fields={}]) = {ways=4, sets=128, entry=type [size=256, fields={V=field V(1, [0..0], 0x00), TAG=field TAG(24, [1..24], 0x000000), DATA=field DATA(256, [25..280], 0x0000000000000000000000000000000000000000000000000000000000000000)}], index=(BVEXTRACT 11 5 pa), match=(AND (EQ entry.V 1) (EQ entry.TAG (BVEXTRACT 35 12 pa))), policy=PLRU}, L2=buffer L2(pa: PA=type [size=36, fields={}]) = {ways=4, sets=4096, entry=type [size=256, fields={V=field V(1, [0..0], 0x00), TAG=field TAG(19, [1..19], 0x000000), DATA=field DATA(256, [20..275], 0x0000000000000000000000000000000000000000000000000000000000000000)}], index=(BVEXTRACT 16 5 pa), match=(AND (EQ entry.V 1) (EQ entry.TAG (BVEXTRACT 35 17 pa))), policy=PLRU}, Memory=buffer Memory(pa: PA=type [size=36, fields={}]) = {ways=1, sets=1, entry=type [size=256, fields={DATA=field DATA(256, [0..255])}], index=(BVEXTRACT 63 5 pa), match=0, policy=NONE}}
    [junit]  memories={pmem=mmu pmem(va: VA=type [size=64, fields={}])=(data: type [size=64, fields={}]) [vars={tlbEntry=tlbEntry: JTLB.entry=type [size=24, fields={ASID=field ASID(8, [0..7]), VPN2=field VPN2(27, [8..34]), R=field R(2, [35..36]), G0=field G0(1, [37..37]), V0=field V0(1, [38..38]), D0=field D0(1, [39..39]), C0=field C0(3, [40..42]), PFN0=field PFN0(24, [43..66]), G1=field G1(1, [67..67]), V1=field V1(1, [68..68]), D1=field D1(1, [69..69]), C1=field C1(3, [70..72]), PFN1=field PFN1(24, [73..96])}], l1Entry=l1Entry: L1.entry=type [size=256, fields={V=field V(1, [0..0], 0x00), TAG=field TAG(24, [1..24], 0x000000), DATA=field DATA(256, [25..280], 0x0000000000000000000000000000000000000000000000000000000000000000)}], l2Entry=l2Entry: L2.entry=type [size=256, fields={V=field V(1, [0..0], 0x00), TAG=field TAG(19, [1..19], 0x000000), DATA=field DATA(256, [20..275], 0x0000000000000000000000000000000000000000000000000000000000000000)}], evenOddBit=evenOddBit: type [size=5, fields={}], g=g: type [size=1, fields={}], v=v: type [size=1, fields={}], d=d: type [size=1, fields={}], c=c: type [size=3, fields={}], pfn=pfn: type [size=24, fields={}], pa=pa: PA=type [size=36, fields={}], cacheData=cacheData: type [size=256, fields={}]}, attributes=[attribute read = [StmtIf [if=[<(NOTEQ (BVEXTRACT 0 2 va) 0), [stmt exception["AddressError"]]>], else=[]], stmt assign[c = 3], StmtIf [if=[<USEG(va).hit, [StmtIf [if=[<DTLB(va).hit, [stmt assign[tlbEntry = DTLB(va).read]]>, <JTLB(va).hit, [stmt assign[tlbEntry = JTLB(va).read]]>], else=[stmt exception["TLBMiss"]]], stmt assign[evenOddBit = 12], StmtIf [if=[<(EQ (BVEXTRACT 12 12 va) 0), [stmt assign[g = tlbEntry.G0], stmt assign[v = tlbEntry.V0], stmt assign[d = tlbEntry.D0], stmt assign[c = tlbEntry.C0], stmt assign[pfn = tlbEntry.PFN0]]>], else=[stmt assign[g = tlbEntry.G1], stmt assign[v = tlbEntry.V1], stmt assign[d = tlbEntry.D1], stmt assign[c = tlbEntry.C1], stmt assign[pfn = tlbEntry.PFN1]]], StmtIf [if=[<(EQ v 1), [stmt assign[pa = (BVCONCAT (BVEXTRACT 24 0 pfn) (BVEXTRACT 11 0 va))]]>], else=[stmt exception["TLBInvalid"]]]]>], else=[stmt assign[pa = (BVEXTRACT 28 0 va)]]], StmtIf [if=[<(NOTEQ (BVEXTRACT 1 0 c) 2), [StmtIf [if=[<L1(pa).hit, [stmt assign[l1Entry = L1(pa).read], stmt assign[cacheData = l1Entry.DATA], stmt assign[data = (BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData)]]>], else=[StmtIf [if=[<(EQ (BVEXTRACT 1 0 c) 3), [StmtIf [if=[<L2(pa).hit, [stmt assign[l2Entry = L2(pa).read], stmt assign[cacheData = l2Entry.DATA], stmt assign[data = (BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData)], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = cacheData], stmt assign[L1(pa).write = l1Entry]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[data = (BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData)], stmt assign[l2Entry.V = 1], stmt assign[l2Entry.TAG = (BVEXTRACT 35 17 pa)], stmt assign[l2Entry.DATA = cacheData], stmt assign[L2(pa).write = l2Entry], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = cacheData], stmt assign[L1(pa).write = l1Entry]]]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[data = (BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData)], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = cacheData], stmt assign[L1(pa).write = l1Entry]]]]]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[data = (BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData)]]]], attribute write = [StmtIf [if=[<(NOTEQ (BVEXTRACT 0 2 va) 0), [stmt exception["AddressError"]]>], else=[]], stmt assign[c = 3], StmtIf [if=[<USEG(va).hit, [StmtIf [if=[<DTLB(va).hit, [stmt assign[tlbEntry = DTLB(va).read]]>, <JTLB(va).hit, [stmt assign[tlbEntry = JTLB(va).read]]>], else=[stmt exception["TLBMiss"]]], stmt assign[evenOddBit = 12], StmtIf [if=[<(EQ (BVEXTRACT 12 12 va) 0), [stmt assign[g = tlbEntry.G0], stmt assign[v = tlbEntry.V0], stmt assign[d = tlbEntry.D0], stmt assign[c = tlbEntry.C0], stmt assign[pfn = tlbEntry.PFN0]]>], else=[stmt assign[g = tlbEntry.G1], stmt assign[v = tlbEntry.V1], stmt assign[d = tlbEntry.D1], stmt assign[c = tlbEntry.C1], stmt assign[pfn = tlbEntry.PFN1]]], StmtIf [if=[<(EQ v 1), [StmtIf [if=[<(EQ d 1), [stmt assign[pa = (BVCONCAT (BVEXTRACT 24 0 pfn) (BVEXTRACT 11 0 va))]]>], else=[stmt exception["TLBModified"]]]]>], else=[stmt exception["TLBInvalid"]]]]>], else=[stmt assign[pa = (BVEXTRACT 28 0 va)]]], StmtIf [if=[<(NOTEQ (BVEXTRACT 1 0 c) 2), [StmtIf [if=[<L1(pa).hit, [stmt assign[l1Entry = L1(pa).read], stmt assign[(BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) l1Entry.DATA) = data], stmt assign[L1(pa).write = l1Entry], stmt assign[Memory(pa).write = l1Entry.DATA]]>], else=[StmtIf [if=[<(EQ (BVEXTRACT 1 0 c) 3), [StmtIf [if=[<L2(pa).hit, [stmt assign[l2Entry = L2(pa).read], stmt assign[(BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) l2Entry.DATA) = data], stmt assign[L2(pa).write = l2Entry], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = l2Entry.DATA], stmt assign[L1(pa).write = l1Entry], stmt assign[Memory(pa).write = l1Entry.DATA]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[(BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData) = data], stmt assign[Memory(pa).write = cacheData], stmt assign[l2Entry.V = 1], stmt assign[l2Entry.TAG = (BVEXTRACT 35 17 pa)], stmt assign[l2Entry.DATA = cacheData], stmt assign[L2(pa).write = l2Entry], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = cacheData], stmt assign[L1(pa).write = l1Entry]]]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[(BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData) = data], stmt assign[Memory(pa).write = cacheData], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = cacheData], stmt assign[L1(pa).write = l1Entry]]]]]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[(BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData) = data], stmt assign[Memory(pa).write = cacheData]]]]]]}
    [junit] ---------------------------------
    [junit] MMU:
    [junit] Addresses: 2
    [junit] VA[64]
    [junit] PA[36]
    [junit] Start address: VA[64]
    [junit] 
    [junit] Devices: 5
    [junit]     JTLB
    [junit]     DTLB
    [junit]     L1
    [junit]     L2
    [junit]     Memory
    [junit] 
    [junit] Actions: 96
    [junit] Start action: ROOT
    [junit] ROOT: 
    [junit]     Transition: {source: ROOT -> guard:[LOAD] -> target: START}
    [junit]     Transition: {source: ROOT -> guard:[STORE] -> target: START}
    [junit] START: 
    [junit]     Transition: {source: START -> guard:[VA[0:2]!=0] -> target: Branch_1[(NOTEQ (BVEXTRACT 0 2 va) 0)]}
    [junit]     Transition: {source: START -> guard:[VA[0:2]=0] -> target: Branch_2[not (NOTEQ (BVEXTRACT 0 2 va) 0)]}
    [junit]     Transition: {source: START -> guard:[VA[0:2]!=0] -> target: Branch_30[(NOTEQ (BVEXTRACT 0 2 va) 0)]}
    [junit]     Transition: {source: START -> guard:[VA[0:2]=0] -> target: Branch_31[not (NOTEQ (BVEXTRACT 0 2 va) 0)]}
    [junit] STOP: 
    [junit] Join_0: 
    [junit]     Transition: {source: Join_0 -> guard:[VA[31:63]=0] -> target: Branch_4[USEG(va).hit]}
    [junit]     Transition: {source: Join_0 -> guard:[null] -> target: Branch_16[not USEG(va).hit]}
    [junit] Branch_1[(NOTEQ (BVEXTRACT 0 2 va) 0)]: 
    [junit]     Transition: {source: Branch_1[(NOTEQ (BVEXTRACT 0 2 va) 0)] -> guard:[null] -> target: AddressError}
    [junit] AddressError: 
    [junit] Branch_2[not (NOTEQ (BVEXTRACT 0 2 va) 0)]: 
    [junit]     Transition: {source: Branch_2[not (NOTEQ (BVEXTRACT 0 2 va) 0)] -> guard:[null] -> target: Join_0}
    [junit] Join_3: 
    [junit]     Transition: {source: Join_3 -> guard:[c[1:0]!=2] -> target: Branch_18[(NOTEQ (BVEXTRACT 1 0 c) 2)]}
    [junit]     Transition: {source: Join_3 -> guard:[c[1:0]=2] -> target: Branch_28[not (NOTEQ (BVEXTRACT 1 0 c) 2)]}
    [junit] Branch_4[USEG(va).hit]: 
    [junit]     Transition: {source: Branch_4[USEG(va).hit] -> guard:[DTLB.Event=HIT] -> target: Branch_6[DTLB(va).hit]}
    [junit]     Transition: {source: Branch_4[USEG(va).hit] -> guard:[DTLB.Event=MISS] -> target: Branch_7[not DTLB(va).hit]}
    [junit] Join_5: 
    [junit]     Transition: {source: Join_5 -> guard:[VA[12]=0] -> target: Branch_11[(EQ (BVEXTRACT 12 12 va) 0)]}
    [junit]     Transition: {source: Join_5 -> guard:[VA[12]!=0] -> target: Branch_12[not (EQ (BVEXTRACT 12 12 va) 0)]}
    [junit] Branch_6[DTLB(va).hit]: 
    [junit]     Transition: {source: Branch_6[DTLB(va).hit] -> guard:[null] -> target: Assignment (tlbEntry = DTLB(va).read)}
    [junit] Assignment (tlbEntry = DTLB(va).read): 
    [junit]     Transition: {source: Assignment (tlbEntry = DTLB(va).read) -> guard:[null] -> target: Join_34}
    [junit] Branch_7[not DTLB(va).hit]: 
    [junit]     Transition: {source: Branch_7[not DTLB(va).hit] -> guard:[JTLB.Event=HIT] -> target: Branch_8[JTLB(va).hit]}
    [junit]     Transition: {source: Branch_7[not DTLB(va).hit] -> guard:[JTLB.Event=MISS] -> target: Branch_9[not JTLB(va).hit]}
    [junit] Branch_8[JTLB(va).hit]: 
    [junit]     Transition: {source: Branch_8[JTLB(va).hit] -> guard:[null] -> target: Assignment (tlbEntry = JTLB(va).read)}
    [junit] Assignment (tlbEntry = JTLB(va).read): 
    [junit]     Transition: {source: Assignment (tlbEntry = JTLB(va).read) -> guard:[null] -> target: Join_34}
    [junit] Branch_9[not JTLB(va).hit]: 
    [junit]     Transition: {source: Branch_9[not JTLB(va).hit] -> guard:[null] -> target: TLBMiss}
    [junit] TLBMiss: 
    [junit] Join_10: 
    [junit]     Transition: {source: Join_10 -> guard:[v=1] -> target: Branch_14[(EQ v 1)]}
    [junit]     Transition: {source: Join_10 -> guard:[v!=1] -> target: Branch_15[not (EQ v 1)]}
    [junit] Branch_11[(EQ (BVEXTRACT 12 12 va) 0)]: 
    [junit]     Transition: {source: Branch_11[(EQ (BVEXTRACT 12 12 va) 0)] -> guard:[null] -> target: Assignment (g = tlbEntry.G0)}
    [junit] Assignment (g = tlbEntry.G0): 
    [junit]     Transition: {source: Assignment (g = tlbEntry.G0) -> guard:[null] -> target: Assignment (v = tlbEntry.V0)}
    [junit] Assignment (v = tlbEntry.V0): 
    [junit]     Transition: {source: Assignment (v = tlbEntry.V0) -> guard:[null] -> target: Assignment (d = tlbEntry.D0)}
    [junit] Assignment (d = tlbEntry.D0): 
    [junit]     Transition: {source: Assignment (d = tlbEntry.D0) -> guard:[null] -> target: Assignment (c = tlbEntry.C0)}
    [junit] Assignment (c = tlbEntry.C0): 
    [junit]     Transition: {source: Assignment (c = tlbEntry.C0) -> guard:[null] -> target: Assignment (pfn = tlbEntry.PFN0)}
    [junit] Assignment (pfn = tlbEntry.PFN0): 
    [junit]     Transition: {source: Assignment (pfn = tlbEntry.PFN0) -> guard:[null] -> target: Join_39}
    [junit] Branch_12[not (EQ (BVEXTRACT 12 12 va) 0)]: 
    [junit]     Transition: {source: Branch_12[not (EQ (BVEXTRACT 12 12 va) 0)] -> guard:[null] -> target: Assignment (g = tlbEntry.G1)}
    [junit] Assignment (g = tlbEntry.G1): 
    [junit]     Transition: {source: Assignment (g = tlbEntry.G1) -> guard:[null] -> target: Assignment (v = tlbEntry.V1)}
    [junit] Assignment (v = tlbEntry.V1): 
    [junit]     Transition: {source: Assignment (v = tlbEntry.V1) -> guard:[null] -> target: Assignment (d = tlbEntry.D1)}
    [junit] Assignment (d = tlbEntry.D1): 
    [junit]     Transition: {source: Assignment (d = tlbEntry.D1) -> guard:[null] -> target: Assignment (c = tlbEntry.C1)}
    [junit] Assignment (c = tlbEntry.C1): 
    [junit]     Transition: {source: Assignment (c = tlbEntry.C1) -> guard:[null] -> target: Assignment (pfn = tlbEntry.PFN1)}
    [junit] Assignment (pfn = tlbEntry.PFN1): 
    [junit]     Transition: {source: Assignment (pfn = tlbEntry.PFN1) -> guard:[null] -> target: Join_39}
    [junit] Join_13: 
    [junit]     Transition: {source: Join_13 -> guard:[null] -> target: Join_3}
    [junit] Branch_14[(EQ v 1)]: 
    [junit]     Transition: {source: Branch_14[(EQ v 1)] -> guard:[null] -> target: Assignment (pa = (BVCONCAT (BVEXTRACT 24 0 pfn) (BVEXTRACT 11 0 va)))}
    [junit] Assignment (pa = (BVCONCAT (BVEXTRACT 24 0 pfn) (BVEXTRACT 11 0 va))): 
    [junit]     Transition: {source: Assignment (pa = (BVCONCAT (BVEXTRACT 24 0 pfn) (BVEXTRACT 11 0 va))) -> guard:[null] -> target: Join_44}
    [junit] Branch_15[not (EQ v 1)]: 
    [junit]     Transition: {source: Branch_15[not (EQ v 1)] -> guard:[null] -> target: TLBInvalid}
    [junit] TLBInvalid: 
    [junit] Branch_16[not USEG(va).hit]: 
    [junit]     Transition: {source: Branch_16[not USEG(va).hit] -> guard:[null] -> target: Assignment (pa = (BVEXTRACT 28 0 va))}
    [junit] Assignment (pa = (BVEXTRACT 28 0 va)): 
    [junit]     Transition: {source: Assignment (pa = (BVEXTRACT 28 0 va)) -> guard:[null] -> target: Join_32}
    [junit] Join_17: 
    [junit]     Transition: {source: Join_17 -> guard:[null] -> target: STOP}
    [junit] Branch_18[(NOTEQ (BVEXTRACT 1 0 c) 2)]: 
    [junit]     Transition: {source: Branch_18[(NOTEQ (BVEXTRACT 1 0 c) 2)] -> guard:[L1.Event=HIT] -> target: Branch_20[L1(pa).hit]}
    [junit]     Transition: {source: Branch_18[(NOTEQ (BVEXTRACT 1 0 c) 2)] -> guard:[L1.Event=MISS] -> target: Branch_21[not L1(pa).hit]}
    [junit] Join_19: 
    [junit]     Transition: {source: Join_19 -> guard:[null] -> target: Join_17}
    [junit] Branch_20[L1(pa).hit]: 
    [junit]     Transition: {source: Branch_20[L1(pa).hit] -> guard:[null] -> target: Assignment (l1Entry = L1(pa).read)}
    [junit] Assignment (l1Entry = L1(pa).read): 
    [junit]     Transition: {source: Assignment (l1Entry = L1(pa).read) -> guard:[null] -> target: Assignment (L1(pa).write = l1Entry)}
    [junit] Assignment (cacheData = l1Entry.DATA): 
    [junit]     Transition: {source: Assignment (cacheData = l1Entry.DATA) -> guard:[null] -> target: Join_19}
    [junit] Branch_21[not L1(pa).hit]: 
    [junit]     Transition: {source: Branch_21[not L1(pa).hit] -> guard:[c[1:0]=3] -> target: Branch_23[(EQ (BVEXTRACT 1 0 c) 3)]}
    [junit]     Transition: {source: Branch_21[not L1(pa).hit] -> guard:[c[1:0]!=3] -> target: Branch_27[not (EQ (BVEXTRACT 1 0 c) 3)]}
    [junit] Join_22: 
    [junit]     Transition: {source: Join_22 -> guard:[null] -> target: Join_19}
    [junit] Branch_23[(EQ (BVEXTRACT 1 0 c) 3)]: 
    [junit]     Transition: {source: Branch_23[(EQ (BVEXTRACT 1 0 c) 3)] -> guard:[L2.Event=HIT] -> target: Branch_25[L2(pa).hit]}
    [junit]     Transition: {source: Branch_23[(EQ (BVEXTRACT 1 0 c) 3)] -> guard:[L2.Event=MISS] -> target: Branch_26[not L2(pa).hit]}
    [junit] Join_24: 
    [junit]     Transition: {source: Join_24 -> guard:[null] -> target: Join_22}
    [junit] Branch_25[L2(pa).hit]: 
    [junit]     Transition: {source: Branch_25[L2(pa).hit] -> guard:[null] -> target: Assignment (l2Entry = L2(pa).read)}
    [junit] Assignment (l2Entry = L2(pa).read): 
    [junit]     Transition: {source: Assignment (l2Entry = L2(pa).read) -> guard:[null] -> target: Assignment (L2(pa).write = l2Entry)}
    [junit] Assignment (cacheData = l2Entry.DATA): 
    [junit]     Transition: {source: Assignment (cacheData = l2Entry.DATA) -> guard:[null] -> target: Assignment (l1Entry.TAG = (BVEXTRACT 35 12 pa))}
    [junit] Assignment (l1Entry.TAG = (BVEXTRACT 35 12 pa)): 
    [junit]     Transition: {source: Assignment (l1Entry.TAG = (BVEXTRACT 35 12 pa)) -> guard:[null] -> target: Assignment (l1Entry.DATA = cacheData)}
    [junit] Assignment (l1Entry.DATA = cacheData): 
    [junit]     Transition: {source: Assignment (l1Entry.DATA = cacheData) -> guard:[null] -> target: Assignment (L1(pa).write = l1Entry)}
    [junit] Assignment (L1(pa).write = l1Entry): 
    [junit]     Transition: {source: Assignment (L1(pa).write = l1Entry) -> guard:[null] -> target: Join_54}
    [junit] Branch_26[not L2(pa).hit]: 
    [junit]     Transition: {source: Branch_26[not L2(pa).hit] -> guard:[null] -> target: Assignment (cacheData = Memory(pa).read)}
    [junit] Assignment (cacheData = Memory(pa).read): 
    [junit]     Transition: {source: Assignment (cacheData = Memory(pa).read) -> guard:[null] -> target: Assignment (Memory(pa).write = cacheData)}
    [junit] Assignment (l2Entry.TAG = (BVEXTRACT 35 17 pa)): 
    [junit]     Transition: {source: Assignment (l2Entry.TAG = (BVEXTRACT 35 17 pa)) -> guard:[null] -> target: Assignment (l2Entry.DATA = cacheData)}
    [junit] Assignment (l2Entry.DATA = cacheData): 
    [junit]     Transition: {source: Assignment (l2Entry.DATA = cacheData) -> guard:[null] -> target: Assignment (L2(pa).write = l2Entry)}
    [junit] Assignment (L2(pa).write = l2Entry): 
    [junit]     Transition: {source: Assignment (L2(pa).write = l2Entry) -> guard:[null] -> target: Assignment (l1Entry.TAG = (BVEXTRACT 35 12 pa))}
    [junit] Branch_27[not (EQ (BVEXTRACT 1 0 c) 3)]: 
    [junit]     Transition: {source: Branch_27[not (EQ (BVEXTRACT 1 0 c) 3)] -> guard:[null] -> target: Assignment (cacheData = Memory(pa).read)}
    [junit] Branch_28[not (NOTEQ (BVEXTRACT 1 0 c) 2)]: 
    [junit]     Transition: {source: Branch_28[not (NOTEQ (BVEXTRACT 1 0 c) 2)] -> guard:[null] -> target: Assignment (cacheData = Memory(pa).read)}
    [junit] Join_29: 
    [junit]     Transition: {source: Join_29 -> guard:[VA[31:63]=0] -> target: Branch_33[USEG(va).hit]}
    [junit]     Transition: {source: Join_29 -> guard:[null] -> target: Branch_48[not USEG(va).hit]}
    [junit] Branch_30[(NOTEQ (BVEXTRACT 0 2 va) 0)]: 
    [junit]     Transition: {source: Branch_30[(NOTEQ (BVEXTRACT 0 2 va) 0)] -> guard:[null] -> target: AddressError}
    [junit] Branch_31[not (NOTEQ (BVEXTRACT 0 2 va) 0)]: 
    [junit]     Transition: {source: Branch_31[not (NOTEQ (BVEXTRACT 0 2 va) 0)] -> guard:[null] -> target: Join_29}
    [junit] Join_32: 
    [junit]     Transition: {source: Join_32 -> guard:[c[1:0]!=2] -> target: Branch_50[(NOTEQ (BVEXTRACT 1 0 c) 2)]}
    [junit]     Transition: {source: Join_32 -> guard:[c[1:0]=2] -> target: Branch_60[not (NOTEQ (BVEXTRACT 1 0 c) 2)]}
    [junit] Branch_33[USEG(va).hit]: 
    [junit]     Transition: {source: Branch_33[USEG(va).hit] -> guard:[DTLB.Event=HIT] -> target: Branch_35[DTLB(va).hit]}
    [junit]     Transition: {source: Branch_33[USEG(va).hit] -> guard:[DTLB.Event=MISS] -> target: Branch_36[not DTLB(va).hit]}
    [junit] Join_34: 
    [junit]     Transition: {source: Join_34 -> guard:[VA[12]=0] -> target: Branch_40[(EQ (BVEXTRACT 12 12 va) 0)]}
    [junit]     Transition: {source: Join_34 -> guard:[VA[12]!=0] -> target: Branch_41[not (EQ (BVEXTRACT 12 12 va) 0)]}
    [junit] Branch_35[DTLB(va).hit]: 
    [junit]     Transition: {source: Branch_35[DTLB(va).hit] -> guard:[null] -> target: Assignment (tlbEntry = DTLB(va).read)}
    [junit] Branch_36[not DTLB(va).hit]: 
    [junit]     Transition: {source: Branch_36[not DTLB(va).hit] -> guard:[JTLB.Event=HIT] -> target: Branch_37[JTLB(va).hit]}
    [junit]     Transition: {source: Branch_36[not DTLB(va).hit] -> guard:[JTLB.Event=MISS] -> target: Branch_38[not JTLB(va).hit]}
    [junit] Branch_37[JTLB(va).hit]: 
    [junit]     Transition: {source: Branch_37[JTLB(va).hit] -> guard:[null] -> target: Assignment (tlbEntry = JTLB(va).read)}
    [junit] Branch_38[not JTLB(va).hit]: 
    [junit]     Transition: {source: Branch_38[not JTLB(va).hit] -> guard:[null] -> target: TLBMiss}
    [junit] Join_39: 
    [junit]     Transition: {source: Join_39 -> guard:[v=1] -> target: Branch_43[(EQ v 1)]}
    [junit]     Transition: {source: Join_39 -> guard:[v!=1] -> target: Branch_47[not (EQ v 1)]}
    [junit] Branch_40[(EQ (BVEXTRACT 12 12 va) 0)]: 
    [junit]     Transition: {source: Branch_40[(EQ (BVEXTRACT 12 12 va) 0)] -> guard:[null] -> target: Assignment (g = tlbEntry.G0)}
    [junit] Branch_41[not (EQ (BVEXTRACT 12 12 va) 0)]: 
    [junit]     Transition: {source: Branch_41[not (EQ (BVEXTRACT 12 12 va) 0)] -> guard:[null] -> target: Assignment (g = tlbEntry.G1)}
    [junit] Join_42: 
    [junit]     Transition: {source: Join_42 -> guard:[null] -> target: Join_32}
    [junit] Branch_43[(EQ v 1)]: 
    [junit]     Transition: {source: Branch_43[(EQ v 1)] -> guard:[d=1] -> target: Branch_45[(EQ d 1)]}
    [junit]     Transition: {source: Branch_43[(EQ v 1)] -> guard:[d!=1] -> target: Branch_46[not (EQ d 1)]}
    [junit] Join_44: 
    [junit]     Transition: {source: Join_44 -> guard:[null] -> target: Join_42}
    [junit] Branch_45[(EQ d 1)]: 
    [junit]     Transition: {source: Branch_45[(EQ d 1)] -> guard:[null] -> target: Assignment (pa = (BVCONCAT (BVEXTRACT 24 0 pfn) (BVEXTRACT 11 0 va)))}
    [junit] Branch_46[not (EQ d 1)]: 
    [junit]     Transition: {source: Branch_46[not (EQ d 1)] -> guard:[null] -> target: TLBModified}
    [junit] TLBModified: 
    [junit] Branch_47[not (EQ v 1)]: 
    [junit]     Transition: {source: Branch_47[not (EQ v 1)] -> guard:[null] -> target: TLBInvalid}
    [junit] Branch_48[not USEG(va).hit]: 
    [junit]     Transition: {source: Branch_48[not USEG(va).hit] -> guard:[null] -> target: Assignment (pa = (BVEXTRACT 28 0 va))}
    [junit] Join_49: 
    [junit]     Transition: {source: Join_49 -> guard:[null] -> target: STOP}
    [junit] Branch_50[(NOTEQ (BVEXTRACT 1 0 c) 2)]: 
    [junit]     Transition: {source: Branch_50[(NOTEQ (BVEXTRACT 1 0 c) 2)] -> guard:[L1.Event=HIT] -> target: Branch_52[L1(pa).hit]}
    [junit]     Transition: {source: Branch_50[(NOTEQ (BVEXTRACT 1 0 c) 2)] -> guard:[L1.Event=MISS] -> target: Branch_53[not L1(pa).hit]}
    [junit] Join_51: 
    [junit]     Transition: {source: Join_51 -> guard:[null] -> target: Join_49}
    [junit] Branch_52[L1(pa).hit]: 
    [junit]     Transition: {source: Branch_52[L1(pa).hit] -> guard:[null] -> target: Assignment (l1Entry = L1(pa).read)}
    [junit] Assignment (Memory(pa).write = l1Entry.DATA): 
    [junit]     Transition: {source: Assignment (Memory(pa).write = l1Entry.DATA) -> guard:[null] -> target: Join_56}
    [junit] Branch_53[not L1(pa).hit]: 
    [junit]     Transition: {source: Branch_53[not L1(pa).hit] -> guard:[c[1:0]=3] -> target: Branch_55[(EQ (BVEXTRACT 1 0 c) 3)]}
    [junit]     Transition: {source: Branch_53[not L1(pa).hit] -> guard:[c[1:0]!=3] -> target: Branch_59[not (EQ (BVEXTRACT 1 0 c) 3)]}
    [junit] Join_54: 
    [junit]     Transition: {source: Join_54 -> guard:[null] -> target: Join_51}
    [junit] Branch_55[(EQ (BVEXTRACT 1 0 c) 3)]: 
    [junit]     Transition: {source: Branch_55[(EQ (BVEXTRACT 1 0 c) 3)] -> guard:[L2.Event=HIT] -> target: Branch_57[L2(pa).hit]}
    [junit]     Transition: {source: Branch_55[(EQ (BVEXTRACT 1 0 c) 3)] -> guard:[L2.Event=MISS] -> target: Branch_58[not L2(pa).hit]}
    [junit] Join_56: 
    [junit]     Transition: {source: Join_56 -> guard:[null] -> target: Join_54}
    [junit] Branch_57[L2(pa).hit]: 
    [junit]     Transition: {source: Branch_57[L2(pa).hit] -> guard:[null] -> target: Assignment (l2Entry = L2(pa).read)}
    [junit] Assignment (l1Entry.DATA = l2Entry.DATA): 
    [junit]     Transition: {source: Assignment (l1Entry.DATA = l2Entry.DATA) -> guard:[null] -> target: Assignment (L1(pa).write = l1Entry)}
    [junit] Branch_58[not L2(pa).hit]: 
    [junit]     Transition: {source: Branch_58[not L2(pa).hit] -> guard:[null] -> target: Assignment (cacheData = Memory(pa).read)}
    [junit] Assignment (Memory(pa).write = cacheData): 
    [junit]     Transition: {source: Assignment (Memory(pa).write = cacheData) -> guard:[null] -> target: Join_49}
    [junit] Branch_59[not (EQ (BVEXTRACT 1 0 c) 3)]: 
    [junit]     Transition: {source: Branch_59[not (EQ (BVEXTRACT 1 0 c) 3)] -> guard:[null] -> target: Assignment (cacheData = Memory(pa).read)}
    [junit] Branch_60[not (NOTEQ (BVEXTRACT 1 0 c) 2)]: 
    [junit]     Transition: {source: Branch_60[not (NOTEQ (BVEXTRACT 1 0 c) 2)] -> guard:[null] -> target: Assignment (cacheData = Memory(pa).read)}
    [junit] 
    [junit] Mmu Ir:
    [junit]  addresses={VA=address VA[type [size=64, fields={}]], PA=address PA[type [size=36, fields={}]]}
    [junit]  segments={USEG=segment USEG(va: VA=type [size=64, fields={}]) range = (0x0, 0x7FFFFFFF), XUSEG=segment XUSEG(va: VA=type [size=64, fields={}]) range = (0x80000000, 0xFFFFFFFFFF), SUSEG=segment SUSEG(va: VA=type [size=64, fields={}]) range = (0x0, 0x7FFFFFFF), XSUSEG=segment XSUSEG(va: VA=type [size=64, fields={}]) range = (0x80000000, 0xFFFFFFFFFF), XSSEG=segment XSSEG(va: VA=type [size=64, fields={}]) range = (0x4000000000000000, 0x400000FFFFFFFFFF), CSSEG=segment CSSEG(va: VA=type [size=64, fields={}]) range = (0xFFFFFFFFC0000000, 0xFFFFFFFFDFFFFFFF), KUSEG=segment KUSEG(va: VA=type [size=64, fields={}]) range = (0x0, 0x7FFFFFFF), XKUSEG=segment XKUSEG(va: VA=type [size=64, fields={}]) range = (0x80000000, 0xFFFFFFFFFF), XKSSEG=segment XKSSEG(va: VA=type [size=64, fields={}]) range = (0x4000000000000000, 0x400000FFFFFFFFFF), XKSEG=segment XKSEG(va: VA=type [size=64, fields={}]) range = (0xC000000000000000, 0xC00000FF7FFFFFFF), CKSSEG=segment CKSSEG(va: VA=type [size=64, fields={}]) range = (0xFFFFFFFFC0000000, 0xFFFFFFFFDFFFFFFF), CKSEG3=segment CKSEG3(va: VA=type [size=64, fields={}]) range = (0xFFFFFFFFE0000000, 0xFFFFFFFFFFFFFFFF)}
    [junit]  buffers={JTLB=buffer JTLB(va: VA=type [size=64, fields={}]) = {ways=64, sets=1, entry=type [size=24, fields={ASID=field ASID(8, [0..7]), VPN2=field VPN2(27, [8..34]), R=field R(2, [35..36]), G0=field G0(1, [37..37]), V0=field V0(1, [38..38]), D0=field D0(1, [39..39]), C0=field C0(3, [40..42]), PFN0=field PFN0(24, [43..66]), G1=field G1(1, [67..67]), V1=field V1(1, [68..68]), D1=field D1(1, [69..69]), C1=field C1(3, [70..72]), PFN1=field PFN1(24, [73..96])}], index=0, match=(EQ entry.VPN2 (BVEXTRACT 39 13 va)), policy=NONE}, DTLB=buffer DTLB(va: VA=type [size=64, fields={}]) = {ways=4, sets=1, entry=type [size=24, fields={ASID=field ASID(8, [0..7]), VPN2=field VPN2(27, [8..34]), R=field R(2, [35..36]), G0=field G0(1, [37..37]), V0=field V0(1, [38..38]), D0=field D0(1, [39..39]), C0=field C0(3, [40..42]), PFN0=field PFN0(24, [43..66]), G1=field G1(1, [67..67]), V1=field V1(1, [68..68]), D1=field D1(1, [69..69]), C1=field C1(3, [70..72]), PFN1=field PFN1(24, [73..96])}], index=0, match=(EQ entry.VPN2 (BVEXTRACT 39 13 va)), policy=PLRU}, L1=buffer L1(pa: PA=type [size=36, fields={}]) = {ways=4, sets=128, entry=type [size=256, fields={V=field V(1, [0..0], 0x00), TAG=field TAG(24, [1..24], 0x000000), DATA=field DATA(256, [25..280], 0x0000000000000000000000000000000000000000000000000000000000000000)}], index=(BVEXTRACT 11 5 pa), match=(AND (EQ entry.V 1) (EQ entry.TAG (BVEXTRACT 35 12 pa))), policy=PLRU}, L2=buffer L2(pa: PA=type [size=36, fields={}]) = {ways=4, sets=4096, entry=type [size=256, fields={V=field V(1, [0..0], 0x00), TAG=field TAG(19, [1..19], 0x000000), DATA=field DATA(256, [20..275], 0x0000000000000000000000000000000000000000000000000000000000000000)}], index=(BVEXTRACT 16 5 pa), match=(AND (EQ entry.V 1) (EQ entry.TAG (BVEXTRACT 35 17 pa))), policy=PLRU}, Memory=buffer Memory(pa: PA=type [size=36, fields={}]) = {ways=1, sets=1, entry=type [size=256, fields={DATA=field DATA(256, [0..255])}], index=(BVEXTRACT 63 5 pa), match=0, policy=NONE}}
    [junit]  memories={pmem=mmu pmem(va: VA=type [size=64, fields={}])=(data: type [size=64, fields={}]) [vars={tlbEntry=tlbEntry: JTLB.entry=type [size=24, fields={ASID=field ASID(8, [0..7]), VPN2=field VPN2(27, [8..34]), R=field R(2, [35..36]), G0=field G0(1, [37..37]), V0=field V0(1, [38..38]), D0=field D0(1, [39..39]), C0=field C0(3, [40..42]), PFN0=field PFN0(24, [43..66]), G1=field G1(1, [67..67]), V1=field V1(1, [68..68]), D1=field D1(1, [69..69]), C1=field C1(3, [70..72]), PFN1=field PFN1(24, [73..96])}], l1Entry=l1Entry: L1.entry=type [size=256, fields={V=field V(1, [0..0], 0x00), TAG=field TAG(24, [1..24], 0x000000), DATA=field DATA(256, [25..280], 0x0000000000000000000000000000000000000000000000000000000000000000)}], l2Entry=l2Entry: L2.entry=type [size=256, fields={V=field V(1, [0..0], 0x00), TAG=field TAG(19, [1..19], 0x000000), DATA=field DATA(256, [20..275], 0x0000000000000000000000000000000000000000000000000000000000000000)}], evenOddBit=evenOddBit: type [size=5, fields={}], g=g: type [size=1, fields={}], v=v: type [size=1, fields={}], d=d: type [size=1, fields={}], c=c: type [size=3, fields={}], pfn=pfn: type [size=24, fields={}], pa=pa: PA=type [size=36, fields={}], cacheData=cacheData: type [size=256, fields={}]}, attributes=[attribute read = [StmtIf [if=[<(NOTEQ (BVEXTRACT 0 2 va) 0), [stmt exception["AddressError"]]>], else=[]], stmt assign[c = 3], StmtIf [if=[<USEG(va).hit, [StmtIf [if=[<DTLB(va).hit, [stmt assign[tlbEntry = DTLB(va).read]]>, <JTLB(va).hit, [stmt assign[tlbEntry = JTLB(va).read]]>], else=[stmt exception["TLBMiss"]]], stmt assign[evenOddBit = 12], StmtIf [if=[<(EQ (BVEXTRACT 12 12 va) 0), [stmt assign[g = tlbEntry.G0], stmt assign[v = tlbEntry.V0], stmt assign[d = tlbEntry.D0], stmt assign[c = tlbEntry.C0], stmt assign[pfn = tlbEntry.PFN0]]>], else=[stmt assign[g = tlbEntry.G1], stmt assign[v = tlbEntry.V1], stmt assign[d = tlbEntry.D1], stmt assign[c = tlbEntry.C1], stmt assign[pfn = tlbEntry.PFN1]]], StmtIf [if=[<(EQ v 1), [stmt assign[pa = (BVCONCAT (BVEXTRACT 24 0 pfn) (BVEXTRACT 11 0 va))]]>], else=[stmt exception["TLBInvalid"]]]]>], else=[stmt assign[pa = (BVEXTRACT 28 0 va)]]], StmtIf [if=[<(NOTEQ (BVEXTRACT 1 0 c) 2), [StmtIf [if=[<L1(pa).hit, [stmt assign[l1Entry = L1(pa).read], stmt assign[cacheData = l1Entry.DATA], stmt assign[data = (BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData)]]>], else=[StmtIf [if=[<(EQ (BVEXTRACT 1 0 c) 3), [StmtIf [if=[<L2(pa).hit, [stmt assign[l2Entry = L2(pa).read], stmt assign[cacheData = l2Entry.DATA], stmt assign[data = (BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData)], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = cacheData], stmt assign[L1(pa).write = l1Entry]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[data = (BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData)], stmt assign[l2Entry.V = 1], stmt assign[l2Entry.TAG = (BVEXTRACT 35 17 pa)], stmt assign[l2Entry.DATA = cacheData], stmt assign[L2(pa).write = l2Entry], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = cacheData], stmt assign[L1(pa).write = l1Entry]]]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[data = (BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData)], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = cacheData], stmt assign[L1(pa).write = l1Entry]]]]]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[data = (BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData)]]]], attribute write = [StmtIf [if=[<(NOTEQ (BVEXTRACT 0 2 va) 0), [stmt exception["AddressError"]]>], else=[]], stmt assign[c = 3], StmtIf [if=[<USEG(va).hit, [StmtIf [if=[<DTLB(va).hit, [stmt assign[tlbEntry = DTLB(va).read]]>, <JTLB(va).hit, [stmt assign[tlbEntry = JTLB(va).read]]>], else=[stmt exception["TLBMiss"]]], stmt assign[evenOddBit = 12], StmtIf [if=[<(EQ (BVEXTRACT 12 12 va) 0), [stmt assign[g = tlbEntry.G0], stmt assign[v = tlbEntry.V0], stmt assign[d = tlbEntry.D0], stmt assign[c = tlbEntry.C0], stmt assign[pfn = tlbEntry.PFN0]]>], else=[stmt assign[g = tlbEntry.G1], stmt assign[v = tlbEntry.V1], stmt assign[d = tlbEntry.D1], stmt assign[c = tlbEntry.C1], stmt assign[pfn = tlbEntry.PFN1]]], StmtIf [if=[<(EQ v 1), [StmtIf [if=[<(EQ d 1), [stmt assign[pa = (BVCONCAT (BVEXTRACT 24 0 pfn) (BVEXTRACT 11 0 va))]]>], else=[stmt exception["TLBModified"]]]]>], else=[stmt exception["TLBInvalid"]]]]>], else=[stmt assign[pa = (BVEXTRACT 28 0 va)]]], StmtIf [if=[<(NOTEQ (BVEXTRACT 1 0 c) 2), [StmtIf [if=[<L1(pa).hit, [stmt assign[l1Entry = L1(pa).read], stmt assign[(BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) l1Entry.DATA) = data], stmt assign[L1(pa).write = l1Entry], stmt assign[Memory(pa).write = l1Entry.DATA]]>], else=[StmtIf [if=[<(EQ (BVEXTRACT 1 0 c) 3), [StmtIf [if=[<L2(pa).hit, [stmt assign[l2Entry = L2(pa).read], stmt assign[(BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) l2Entry.DATA) = data], stmt assign[L2(pa).write = l2Entry], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = l2Entry.DATA], stmt assign[L1(pa).write = l1Entry], stmt assign[Memory(pa).write = l1Entry.DATA]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[(BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData) = data], stmt assign[Memory(pa).write = cacheData], stmt assign[l2Entry.V = 1], stmt assign[l2Entry.TAG = (BVEXTRACT 35 17 pa)], stmt assign[l2Entry.DATA = cacheData], stmt assign[L2(pa).write = l2Entry], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = cacheData], stmt assign[L1(pa).write = l1Entry]]]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[(BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData) = data], stmt assign[Memory(pa).write = cacheData], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = cacheData], stmt assign[L1(pa).write = l1Entry]]]]]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[(BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData) = data], stmt assign[Memory(pa).write = cacheData]]]]]]}
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,251 sec
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,251 sec
    [junit] ------------- Standard Output ---------------
    [junit] Translating: ./src/test/mmu/general.mmu
    [junit] Model name: general
    [junit] 
    [junit] Mmu Ir:
    [junit]  addresses={VA=address VA[type [size=64, fields={}]], PA=address PA[type [size=36, fields={}]]}
    [junit]  segments={USEG=segment USEG(va: VA=type [size=64, fields={}]) range = (0x0, 0x7FFFFFFF), XUSEG=segment XUSEG(va: VA=type [size=64, fields={}]) range = (0x80000000, 0xFFFFFFFFFF), SUSEG=segment SUSEG(va: VA=type [size=64, fields={}]) range = (0x0, 0x7FFFFFFF), XSUSEG=segment XSUSEG(va: VA=type [size=64, fields={}]) range = (0x80000000, 0xFFFFFFFFFF), XSSEG=segment XSSEG(va: VA=type [size=64, fields={}]) range = (0x4000000000000000, 0x400000FFFFFFFFFF), CSSEG=segment CSSEG(va: VA=type [size=64, fields={}]) range = (0xFFFFFFFFC0000000, 0xFFFFFFFFDFFFFFFF), KUSEG=segment KUSEG(va: VA=type [size=64, fields={}]) range = (0x0, 0x7FFFFFFF), XKUSEG=segment XKUSEG(va: VA=type [size=64, fields={}]) range = (0x80000000, 0xFFFFFFFFFF), XKSSEG=segment XKSSEG(va: VA=type [size=64, fields={}]) range = (0x4000000000000000, 0x400000FFFFFFFFFF), XKSEG=segment XKSEG(va: VA=type [size=64, fields={}]) range = (0xC000000000000000, 0xC00000FF7FFFFFFF), CKSSEG=segment CKSSEG(va: VA=type [size=64, fields={}]) range = (0xFFFFFFFFC0000000, 0xFFFFFFFFDFFFFFFF), CKSEG3=segment CKSEG3(va: VA=type [size=64, fields={}]) range = (0xFFFFFFFFE0000000, 0xFFFFFFFFFFFFFFFF)}
    [junit]  buffers={JTLB=buffer JTLB(va: VA=type [size=64, fields={}]) = {ways=64, sets=1, entry=type [size=24, fields={ASID=field ASID(8, [0..7]), VPN2=field VPN2(27, [8..34]), R=field R(2, [35..36]), G0=field G0(1, [37..37]), V0=field V0(1, [38..38]), D0=field D0(1, [39..39]), C0=field C0(3, [40..42]), PFN0=field PFN0(24, [43..66]), G1=field G1(1, [67..67]), V1=field V1(1, [68..68]), D1=field D1(1, [69..69]), C1=field C1(3, [70..72]), PFN1=field PFN1(24, [73..96])}], index=0, match=(EQ entry.VPN2 (BVEXTRACT 39 13 va)), policy=NONE}, DTLB=buffer DTLB(va: VA=type [size=64, fields={}]) = {ways=4, sets=1, entry=type [size=24, fields={ASID=field ASID(8, [0..7]), VPN2=field VPN2(27, [8..34]), R=field R(2, [35..36]), G0=field G0(1, [37..37]), V0=field V0(1, [38..38]), D0=field D0(1, [39..39]), C0=field C0(3, [40..42]), PFN0=field PFN0(24, [43..66]), G1=field G1(1, [67..67]), V1=field V1(1, [68..68]), D1=field D1(1, [69..69]), C1=field C1(3, [70..72]), PFN1=field PFN1(24, [73..96])}], index=0, match=(EQ entry.VPN2 (BVEXTRACT 39 13 va)), policy=PLRU}, L1=buffer L1(pa: PA=type [size=36, fields={}]) = {ways=4, sets=128, entry=type [size=256, fields={V=field V(1, [0..0], 0x00), TAG=field TAG(24, [1..24], 0x000000), DATA=field DATA(256, [25..280], 0x0000000000000000000000000000000000000000000000000000000000000000)}], index=(BVEXTRACT 11 5 pa), match=(AND (EQ entry.V 1) (EQ entry.TAG (BVEXTRACT 35 12 pa))), policy=PLRU}, L2=buffer L2(pa: PA=type [size=36, fields={}]) = {ways=4, sets=4096, entry=type [size=256, fields={V=field V(1, [0..0], 0x00), TAG=field TAG(19, [1..19], 0x000000), DATA=field DATA(256, [20..275], 0x0000000000000000000000000000000000000000000000000000000000000000)}], index=(BVEXTRACT 16 5 pa), match=(AND (EQ entry.V 1) (EQ entry.TAG (BVEXTRACT 35 17 pa))), policy=PLRU}, Memory=buffer Memory(pa: PA=type [size=36, fields={}]) = {ways=1, sets=1, entry=type [size=256, fields={DATA=field DATA(256, [0..255])}], index=(BVEXTRACT 63 5 pa), match=0, policy=NONE}}
    [junit]  memories={pmem=mmu pmem(va: VA=type [size=64, fields={}])=(data: type [size=64, fields={}]) [vars={tlbEntry=tlbEntry: JTLB.entry=type [size=24, fields={ASID=field ASID(8, [0..7]), VPN2=field VPN2(27, [8..34]), R=field R(2, [35..36]), G0=field G0(1, [37..37]), V0=field V0(1, [38..38]), D0=field D0(1, [39..39]), C0=field C0(3, [40..42]), PFN0=field PFN0(24, [43..66]), G1=field G1(1, [67..67]), V1=field V1(1, [68..68]), D1=field D1(1, [69..69]), C1=field C1(3, [70..72]), PFN1=field PFN1(24, [73..96])}], l1Entry=l1Entry: L1.entry=type [size=256, fields={V=field V(1, [0..0], 0x00), TAG=field TAG(24, [1..24], 0x000000), DATA=field DATA(256, [25..280], 0x0000000000000000000000000000000000000000000000000000000000000000)}], l2Entry=l2Entry: L2.entry=type [size=256, fields={V=field V(1, [0..0], 0x00), TAG=field TAG(19, [1..19], 0x000000), DATA=field DATA(256, [20..275], 0x0000000000000000000000000000000000000000000000000000000000000000)}], evenOddBit=evenOddBit: type [size=5, fields={}], g=g: type [size=1, fields={}], v=v: type [size=1, fields={}], d=d: type [size=1, fields={}], c=c: type [size=3, fields={}], pfn=pfn: type [size=24, fields={}], pa=pa: PA=type [size=36, fields={}], cacheData=cacheData: type [size=256, fields={}]}, attributes=[attribute read = [StmtIf [if=[<(NOTEQ (BVEXTRACT 0 2 va) 0), [stmt exception["AddressError"]]>], else=[]], stmt assign[c = 3], StmtIf [if=[<USEG(va).hit, [StmtIf [if=[<DTLB(va).hit, [stmt assign[tlbEntry = DTLB(va).read]]>, <JTLB(va).hit, [stmt assign[tlbEntry = JTLB(va).read]]>], else=[stmt exception["TLBMiss"]]], stmt assign[evenOddBit = 12], StmtIf [if=[<(EQ (BVEXTRACT 12 12 va) 0), [stmt assign[g = tlbEntry.G0], stmt assign[v = tlbEntry.V0], stmt assign[d = tlbEntry.D0], stmt assign[c = tlbEntry.C0], stmt assign[pfn = tlbEntry.PFN0]]>], else=[stmt assign[g = tlbEntry.G1], stmt assign[v = tlbEntry.V1], stmt assign[d = tlbEntry.D1], stmt assign[c = tlbEntry.C1], stmt assign[pfn = tlbEntry.PFN1]]], StmtIf [if=[<(EQ v 1), [stmt assign[pa = (BVCONCAT (BVEXTRACT 24 0 pfn) (BVEXTRACT 11 0 va))]]>], else=[stmt exception["TLBInvalid"]]]]>], else=[stmt assign[pa = (BVEXTRACT 28 0 va)]]], StmtIf [if=[<(NOTEQ (BVEXTRACT 1 0 c) 2), [StmtIf [if=[<L1(pa).hit, [stmt assign[l1Entry = L1(pa).read], stmt assign[cacheData = l1Entry.DATA], stmt assign[data = (BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData)]]>], else=[StmtIf [if=[<(EQ (BVEXTRACT 1 0 c) 3), [StmtIf [if=[<L2(pa).hit, [stmt assign[l2Entry = L2(pa).read], stmt assign[cacheData = l2Entry.DATA], stmt assign[data = (BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData)], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = cacheData], stmt assign[L1(pa).write = l1Entry]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[data = (BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData)], stmt assign[l2Entry.V = 1], stmt assign[l2Entry.TAG = (BVEXTRACT 35 17 pa)], stmt assign[l2Entry.DATA = cacheData], stmt assign[L2(pa).write = l2Entry], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = cacheData], stmt assign[L1(pa).write = l1Entry]]]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[data = (BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData)], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = cacheData], stmt assign[L1(pa).write = l1Entry]]]]]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[data = (BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData)]]]], attribute write = [StmtIf [if=[<(NOTEQ (BVEXTRACT 0 2 va) 0), [stmt exception["AddressError"]]>], else=[]], stmt assign[c = 3], StmtIf [if=[<USEG(va).hit, [StmtIf [if=[<DTLB(va).hit, [stmt assign[tlbEntry = DTLB(va).read]]>, <JTLB(va).hit, [stmt assign[tlbEntry = JTLB(va).read]]>], else=[stmt exception["TLBMiss"]]], stmt assign[evenOddBit = 12], StmtIf [if=[<(EQ (BVEXTRACT 12 12 va) 0), [stmt assign[g = tlbEntry.G0], stmt assign[v = tlbEntry.V0], stmt assign[d = tlbEntry.D0], stmt assign[c = tlbEntry.C0], stmt assign[pfn = tlbEntry.PFN0]]>], else=[stmt assign[g = tlbEntry.G1], stmt assign[v = tlbEntry.V1], stmt assign[d = tlbEntry.D1], stmt assign[c = tlbEntry.C1], stmt assign[pfn = tlbEntry.PFN1]]], StmtIf [if=[<(EQ v 1), [StmtIf [if=[<(EQ d 1), [stmt assign[pa = (BVCONCAT (BVEXTRACT 24 0 pfn) (BVEXTRACT 11 0 va))]]>], else=[stmt exception["TLBModified"]]]]>], else=[stmt exception["TLBInvalid"]]]]>], else=[stmt assign[pa = (BVEXTRACT 28 0 va)]]], StmtIf [if=[<(NOTEQ (BVEXTRACT 1 0 c) 2), [StmtIf [if=[<L1(pa).hit, [stmt assign[l1Entry = L1(pa).read], stmt assign[(BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) l1Entry.DATA) = data], stmt assign[L1(pa).write = l1Entry], stmt assign[Memory(pa).write = l1Entry.DATA]]>], else=[StmtIf [if=[<(EQ (BVEXTRACT 1 0 c) 3), [StmtIf [if=[<L2(pa).hit, [stmt assign[l2Entry = L2(pa).read], stmt assign[(BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) l2Entry.DATA) = data], stmt assign[L2(pa).write = l2Entry], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = l2Entry.DATA], stmt assign[L1(pa).write = l1Entry], stmt assign[Memory(pa).write = l1Entry.DATA]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[(BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData) = data], stmt assign[Memory(pa).write = cacheData], stmt assign[l2Entry.V = 1], stmt assign[l2Entry.TAG = (BVEXTRACT 35 17 pa)], stmt assign[l2Entry.DATA = cacheData], stmt assign[L2(pa).write = l2Entry], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = cacheData], stmt assign[L1(pa).write = l1Entry]]]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[(BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData) = data], stmt assign[Memory(pa).write = cacheData], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = cacheData], stmt assign[L1(pa).write = l1Entry]]]]]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[(BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData) = data], stmt assign[Memory(pa).write = cacheData]]]]]]}
    [junit] ---------------------------------
    [junit] MMU:
    [junit] Addresses: 2
    [junit] VA[64]
    [junit] PA[36]
    [junit] Start address: VA[64]
    [junit] 
    [junit] Devices: 5
    [junit]     JTLB
    [junit]     DTLB
    [junit]     L1
    [junit]     L2
    [junit]     Memory
    [junit] 
    [junit] Actions: 96
    [junit] Start action: ROOT
    [junit] ROOT: 
    [junit]     Transition: {source: ROOT -> guard:[LOAD] -> target: START}
    [junit]     Transition: {source: ROOT -> guard:[STORE] -> target: START}
    [junit] START: 
    [junit]     Transition: {source: START -> guard:[VA[0:2]!=0] -> target: Branch_1[(NOTEQ (BVEXTRACT 0 2 va) 0)]}
    [junit]     Transition: {source: START -> guard:[VA[0:2]=0] -> target: Branch_2[not (NOTEQ (BVEXTRACT 0 2 va) 0)]}
    [junit]     Transition: {source: START -> guard:[VA[0:2]!=0] -> target: Branch_30[(NOTEQ (BVEXTRACT 0 2 va) 0)]}
    [junit]     Transition: {source: START -> guard:[VA[0:2]=0] -> target: Branch_31[not (NOTEQ (BVEXTRACT 0 2 va) 0)]}
    [junit] STOP: 
    [junit] Join_0: 
    [junit]     Transition: {source: Join_0 -> guard:[VA[31:63]=0] -> target: Branch_4[USEG(va).hit]}
    [junit]     Transition: {source: Join_0 -> guard:[null] -> target: Branch_16[not USEG(va).hit]}
    [junit] Branch_1[(NOTEQ (BVEXTRACT 0 2 va) 0)]: 
    [junit]     Transition: {source: Branch_1[(NOTEQ (BVEXTRACT 0 2 va) 0)] -> guard:[null] -> target: AddressError}
    [junit] AddressError: 
    [junit] Branch_2[not (NOTEQ (BVEXTRACT 0 2 va) 0)]: 
    [junit]     Transition: {source: Branch_2[not (NOTEQ (BVEXTRACT 0 2 va) 0)] -> guard:[null] -> target: Join_0}
    [junit] Join_3: 
    [junit]     Transition: {source: Join_3 -> guard:[c[1:0]!=2] -> target: Branch_18[(NOTEQ (BVEXTRACT 1 0 c) 2)]}
    [junit]     Transition: {source: Join_3 -> guard:[c[1:0]=2] -> target: Branch_28[not (NOTEQ (BVEXTRACT 1 0 c) 2)]}
    [junit] Branch_4[USEG(va).hit]: 
    [junit]     Transition: {source: Branch_4[USEG(va).hit] -> guard:[DTLB.Event=HIT] -> target: Branch_6[DTLB(va).hit]}
    [junit]     Transition: {source: Branch_4[USEG(va).hit] -> guard:[DTLB.Event=MISS] -> target: Branch_7[not DTLB(va).hit]}
    [junit] Join_5: 
    [junit]     Transition: {source: Join_5 -> guard:[VA[12]=0] -> target: Branch_11[(EQ (BVEXTRACT 12 12 va) 0)]}
    [junit]     Transition: {source: Join_5 -> guard:[VA[12]!=0] -> target: Branch_12[not (EQ (BVEXTRACT 12 12 va) 0)]}
    [junit] Branch_6[DTLB(va).hit]: 
    [junit]     Transition: {source: Branch_6[DTLB(va).hit] -> guard:[null] -> target: Assignment (tlbEntry = DTLB(va).read)}
    [junit] Assignment (tlbEntry = DTLB(va).read): 
    [junit]     Transition: {source: Assignment (tlbEntry = DTLB(va).read) -> guard:[null] -> target: Join_34}
    [junit] Branch_7[not DTLB(va).hit]: 
    [junit]     Transition: {source: Branch_7[not DTLB(va).hit] -> guard:[JTLB.Event=HIT] -> target: Branch_8[JTLB(va).hit]}
    [junit]     Transition: {source: Branch_7[not DTLB(va).hit] -> guard:[JTLB.Event=MISS] -> target: Branch_9[not JTLB(va).hit]}
    [junit] Branch_8[JTLB(va).hit]: 
    [junit]     Transition: {source: Branch_8[JTLB(va).hit] -> guard:[null] -> target: Assignment (tlbEntry = JTLB(va).read)}
    [junit] Assignment (tlbEntry = JTLB(va).read): 
    [junit]     Transition: {source: Assignment (tlbEntry = JTLB(va).read) -> guard:[null] -> target: Join_34}
    [junit] Branch_9[not JTLB(va).hit]: 
    [junit]     Transition: {source: Branch_9[not JTLB(va).hit] -> guard:[null] -> target: TLBMiss}
    [junit] TLBMiss: 
    [junit] Join_10: 
    [junit]     Transition: {source: Join_10 -> guard:[v=1] -> target: Branch_14[(EQ v 1)]}
    [junit]     Transition: {source: Join_10 -> guard:[v!=1] -> target: Branch_15[not (EQ v 1)]}
    [junit] Branch_11[(EQ (BVEXTRACT 12 12 va) 0)]: 
    [junit]     Transition: {source: Branch_11[(EQ (BVEXTRACT 12 12 va) 0)] -> guard:[null] -> target: Assignment (g = tlbEntry.G0)}
    [junit] Assignment (g = tlbEntry.G0): 
    [junit]     Transition: {source: Assignment (g = tlbEntry.G0) -> guard:[null] -> target: Assignment (v = tlbEntry.V0)}
    [junit] Assignment (v = tlbEntry.V0): 
    [junit]     Transition: {source: Assignment (v = tlbEntry.V0) -> guard:[null] -> target: Assignment (d = tlbEntry.D0)}
    [junit] Assignment (d = tlbEntry.D0): 
    [junit]     Transition: {source: Assignment (d = tlbEntry.D0) -> guard:[null] -> target: Assignment (c = tlbEntry.C0)}
    [junit] Assignment (c = tlbEntry.C0): 
    [junit]     Transition: {source: Assignment (c = tlbEntry.C0) -> guard:[null] -> target: Assignment (pfn = tlbEntry.PFN0)}
    [junit] Assignment (pfn = tlbEntry.PFN0): 
    [junit]     Transition: {source: Assignment (pfn = tlbEntry.PFN0) -> guard:[null] -> target: Join_39}
    [junit] Branch_12[not (EQ (BVEXTRACT 12 12 va) 0)]: 
    [junit]     Transition: {source: Branch_12[not (EQ (BVEXTRACT 12 12 va) 0)] -> guard:[null] -> target: Assignment (g = tlbEntry.G1)}
    [junit] Assignment (g = tlbEntry.G1): 
    [junit]     Transition: {source: Assignment (g = tlbEntry.G1) -> guard:[null] -> target: Assignment (v = tlbEntry.V1)}
    [junit] Assignment (v = tlbEntry.V1): 
    [junit]     Transition: {source: Assignment (v = tlbEntry.V1) -> guard:[null] -> target: Assignment (d = tlbEntry.D1)}
    [junit] Assignment (d = tlbEntry.D1): 
    [junit]     Transition: {source: Assignment (d = tlbEntry.D1) -> guard:[null] -> target: Assignment (c = tlbEntry.C1)}
    [junit] Assignment (c = tlbEntry.C1): 
    [junit]     Transition: {source: Assignment (c = tlbEntry.C1) -> guard:[null] -> target: Assignment (pfn = tlbEntry.PFN1)}
    [junit] Assignment (pfn = tlbEntry.PFN1): 
    [junit]     Transition: {source: Assignment (pfn = tlbEntry.PFN1) -> guard:[null] -> target: Join_39}
    [junit] Join_13: 
    [junit]     Transition: {source: Join_13 -> guard:[null] -> target: Join_3}
    [junit] Branch_14[(EQ v 1)]: 
    [junit]     Transition: {source: Branch_14[(EQ v 1)] -> guard:[null] -> target: Assignment (pa = (BVCONCAT (BVEXTRACT 24 0 pfn) (BVEXTRACT 11 0 va)))}
    [junit] Assignment (pa = (BVCONCAT (BVEXTRACT 24 0 pfn) (BVEXTRACT 11 0 va))): 
    [junit]     Transition: {source: Assignment (pa = (BVCONCAT (BVEXTRACT 24 0 pfn) (BVEXTRACT 11 0 va))) -> guard:[null] -> target: Join_44}
    [junit] Branch_15[not (EQ v 1)]: 
    [junit]     Transition: {source: Branch_15[not (EQ v 1)] -> guard:[null] -> target: TLBInvalid}
    [junit] TLBInvalid: 
    [junit] Branch_16[not USEG(va).hit]: 
    [junit]     Transition: {source: Branch_16[not USEG(va).hit] -> guard:[null] -> target: Assignment (pa = (BVEXTRACT 28 0 va))}
    [junit] Assignment (pa = (BVEXTRACT 28 0 va)): 
    [junit]     Transition: {source: Assignment (pa = (BVEXTRACT 28 0 va)) -> guard:[null] -> target: Join_32}
    [junit] Join_17: 
    [junit]     Transition: {source: Join_17 -> guard:[null] -> target: STOP}
    [junit] Branch_18[(NOTEQ (BVEXTRACT 1 0 c) 2)]: 
    [junit]     Transition: {source: Branch_18[(NOTEQ (BVEXTRACT 1 0 c) 2)] -> guard:[L1.Event=HIT] -> target: Branch_20[L1(pa).hit]}
    [junit]     Transition: {source: Branch_18[(NOTEQ (BVEXTRACT 1 0 c) 2)] -> guard:[L1.Event=MISS] -> target: Branch_21[not L1(pa).hit]}
    [junit] Join_19: 
    [junit]     Transition: {source: Join_19 -> guard:[null] -> target: Join_17}
    [junit] Branch_20[L1(pa).hit]: 
    [junit]     Transition: {source: Branch_20[L1(pa).hit] -> guard:[null] -> target: Assignment (l1Entry = L1(pa).read)}
    [junit] Assignment (l1Entry = L1(pa).read): 
    [junit]     Transition: {source: Assignment (l1Entry = L1(pa).read) -> guard:[null] -> target: Assignment (L1(pa).write = l1Entry)}
    [junit] Assignment (cacheData = l1Entry.DATA): 
    [junit]     Transition: {source: Assignment (cacheData = l1Entry.DATA) -> guard:[null] -> target: Join_19}
    [junit] Branch_21[not L1(pa).hit]: 
    [junit]     Transition: {source: Branch_21[not L1(pa).hit] -> guard:[c[1:0]=3] -> target: Branch_23[(EQ (BVEXTRACT 1 0 c) 3)]}
    [junit]     Transition: {source: Branch_21[not L1(pa).hit] -> guard:[c[1:0]!=3] -> target: Branch_27[not (EQ (BVEXTRACT 1 0 c) 3)]}
    [junit] Join_22: 
    [junit]     Transition: {source: Join_22 -> guard:[null] -> target: Join_19}
    [junit] Branch_23[(EQ (BVEXTRACT 1 0 c) 3)]: 
    [junit]     Transition: {source: Branch_23[(EQ (BVEXTRACT 1 0 c) 3)] -> guard:[L2.Event=HIT] -> target: Branch_25[L2(pa).hit]}
    [junit]     Transition: {source: Branch_23[(EQ (BVEXTRACT 1 0 c) 3)] -> guard:[L2.Event=MISS] -> target: Branch_26[not L2(pa).hit]}
    [junit] Join_24: 
    [junit]     Transition: {source: Join_24 -> guard:[null] -> target: Join_22}
    [junit] Branch_25[L2(pa).hit]: 
    [junit]     Transition: {source: Branch_25[L2(pa).hit] -> guard:[null] -> target: Assignment (l2Entry = L2(pa).read)}
    [junit] Assignment (l2Entry = L2(pa).read): 
    [junit]     Transition: {source: Assignment (l2Entry = L2(pa).read) -> guard:[null] -> target: Assignment (L2(pa).write = l2Entry)}
    [junit] Assignment (cacheData = l2Entry.DATA): 
    [junit]     Transition: {source: Assignment (cacheData = l2Entry.DATA) -> guard:[null] -> target: Assignment (l1Entry.TAG = (BVEXTRACT 35 12 pa))}
    [junit] Assignment (l1Entry.TAG = (BVEXTRACT 35 12 pa)): 
    [junit]     Transition: {source: Assignment (l1Entry.TAG = (BVEXTRACT 35 12 pa)) -> guard:[null] -> target: Assignment (l1Entry.DATA = cacheData)}
    [junit] Assignment (l1Entry.DATA = cacheData): 
    [junit]     Transition: {source: Assignment (l1Entry.DATA = cacheData) -> guard:[null] -> target: Assignment (L1(pa).write = l1Entry)}
    [junit] Assignment (L1(pa).write = l1Entry): 
    [junit]     Transition: {source: Assignment (L1(pa).write = l1Entry) -> guard:[null] -> target: Join_54}
    [junit] Branch_26[not L2(pa).hit]: 
    [junit]     Transition: {source: Branch_26[not L2(pa).hit] -> guard:[null] -> target: Assignment (cacheData = Memory(pa).read)}
    [junit] Assignment (cacheData = Memory(pa).read): 
    [junit]     Transition: {source: Assignment (cacheData = Memory(pa).read) -> guard:[null] -> target: Assignment (Memory(pa).write = cacheData)}
    [junit] Assignment (l2Entry.TAG = (BVEXTRACT 35 17 pa)): 
    [junit]     Transition: {source: Assignment (l2Entry.TAG = (BVEXTRACT 35 17 pa)) -> guard:[null] -> target: Assignment (l2Entry.DATA = cacheData)}
    [junit] Assignment (l2Entry.DATA = cacheData): 
    [junit]     Transition: {source: Assignment (l2Entry.DATA = cacheData) -> guard:[null] -> target: Assignment (L2(pa).write = l2Entry)}
    [junit] Assignment (L2(pa).write = l2Entry): 
    [junit]     Transition: {source: Assignment (L2(pa).write = l2Entry) -> guard:[null] -> target: Assignment (l1Entry.TAG = (BVEXTRACT 35 12 pa))}
    [junit] Branch_27[not (EQ (BVEXTRACT 1 0 c) 3)]: 
    [junit]     Transition: {source: Branch_27[not (EQ (BVEXTRACT 1 0 c) 3)] -> guard:[null] -> target: Assignment (cacheData = Memory(pa).read)}
    [junit] Branch_28[not (NOTEQ (BVEXTRACT 1 0 c) 2)]: 
    [junit]     Transition: {source: Branch_28[not (NOTEQ (BVEXTRACT 1 0 c) 2)] -> guard:[null] -> target: Assignment (cacheData = Memory(pa).read)}
    [junit] Join_29: 
    [junit]     Transition: {source: Join_29 -> guard:[VA[31:63]=0] -> target: Branch_33[USEG(va).hit]}
    [junit]     Transition: {source: Join_29 -> guard:[null] -> target: Branch_48[not USEG(va).hit]}
    [junit] Branch_30[(NOTEQ (BVEXTRACT 0 2 va) 0)]: 
    [junit]     Transition: {source: Branch_30[(NOTEQ (BVEXTRACT 0 2 va) 0)] -> guard:[null] -> target: AddressError}
    [junit] Branch_31[not (NOTEQ (BVEXTRACT 0 2 va) 0)]: 
    [junit]     Transition: {source: Branch_31[not (NOTEQ (BVEXTRACT 0 2 va) 0)] -> guard:[null] -> target: Join_29}
    [junit] Join_32: 
    [junit]     Transition: {source: Join_32 -> guard:[c[1:0]!=2] -> target: Branch_50[(NOTEQ (BVEXTRACT 1 0 c) 2)]}
    [junit]     Transition: {source: Join_32 -> guard:[c[1:0]=2] -> target: Branch_60[not (NOTEQ (BVEXTRACT 1 0 c) 2)]}
    [junit] Branch_33[USEG(va).hit]: 
    [junit]     Transition: {source: Branch_33[USEG(va).hit] -> guard:[DTLB.Event=HIT] -> target: Branch_35[DTLB(va).hit]}
    [junit]     Transition: {source: Branch_33[USEG(va).hit] -> guard:[DTLB.Event=MISS] -> target: Branch_36[not DTLB(va).hit]}
    [junit] Join_34: 
    [junit]     Transition: {source: Join_34 -> guard:[VA[12]=0] -> target: Branch_40[(EQ (BVEXTRACT 12 12 va) 0)]}
    [junit]     Transition: {source: Join_34 -> guard:[VA[12]!=0] -> target: Branch_41[not (EQ (BVEXTRACT 12 12 va) 0)]}
    [junit] Branch_35[DTLB(va).hit]: 
    [junit]     Transition: {source: Branch_35[DTLB(va).hit] -> guard:[null] -> target: Assignment (tlbEntry = DTLB(va).read)}
    [junit] Branch_36[not DTLB(va).hit]: 
    [junit]     Transition: {source: Branch_36[not DTLB(va).hit] -> guard:[JTLB.Event=HIT] -> target: Branch_37[JTLB(va).hit]}
    [junit]     Transition: {source: Branch_36[not DTLB(va).hit] -> guard:[JTLB.Event=MISS] -> target: Branch_38[not JTLB(va).hit]}
    [junit] Branch_37[JTLB(va).hit]: 
    [junit]     Transition: {source: Branch_37[JTLB(va).hit] -> guard:[null] -> target: Assignment (tlbEntry = JTLB(va).read)}
    [junit] Branch_38[not JTLB(va).hit]: 
    [junit]     Transition: {source: Branch_38[not JTLB(va).hit] -> guard:[null] -> target: TLBMiss}
    [junit] Join_39: 
    [junit]     Transition: {source: Join_39 -> guard:[v=1] -> target: Branch_43[(EQ v 1)]}
    [junit]     Transition: {source: Join_39 -> guard:[v!=1] -> target: Branch_47[not (EQ v 1)]}
    [junit] Branch_40[(EQ (BVEXTRACT 12 12 va) 0)]: 
    [junit]     Transition: {source: Branch_40[(EQ (BVEXTRACT 12 12 va) 0)] -> guard:[null] -> target: Assignment (g = tlbEntry.G0)}
    [junit] Branch_41[not (EQ (BVEXTRACT 12 12 va) 0)]: 
    [junit]     Transition: {source: Branch_41[not (EQ (BVEXTRACT 12 12 va) 0)] -> guard:[null] -> target: Assignment (g = tlbEntry.G1)}
    [junit] Join_42: 
    [junit]     Transition: {source: Join_42 -> guard:[null] -> target: Join_32}
    [junit] Branch_43[(EQ v 1)]: 
    [junit]     Transition: {source: Branch_43[(EQ v 1)] -> guard:[d=1] -> target: Branch_45[(EQ d 1)]}
    [junit]     Transition: {source: Branch_43[(EQ v 1)] -> guard:[d!=1] -> target: Branch_46[not (EQ d 1)]}
    [junit] Join_44: 
    [junit]     Transition: {source: Join_44 -> guard:[null] -> target: Join_42}
    [junit] Branch_45[(EQ d 1)]: 
    [junit]     Transition: {source: Branch_45[(EQ d 1)] -> guard:[null] -> target: Assignment (pa = (BVCONCAT (BVEXTRACT 24 0 pfn) (BVEXTRACT 11 0 va)))}
    [junit] Branch_46[not (EQ d 1)]: 
    [junit]     Transition: {source: Branch_46[not (EQ d 1)] -> guard:[null] -> target: TLBModified}
    [junit] TLBModified: 
    [junit] Branch_47[not (EQ v 1)]: 
    [junit]     Transition: {source: Branch_47[not (EQ v 1)] -> guard:[null] -> target: TLBInvalid}
    [junit] Branch_48[not USEG(va).hit]: 
    [junit]     Transition: {source: Branch_48[not USEG(va).hit] -> guard:[null] -> target: Assignment (pa = (BVEXTRACT 28 0 va))}
    [junit] Join_49: 
    [junit]     Transition: {source: Join_49 -> guard:[null] -> target: STOP}
    [junit] Branch_50[(NOTEQ (BVEXTRACT 1 0 c) 2)]: 
    [junit]     Transition: {source: Branch_50[(NOTEQ (BVEXTRACT 1 0 c) 2)] -> guard:[L1.Event=HIT] -> target: Branch_52[L1(pa).hit]}
    [junit]     Transition: {source: Branch_50[(NOTEQ (BVEXTRACT 1 0 c) 2)] -> guard:[L1.Event=MISS] -> target: Branch_53[not L1(pa).hit]}
    [junit] Join_51: 
    [junit]     Transition: {source: Join_51 -> guard:[null] -> target: Join_49}
    [junit] Branch_52[L1(pa).hit]: 
    [junit]     Transition: {source: Branch_52[L1(pa).hit] -> guard:[null] -> target: Assignment (l1Entry = L1(pa).read)}
    [junit] Assignment (Memory(pa).write = l1Entry.DATA): 
    [junit]     Transition: {source: Assignment (Memory(pa).write = l1Entry.DATA) -> guard:[null] -> target: Join_56}
    [junit] Branch_53[not L1(pa).hit]: 
    [junit]     Transition: {source: Branch_53[not L1(pa).hit] -> guard:[c[1:0]=3] -> target: Branch_55[(EQ (BVEXTRACT 1 0 c) 3)]}
    [junit]     Transition: {source: Branch_53[not L1(pa).hit] -> guard:[c[1:0]!=3] -> target: Branch_59[not (EQ (BVEXTRACT 1 0 c) 3)]}
    [junit] Join_54: 
    [junit]     Transition: {source: Join_54 -> guard:[null] -> target: Join_51}
    [junit] Branch_55[(EQ (BVEXTRACT 1 0 c) 3)]: 
    [junit]     Transition: {source: Branch_55[(EQ (BVEXTRACT 1 0 c) 3)] -> guard:[L2.Event=HIT] -> target: Branch_57[L2(pa).hit]}
    [junit]     Transition: {source: Branch_55[(EQ (BVEXTRACT 1 0 c) 3)] -> guard:[L2.Event=MISS] -> target: Branch_58[not L2(pa).hit]}
    [junit] Join_56: 
    [junit]     Transition: {source: Join_56 -> guard:[null] -> target: Join_54}
    [junit] Branch_57[L2(pa).hit]: 
    [junit]     Transition: {source: Branch_57[L2(pa).hit] -> guard:[null] -> target: Assignment (l2Entry = L2(pa).read)}
    [junit] Assignment (l1Entry.DATA = l2Entry.DATA): 
    [junit]     Transition: {source: Assignment (l1Entry.DATA = l2Entry.DATA) -> guard:[null] -> target: Assignment (L1(pa).write = l1Entry)}
    [junit] Branch_58[not L2(pa).hit]: 
    [junit]     Transition: {source: Branch_58[not L2(pa).hit] -> guard:[null] -> target: Assignment (cacheData = Memory(pa).read)}
    [junit] Assignment (Memory(pa).write = cacheData): 
    [junit]     Transition: {source: Assignment (Memory(pa).write = cacheData) -> guard:[null] -> target: Join_49}
    [junit] Branch_59[not (EQ (BVEXTRACT 1 0 c) 3)]: 
    [junit]     Transition: {source: Branch_59[not (EQ (BVEXTRACT 1 0 c) 3)] -> guard:[null] -> target: Assignment (cacheData = Memory(pa).read)}
    [junit] Branch_60[not (NOTEQ (BVEXTRACT 1 0 c) 2)]: 
    [junit]     Transition: {source: Branch_60[not (NOTEQ (BVEXTRACT 1 0 c) 2)] -> guard:[null] -> target: Assignment (cacheData = Memory(pa).read)}
    [junit] 
    [junit] Mmu Ir:
    [junit]  addresses={VA=address VA[type [size=64, fields={}]], PA=address PA[type [size=36, fields={}]]}
    [junit]  segments={USEG=segment USEG(va: VA=type [size=64, fields={}]) range = (0x0, 0x7FFFFFFF), XUSEG=segment XUSEG(va: VA=type [size=64, fields={}]) range = (0x80000000, 0xFFFFFFFFFF), SUSEG=segment SUSEG(va: VA=type [size=64, fields={}]) range = (0x0, 0x7FFFFFFF), XSUSEG=segment XSUSEG(va: VA=type [size=64, fields={}]) range = (0x80000000, 0xFFFFFFFFFF), XSSEG=segment XSSEG(va: VA=type [size=64, fields={}]) range = (0x4000000000000000, 0x400000FFFFFFFFFF), CSSEG=segment CSSEG(va: VA=type [size=64, fields={}]) range = (0xFFFFFFFFC0000000, 0xFFFFFFFFDFFFFFFF), KUSEG=segment KUSEG(va: VA=type [size=64, fields={}]) range = (0x0, 0x7FFFFFFF), XKUSEG=segment XKUSEG(va: VA=type [size=64, fields={}]) range = (0x80000000, 0xFFFFFFFFFF), XKSSEG=segment XKSSEG(va: VA=type [size=64, fields={}]) range = (0x4000000000000000, 0x400000FFFFFFFFFF), XKSEG=segment XKSEG(va: VA=type [size=64, fields={}]) range = (0xC000000000000000, 0xC00000FF7FFFFFFF), CKSSEG=segment CKSSEG(va: VA=type [size=64, fields={}]) range = (0xFFFFFFFFC0000000, 0xFFFFFFFFDFFFFFFF), CKSEG3=segment CKSEG3(va: VA=type [size=64, fields={}]) range = (0xFFFFFFFFE0000000, 0xFFFFFFFFFFFFFFFF)}
    [junit]  buffers={JTLB=buffer JTLB(va: VA=type [size=64, fields={}]) = {ways=64, sets=1, entry=type [size=24, fields={ASID=field ASID(8, [0..7]), VPN2=field VPN2(27, [8..34]), R=field R(2, [35..36]), G0=field G0(1, [37..37]), V0=field V0(1, [38..38]), D0=field D0(1, [39..39]), C0=field C0(3, [40..42]), PFN0=field PFN0(24, [43..66]), G1=field G1(1, [67..67]), V1=field V1(1, [68..68]), D1=field D1(1, [69..69]), C1=field C1(3, [70..72]), PFN1=field PFN1(24, [73..96])}], index=0, match=(EQ entry.VPN2 (BVEXTRACT 39 13 va)), policy=NONE}, DTLB=buffer DTLB(va: VA=type [size=64, fields={}]) = {ways=4, sets=1, entry=type [size=24, fields={ASID=field ASID(8, [0..7]), VPN2=field VPN2(27, [8..34]), R=field R(2, [35..36]), G0=field G0(1, [37..37]), V0=field V0(1, [38..38]), D0=field D0(1, [39..39]), C0=field C0(3, [40..42]), PFN0=field PFN0(24, [43..66]), G1=field G1(1, [67..67]), V1=field V1(1, [68..68]), D1=field D1(1, [69..69]), C1=field C1(3, [70..72]), PFN1=field PFN1(24, [73..96])}], index=0, match=(EQ entry.VPN2 (BVEXTRACT 39 13 va)), policy=PLRU}, L1=buffer L1(pa: PA=type [size=36, fields={}]) = {ways=4, sets=128, entry=type [size=256, fields={V=field V(1, [0..0], 0x00), TAG=field TAG(24, [1..24], 0x000000), DATA=field DATA(256, [25..280], 0x0000000000000000000000000000000000000000000000000000000000000000)}], index=(BVEXTRACT 11 5 pa), match=(AND (EQ entry.V 1) (EQ entry.TAG (BVEXTRACT 35 12 pa))), policy=PLRU}, L2=buffer L2(pa: PA=type [size=36, fields={}]) = {ways=4, sets=4096, entry=type [size=256, fields={V=field V(1, [0..0], 0x00), TAG=field TAG(19, [1..19], 0x000000), DATA=field DATA(256, [20..275], 0x0000000000000000000000000000000000000000000000000000000000000000)}], index=(BVEXTRACT 16 5 pa), match=(AND (EQ entry.V 1) (EQ entry.TAG (BVEXTRACT 35 17 pa))), policy=PLRU}, Memory=buffer Memory(pa: PA=type [size=36, fields={}]) = {ways=1, sets=1, entry=type [size=256, fields={DATA=field DATA(256, [0..255])}], index=(BVEXTRACT 63 5 pa), match=0, policy=NONE}}
    [junit]  memories={pmem=mmu pmem(va: VA=type [size=64, fields={}])=(data: type [size=64, fields={}]) [vars={tlbEntry=tlbEntry: JTLB.entry=type [size=24, fields={ASID=field ASID(8, [0..7]), VPN2=field VPN2(27, [8..34]), R=field R(2, [35..36]), G0=field G0(1, [37..37]), V0=field V0(1, [38..38]), D0=field D0(1, [39..39]), C0=field C0(3, [40..42]), PFN0=field PFN0(24, [43..66]), G1=field G1(1, [67..67]), V1=field V1(1, [68..68]), D1=field D1(1, [69..69]), C1=field C1(3, [70..72]), PFN1=field PFN1(24, [73..96])}], l1Entry=l1Entry: L1.entry=type [size=256, fields={V=field V(1, [0..0], 0x00), TAG=field TAG(24, [1..24], 0x000000), DATA=field DATA(256, [25..280], 0x0000000000000000000000000000000000000000000000000000000000000000)}], l2Entry=l2Entry: L2.entry=type [size=256, fields={V=field V(1, [0..0], 0x00), TAG=field TAG(19, [1..19], 0x000000), DATA=field DATA(256, [20..275], 0x0000000000000000000000000000000000000000000000000000000000000000)}], evenOddBit=evenOddBit: type [size=5, fields={}], g=g: type [size=1, fields={}], v=v: type [size=1, fields={}], d=d: type [size=1, fields={}], c=c: type [size=3, fields={}], pfn=pfn: type [size=24, fields={}], pa=pa: PA=type [size=36, fields={}], cacheData=cacheData: type [size=256, fields={}]}, attributes=[attribute read = [StmtIf [if=[<(NOTEQ (BVEXTRACT 0 2 va) 0), [stmt exception["AddressError"]]>], else=[]], stmt assign[c = 3], StmtIf [if=[<USEG(va).hit, [StmtIf [if=[<DTLB(va).hit, [stmt assign[tlbEntry = DTLB(va).read]]>, <JTLB(va).hit, [stmt assign[tlbEntry = JTLB(va).read]]>], else=[stmt exception["TLBMiss"]]], stmt assign[evenOddBit = 12], StmtIf [if=[<(EQ (BVEXTRACT 12 12 va) 0), [stmt assign[g = tlbEntry.G0], stmt assign[v = tlbEntry.V0], stmt assign[d = tlbEntry.D0], stmt assign[c = tlbEntry.C0], stmt assign[pfn = tlbEntry.PFN0]]>], else=[stmt assign[g = tlbEntry.G1], stmt assign[v = tlbEntry.V1], stmt assign[d = tlbEntry.D1], stmt assign[c = tlbEntry.C1], stmt assign[pfn = tlbEntry.PFN1]]], StmtIf [if=[<(EQ v 1), [stmt assign[pa = (BVCONCAT (BVEXTRACT 24 0 pfn) (BVEXTRACT 11 0 va))]]>], else=[stmt exception["TLBInvalid"]]]]>], else=[stmt assign[pa = (BVEXTRACT 28 0 va)]]], StmtIf [if=[<(NOTEQ (BVEXTRACT 1 0 c) 2), [StmtIf [if=[<L1(pa).hit, [stmt assign[l1Entry = L1(pa).read], stmt assign[cacheData = l1Entry.DATA], stmt assign[data = (BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData)]]>], else=[StmtIf [if=[<(EQ (BVEXTRACT 1 0 c) 3), [StmtIf [if=[<L2(pa).hit, [stmt assign[l2Entry = L2(pa).read], stmt assign[cacheData = l2Entry.DATA], stmt assign[data = (BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData)], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = cacheData], stmt assign[L1(pa).write = l1Entry]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[data = (BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData)], stmt assign[l2Entry.V = 1], stmt assign[l2Entry.TAG = (BVEXTRACT 35 17 pa)], stmt assign[l2Entry.DATA = cacheData], stmt assign[L2(pa).write = l2Entry], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = cacheData], stmt assign[L1(pa).write = l1Entry]]]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[data = (BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData)], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = cacheData], stmt assign[L1(pa).write = l1Entry]]]]]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[data = (BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData)]]]], attribute write = [StmtIf [if=[<(NOTEQ (BVEXTRACT 0 2 va) 0), [stmt exception["AddressError"]]>], else=[]], stmt assign[c = 3], StmtIf [if=[<USEG(va).hit, [StmtIf [if=[<DTLB(va).hit, [stmt assign[tlbEntry = DTLB(va).read]]>, <JTLB(va).hit, [stmt assign[tlbEntry = JTLB(va).read]]>], else=[stmt exception["TLBMiss"]]], stmt assign[evenOddBit = 12], StmtIf [if=[<(EQ (BVEXTRACT 12 12 va) 0), [stmt assign[g = tlbEntry.G0], stmt assign[v = tlbEntry.V0], stmt assign[d = tlbEntry.D0], stmt assign[c = tlbEntry.C0], stmt assign[pfn = tlbEntry.PFN0]]>], else=[stmt assign[g = tlbEntry.G1], stmt assign[v = tlbEntry.V1], stmt assign[d = tlbEntry.D1], stmt assign[c = tlbEntry.C1], stmt assign[pfn = tlbEntry.PFN1]]], StmtIf [if=[<(EQ v 1), [StmtIf [if=[<(EQ d 1), [stmt assign[pa = (BVCONCAT (BVEXTRACT 24 0 pfn) (BVEXTRACT 11 0 va))]]>], else=[stmt exception["TLBModified"]]]]>], else=[stmt exception["TLBInvalid"]]]]>], else=[stmt assign[pa = (BVEXTRACT 28 0 va)]]], StmtIf [if=[<(NOTEQ (BVEXTRACT 1 0 c) 2), [StmtIf [if=[<L1(pa).hit, [stmt assign[l1Entry = L1(pa).read], stmt assign[(BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) l1Entry.DATA) = data], stmt assign[L1(pa).write = l1Entry], stmt assign[Memory(pa).write = l1Entry.DATA]]>], else=[StmtIf [if=[<(EQ (BVEXTRACT 1 0 c) 3), [StmtIf [if=[<L2(pa).hit, [stmt assign[l2Entry = L2(pa).read], stmt assign[(BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) l2Entry.DATA) = data], stmt assign[L2(pa).write = l2Entry], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = l2Entry.DATA], stmt assign[L1(pa).write = l1Entry], stmt assign[Memory(pa).write = l1Entry.DATA]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[(BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData) = data], stmt assign[Memory(pa).write = cacheData], stmt assign[l2Entry.V = 1], stmt assign[l2Entry.TAG = (BVEXTRACT 35 17 pa)], stmt assign[l2Entry.DATA = cacheData], stmt assign[L2(pa).write = l2Entry], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = cacheData], stmt assign[L1(pa).write = l1Entry]]]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[(BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData) = data], stmt assign[Memory(pa).write = cacheData], stmt assign[l1Entry.V = 1], stmt assign[l1Entry.TAG = (BVEXTRACT 35 12 pa)], stmt assign[l1Entry.DATA = cacheData], stmt assign[L1(pa).write = l1Entry]]]]]]>], else=[stmt assign[cacheData = Memory(pa).read], stmt assign[(BVEXTRACT (BVADD (BVMUL 01000 (BVEXTRACT 4 0 pa)) 63) (BVMUL 01000 (BVEXTRACT 4 0 pa)) cacheData) = data], stmt assign[Memory(pa).write = cacheData]]]]]]}
    [junit] ------------- ---------------- ---------------
    [junit] 
    [junit] Testcase: test took 0,25 sec
    [junit] Running ru.ispras.microtesk.translator.mmu.spec.MmuCalculatorTestCase
    [junit] Testsuite: ru.ispras.microtesk.translator.mmu.spec.MmuCalculatorTestCase
    [junit] Test: width=1234, count=0
    [junit] Expr: 0
    [junit] Value: 90dd10383a1cdbdb
    [junit] Test: width=1, count=64
    [junit] Expr: {VAR[0], VAR[1], VAR[2], VAR[3], VAR[4], VAR[5], VAR[6], VAR[7], VAR[8], VAR[9], VAR[10], VAR[11], VAR[12], VAR[13], VAR[14], VAR[15], VAR[16], VAR[17], VAR[18], VAR[19], VAR[20], VAR[21], VAR[22], VAR[23], VAR[24], VAR[25], VAR[26], VAR[27], VAR[28], VAR[29], VAR[30], VAR[31], VAR[32], VAR[33], VAR[34], VAR[35], VAR[36], VAR[37], VAR[38], VAR[39], VAR[40], VAR[41], VAR[42], VAR[43], VAR[44], VAR[45], VAR[46], VAR[47], VAR[48], VAR[49], VAR[50], VAR[51], VAR[52], VAR[53], VAR[54], VAR[55], VAR[56], VAR[57], VAR[58], VAR[59], VAR[60], VAR[61], VAR[62], VAR[63]}
    [junit] Value: ffffffffbf755566
    [junit] Test: width=2, count=32
    [junit] Expr: {VAR[0:1], VAR[1:2], VAR[2:3], VAR[3:4], VAR[4:5], VAR[5:6], VAR[6:7], VAR[7:8], VAR[8:9], VAR[9:10], VAR[10:11], VAR[11:12], VAR[12:13], VAR[13:14], VAR[14:15], VAR[15:16], VAR[16:17], VAR[17:18], VAR[18:19], VAR[19:20], VAR[20:21], VAR[21:22], VAR[22:23], VAR[23:24], VAR[24:25], VAR[25:26], VAR[26:27], VAR[27:28], VAR[28:29], VAR[29:30], VAR[30:31], VAR[31:32]}
    [junit] Value: ffffffffb28b4590
    [junit] Test: width=3, count=21
    [junit] Expr: {VAR[0:2], VAR[1:3], VAR[2:4], VAR[3:5], VAR[4:6], VAR[5:7], VAR[6:8], VAR[7:9], VAR[8:10], VAR[9:11], VAR[10:12], VAR[11:13], VAR[12:14], VAR[13:15], VAR[14:16], VAR[15:17], VAR[16:18], VAR[17:19], VAR[18:20], VAR[19:21], VAR[20:22]}
    [junit] Value: ffffffffa0ffae42
    [junit] Test: width=4, count=16
    [junit] Expr: {VAR[0:3], VAR[1:4], VAR[2:5], VAR[3:6], VAR[4:7], VAR[5:8], VAR[6:9], VAR[7:10], VAR[8:11], VAR[9:12], VAR[10:13], VAR[11:14], VAR[12:15], VAR[13:16], VAR[14:17], VAR[15:18]}
    [junit] Value: ffffffffaf875517
    [junit] Test: width=5, count=12
    [junit] Expr: {VAR[0:4], VAR[1:5], VAR[2:6], VAR[3:7], VAR[4:8], VAR[5:9], VAR[6:10], VAR[7:11], VAR[8:12], VAR[9:13], VAR[10:14], VAR[11:15]}
    [junit] Value: 991bcd0554e69338
    [junit] Test: width=6, count=10
    [junit] Expr: {VAR[0:5], VAR[1:6], VAR[2:7], VAR[3:8], VAR[4:9], VAR[5:10], VAR[6:11], VAR[7:12], VAR[8:13], VAR[9:14]}
    [junit] Value: 4ab57b9c6eba503f
    [junit] Test: width=7, count=9
    [junit] Expr: {VAR[0:6], VAR[1:7], VAR[2:8], VAR[3:9], VAR[4:10], VAR[5:11], VAR[6:12], VAR[7:13], VAR[8:14]}
    [junit] Value: 757f42565e39bf69
    [junit] Test: width=8, count=8
    [junit] Expr: {VAR[0:7], VAR[1:8], VAR[2:9], VAR[3:10], VAR[4:11], VAR[5:12], VAR[6:13], VAR[7:14]}
    [junit] Value: eec886cf56d10b9c
    [junit] Test: width=9, count=7
    [junit] Expr: {VAR[0:8], VAR[1:9], VAR[2:10], VAR[3:11], VAR[4:12], VAR[5:13], VAR[6:14]}
    [junit] Value: ffffffff81e71ddb
    [junit] Test: width=10, count=6
    [junit] Expr: {VAR[0:9], VAR[1:10], VAR[2:11], VAR[3:12], VAR[4:13], VAR[5:14]}
    [junit] Value: 8567b9a75d98adab
    [junit] Test: width=11, count=5
    [junit] Expr: {VAR[0:10], VAR[1:11], VAR[2:12], VAR[3:13], VAR[4:14]}
    [junit] Value: e291bb6f341ece12
    [junit] Test: width=12, count=5
    [junit] Expr: {VAR[0:11], VAR[1:12], VAR[2:13], VAR[3:14], VAR[4:15]}
    [junit] Value: 906e0c1600b012a7
    [junit] Test: width=13, count=4
    [junit] Expr: {VAR[0:12], VAR[1:13], VAR[2:14], VAR[3:15]}
    [junit] Value: d9d604c859e550c5
    [junit] Test: width=14, count=4
    [junit] Expr: {VAR[0:13], VAR[1:14], VAR[2:15], VAR[3:16]}
    [junit] Value: ffffffff88ac3ff6
    [junit] Test: width=15, count=4
    [junit] Expr: {VAR[0:14], VAR[1:15], VAR[2:16], VAR[3:17]}
    [junit] Value: ab84b5877dd09d84
    [junit] Test: width=16, count=4
    [junit] Expr: {VAR[0:15], VAR[1:16], VAR[2:17], VAR[3:18]}
    [junit] Value: 43fc101b25e2ec88
    [junit] Test: width=17, count=3
    [junit] Expr: {VAR[0:16], VAR[1:17], VAR[2:18]}
    [junit] Value: ffffffffe9ca25e0
    [junit] Test: width=18, count=3
    [junit] Expr: {VAR[0:17], VAR[1:18], VAR[2:19]}
    [junit] Value: ffffffff866beb31
    [junit] Test: width=19, count=3
    [junit] Expr: {VAR[0:18], VAR[1:19], VAR[2:20]}
    [junit] Value: d812196c4bdb9cc7
    [junit] Test: width=20, count=3
    [junit] Expr: {VAR[0:19], VAR[1:20], VAR[2:21]}
    [junit] Value: ffffffffe94510ae
    [junit] Test: width=21, count=3
    [junit] Expr: {VAR[0:20], VAR[1:21], VAR[2:22]}
    [junit] Value: ffffffffb07eb8a8
    [junit] Test: width=22, count=2
    [junit] Expr: {VAR[0:21], VAR[1:22]}
    [junit] Value: ffffffff88e1eb22
    [junit] Test: width=23, count=2
    [junit] Expr: {VAR[0:22], VAR[1:23]}
    [junit] Value: 126f36f2577bfdaf
    [junit] Test: width=24, count=2
    [junit] Expr: {VAR[0:23], VAR[1:24]}
    [junit] Value: d0d8f8f7d218e7f
    [junit] Test: width=25, count=2
    [junit] Expr: {VAR[0:24], VAR[1:25]}
    [junit] Value: ffffffffdfaa5513
    [junit] Test: width=26, count=2
    [junit] Expr: {VAR[0:25], VAR[1:26]}
    [junit] Value: ffffffffad1fb7ef
    [junit] Test: width=27, count=2
    [junit] Expr: {VAR[0:26], VAR[1:27]}
    [junit] Value: ffffffffac83b5ff
    [junit] Test: width=28, count=2
    [junit] Expr: {VAR[0:27], VAR[1:28]}
    [junit] Value: ffffffffe7927a5d
    [junit] Test: width=29, count=2
    [junit] Expr: {VAR[0:28], VAR[1:29]}
    [junit] Value: ffffffff9d4285a3
    [junit] Test: width=30, count=2
    [junit] Expr: {VAR[0:29], VAR[1:30]}
    [junit] Value: cd0ba8b7443a01be
    [junit] Test: width=31, count=2
    [junit] Expr: {VAR[0:30], VAR[1:31]}
    [junit] Value: 680c94fa08377344
    [junit] Test: width=32, count=2
    [junit] Expr: {VAR[0:31], VAR[1:32]}
    [junit] Value: ffffffffb3c4bcea
    [junit] Test: width=33, count=1
    [junit] Expr: VAR[0:32]
    [junit] Value: ffffffffea322024
    [junit] Test: width=34, count=1
    [junit] Expr: VAR[0:33]
    [junit] Value: b75ea8a31d697578
    [junit] Test: width=35, count=1
    [junit] Expr: VAR[0:34]
    [junit] Value: ffffffffb842269e
    [junit] Test: width=36, count=1
    [junit] Expr: VAR[0:35]
    [junit] Value: c5e3936b4cbcd87f
    [junit] Test: width=37, count=1
    [junit] Expr: VAR[0:36]
    [junit] Value: ffffffffaa19a45a
    [junit] Test: width=38, count=1
    [junit] Expr: VAR[0:37]
    [junit] Value: ffffffff93797259
    [junit] Test: width=39, count=1
    [junit] Expr: VAR[0:38]
    [junit] Value: 9f6500c11c62f791
    [junit] Test: width=40, count=1
    [junit] Expr: VAR[0:39]
    [junit] Value: 7f43373551c5de2d
    [junit] Test: width=41, count=1
    [junit] Expr: VAR[0:40]
    [junit] Value: 9aed867a6b4db6d4
    [junit] Test: width=42, count=1
    [junit] Expr: VAR[0:41]
    [junit] Value: ffffffffe46f9715
    [junit] Test: width=43, count=1
    [junit] Expr: VAR[0:42]
    [junit] Value: 657330aa5a3701f3
    [junit] Test: width=44, count=1
    [junit] Expr: VAR[0:43]
    [junit] Value: fffffffff0264c61
    [junit] Test: width=45, count=1
    [junit] Expr: VAR[0:44]
    [junit] Value: ffffffffd180d36f
    [junit] Test: width=46, count=1
    [junit] Expr: VAR[0:45]
    [junit] Value: ffffffffc5f8ebe4
    [junit] Test: width=47, count=1
    [junit] Expr: VAR[0:46]
    [junit] Value: ffffffffd8c5d24b
    [junit] Test: width=48, count=1
    [junit] Expr: VAR[0:47]
    [junit] Value: ffffffff9b277bb9
    [junit] Test: width=49, count=1
    [junit] Expr: VAR[0:48]
    [junit] Value: ffffffff803eff49
    [junit] Test: width=50, count=1
    [junit] Expr: VAR[0:49]
    [junit] Value: ffffffff8ee4385b
    [junit] Test: width=51, count=1
    [junit] Expr: VAR[0:50]
    [junit] Value: f7d9a6e469563008
    [junit] Test: width=52, count=1
    [junit] Expr: VAR[0:51]
    [junit] Value: ffffffffeab59b00
    [junit] Test: width=53, count=1
    [junit] Expr: VAR[0:52]
    [junit] Value: ffffffff96a50b98
    [junit] Test: width=54, count=1
    [junit] Expr: VAR[0:53]
    [junit] Value: ffffffffb8f4cd7c
    [junit] Test: width=55, count=1
    [junit] Expr: VAR[0:54]
    [junit] Value: ffffffffde087b60
    [junit] Test: width=56, count=1
    [junit] Expr: VAR[0:55]
    [junit] Value: ffffffffe21e32c5
    [junit] Test: width=57, count=1
    [junit] Expr: VAR[0:56]
    [junit] Value: 6981d0fb1a949721
    [junit] Test: width=58, count=1
    [junit] Expr: VAR[0:57]
    [junit] Value: ffffffffa56ffed2
    [junit] Test: width=59, count=1
    [junit] Expr: VAR[0:58]
    [junit] Value: 37407601387909ef
    [junit] Test: width=60, count=1
    [junit] Expr: VAR[0:59]
    [junit] Value: ffffffffb2d38082
    [junit] Test: width=61, count=1
    [junit] Expr: VAR[0:60]
    [junit] Value: 90036c9533592eb4
    [junit] Test: width=62, count=1
    [junit] Expr: VAR[0:61]
    [junit] Value: ffffffffdd5bbac5
    [junit] Test: width=63, count=1
    [junit] Expr: VAR[0:62]
    [junit] Value: 3e6acdd51cb8a312
    [junit] Test: width=64, count=1
    [junit] Expr: VAR
    [junit] Value: ffffffffa001f7c9
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,017 sec
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,017 sec
    [junit] ------------- Standard Output ---------------
    [junit] Test: width=1234, count=0
    [junit] Expr: 0
    [junit] Value: 90dd10383a1cdbdb
    [junit] Test: width=1, count=64
    [junit] Expr: {VAR[0], VAR[1], VAR[2], VAR[3], VAR[4], VAR[5], VAR[6], VAR[7], VAR[8], VAR[9], VAR[10], VAR[11], VAR[12], VAR[13], VAR[14], VAR[15], VAR[16], VAR[17], VAR[18], VAR[19], VAR[20], VAR[21], VAR[22], VAR[23], VAR[24], VAR[25], VAR[26], VAR[27], VAR[28], VAR[29], VAR[30], VAR[31], VAR[32], VAR[33], VAR[34], VAR[35], VAR[36], VAR[37], VAR[38], VAR[39], VAR[40], VAR[41], VAR[42], VAR[43], VAR[44], VAR[45], VAR[46], VAR[47], VAR[48], VAR[49], VAR[50], VAR[51], VAR[52], VAR[53], VAR[54], VAR[55], VAR[56], VAR[57], VAR[58], VAR[59], VAR[60], VAR[61], VAR[62], VAR[63]}
    [junit] Value: ffffffffbf755566
    [junit] Test: width=2, count=32
    [junit] Expr: {VAR[0:1], VAR[1:2], VAR[2:3], VAR[3:4], VAR[4:5], VAR[5:6], VAR[6:7], VAR[7:8], VAR[8:9], VAR[9:10], VAR[10:11], VAR[11:12], VAR[12:13], VAR[13:14], VAR[14:15], VAR[15:16], VAR[16:17], VAR[17:18], VAR[18:19], VAR[19:20], VAR[20:21], VAR[21:22], VAR[22:23], VAR[23:24], VAR[24:25], VAR[25:26], VAR[26:27], VAR[27:28], VAR[28:29], VAR[29:30], VAR[30:31], VAR[31:32]}
    [junit] Value: ffffffffb28b4590
    [junit] Test: width=3, count=21
    [junit] Expr: {VAR[0:2], VAR[1:3], VAR[2:4], VAR[3:5], VAR[4:6], VAR[5:7], VAR[6:8], VAR[7:9], VAR[8:10], VAR[9:11], VAR[10:12], VAR[11:13], VAR[12:14], VAR[13:15], VAR[14:16], VAR[15:17], VAR[16:18], VAR[17:19], VAR[18:20], VAR[19:21], VAR[20:22]}
    [junit] Value: ffffffffa0ffae42
    [junit] Test: width=4, count=16
    [junit] Expr: {VAR[0:3], VAR[1:4], VAR[2:5], VAR[3:6], VAR[4:7], VAR[5:8], VAR[6:9], VAR[7:10], VAR[8:11], VAR[9:12], VAR[10:13], VAR[11:14], VAR[12:15], VAR[13:16], VAR[14:17], VAR[15:18]}
    [junit] Value: ffffffffaf875517
    [junit] Test: width=5, count=12
    [junit] Expr: {VAR[0:4], VAR[1:5], VAR[2:6], VAR[3:7], VAR[4:8], VAR[5:9], VAR[6:10], VAR[7:11], VAR[8:12], VAR[9:13], VAR[10:14], VAR[11:15]}
    [junit] Value: 991bcd0554e69338
    [junit] Test: width=6, count=10
    [junit] Expr: {VAR[0:5], VAR[1:6], VAR[2:7], VAR[3:8], VAR[4:9], VAR[5:10], VAR[6:11], VAR[7:12], VAR[8:13], VAR[9:14]}
    [junit] Value: 4ab57b9c6eba503f
    [junit] Test: width=7, count=9
    [junit] Expr: {VAR[0:6], VAR[1:7], VAR[2:8], VAR[3:9], VAR[4:10], VAR[5:11], VAR[6:12], VAR[7:13], VAR[8:14]}
    [junit] Value: 757f42565e39bf69
    [junit] Test: width=8, count=8
    [junit] Expr: {VAR[0:7], VAR[1:8], VAR[2:9], VAR[3:10], VAR[4:11], VAR[5:12], VAR[6:13], VAR[7:14]}
    [junit] Value: eec886cf56d10b9c
    [junit] Test: width=9, count=7
    [junit] Expr: {VAR[0:8], VAR[1:9], VAR[2:10], VAR[3:11], VAR[4:12], VAR[5:13], VAR[6:14]}
    [junit] Value: ffffffff81e71ddb
    [junit] Test: width=10, count=6
    [junit] Expr: {VAR[0:9], VAR[1:10], VAR[2:11], VAR[3:12], VAR[4:13], VAR[5:14]}
    [junit] Value: 8567b9a75d98adab
    [junit] Test: width=11, count=5
    [junit] Expr: {VAR[0:10], VAR[1:11], VAR[2:12], VAR[3:13], VAR[4:14]}
    [junit] Value: e291bb6f341ece12
    [junit] Test: width=12, count=5
    [junit] Expr: {VAR[0:11], VAR[1:12], VAR[2:13], VAR[3:14], VAR[4:15]}
    [junit] Value: 906e0c1600b012a7
    [junit] Test: width=13, count=4
    [junit] Expr: {VAR[0:12], VAR[1:13], VAR[2:14], VAR[3:15]}
    [junit] Value: d9d604c859e550c5
    [junit] Test: width=14, count=4
    [junit] Expr: {VAR[0:13], VAR[1:14], VAR[2:15], VAR[3:16]}
    [junit] Value: ffffffff88ac3ff6
    [junit] Test: width=15, count=4
    [junit] Expr: {VAR[0:14], VAR[1:15], VAR[2:16], VAR[3:17]}
    [junit] Value: ab84b5877dd09d84
    [junit] Test: width=16, count=4
    [junit] Expr: {VAR[0:15], VAR[1:16], VAR[2:17], VAR[3:18]}
    [junit] Value: 43fc101b25e2ec88
    [junit] Test: width=17, count=3
    [junit] Expr: {VAR[0:16], VAR[1:17], VAR[2:18]}
    [junit] Value: ffffffffe9ca25e0
    [junit] Test: width=18, count=3
    [junit] Expr: {VAR[0:17], VAR[1:18], VAR[2:19]}
    [junit] Value: ffffffff866beb31
    [junit] Test: width=19, count=3
    [junit] Expr: {VAR[0:18], VAR[1:19], VAR[2:20]}
    [junit] Value: d812196c4bdb9cc7
    [junit] Test: width=20, count=3
    [junit] Expr: {VAR[0:19], VAR[1:20], VAR[2:21]}
    [junit] Value: ffffffffe94510ae
    [junit] Test: width=21, count=3
    [junit] Expr: {VAR[0:20], VAR[1:21], VAR[2:22]}
    [junit] Value: ffffffffb07eb8a8
    [junit] Test: width=22, count=2
    [junit] Expr: {VAR[0:21], VAR[1:22]}
    [junit] Value: ffffffff88e1eb22
    [junit] Test: width=23, count=2
    [junit] Expr: {VAR[0:22], VAR[1:23]}
    [junit] Value: 126f36f2577bfdaf
    [junit] Test: width=24, count=2
    [junit] Expr: {VAR[0:23], VAR[1:24]}
    [junit] Value: d0d8f8f7d218e7f
    [junit] Test: width=25, count=2
    [junit] Expr: {VAR[0:24], VAR[1:25]}
    [junit] Value: ffffffffdfaa5513
    [junit] Test: width=26, count=2
    [junit] Expr: {VAR[0:25], VAR[1:26]}
    [junit] Value: ffffffffad1fb7ef
    [junit] Test: width=27, count=2
    [junit] Expr: {VAR[0:26], VAR[1:27]}
    [junit] Value: ffffffffac83b5ff
    [junit] Test: width=28, count=2
    [junit] Expr: {VAR[0:27], VAR[1:28]}
    [junit] Value: ffffffffe7927a5d
    [junit] Test: width=29, count=2
    [junit] Expr: {VAR[0:28], VAR[1:29]}
    [junit] Value: ffffffff9d4285a3
    [junit] Test: width=30, count=2
    [junit] Expr: {VAR[0:29], VAR[1:30]}
    [junit] Value: cd0ba8b7443a01be
    [junit] Test: width=31, count=2
    [junit] Expr: {VAR[0:30], VAR[1:31]}
    [junit] Value: 680c94fa08377344
    [junit] Test: width=32, count=2
    [junit] Expr: {VAR[0:31], VAR[1:32]}
    [junit] Value: ffffffffb3c4bcea
    [junit] Test: width=33, count=1
    [junit] Expr: VAR[0:32]
    [junit] Value: ffffffffea322024
    [junit] Test: width=34, count=1
    [junit] Expr: VAR[0:33]
    [junit] Value: b75ea8a31d697578
    [junit] Test: width=35, count=1
    [junit] Expr: VAR[0:34]
    [junit] Value: ffffffffb842269e
    [junit] Test: width=36, count=1
    [junit] Expr: VAR[0:35]
    [junit] Value: c5e3936b4cbcd87f
    [junit] Test: width=37, count=1
    [junit] Expr: VAR[0:36]
    [junit] Value: ffffffffaa19a45a
    [junit] Test: width=38, count=1
    [junit] Expr: VAR[0:37]
    [junit] Value: ffffffff93797259
    [junit] Test: width=39, count=1
    [junit] Expr: VAR[0:38]
    [junit] Value: 9f6500c11c62f791
    [junit] Test: width=40, count=1
    [junit] Expr: VAR[0:39]
    [junit] Value: 7f43373551c5de2d
    [junit] Test: width=41, count=1
    [junit] Expr: VAR[0:40]
    [junit] Value: 9aed867a6b4db6d4
    [junit] Test: width=42, count=1
    [junit] Expr: VAR[0:41]
    [junit] Value: ffffffffe46f9715
    [junit] Test: width=43, count=1
    [junit] Expr: VAR[0:42]
    [junit] Value: 657330aa5a3701f3
    [junit] Test: width=44, count=1
    [junit] Expr: VAR[0:43]
    [junit] Value: fffffffff0264c61
    [junit] Test: width=45, count=1
    [junit] Expr: VAR[0:44]
    [junit] Value: ffffffffd180d36f
    [junit] Test: width=46, count=1
    [junit] Expr: VAR[0:45]
    [junit] Value: ffffffffc5f8ebe4
    [junit] Test: width=47, count=1
    [junit] Expr: VAR[0:46]
    [junit] Value: ffffffffd8c5d24b
    [junit] Test: width=48, count=1
    [junit] Expr: VAR[0:47]
    [junit] Value: ffffffff9b277bb9
    [junit] Test: width=49, count=1
    [junit] Expr: VAR[0:48]
    [junit] Value: ffffffff803eff49
    [junit] Test: width=50, count=1
    [junit] Expr: VAR[0:49]
    [junit] Value: ffffffff8ee4385b
    [junit] Test: width=51, count=1
    [junit] Expr: VAR[0:50]
    [junit] Value: f7d9a6e469563008
    [junit] Test: width=52, count=1
    [junit] Expr: VAR[0:51]
    [junit] Value: ffffffffeab59b00
    [junit] Test: width=53, count=1
    [junit] Expr: VAR[0:52]
    [junit] Value: ffffffff96a50b98
    [junit] Test: width=54, count=1
    [junit] Expr: VAR[0:53]
    [junit] Value: ffffffffb8f4cd7c
    [junit] Test: width=55, count=1
    [junit] Expr: VAR[0:54]
    [junit] Value: ffffffffde087b60
    [junit] Test: width=56, count=1
    [junit] Expr: VAR[0:55]
    [junit] Value: ffffffffe21e32c5
    [junit] Test: width=57, count=1
    [junit] Expr: VAR[0:56]
    [junit] Value: 6981d0fb1a949721
    [junit] Test: width=58, count=1
    [junit] Expr: VAR[0:57]
    [junit] Value: ffffffffa56ffed2
    [junit] Test: width=59, count=1
    [junit] Expr: VAR[0:58]
    [junit] Value: 37407601387909ef
    [junit] Test: width=60, count=1
    [junit] Expr: VAR[0:59]
    [junit] Value: ffffffffb2d38082
    [junit] Test: width=61, count=1
    [junit] Expr: VAR[0:60]
    [junit] Value: 90036c9533592eb4
    [junit] Test: width=62, count=1
    [junit] Expr: VAR[0:61]
    [junit] Value: ffffffffdd5bbac5
    [junit] Test: width=63, count=1
    [junit] Expr: VAR[0:62]
    [junit] Value: 3e6acdd51cb8a312
    [junit] Test: width=64, count=1
    [junit] Expr: VAR
    [junit] Value: ffffffffa001f7c9
    [junit] ------------- ---------------- ---------------
    [junit] 
    [junit] Testcase: runTest took 0,016 sec
    [junit] Running ru.ispras.microtesk.translator.mmu.spec.MmuConditionTestCase
    [junit] Testsuite: ru.ispras.microtesk.translator.mmu.spec.MmuConditionTestCase
    [junit] Range: min=0, max=7fffffff
    [junit] Condition: {
    [junit] VAR[31:63]=0,
    [junit] }
    [junit] 
    [junit] Range: min=80000000, max=ffffffffff
    [junit] Condition: {
    [junit] VAR[40:63]=0,
    [junit] VAR[31:39]!=0,
    [junit] }
    [junit] 
    [junit] Range: min=4000000000000000, max=400000ffffffffff
    [junit] Condition: {
    [junit] VAR[40:63]=800000,
    [junit] }
    [junit] 
    [junit] Range: min=ffffffffc0000000, max=ffffffffdfffffff
    [junit] Condition: {
    [junit] VAR[29:63]=ffffffffc,
    [junit] }
    [junit] 
    [junit] Range: min=ffffffffe0000000, max=ffffffffffffffff
    [junit] Condition: {
    [junit] VAR[29:63]=ffffffffe,
    [junit] }
    [junit] 
    [junit] Range: min=c000000000000000, max=c00000ff7fffffff
    [junit] null
    [junit] Tests run: 1, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0,006 sec
    [junit] Tests run: 1, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0,006 sec
    [junit] ------------- Standard Output ---------------
    [junit] Range: min=0, max=7fffffff
    [junit] Condition: {
    [junit] VAR[31:63]=0,
    [junit] }
    [junit] 
    [junit] Range: min=80000000, max=ffffffffff
    [junit] Condition: {
    [junit] VAR[40:63]=0,
    [junit] VAR[31:39]!=0,
    [junit] }
    [junit] 
    [junit] Range: min=4000000000000000, max=400000ffffffffff
    [junit] Condition: {
    [junit] VAR[40:63]=800000,
    [junit] }
    [junit] 
    [junit] Range: min=ffffffffc0000000, max=ffffffffdfffffff
    [junit] Condition: {
    [junit] VAR[29:63]=ffffffffc,
    [junit] }
    [junit] 
    [junit] Range: min=ffffffffe0000000, max=ffffffffffffffff
    [junit] Condition: {
    [junit] VAR[29:63]=ffffffffe,
    [junit] }
    [junit] 
    [junit] Range: min=c000000000000000, max=c00000ff7fffffff
    [junit] null
    [junit] ------------- ---------------- ---------------
    [junit] 
    [junit] Testcase: runTest took 0,004 sec
    [junit] 	FAILED
    [junit] null
    [junit] junit.framework.AssertionFailedError
    [junit] 	at ru.ispras.microtesk.translator.mmu.spec.MmuConditionTestCase.runTest(Unknown Source)
    [junit] 	at ru.ispras.microtesk.translator.mmu.spec.MmuConditionTestCase.runTest(Unknown Source)
    [junit] 
    [junit] Running ru.ispras.microtesk.translator.mmu.spec.MmuDeviceTestCase
    [junit] Testsuite: ru.ispras.microtesk.translator.mmu.spec.MmuDeviceTestCase
    [junit] Test: DTLB, ffffffffdafc2ff7
    [junit] tag=7fed7e1, index=0, offset=ff7
    [junit] Test: L1, ffffffff9e10d5a4
    [junit] tag=f9e10d, index=2d, offset=4
    [junit] Test: L2, 521270865eb88a2d
    [junit] tag=32f5c, index=451, offset=d
    [junit] Test: DTLB, 59ae81255f0e9113
    [junit] tag=12af874, index=0, offset=1113
    [junit] Test: L1, c5c7a797441c2cc5
    [junit] tag=7441c2, index=66, offset=5
    [junit] Test: L2, ffffffffcef337d7
    [junit] tag=7e779, index=9be, offset=17
    [junit] Test: DTLB, 69f957f32e300696
    [junit] tag=7997180, index=0, offset=696
    [junit] Test: L1, 2642d0bb77bc5ff2
    [junit] tag=b77bc5, index=7f, offset=12
    [junit] Test: L2, 228da1c463709103
    [junit] tag=231b8, index=488, offset=3
    [junit] Test: DTLB, ffffffffbe2ccab6
    [junit] tag=7fdf166, index=0, offset=ab6
    [junit] Test: L1, ffffffffd861c39e
    [junit] tag=fd861c, index=1c, offset=1e
    [junit] Test: L2, 91c3b97b1630ad7b
    [junit] tag=58b18, index=56b, offset=1b
    [junit] Test: DTLB, fffffffffa47f53c
    [junit] tag=7ffd23f, index=0, offset=153c
    [junit] Test: L1, ffffffff98381938
    [junit] tag=f98381, index=49, offset=18
    [junit] Test: L2, 2968c08d5db55368
    [junit] tag=6aeda, index=a9b, offset=8
    [junit] Test: DTLB, ffffffffd38fde1b
    [junit] tag=7fe9c7e, index=0, offset=1e1b
    [junit] Test: L1, ffffffffb9bf7940
    [junit] tag=fb9bf7, index=4a, offset=0
    [junit] Test: L2, ffffffffa40298a0
    [junit] tag=7d201, index=4c5, offset=0
    [junit] Test: DTLB, b2e39a7f1d8556a3
    [junit] tag=3f8ec2a, index=0, offset=16a3
    [junit] Test: L1, 46021907033acf9
    [junit] tag=7033a, index=67, offset=19
    [junit] Test: L2, ffffffff9fb6cc2b
    [junit] tag=7cfdb, index=661, offset=b
    [junit] Test: DTLB, 5fa38561717c1c8b
    [junit] tag=30b8be0, index=0, offset=1c8b
    [junit] Test: L1, ffffffffea045bf4
    [junit] tag=fea045, index=5f, offset=14
    [junit] Test: L2, ffffffffe6154388
    [junit] tag=7f30a, index=a1c, offset=8
    [junit] Test: DTLB, ffffffffa3e958e8
    [junit] tag=7fd1f4a, index=0, offset=18e8
    [junit] Test: L1, ffffffff9601ae95
    [junit] tag=f9601a, index=74, offset=15
    [junit] Test: L2, ffffffffe248d11e
    [junit] tag=7f124, index=688, offset=1e
    [junit] Test: DTLB, 1050f2222a128969
    [junit] tag=1115094, index=0, offset=969
    [junit] Test: L1, ffffffff8447950b
    [junit] tag=f84479, index=28, offset=b
    [junit] Test: L2, dd1483651a10581d
    [junit] tag=28d08, index=2c0, offset=1d
    [junit] Test: DTLB, 43a910087223f2cc
    [junit] tag=43911f, index=0, offset=12cc
    [junit] Test: L1, ffffffffafba7814
    [junit] tag=fafba7, index=40, offset=14
    [junit] Test: L2, a416c3665c29b5c4
    [junit] tag=32e14, index=dae, offset=4
    [junit] Test: DTLB, ffffffffc67be4ae
    [junit] tag=7fe33df, index=0, offset=4ae
    [junit] Test: L1, ceb1ea433c3b93f
    [junit] tag=433c3b, index=49, offset=1f
    [junit] Test: L2, ffffffff8876e1c7
    [junit] tag=7c43b, index=70e, offset=7
    [junit] Test: DTLB, ffffffffba585247
    [junit] tag=7fdd2c2, index=0, offset=1247
    [junit] Test: L1, 3689a355747090e8
    [junit] tag=574709, index=7, offset=8
    [junit] Test: L2, ffffffff9575181c
    [junit] tag=7caba, index=8c0, offset=1c
    [junit] Test: DTLB, 643c7280b99827c
    [junit] tag=1405ccc, index=0, offset=27c
    [junit] Test: L1, ffffffffd75646b1
    [junit] tag=fd7564, index=35, offset=11
    [junit] Test: L2, a71b79bc62f839ae
    [junit] tag=6317c, index=1cd, offset=e
    [junit] Test: DTLB, c6e20d3624ce728
    [junit] tag=69b1267, index=0, offset=728
    [junit] Test: L1, 102457ed6055612f
    [junit] tag=d60556, index=9, offset=f
    [junit] Test: L2, ffffffff995223c5
    [junit] tag=7cca9, index=11e, offset=5
    [junit] Test: DTLB, ffffffffb85fefb1
    [junit] tag=7fdc2ff, index=0, offset=fb1
    [junit] Test: L1, ffffffffd0bf8ba6
    [junit] tag=fd0bf8, index=5d, offset=6
    [junit] Test: L2, 2edd874760ad8820
    [junit] tag=3b056, index=c41, offset=0
    [junit] Test: DTLB, 46535b6c1dddf2f8
    [junit] tag=360eeef, index=0, offset=12f8
    [junit] Test: L1, 898c8fe04aa98766
    [junit] tag=4aa98, index=3b, offset=6
    [junit] Test: L2, 6dc4bfad7a010390
    [junit] tag=6bd00, index=81c, offset=10
    [junit] Test: DTLB, ffffffffbffbe757
    [junit] tag=7fdffdf, index=0, offset=757
    [junit] Test: L1, a3022ded01e6e66c
    [junit] tag=d01e6e, index=33, offset=c
    [junit] Test: L2, f0632c15aa83811
    [junit] tag=ad54, index=1c0, offset=11
    [junit] Test: DTLB, dafa50b557870d46
    [junit] tag=5aabc38, index=0, offset=d46
    [junit] Test: L1, ffffffffd3f3ae91
    [junit] tag=fd3f3a, index=74, offset=11
    [junit] Test: L2, 36d6ffc64c16769
    [junit] tag=63260, index=b3b, offset=9
    [junit] Test: DTLB, 9c073e316e708678
    [junit] tag=18b7384, index=0, offset=678
    [junit] Test: L1, ffffffffd21b2b3c
    [junit] tag=fd21b2, index=59, offset=1c
    [junit] Test: L2, 5c11795304667bc1
    [junit] tag=18233, index=3de, offset=1
    [junit] Test: DTLB, ffffffff8cddc554
    [junit] tag=7fc66ee, index=0, offset=554
    [junit] Test: L1, ffffffffdfd2f6ba
    [junit] tag=fdfd2f, index=35, offset=1a
    [junit] Test: L2, be05416c10e763c6
    [junit] tag=60873, index=b1e, offset=6
    [junit] Test: DTLB, fffffffff7a95ac0
    [junit] tag=7ffbd4a, index=0, offset=1ac0
    [junit] Test: L1, e566597418b0dcd1
    [junit] tag=418b0d, index=66, offset=11
    [junit] Test: L2, bbfba5f95e981a02
    [junit] tag=4af4c, index=d0, offset=2
    [junit] Test: DTLB, c97d28c14943b456
    [junit] tag=60a4a1d, index=0, offset=1456
    [junit] Test: L1, ffffffff93c41b4f
    [junit] tag=f93c41, index=5a, offset=f
    [junit] Test: L2, d222943d4f45d92d
    [junit] tag=6a7a2, index=ec9, offset=d
    [junit] Test: DTLB, d39575d37fc6bd1b
    [junit] tag=69bfe35, index=0, offset=1d1b
    [junit] Test: L1, ffffffffce575329
    [junit] tag=fce575, index=19, offset=9
    [junit] Test: L2, ffffffff9e1ed6ae
    [junit] tag=7cf0f, index=6b5, offset=e
    [junit] Test: DTLB, ffffffffe2a2c360
    [junit] tag=7ff1516, index=0, offset=360
    [junit] Test: L1, 6f4048fe2e8af295
    [junit] tag=e2e8af, index=14, offset=15
    [junit] Test: L2, ffffffffc9c2637d
    [junit] tag=7e4e1, index=31b, offset=1d
    [junit] Test: DTLB, 139d11de6f65be94
    [junit] tag=6f37b2d, index=0, offset=1e94
    [junit] Test: L1, f7140c7400ec4cf1
    [junit] tag=400ec4, index=67, offset=11
    [junit] Test: L2, ac20432ceda2a3
    [junit] tag=19676, index=d15, offset=3
    [junit] Test: DTLB, ffffffffbd34df15
    [junit] tag=7fde9a6, index=0, offset=1f15
    [junit] Test: L1, fffffffff7de347c
    [junit] tag=ff7de3, index=23, offset=1c
    [junit] Test: L2, f1bdfda97fdb2b16
    [junit] tag=4bfed, index=958, offset=16
    [junit] Test: DTLB, d7d434440ec8ec4
    [junit] tag=2220764, index=0, offset=ec4
    [junit] Test: L1, ffffffffec410517
    [junit] tag=fec410, index=28, offset=17
    [junit] Test: L2, ffffffff8cc20532
    [junit] tag=7c661, index=29, offset=12
    [junit] Test: DTLB, 37cc44864bf99330
    [junit] tag=4325fcc, index=0, offset=1330
    [junit] Test: L1, 7ed04a7e315ae453
    [junit] tag=e315ae, index=22, offset=13
    [junit] Test: L2, ffffffffb4d7f9d8
    [junit] tag=7da6b, index=fce, offset=18
    [junit] Test: DTLB, ffffffffbb079dac
    [junit] tag=7fdd83c, index=0, offset=1dac
    [junit] Test: L1, 756240e840ddae36
    [junit] tag=840dda, index=71, offset=16
    [junit] Test: L2, ffffffffee27e3b3
    [junit] tag=7f713, index=f1d, offset=13
    [junit] Test: DTLB, 83fd18f71924c128
    [junit] tag=7b8c926, index=0, offset=128
    [junit] Test: L1, ffffffff9c98a3f0
    [junit] tag=f9c98a, index=1f, offset=10
    [junit] Test: L2, 67749e0a3b9e9606
    [junit] tag=51dcf, index=4b0, offset=6
    [junit] Test: DTLB, 2c64c8ca0e027f8c
    [junit] tag=6507013, index=0, offset=1f8c
    [junit] Test: L1, e3bd51e11d61e6f9
    [junit] tag=11d61e, index=37, offset=19
    [junit] Test: L2, 812efaaa4ea18f77
    [junit] tag=52750, index=c7b, offset=17
    [junit] Test: DTLB, ffffffffbf149c5f
    [junit] tag=7fdf8a4, index=0, offset=1c5f
    [junit] Test: L1, ffffffffacbdd601
    [junit] tag=facbdd, index=30, offset=1
    [junit] Test: L2, ffffffff93c8ecf2
    [junit] tag=7c9e4, index=767, offset=12
    [junit] Test: DTLB, bf26236562048818
    [junit] tag=32b1024, index=0, offset=818
    [junit] Test: L1, ffffffffee92a6a7
    [junit] tag=fee92a, index=35, offset=7
    [junit] Test: L2, fffffffff1d8a8b4
    [junit] tag=7f8ec, index=545, offset=14
    [junit] Test: DTLB, 49f3d9646dd6d36e
    [junit] tag=3236eb6, index=0, offset=136e
    [junit] Test: L1, 641611f866b46864
    [junit] tag=866b46, index=43, offset=4
    [junit] Test: L2, ffffffff9b2e97c5
    [junit] tag=7cd97, index=4be, offset=5
    [junit] Test: DTLB, ffffffffbb6a4c4d
    [junit] tag=7fddb52, index=0, offset=c4d
    [junit] Test: L1, ffffffffca981d3a
    [junit] tag=fca981, index=69, offset=1a
    [junit] Test: L2, 50a8b735635fd1a4
    [junit] tag=2b1af, index=e8d, offset=4
    [junit] Test: DTLB, ffffffff8e592eaa
    [junit] tag=7fc72c9, index=0, offset=eaa
    [junit] Test: L1, 9bf371e83a0e3cfc
    [junit] tag=83a0e3, index=67, offset=1c
    [junit] Test: L2, ffffffff8075e83d
    [junit] tag=7c03a, index=f41, offset=1d
    [junit] Test: DTLB, ffffffff9ad34496
    [junit] tag=7fcd69a, index=0, offset=496
    [junit] Test: L1, ffffffff8dc5ab41
    [junit] tag=f8dc5a, index=5a, offset=1
    [junit] Test: L2, ffffffff8d76fc1a
    [junit] tag=7c6bb, index=7e0, offset=1a
    [junit] Test: DTLB, 54e3d30c4d616525
    [junit] tag=626b0b, index=0, offset=525
    [junit] Test: L1, ffffffffde33a774
    [junit] tag=fde33a, index=3b, offset=14
    [junit] Test: L2, 1e7afda8490c2c15
    [junit] tag=42486, index=160, offset=15
    [junit] Test: DTLB, e260cdfb1871cc67
    [junit] tag=7d8c38e, index=0, offset=c67
    [junit] Test: L1, 634696de7febbd52
    [junit] tag=e7febb, index=6a, offset=12
    [junit] Test: L2, fffffffff8a6e8b6
    [junit] tag=7fc53, index=745, offset=16
    [junit] Test: DTLB, ffffffffb23a19dc
    [junit] tag=7fd91d0, index=0, offset=19dc
    [junit] Test: L1, ffffffffb74f2af5
    [junit] tag=fb74f2, index=57, offset=15
    [junit] Test: L2, 1acacd1b02a0e5e7
    [junit] tag=58150, index=72f, offset=7
    [junit] Test: DTLB, 7880a15a4827da60
    [junit] tag=2d2413e, index=0, offset=1a60
    [junit] Test: L1, 7d679f1a4cd6d82d
    [junit] tag=a4cd6d, index=41, offset=d
    [junit] Test: L2, f6caaa585c763e90
    [junit] tag=42e3b, index=1f4, offset=10
    [junit] Test: DTLB, ffffffffc982c00a
    [junit] tag=7fe4c16, index=0, offset=a
    [junit] Test: L1, ffffffffac51e6ff
    [junit] tag=fac51e, index=37, offset=1f
    [junit] Test: L2, ffffffffa4d8f962
    [junit] tag=7d26c, index=7cb, offset=2
    [junit] Test: DTLB, 7f99574f210e0b83
    [junit] tag=2790870, index=0, offset=b83
    [junit] Test: L1, fffffffff5cb9a69
    [junit] tag=ff5cb9, index=53, offset=9
    [junit] Test: L2, ffffffffd6be4239
    [junit] tag=7eb5f, index=211, offset=19
    [junit] Test: DTLB, 179f2def39992fb0
    [junit] tag=779ccc9, index=0, offset=fb0
    [junit] Test: L1, fffffffff6fcc7c3
    [junit] tag=ff6fcc, index=3e, offset=3
    [junit] Test: L2, c04e4fdc53f92ecc
    [junit] tag=629fc, index=976, offset=c
    [junit] Test: DTLB, ffffffffb366beb8
    [junit] tag=7fd9b35, index=0, offset=1eb8
    [junit] Test: L1, ecceace03484983d
    [junit] tag=34849, index=41, offset=1d
    [junit] Test: L2, ffffffff9e29f252
    [junit] tag=7cf14, index=f92, offset=12
    [junit] Test: DTLB, fffffffff39d18e5
    [junit] tag=7ff9ce8, index=0, offset=18e5
    [junit] Test: L1, ffffffffc80616b7
    [junit] tag=fc8061, index=35, offset=17
    [junit] Test: L2, ffffffff90b1b116
    [junit] tag=7c858, index=d88, offset=16
    [junit] Test: DTLB, ece4997535617792
    [junit] tag=3a9ab0b, index=0, offset=1792
    [junit] Test: L1, ffffffffb7f3da14
    [junit] tag=fb7f3d, index=50, offset=14
    [junit] Test: L2, bc07e89c34383a91
    [junit] tag=61a1c, index=1d4, offset=11
    [junit] Test: DTLB, ffffffffb7675da7
    [junit] tag=7fdbb3a, index=0, offset=1da7
    [junit] Test: L1, ffffffffdb3a5e19
    [junit] tag=fdb3a5, index=70, offset=19
    [junit] Test: L2, 775bcd72744b1c70
    [junit] tag=13a25, index=8e3, offset=10
    [junit] Test: DTLB, f0c1f80875257756
    [junit] tag=43a92b, index=0, offset=1756
    [junit] Test: L1, ffffffffa8ab5e19
    [junit] tag=fa8ab5, index=70, offset=19
    [junit] Test: L2, 618341b17b2622e4
    [junit] tag=bd93, index=117, offset=4
    [junit] Test: DTLB, 4507bfe975258b5f
    [junit] tag=74ba92c, index=0, offset=b5f
    [junit] Test: L1, fefeae695361e8ed
    [junit] tag=95361e, index=47, offset=d
    [junit] Test: L2, c0ccb9d167f5577e
    [junit] tag=b3fa, index=abb, offset=1e
    [junit] Test: DTLB, 686ea7c508077078
    [junit] tag=628403b, index=0, offset=1078
    [junit] Test: L1, 959bc58d7764ca1f
    [junit] tag=d7764c, index=50, offset=1f
    [junit] Test: L2, ffffffffe4f77cd4
    [junit] tag=7f27b, index=be6, offset=14
    [junit] Test: DTLB, ffffffffa60030f6
    [junit] tag=7fd3001, index=0, offset=10f6
    [junit] Test: L1, 12dad02e2c9ac870
    [junit] tag=e2c9ac, index=43, offset=10
    [junit] Test: L2, 82af4b0b05cff5b0
    [junit] tag=582e7, index=fad, offset=10
    [junit] Test: DTLB, c5bdb63159c22549
    [junit] tag=18ace11, index=0, offset=549
    [junit] Test: L1, f6a9936c4354e016
    [junit] tag=c4354e, index=0, offset=16
    [junit] Test: L2, 7320058c7b14bd00
    [junit] tag=63d8a, index=5e8, offset=0
    [junit] Test: DTLB, ea054ce562cc980d
    [junit] tag=72b1664, index=0, offset=180d
    [junit] Test: L1, ffffffff98b80505
    [junit] tag=f98b80, index=28, offset=5
    [junit] Test: L2, 7449d10e2a0d51d6
    [junit] tag=71506, index=a8e, offset=16
    [junit] Test: DTLB, ee929a764da53146
    [junit] tag=3b26d29, index=0, offset=1146
    [junit] Test: L1, ffffffffb3a81d90
    [junit] tag=fb3a81, index=6c, offset=10
    [junit] Test: L2, ffffffffd0ec66cb
    [junit] tag=7e876, index=336, offset=b
    [junit] Test: DTLB, ffffffffb624897f
    [junit] tag=7fdb124, index=0, offset=97f
    [junit] Test: L1, c247884479f23ca3
    [junit] tag=479f23, index=65, offset=3
    [junit] Test: L2, ffffffffda57ee2c
    [junit] tag=7ed2b, index=f71, offset=c
    [junit] Test: DTLB, ffffffff8ceb6d28
    [junit] tag=7fc675b, index=0, offset=d28
    [junit] Test: L1, ffffffffa9173ac5
    [junit] tag=fa9173, index=56, offset=5
    [junit] Test: L2, fffffffff46d4e32
    [junit] tag=7fa36, index=a71, offset=12
    [junit] Test: DTLB, ffffffff9504d0fd
    [junit] tag=7fca826, index=0, offset=10fd
    [junit] Test: L1, 54bbc7e76d888a30
    [junit] tag=76d888, index=51, offset=10
    [junit] Test: L2, 14fe8703489e1783
    [junit] tag=1a44f, index=bc, offset=3
    [junit] Test: DTLB, ffffffff83a0f663
    [junit] tag=7fc1d07, index=0, offset=1663
    [junit] Test: L1, 9bc754142ab2cd38
    [junit] tag=42ab2c, index=69, offset=18
    [junit] Test: L2, fffffffff0392e98
    [junit] tag=7f81c, index=974, offset=18
    [junit] Test: DTLB, ba6ef90d29991553
    [junit] tag=694cc8, index=0, offset=1553
    [junit] Test: L1, cece980c6b678110
    [junit] tag=c6b678, index=8, offset=10
    [junit] Test: L2, ffffffffae093d8a
    [junit] tag=7d704, index=9ec, offset=a
    [junit] Test: DTLB, ffffffffcca0d27a
    [junit] tag=7fe6506, index=0, offset=127a
    [junit] Test: L1, ffffffff97f88a17
    [junit] tag=f97f88, index=50, offset=17
    [junit] Test: L2, ffffffff9681bb04
    [junit] tag=7cb40, index=dd8, offset=4
    [junit] Test: DTLB, a5fee79d3f966635
    [junit] tag=4e9fcb3, index=0, offset=635
    [junit] Test: L1, fffffffff47e0e94
    [junit] tag=ff47e0, index=74, offset=14
    [junit] Test: L2, 711663681fd61c33
    [junit] tag=40feb, index=e1, offset=13
    [junit] Test: DTLB, ffffffffaead7640
    [junit] tag=7fd756b, index=0, offset=1640
    [junit] Test: L1, d6f934017e6301e9
    [junit] tag=17e630, index=f, offset=9
    [junit] Test: L2, 2751bdfe64964b6d
    [junit] tag=7324b, index=25b, offset=d
    [junit] Test: DTLB, 6fdbaa2a3b2662dd
    [junit] tag=151d933, index=0, offset=2dd
    [junit] Test: L1, 9e65d9760ac1b662
    [junit] tag=60ac1b, index=33, offset=2
    [junit] Test: L2, ffffffffce4232bf
    [junit] tag=7e721, index=195, offset=1f
    [junit] Test: DTLB, ffffffffb4977f6d
    [junit] tag=7fda4bb, index=0, offset=1f6d
    [junit] Test: L1, 8a227d834b63025f
    [junit] tag=34b630, index=12, offset=1f
    [junit] Test: L2, 187643cf4921ba2f
    [junit] tag=7a490, index=dd1, offset=f
    [junit] Test: DTLB, 7d50c4681ce0ea96
    [junit] tag=340e707, index=0, offset=a96
    [junit] Test: L1, ffffffffc6340992
    [junit] tag=fc6340, index=4c, offset=12
    [junit] Test: L2, ffffffffeff7ca87
    [junit] tag=7f7fb, index=e54, offset=7
    [junit] Test: DTLB, ffffffffc13342f4
    [junit] tag=7fe099a, index=0, offset=2f4
    [junit] Test: L1, 408f9c05225e490f
    [junit] tag=5225e4, index=48, offset=f
    [junit] Test: L2, ffffffff9010db9c
    [junit] tag=7c808, index=6dc, offset=1c
    [junit] Test: DTLB, d4c0eb692093cd4f
    [junit] tag=349049e, index=0, offset=d4f
    [junit] Test: L1, ffffffff96bcae5e
    [junit] tag=f96bca, index=72, offset=1e
    [junit] Test: L2, d18001f97daaa051
    [junit] tag=4bed5, index=502, offset=11
    [junit] Test: DTLB, fffffffff3e478e1
    [junit] tag=7ff9f23, index=0, offset=18e1
    [junit] Test: L1, ffffffffb52b764f
    [junit] tag=fb52b7, index=32, offset=f
    [junit] Test: L2, ffffffff85697550
    [junit] tag=7c2b4, index=baa, offset=10
    [junit] Test: DTLB, 97e5112171df943
    [junit] tag=90b8ef, index=0, offset=1943
    [junit] Test: L1, ffffffffd23674fb
    [junit] tag=fd2367, index=27, offset=1b
    [junit] Test: L2, ffffffff9153416b
    [junit] tag=7c8a9, index=a0b, offset=b
    [junit] Test: DTLB, ffffffff9aba6ce9
    [junit] tag=7fcd5d3, index=0, offset=ce9
    [junit] Test: L1, ba00a61a729f537e
    [junit] tag=a729f5, index=1b, offset=1e
    [junit] Test: L2, ffffffffc33d27ec
    [junit] tag=7e19e, index=93f, offset=c
    [junit] Test: DTLB, ffffffffd36964d9
    [junit] tag=7fe9b4b, index=0, offset=4d9
    [junit] Test: L1, 8d295b684137f5b2
    [junit] tag=84137f, index=2d, offset=12
    [junit] Test: L2, ffffffff9018fd23
    [junit] tag=7c80c, index=7e9, offset=3
    [junit] Test: DTLB, f1eaf8c07333d2cb
    [junit] tag=603999e, index=0, offset=12cb
    [junit] Test: L1, 4ac0d7971b355e84
    [junit] tag=71b355, index=74, offset=4
    [junit] Test: L2, 5ab53bb14c7e2f21
    [junit] tag=a63f, index=179, offset=1
    [junit] Test: DTLB, ffffffff95eb7136
    [junit] tag=7fcaf5b, index=0, offset=1136
    [junit] Test: L1, 6bbf84f5541d88ae
    [junit] tag=5541d8, index=45, offset=e
    [junit] Test: L2, ffffffffab1d009a
    [junit] tag=7d58e, index=804, offset=1a
    [junit] Test: DTLB, 63ebd3b240299b41
    [junit] tag=592014c, index=0, offset=1b41
    [junit] Test: L1, ffffffff8e29581d
    [junit] tag=f8e295, index=40, offset=1d
    [junit] Test: L2, ffffffff8df96e99
    [junit] tag=7c6fc, index=b74, offset=19
    [junit] Test: DTLB, ffffffffd6f6a78d
    [junit] tag=7feb7b5, index=0, offset=78d
    [junit] Test: L1, ffffffff80f706d7
    [junit] tag=f80f70, index=36, offset=17
    [junit] Test: L2, c3dec9f15b43b1a5
    [junit] tag=ada1, index=d8d, offset=5
    [junit] Test: DTLB, 607bc274602f3f14
    [junit] tag=3a30179, index=0, offset=1f14
    [junit] Test: L1, 7a56b9266151aae5
    [junit] tag=66151a, index=57, offset=5
    [junit] Test: L2, b973cb02059ada8e
    [junit] tag=102cd, index=6d4, offset=e
    [junit] Test: DTLB, c1f7043e2a36e281
    [junit] tag=1f151b7, index=0, offset=281
    [junit] Test: L1, 784715ca3dc61834
    [junit] tag=a3dc61, index=41, offset=14
    [junit] Test: L2, ffffffffda3047b9
    [junit] tag=7ed18, index=23d, offset=19
    [junit] Test: DTLB, a01d41a24750f9df
    [junit] tag=5123a87, index=0, offset=19df
    [junit] Test: L1, ffffffffc2cc0da6
    [junit] tag=fc2cc0, index=6d, offset=6
    [junit] Test: L2, fffffffff4b162ad
    [junit] tag=7fa58, index=b15, offset=d
    [junit] Test: DTLB, ffffffff8cbe641c
    [junit] tag=7fc65f3, index=0, offset=41c
    [junit] Test: L1, ffffffff97eea8bd
    [junit] tag=f97eea, index=45, offset=1d
    [junit] Test: L2, 76c1887f1694a236
    [junit] tag=78b4a, index=511, offset=16
    [junit] Test: DTLB, a139a0830e038da3
    [junit] tag=418701c, index=0, offset=da3
    [junit] Test: L1, 97ad5efb379b610d
    [junit] tag=b379b6, index=8, offset=d
    [junit] Test: L2, ffffffff9919663c
    [junit] tag=7cc8c, index=b31, offset=1c
    [junit] Test: DTLB, d71651582acdebc1
    [junit] tag=2c1566f, index=0, offset=bc1
    [junit] Test: L1, fb7042116a9ebadb
    [junit] tag=16a9eb, index=56, offset=1b
    [junit] Test: L2, c7dd56aa3f84fb6a
    [junit] tag=51fc2, index=7db, offset=a
    [junit] Test: DTLB, 6c1f298333c4ccf8
    [junit] tag=4199e26, index=0, offset=cf8
    [junit] Test: L1, ffffffffa8ecb0bf
    [junit] tag=fa8ecb, index=5, offset=1f
    [junit] Test: L2, f2ab1541721ebd4
    [junit] tag=20b90, index=f5e, offset=14
    [junit] Test: DTLB, ffffffffa0a8b262
    [junit] tag=7fd0545, index=0, offset=1262
    [junit] Test: L1, b44801d5318a97cd
    [junit] tag=5318a9, index=3e, offset=d
    [junit] Test: L2, 35f6309c4f968792
    [junit] tag=627cb, index=43c, offset=12
    [junit] Test: DTLB, fffffffffc9f95f9
    [junit] tag=7ffe4fc, index=0, offset=15f9
    [junit] Test: L1, 2f1797744a9c96c9
    [junit] tag=44a9c9, index=36, offset=9
    [junit] Test: L2, ffffffffa97e3324
    [junit] tag=7d4bf, index=199, offset=4
    [junit] Test: DTLB, ffffffff8a49d795
    [junit] tag=7fc524e, index=0, offset=1795
    [junit] Test: L1, ffffffffd0c7c0ed
    [junit] tag=fd0c7c, index=7, offset=d
    [junit] Test: L2, ffffffffc6968c78
    [junit] tag=7e34b, index=463, offset=18
    [junit] Test: DTLB, abb934f931d14335
    [junit] tag=7c98e8a, index=0, offset=335
    [junit] Test: L1, ffffffffc0629c11
    [junit] tag=fc0629, index=60, offset=11
    [junit] Test: L2, 2e2c471f1331e309
    [junit] tag=78998, index=f18, offset=9
    [junit] Test: DTLB, b9eb808841d59200
    [junit] tag=4420eac, index=0, offset=1200
    [junit] Test: L1, fffffffff8d55068
    [junit] tag=ff8d55, index=3, offset=8
    [junit] Test: L2, ffffffff81efad24
    [junit] tag=7c0f7, index=d69, offset=4
    [junit] Test: DTLB, ffffffff86eff352
    [junit] tag=7fc377f, index=0, offset=1352
    [junit] Test: L1, fffffffff1da33a5
    [junit] tag=ff1da3, index=1d, offset=5
    [junit] Test: L2, 255ac23c393d6ebb
    [junit] tag=61c9e, index=b75, offset=1b
    [junit] Test: DTLB, 12a225e31f73cb1c
    [junit] tag=718fb9e, index=0, offset=b1c
    [junit] Test: L1, c3e062e348f49bec
    [junit] tag=348f49, index=5f, offset=c
    [junit] Test: L2, ffffffffdf68d9c4
    [junit] tag=7efb4, index=6ce, offset=4
    [junit] Test: DTLB, ffffffffe1e2b2dd
    [junit] tag=7ff0f15, index=0, offset=12dd
    [junit] Test: L1, b1379dcf25cf5e3e
    [junit] tag=f25cf5, index=71, offset=1e
    [junit] Test: L2, ffffffffda4e1ba3
    [junit] tag=7ed27, index=dd, offset=3
    [junit] Test: DTLB, fffffffff3e95487
    [junit] tag=7ff9f4a, index=0, offset=1487
    [junit] Test: L1, ffffffff9435a750
    [junit] tag=f9435a, index=3a, offset=10
    [junit] Test: L2, ffffffff85db6c4f
    [junit] tag=7c2ed, index=b62, offset=f
    [junit] Test: DTLB, 6543595821d90d35
    [junit] tag=2c10ec8, index=0, offset=d35
    [junit] Test: L1, ffffffffa66255f2
    [junit] tag=fa6625, index=2f, offset=12
    [junit] Test: L2, fe6452e904c4b9e2
    [junit] tag=48262, index=5cf, offset=2
    [junit] Test: DTLB, a029a19c5783cf23
    [junit] tag=4e2bc1e, index=0, offset=f23
    [junit] Test: L1, df58728c151e7b87
    [junit] tag=c151e7, index=5c, offset=7
    [junit] Test: L2, ffffffffb20922ab
    [junit] tag=7d904, index=915, offset=b
    [junit] Test: DTLB, ffffffffc57c1422
    [junit] tag=7fe2be0, index=0, offset=1422
    [junit] Test: L1, ffffffffdb2c5aee
    [junit] tag=fdb2c5, index=57, offset=e
    [junit] Test: L2, 7724d48e3a1ad5f9
    [junit] tag=71d0d, index=6af, offset=19
    [junit] Test: DTLB, 7d1420492c33a198
    [junit] tag=249619d, index=0, offset=198
    [junit] Test: L1, d4ed91b4558a144a
    [junit] tag=4558a1, index=22, offset=a
    [junit] Test: L2, 4d205bbc3652e54e
    [junit] tag=61b29, index=72a, offset=e
    [junit] Test: DTLB, ffffffff87e69df5
    [junit] tag=7fc3f34, index=0, offset=1df5
    [junit] Test: L1, ffffffff9299c1fe
    [junit] tag=f9299c, index=f, offset=1e
    [junit] Test: L2, fffffffff1e2fcb7
    [junit] tag=7f8f1, index=7e5, offset=17
    [junit] Test: DTLB, ffffffff81aaa787
    [junit] tag=7fc0d55, index=0, offset=787
    [junit] Test: L1, ffffffffb5f52a5f
    [junit] tag=fb5f52, index=52, offset=1f
    [junit] Test: L2, ffffffffe8e3adef
    [junit] tag=7f471, index=d6f, offset=f
    [junit] Test: DTLB, 805c9bbb75925840
    [junit] tag=5dbac92, index=0, offset=1840
    [junit] Test: L1, ffffffffbf8c87d9
    [junit] tag=fbf8c8, index=3e, offset=19
    [junit] Test: L2, ffffffff95a0f54f
    [junit] tag=7cad0, index=7aa, offset=f
    [junit] Test: DTLB, 9efc987d3ccfae65
    [junit] tag=3e9e67d, index=0, offset=e65
    [junit] Test: L1, 32fd66a92cebf084
    [junit] tag=92cebf, index=4, offset=4
    [junit] Test: L2, 62d683fe5e1ff894
    [junit] tag=72f0f, index=fc4, offset=14
    [junit] Test: DTLB, ffffffffe98921de
    [junit] tag=7ff4c49, index=0, offset=1de
    [junit] Test: L1, ffffffffaa5a1ef9
    [junit] tag=faa5a1, index=77, offset=19
    [junit] Test: L2, 90fc60b171ad61cb
    [junit] tag=b8d6, index=b0e, offset=b
    [junit] Test: DTLB, ef92ad6b2c2e69a7
    [junit] tag=3596173, index=0, offset=9a7
    [junit] Test: L1, 3321896622a76fa8
    [junit] tag=622a76, index=7d, offset=8
    [junit] Test: L2, ab42557a4d7b1f00
    [junit] tag=526bd, index=8f8, offset=0
    [junit] Test: DTLB, ffffffffca7acecc
    [junit] tag=7fe53d6, index=0, offset=ecc
    [junit] Test: L1, ffffffff9eec5a35
    [junit] tag=f9eec5, index=51, offset=15
    [junit] Test: L2, fa95b76d3e264dda
    [junit] tag=69f13, index=26e, offset=1a
    [junit] Test: DTLB, cdb7f6971e02b1e5
    [junit] tag=4b8f015, index=0, offset=11e5
    [junit] Test: L1, ffffffff86eda94b
    [junit] tag=f86eda, index=4a, offset=b
    [junit] Test: L2, ffffffffe9d21506
    [junit] tag=7f4e9, index=a8, offset=6
    [junit] Test: DTLB, ffffffff93a341b7
    [junit] tag=7fc9d1a, index=0, offset=1b7
    [junit] Test: L1, ffffffff8a42a335
    [junit] tag=f8a42a, index=19, offset=15
    [junit] Test: L2, ffffffffd4832a73
    [junit] tag=7ea41, index=953, offset=13
    [junit] Test: DTLB, ffffffffb6380f43
    [junit] tag=7fdb1c0, index=0, offset=f43
    [junit] Test: L1, ffffffffa880468a
    [junit] tag=fa8804, index=34, offset=a
    [junit] Test: L2, f7a592746aa49780
    [junit] tag=23552, index=4bc, offset=0
    [junit] Test: DTLB, fffffffff4bec1c4
    [junit] tag=7ffa5f6, index=0, offset=1c4
    [junit] Test: L1, ffffffffb47dddd6
    [junit] tag=fb47dd, index=6e, offset=16
    [junit] Test: L2, ffffffff9f7fcd52
    [junit] tag=7cfbf, index=e6a, offset=12
    [junit] Test: DTLB, ffffffffbec65618
    [junit] tag=7fdf632, index=0, offset=1618
    [junit] Test: L1, bb55757f7d680f22
    [junit] tag=f7d680, index=79, offset=2
    [junit] Test: L2, ffffffffc08eaecb
    [junit] tag=7e047, index=576, offset=b
    [junit] Test: DTLB, 782ea5270b2968b4
    [junit] tag=138594b, index=0, offset=8b4
    [junit] Test: L1, fffffffffc71c14a
    [junit] tag=ffc71c, index=a, offset=a
    [junit] Test: L2, ffffffff9dd26e4c
    [junit] tag=7cee9, index=372, offset=c
    [junit] Test: DTLB, 9a49639052a84882
    [junit] tag=4829542, index=0, offset=882
    [junit] Test: L1, 409c1cb023f9881a
    [junit] tag=23f98, index=40, offset=1a
    [junit] Test: L2, b3d780643da856d1
    [junit] tag=21ed4, index=2b6, offset=11
    [junit] Test: DTLB, fffffffff113bea2
    [junit] tag=7ff889d, index=0, offset=1ea2
    [junit] Test: L1, ffffffffe52becaf
    [junit] tag=fe52be, index=65, offset=f
    [junit] Test: L2, fde0625f0b881a88
    [junit] tag=785c4, index=d4, offset=8
    [junit] Test: DTLB, abb107c51ad9b371
    [junit] tag=628d6cd, index=0, offset=1371
    [junit] Test: L1, ffffffffcb4a4027
    [junit] tag=fcb4a4, index=1, offset=7
    [junit] Test: L2, b4499d69491ac720
    [junit] tag=4a48d, index=639, offset=0
    [junit] Test: DTLB, ffffffffda91731f
    [junit] tag=7fed48b, index=0, offset=131f
    [junit] Test: L1, 74582e3236ef3440
    [junit] tag=236ef3, index=22, offset=0
    [junit] Test: L2, fffffffffafce980
    [junit] tag=7fd7e, index=74c, offset=0
    [junit] Test: DTLB, 72baadb20f2e5ee2
    [junit] tag=5907972, index=0, offset=1ee2
    [junit] Test: L1, fd6b4b672ae3d6cf
    [junit] tag=72ae3d, index=36, offset=f
    [junit] Test: L2, fffffffffa82249f
    [junit] tag=7fd41, index=124, offset=1f
    [junit] Test: DTLB, ffffffffa1d611cb
    [junit] tag=7fd0eb0, index=0, offset=11cb
    [junit] Test: L1, ffffffff95e2c0bd
    [junit] tag=f95e2c, index=5, offset=1d
    [junit] Test: L2, ffffffffd464f94c
    [junit] tag=7ea32, index=7ca, offset=c
    [junit] Test: DTLB, d60fafbd7a2ec3d1
    [junit] tag=5ebd176, index=0, offset=3d1
    [junit] Test: L1, 77d16ad63fab3770
    [junit] tag=63fab3, index=3b, offset=10
    [junit] Test: L2, 688ba39765fb0ac7
    [junit] tag=3b2fd, index=856, offset=7
    [junit] Test: DTLB, 15d205735b2d22c0
    [junit] tag=39ad969, index=0, offset=2c0
    [junit] Test: L1, ffffffffe3863ebb
    [junit] tag=fe3863, index=75, offset=1b
    [junit] Test: L2, 3a7d228f6b7e433c
    [junit] tag=7b5bf, index=219, offset=1c
    [junit] Test: DTLB, 2e147a4956fceb04
    [junit] tag=24ab7e7, index=0, offset=b04
    [junit] Test: L1, c8461fbf4b2da6d8
    [junit] tag=f4b2da, index=36, offset=18
    [junit] Test: L2, ffffffffec7ee189
    [junit] tag=7f63f, index=70c, offset=9
    [junit] Test: DTLB, 5d0d27bd2a8ed1b7
    [junit] tag=5e95476, index=0, offset=11b7
    [junit] Test: L1, ffffffffd49bffcd
    [junit] tag=fd49bf, index=7e, offset=d
    [junit] Test: L2, ffffffff881d3af8
    [junit] tag=7c40e, index=9d7, offset=18
    [junit] Test: DTLB, ffffffff915052e4
    [junit] tag=7fc8a82, index=0, offset=12e4
    [junit] Test: L1, ecfd434c5e4356fb
    [junit] tag=c5e435, index=37, offset=1b
    [junit] Test: L2, 4ad7b35667cb6c06
    [junit] tag=333e5, index=b60, offset=6
    [junit] Test: DTLB, 9a67b8f37f7e08d
    [junit] tag=479bfbf, index=0, offset=8d
    [junit] Test: L1, ffffffff9d3fbbe1
    [junit] tag=f9d3fb, index=5f, offset=1
    [junit] Test: L2, ffffffffcced468d
    [junit] tag=7e676, index=a34, offset=d
    [junit] Test: DTLB, 5b217bb853215b41
    [junit] tag=5c2990a, index=0, offset=1b41
    [junit] Test: L1, ffffffffbed2c55a
    [junit] tag=fbed2c, index=2a, offset=1a
    [junit] Test: L2, c1070662b425ace
    [junit] tag=315a1, index=2d6, offset=e
    [junit] Test: DTLB, ffffffffad11437c
    [junit] tag=7fd688a, index=0, offset=37c
    [junit] Test: L1, ffffffff80976b64
    [junit] tag=f80976, index=5b, offset=4
    [junit] Test: L2, 658b9919560834c8
    [junit] tag=4ab04, index=1a6, offset=8
    [junit] Test: DTLB, 22764d881906cbb5
    [junit] tag=440c836, index=0, offset=bb5
    [junit] Test: L1, dd1751bb25f4e285
    [junit] tag=b25f4e, index=14, offset=5
    [junit] Test: L2, fad30d57436eb8ca
    [junit] tag=3a1b7, index=5c6, offset=a
    [junit] Test: DTLB, f4ce62de20e758ca
    [junit] tag=6f1073a, index=0, offset=18ca
    [junit] Test: L1, aaeed57c52423613
    [junit] tag=c52423, index=30, offset=13
    [junit] Test: L2, ffffffffb3e02474
    [junit] tag=7d9f0, index=123, offset=14
    [junit] Test: DTLB, a83e50b3421742b3
    [junit] tag=59a10ba, index=0, offset=2b3
    [junit] Test: L1, 790fced5744c60a4
    [junit] tag=5744c6, index=5, offset=4
    [junit] Test: L2, 207636b114f51c58
    [junit] tag=8a7a, index=8e2, offset=18
    [junit] Test: DTLB, e8fc1e15f6aefed
    [junit] tag=70afb57, index=0, offset=fed
    [junit] Test: L1, ffffffffc85e8b27
    [junit] tag=fc85e8, index=59, offset=7
    [junit] Test: L2, 2e9c37f140c970ee
    [junit] tag=a064, index=b87, offset=e
    [junit] Test: DTLB, cde157317e355302
    [junit] tag=18bf1aa, index=0, offset=1302
    [junit] Test: L1, ffffffffef86ce51
    [junit] tag=fef86c, index=72, offset=11
    [junit] Test: L2, ffffffffc2173681
    [junit] tag=7e10b, index=9b4, offset=1
    [junit] Test: DTLB, 54d2b9da37d30978
    [junit] tag=6d1be98, index=0, offset=978
    [junit] Test: L1, 2d238b782b80917b
    [junit] tag=82b809, index=b, offset=1b
    [junit] Test: L2, 818a907c0cf1eecd
    [junit] tag=60678, index=f76, offset=d
    [junit] Test: DTLB, d34d4704acfc932
    [junit] tag=382567e, index=0, offset=932
    [junit] Test: L1, ffffffffb0307f57
    [junit] tag=fb0307, index=7a, offset=17
    [junit] Test: L2, 62a1695e09224266
    [junit] tag=70491, index=213, offset=6
    [junit] Test: DTLB, ff5c06a23bc46bcd
    [junit] tag=511de23, index=0, offset=bcd
    [junit] Test: L1, ffffffffc6be57f4
    [junit] tag=fc6be5, index=3f, offset=14
    [junit] Test: L2, ffffffffcddac154
    [junit] tag=7e6ed, index=60a, offset=14
    [junit] Test: DTLB, ffffffffd4043636
    [junit] tag=7fea021, index=0, offset=1636
    [junit] Test: L1, fffffffff5ea00c6
    [junit] tag=ff5ea0, index=6, offset=6
    [junit] Test: L2, ffffffffaca397ba
    [junit] tag=7d651, index=cbd, offset=1a
    [junit] Test: DTLB, 8ffefc9652835ad0
    [junit] tag=4b2941a, index=0, offset=1ad0
    [junit] Test: L1, ee38473c688fa3be
    [junit] tag=c688fa, index=1d, offset=1e
    [junit] Test: L2, 5a37575833217e14
    [junit] tag=41990, index=bf0, offset=14
    [junit] Test: DTLB, 4dc1e52623f96bdc
    [junit] tag=1311fcb, index=0, offset=bdc
    [junit] Test: L1, ffffffff9e41898b
    [junit] tag=f9e418, index=4c, offset=b
    [junit] Test: L2, 1feeb94d3952880f
    [junit] tag=69ca9, index=440, offset=f
    [junit] Test: DTLB, bb446ab17292885b
    [junit] tag=58b9494, index=0, offset=85b
    [junit] Test: L1, ffffffffe76e16c1
    [junit] tag=fe76e1, index=36, offset=1
    [junit] Test: L2, 8a59b222f555085
    [junit] tag=117aa, index=a84, offset=5
    [junit] Test: DTLB, ffffffffca949aaf
    [junit] tag=7fe54a4, index=0, offset=1aaf
    [junit] Test: L1, 1fba105220e2a240
    [junit] tag=220e2a, index=12, offset=0
    [junit] Test: L2, 6a06a1da72318fba
    [junit] tag=53918, index=c7d, offset=1a
    [junit] Test: DTLB, ffffffff9cae0c40
    [junit] tag=7fce570, index=0, offset=c40
    [junit] Test: L1, ffffffff81e52733
    [junit] tag=f81e52, index=39, offset=13
    [junit] Test: L2, 36eb7391a4b0beb
    [junit] tag=48d25, index=85f, offset=b
    [junit] Test: DTLB, ffffffffab2ba5e1
    [junit] tag=7fd595d, index=0, offset=5e1
    [junit] Test: L1, 9f8ce7744efd3126
    [junit] tag=44efd3, index=9, offset=6
    [junit] Test: L2, ffffffffe848386e
    [junit] tag=7f424, index=1c3, offset=e
    [junit] Test: DTLB, ffffffffbda22fef
    [junit] tag=7fded11, index=0, offset=fef
    [junit] Test: L1, b554a6eb5d00ceb7
    [junit] tag=b5d00c, index=75, offset=17
    [junit] Test: L2, 895d98ac020fdbb6
    [junit] tag=60107, index=edd, offset=16
    [junit] Test: DTLB, 94d240243228f07c
    [junit] tag=1219147, index=0, offset=107c
    [junit] Test: L1, 121e386a007c9c7a
    [junit] tag=a007c9, index=63, offset=1a
    [junit] Test: L2, ffffffff8a4b4cdc
    [junit] tag=7c525, index=a66, offset=1c
    [junit] Test: DTLB, ffffffff92bce63e
    [junit] tag=7fc95e7, index=0, offset=63e
    [junit] Test: L1, ffffffffdcc6af58
    [junit] tag=fdcc6a, index=7a, offset=18
    [junit] Test: L2, ffffffffb81a21db
    [junit] tag=7dc0d, index=10e, offset=1b
    [junit] Test: DTLB, fffffffffacad053
    [junit] tag=7ffd656, index=0, offset=1053
    [junit] Test: L1, f30d6b5b58bdb012
    [junit] tag=b58bdb, index=0, offset=12
    [junit] Test: L2, ffffffff9634c6e6
    [junit] tag=7cb1a, index=637, offset=6
    [junit] Test: DTLB, ffffffffcbe7c951
    [junit] tag=7fe5f3e, index=0, offset=951
    [junit] Test: L1, ffffffffe9d59937
    [junit] tag=fe9d59, index=49, offset=17
    [junit] Test: L2, e9fef7f11ded127
    [junit] tag=788ef, index=689, offset=7
    [junit] Test: DTLB, 5d61b81a6dbc66bd
    [junit] tag=d36de3, index=0, offset=6bd
    [junit] Test: L1, ffffffffa6859683
    [junit] tag=fa6859, index=34, offset=3
    [junit] Test: L2, ffffffff9111680e
    [junit] tag=7c888, index=b40, offset=e
    [junit] Test: DTLB, 6d89ddbc22dde40c
    [junit] tag=5e116ef, index=0, offset=40c
    [junit] Test: L1, fffffffff88bf6e9
    [junit] tag=ff88bf, index=37, offset=9
    [junit] Test: L2, d16655ee361bc3fd
    [junit] tag=71b0d, index=e1f, offset=1d
    [junit] Test: DTLB, ac07268223fa179a
    [junit] tag=4111fd0, index=0, offset=179a
    [junit] Test: L1, 48df65ef4c42bc04
    [junit] tag=f4c42b, index=60, offset=4
    [junit] Test: L2, ffffffff8aa55c5f
    [junit] tag=7c552, index=ae2, offset=1f
    [junit] Test: DTLB, f373d58976f59474
    [junit] tag=44bb7ac, index=0, offset=1474
    [junit] Test: L1, ffffffff88468aba
    [junit] tag=f88468, index=55, offset=1a
    [junit] Test: L2, d9112e293e49291e
    [junit] tag=49f24, index=948, offset=1e
    [junit] Test: DTLB, 4de840447e91ead7
    [junit] tag=223f48f, index=0, offset=ad7
    [junit] Test: L1, fffffffff1701fdd
    [junit] tag=ff1701, index=7e, offset=1d
    [junit] Test: L2, ffffffff88fbc0d2
    [junit] tag=7c47d, index=e06, offset=12
    [junit] Test: DTLB, db9c3576513e6c38
    [junit] tag=3b289f3, index=0, offset=c38
    [junit] Test: L1, ffffffffdb6aad43
    [junit] tag=fdb6aa, index=6a, offset=3
    [junit] Test: L2, ffffffff8a93b91a
    [junit] tag=7c549, index=dc8, offset=1a
    [junit] Test: DTLB, 96fba7a6614f0b8a
    [junit] tag=5330a78, index=0, offset=b8a
    [junit] Test: L1, ffffffff8414d237
    [junit] tag=f8414d, index=11, offset=17
    [junit] Test: L2, 46c6ec8f7ba0f491
    [junit] tag=7bdd0, index=7a4, offset=11
    [junit] Test: DTLB, ffffffffc32f7b60
    [junit] tag=7fe197b, index=0, offset=1b60
    [junit] Test: L1, a793cc565dc7e115
    [junit] tag=65dc7e, index=8, offset=15
    [junit] Test: L2, 719e82071363be93
    [junit] tag=389b1, index=df4, offset=13
    [junit] Test: DTLB, ffffffff871cec55
    [junit] tag=7fc38e7, index=0, offset=c55
    [junit] Test: L1, ffffffffffd43027
    [junit] tag=fffd43, index=1, offset=7
    [junit] Test: L2, 561353871e1ba11c
    [junit] tag=38f0d, index=d08, offset=1c
    [junit] Test: DTLB, 39be261d2c27d4d2
    [junit] tag=e9613e, index=0, offset=14d2
    [junit] Test: L1, ffffffffaa35546c
    [junit] tag=faa355, index=23, offset=c
    [junit] Test: L2, ffffffff863b5e00
    [junit] tag=7c31d, index=af0, offset=0
    [junit] Test: DTLB, 1590a644640d1f2
    [junit] tag=3223206, index=0, offset=11f2
    [junit] Test: L1, fffffffff54b33a1
    [junit] tag=ff54b3, index=1d, offset=1
    [junit] Test: L2, 95daf1e058ce5f5f
    [junit] tag=2c67, index=2fa, offset=1f
    [junit] Test: DTLB, 6d3b105465203ce2
    [junit] tag=2a32901, index=0, offset=1ce2
    [junit] Test: L1, ffffffffa2a64c30
    [junit] tag=fa2a64, index=61, offset=10
    [junit] Test: L2, eedb2e02132bfd33
    [junit] tag=10995, index=fe9, offset=13
    [junit] Test: DTLB, ffffffffb210cbb5
    [junit] tag=7fd9086, index=0, offset=bb5
    [junit] Test: L1, ffffffffb3246bca
    [junit] tag=fb3246, index=5e, offset=a
    [junit] Test: L2, ceadd4c5433a970d
    [junit] tag=2a19d, index=4b8, offset=d
    [junit] Test: DTLB, f4895f3b71029c72
    [junit] tag=1db8814, index=0, offset=1c72
    [junit] Test: L1, 32bd2442739a2870
    [junit] tag=2739a2, index=43, offset=10
    [junit] Test: L2, c664eeb73ce98a95
    [junit] tag=39e74, index=c54, offset=15
    [junit] Test: DTLB, 8966f6b178dd2b78
    [junit] tag=58bc6e9, index=0, offset=b78
    [junit] Test: L1, b8fa13f100a36d0f
    [junit] tag=100a36, index=68, offset=f
    [junit] Test: L2, ad6037a318c955c7
    [junit] tag=18c64, index=aae, offset=7
    [junit] Test: DTLB, fffffffff12b7500
    [junit] tag=7ff895b, index=0, offset=1500
    [junit] Test: L1, 2a00b235599256fd
    [junit] tag=559925, index=37, offset=1d
    [junit] Test: L2, 763433e9552af28a
    [junit] tag=4aa95, index=794, offset=a
    [junit] Test: DTLB, fffffffffb227e1c
    [junit] tag=7ffd913, index=0, offset=1e1c
    [junit] Test: L1, ffffffffecb279a4
    [junit] tag=fecb27, index=4d, offset=4
    [junit] Test: L2, fffffffff1500d03
    [junit] tag=7f8a8, index=68, offset=3
    [junit] Test: DTLB, 20acdeee402590a4
    [junit] tag=772012c, index=0, offset=10a4
    [junit] Test: L1, 70d998f71f80c4fd
    [junit] tag=71f80c, index=27, offset=1d
    [junit] Test: L2, ffffffff95254838
    [junit] tag=7ca92, index=a41, offset=18
    [junit] Test: DTLB, ffffffffa2935d1c
    [junit] tag=7fd149a, index=0, offset=1d1c
    [junit] Test: L1, 6b3446e26ad2b70a
    [junit] tag=26ad2b, index=38, offset=a
    [junit] Test: L2, fffffffffdec0aa1
    [junit] tag=7fef6, index=55, offset=1
    [junit] Test: DTLB, 5a428d4e10eca767
    [junit] tag=2708765, index=0, offset=767
    [junit] Test: L1, ffffffffb09e9ebe
    [junit] tag=fb09e9, index=75, offset=1e
    [junit] Test: L2, fffffffffee00cda
    [junit] tag=7ff70, index=66, offset=1a
    [junit] Test: DTLB, c6e2855d6e4de640
    [junit] tag=2eb726f, index=0, offset=640
    [junit] Test: L1, fc97697e28abefdb
    [junit] tag=e28abe, index=7e, offset=1b
    [junit] Test: L2, ffffffffe6877f0d
    [junit] tag=7f343, index=bf8, offset=d
    [junit] Test: DTLB, ffffffffe4abd7b4
    [junit] tag=7ff255e, index=0, offset=17b4
    [junit] Test: L1, ffffffffb84df2fe
    [junit] tag=fb84df, index=17, offset=1e
    [junit] Test: L2, 2e149a1c70889555
    [junit] tag=63844, index=4aa, offset=15
    [junit] Test: DTLB, f2614bce4f19be1b
    [junit] tag=67278cd, index=0, offset=1e1b
    [junit] Test: L1, c1dda70199bf0f8
    [junit] tag=199bf, index=7, offset=18
    [junit] Test: L2, 9412de0703716074
    [junit] tag=381b8, index=b03, offset=14
    [junit] Test: DTLB, ffffffffa9412834
    [junit] tag=7fd4a09, index=0, offset=834
    [junit] Test: L1, ffffffffe999b0ab
    [junit] tag=fe999b, index=5, offset=b
    [junit] Test: L2, a044de514d403289
    [junit] tag=a6a0, index=194, offset=9
    [junit] Test: DTLB, ffffffff8a6a1281
    [junit] tag=7fc5350, index=0, offset=1281
    [junit] Test: L1, ffffffffc2ba1594
    [junit] tag=fc2ba1, index=2c, offset=14
    [junit] Test: L2, 7ba3da3378cd2326
    [junit] tag=1bc66, index=919, offset=6
    [junit] Test: DTLB, 457311161054fa06
    [junit] tag=b082a7, index=0, offset=1a06
    [junit] Test: L1, 24086a8c174e9b0a
    [junit] tag=c174e9, index=58, offset=a
    [junit] Test: L2, bac7c7e841f2838b
    [junit] tag=420f9, index=41c, offset=b
    [junit] Test: DTLB, fef1405576829cec
    [junit] tag=2abb414, index=0, offset=1cec
    [junit] Test: L1, 4413efaf46c5ebf3
    [junit] tag=f46c5e, index=5f, offset=13
    [junit] Test: L2, ffffffffaaf7b662
    [junit] tag=7d57b, index=db3, offset=2
    [junit] Test: DTLB, 2e83c47258399059
    [junit] tag=392c1cc, index=0, offset=1059
    [junit] Test: L1, 22ad35ca769d733d
    [junit] tag=a769d7, index=19, offset=1d
    [junit] Test: L2, ffffffff8d37dc04
    [junit] tag=7c69b, index=ee0, offset=4
    [junit] Test: DTLB, ffffffffb1fc9343
    [junit] tag=7fd8fe4, index=0, offset=1343
    [junit] Test: L1, ffffffffa658b437
    [junit] tag=fa658b, index=21, offset=17
    [junit] Test: L2, ffffffffe9ae2be8
    [junit] tag=7f4d7, index=15f, offset=8
    [junit] Test: DTLB, ffffffffce4ba346
    [junit] tag=7fe725d, index=0, offset=346
    [junit] Test: L1, 33d6855755c6d283
    [junit] tag=755c6d, index=14, offset=3
    [junit] Test: L2, c23be41373c4e809
    [junit] tag=1b9e2, index=740, offset=9
    [junit] Test: DTLB, ffffffff8d4be434
    [junit] tag=7fc6a5f, index=0, offset=434
    [junit] Test: L1, 5fc614077830f8d6
    [junit] tag=77830f, index=46, offset=16
    [junit] Test: L2, fffffffff822505a
    [junit] tag=7fc11, index=282, offset=1a
    [junit] Test: DTLB, ffffffff9ad7ceab
    [junit] tag=7fcd6be, index=0, offset=eab
    [junit] Test: L1, ffffffff95708944
    [junit] tag=f95708, index=4a, offset=4
    [junit] Test: L2, ffffffff9942a20f
    [junit] tag=7cca1, index=510, offset=f
    [junit] Test: DTLB, 823694c3165d9299
    [junit] tag=618b2ec, index=0, offset=1299
    [junit] Test: L1, ffffffffe62a1d09
    [junit] tag=fe62a1, index=68, offset=9
    [junit] Test: L2, ffffffffc8da0c59
    [junit] tag=7e46d, index=62, offset=19
    [junit] Test: DTLB, 3497e6ec0dbe0ed1
    [junit] tag=7606df0, index=0, offset=ed1
    [junit] Test: L1, ffffffff9f2ac500
    [junit] tag=f9f2ac, index=28, offset=0
    [junit] Test: L2, 3cf6b88b0e288e38
    [junit] tag=58714, index=471, offset=18
    [junit] Test: DTLB, ffffffffb6fe1b4e
    [junit] tag=7fdb7f0, index=0, offset=1b4e
    [junit] Test: L1, ffffffffc3d94226
    [junit] tag=fc3d94, index=11, offset=6
    [junit] Test: L2, 1df83cb73e609391
    [junit] tag=39f30, index=49c, offset=11
    [junit] Test: DTLB, ffffffff9d2d0a9f
    [junit] tag=7fce968, index=0, offset=a9f
    [junit] Test: L1, fffffffffe9e7c53
    [junit] tag=ffe9e7, index=62, offset=13
    [junit] Test: L2, ffffffffd0d155a3
    [junit] tag=7e868, index=aad, offset=3
    [junit] Test: DTLB, 9caf6321007dd2e6
    [junit] tag=10803ee, index=0, offset=12e6
    [junit] Test: L1, e49885453d930743
    [junit] tag=53d930, index=3a, offset=3
    [junit] Test: L2, c214854010352684
    [junit] tag=81a, index=934, offset=4
    [junit] Test: DTLB, 174fd2e303e3cfd9
    [junit] tag=7181f1e, index=0, offset=fd9
    [junit] Test: L1, c84fe30f78284e20
    [junit] tag=f78284, index=71, offset=0
    [junit] Test: L2, 61557549186e6235
    [junit] tag=48c37, index=311, offset=15
    [junit] Test: DTLB, 7700fcd011451921
    [junit] tag=6808a28, index=0, offset=1921
    [junit] Test: L1, c54d554b5787cb29
    [junit] tag=b5787c, index=59, offset=9
    [junit] Test: L2, ffffffff9dc82a60
    [junit] tag=7cee4, index=153, offset=0
    [junit] Test: DTLB, bdc3ff9165f535c9
    [junit] tag=48b2fa9, index=0, offset=15c9
    [junit] Test: L1, ffffffff9ef78052
    [junit] tag=f9ef78, index=2, offset=12
    [junit] Test: L2, ffffffff91aff8e4
    [junit] tag=7c8d7, index=fc7, offset=4
    [junit] Test: DTLB, e5faaf1a46598b08
    [junit] tag=d232cc, index=0, offset=b08
    [junit] Test: L1, ffffffffb25bab8b
    [junit] tag=fb25ba, index=5c, offset=b
    [junit] Test: L2, ffffffffaf5c8e0b
    [junit] tag=7d7ae, index=470, offset=b
    [junit] Test: DTLB, ffffffff9db0449c
    [junit] tag=7fced82, index=0, offset=49c
    [junit] Test: L1, eaf1cf932469cbcc
    [junit] tag=32469c, index=5e, offset=c
    [junit] Test: L2, ffffffffb8d3ea68
    [junit] tag=7dc69, index=f53, offset=8
    [junit] Test: DTLB, 747de87925ac129c
    [junit] tag=3c92d60, index=0, offset=129c
    [junit] Test: L1, ffffffffe5a6db7d
    [junit] tag=fe5a6d, index=5b, offset=1d
    [junit] Test: L2, ffffffff98add62e
    [junit] tag=7cc56, index=eb1, offset=e
    [junit] Test: DTLB, ffffffffe8069d20
    [junit] tag=7ff4034, index=0, offset=1d20
    [junit] Test: L1, ffffffff85c6ae57
    [junit] tag=f85c6a, index=72, offset=17
    [junit] Test: L2, ffffffff8c2bbfbf
    [junit] tag=7c615, index=dfd, offset=1f
    [junit] Test: DTLB, ffffffffc33c6091
    [junit] tag=7fe19e3, index=0, offset=91
    [junit] Test: L1, d835f6274d819ae4
    [junit] tag=74d819, index=57, offset=4
    [junit] Test: L2, ffffffffd830867d
    [junit] tag=7ec18, index=433, offset=1d
    [junit] Test: DTLB, ffffffffe014ecdc
    [junit] tag=7ff00a7, index=0, offset=cdc
    [junit] Test: L1, e66f82b509b23c91
    [junit] tag=509b23, index=64, offset=11
    [junit] Test: L2, ffffffff8f40ea98
    [junit] tag=7c7a0, index=754, offset=18
    [junit] Test: DTLB, 4ca886057df96027
    [junit] tag=2befcb, index=0, offset=27
    [junit] Test: L1, cf8830506a570603
    [junit] tag=6a570, index=30, offset=3
    [junit] Test: L2, ffffffffc9176f63
    [junit] tag=7e48b, index=b7b, offset=3
    [junit] Test: DTLB, ffffffffd5021f10
    [junit] tag=7fea810, index=0, offset=1f10
    [junit] Test: L1, ffffffffc395b921
    [junit] tag=fc395b, index=49, offset=1
    [junit] Test: L2, 188d2cba742f6e45
    [junit] tag=53a17, index=b72, offset=5
    [junit] Test: DTLB, 3561eed750846622
    [junit] tag=6ba8423, index=0, offset=622
    [junit] Test: L1, 35a380ff63936770
    [junit] tag=f63936, index=3b, offset=10
    [junit] Test: L2, 85c810e17ba573ac
    [junit] tag=bdd2, index=b9d, offset=c
    [junit] Test: DTLB, ffffffff859ddefe
    [junit] tag=7fc2cee, index=0, offset=1efe
    [junit] Test: L1, 298a06a52ba08509
    [junit] tag=52ba08, index=28, offset=9
    [junit] Test: L2, cbf6a31f265d6e1c
    [junit] tag=7932e, index=b70, offset=1c
    [junit] Test: DTLB, ffffffffbb1ff039
    [junit] tag=7fdd8ff, index=0, offset=1039
    [junit] Test: L1, ffffffff8458d6b6
    [junit] tag=f8458d, index=35, offset=16
    [junit] Test: L2, 1b7bc4a61c2e578d
    [junit] tag=30e17, index=2bc, offset=d
    [junit] Test: DTLB, ffffffff89674e88
    [junit] tag=7fc4b3a, index=0, offset=e88
    [junit] Test: L1, 47e2c2171fd111d9
    [junit] tag=71fd11, index=e, offset=19
    [junit] Test: L2, bed709b61095e757
    [junit] tag=3084a, index=f3a, offset=17
    [junit] Test: DTLB, fffffffff0fd262a
    [junit] tag=7ff87e9, index=0, offset=62a
    [junit] Test: L1, 36ad02336f90d8c2
    [junit] tag=36f90d, index=46, offset=2
    [junit] Test: L2, 8206667c0e5fb711
    [junit] tag=6072f, index=db8, offset=11
    [junit] Test: DTLB, ffffffff8ca2b971
    [junit] tag=7fc6515, index=0, offset=1971
    [junit] Test: L1, 54c7ae3627745cd3
    [junit] tag=627745, index=66, offset=13
    [junit] Test: L2, ffffffffffc369d7
    [junit] tag=7ffe1, index=b4e, offset=17
    [junit] Test: DTLB, ffffffffd91294fd
    [junit] tag=7fec894, index=0, offset=14fd
    [junit] Test: L1, e41448686e0adbff
    [junit] tag=86e0ad, index=5f, offset=1f
    [junit] Test: L2, ffffffffadec8705
    [junit] tag=7d6f6, index=438, offset=5
    [junit] Test: DTLB, ffffffffdd80d4bd
    [junit] tag=7feec06, index=0, offset=14bd
    [junit] Test: L1, 79cc2dce4fc72109
    [junit] tag=e4fc72, index=8, offset=9
    [junit] Test: L2, ffffffffb3e3ee09
    [junit] tag=7d9f1, index=f70, offset=9
    [junit] Test: DTLB, 7c4340c82ab04383
    [junit] tag=6415582, index=0, offset=383
    [junit] Test: L1, ffffffffc17a0b35
    [junit] tag=fc17a0, index=59, offset=15
    [junit] Test: L2, c7882f1565498497
    [junit] tag=2b2a4, index=c24, offset=17
    [junit] Test: DTLB, ffffffff8a80ad24
    [junit] tag=7fc5405, index=0, offset=d24
    [junit] Test: L1, 244ec5f3124c6c22
    [junit] tag=3124c6, index=61, offset=2
    [junit] Test: L2, ffffffff99fc8ab0
    [junit] tag=7ccfe, index=455, offset=10
    [junit] Test: DTLB, 5ccb7b440ad5d1b5
    [junit] tag=22056ae, index=0, offset=11b5
    [junit] Test: L1, ffffffffbf9c52a4
    [junit] tag=fbf9c5, index=15, offset=4
    [junit] Test: L2, fc85ba7c32166030
    [junit] tag=6190b, index=301, offset=10
    [junit] Test: DTLB, 27b5eb211d556c88
    [junit] tag=108eaab, index=0, offset=c88
    [junit] Test: L1, ffffffff81f777d4
    [junit] tag=f81f77, index=3e, offset=14
    [junit] Test: L2, ffffffffaf6ff2a7
    [junit] tag=7d7b7, index=f95, offset=7
    [junit] Test: DTLB, ffffffffd522c5d4
    [junit] tag=7fea916, index=0, offset=5d4
    [junit] Test: L1, 519c386f0578c72f
    [junit] tag=f0578c, index=39, offset=f
    [junit] Test: L2, ffffffffa9648ee9
    [junit] tag=7d4b2, index=477, offset=9
    [junit] Test: DTLB, fffffffffac80680
    [junit] tag=7ffd640, index=0, offset=680
    [junit] Test: L1, 3428a2292078d615
    [junit] tag=92078d, index=30, offset=15
    [junit] Test: L2, 599695a90d876844
    [junit] tag=486c3, index=b42, offset=4
    [junit] Test: DTLB, 3312825d4233602c
    [junit] tag=2ea119b, index=0, offset=2c
    [junit] Test: L1, ffffffffdae6cbfe
    [junit] tag=fdae6c, index=5f, offset=1e
    [junit] Test: L2, 1050590b7387ca8a
    [junit] tag=5b9c3, index=e54, offset=a
    [junit] Test: DTLB, 261896d0303e5ee8
    [junit] tag=68181f2, index=0, offset=1ee8
    [junit] Test: L1, ffffffffa7dcf52c
    [junit] tag=fa7dcf, index=29, offset=c
    [junit] Test: L2, 87422c7e5ab914de
    [junit] tag=72d5c, index=8a6, offset=1e
    [junit] Test: DTLB, 8bd295c159fd1371
    [junit] tag=60acfe8, index=0, offset=1371
    [junit] Test: L1, ffffffffff54a11d
    [junit] tag=fff54a, index=8, offset=1d
    [junit] Test: L2, 1792dbf27c189346
    [junit] tag=13e0c, index=49a, offset=6
    [junit] Test: DTLB, 8dd121b07b1d4fd8
    [junit] tag=583d8ea, index=0, offset=fd8
    [junit] Test: L1, fe7fe6e8089cd0fc
    [junit] tag=8089cd, index=7, offset=1c
    [junit] Test: L2, ffffffffd00302e8
    [junit] tag=7e801, index=817, offset=8
    [junit] Test: DTLB, 12391af4463a2fb0
    [junit] tag=7a231d1, index=0, offset=fb0
    [junit] Test: L1, ba98da0e12a705e1
    [junit] tag=e12a70, index=2f, offset=1
    [junit] Test: L2, ffffffffcd8313f5
    [junit] tag=7e6c1, index=89f, offset=15
    [junit] Test: DTLB, 51950de01ccb1574
    [junit] tag=700e658, index=0, offset=1574
    [junit] Test: L1, ffffffffb624a539
    [junit] tag=fb624a, index=29, offset=19
    [junit] Test: L2, 4560ab6650a891e
    [junit] tag=33285, index=448, offset=1e
    [junit] Test: DTLB, e3876d061bb4c52
    [junit] tag=6830dda, index=0, offset=c52
    [junit] Test: L1, a14788b3313d712f
    [junit] tag=3313d7, index=9, offset=f
    [junit] Test: L2, 9c2439e67cc2ec5
    [junit] tag=733e6, index=176, offset=5
    [junit] Test: DTLB, 3d1c30ef1d7c4efc
    [junit] tag=778ebe2, index=0, offset=efc
    [junit] Test: L1, 18cafcbc5838594e
    [junit] tag=c58385, index=4a, offset=e
    [junit] Test: L2, ffffffff98c67a7d
    [junit] tag=7cc63, index=3d3, offset=1d
    [junit] Test: DTLB, ffffffffd13ae207
    [junit] tag=7fe89d7, index=0, offset=207
    [junit] Test: L1, bc51cc9a0e8b66c6
    [junit] tag=a0e8b6, index=36, offset=6
    [junit] Test: L2, ffffffff8f31851d
    [junit] tag=7c798, index=c28, offset=1d
    [junit] Test: DTLB, 4f7de42454349d01
    [junit] tag=122a1a4, index=0, offset=1d01
    [junit] Test: L1, a1a2f2df47f28248
    [junit] tag=f47f28, index=12, offset=8
    [junit] Test: L2, ca2c36a46dea2ef4
    [junit] tag=236f5, index=177, offset=14
    [junit] Test: DTLB, ffffffff88434702
    [junit] tag=7fc421a, index=0, offset=702
    [junit] Test: L1, 51c76d2b19c8d125
    [junit] tag=b19c8d, index=9, offset=5
    [junit] Test: L2, 5c231a8d1cba1e53
    [junit] tag=68e5d, index=f2, offset=13
    [junit] Test: DTLB, ffffffff8946a2cc
    [junit] tag=7fc4a35, index=0, offset=2cc
    [junit] Test: L1, ffffffffde143d1d
    [junit] tag=fde143, index=68, offset=1d
    [junit] Test: L2, ffffffffe2bd9777
    [junit] tag=7f15e, index=cbb, offset=17
    [junit] Test: DTLB, ffffffffcca504bf
    [junit] tag=7fe6528, index=0, offset=4bf
    [junit] Test: L1, ffffffffc0e41fae
    [junit] tag=fc0e41, index=7d, offset=e
    [junit] Test: L2, 652870217c046572
    [junit] tag=be02, index=32b, offset=12
    [junit] Test: DTLB, fffffffffdf77b15
    [junit] tag=7ffefbb, index=0, offset=1b15
    [junit] Test: L1, ffffffffec4bbcc2
    [junit] tag=fec4bb, index=66, offset=2
    [junit] Test: L2, 3756eb3c13a580c5
    [junit] tag=609d2, index=c06, offset=5
    [junit] Test: DTLB, ffffffffd776c4a6
    [junit] tag=7febbb6, index=0, offset=4a6
    [junit] Test: L1, fffffffff7394470
    [junit] tag=ff7394, index=23, offset=10
    [junit] Test: L2, da038eee18640485
    [junit] tag=70c32, index=24, offset=5
    [junit] Test: DTLB, ffffffffb289381c
    [junit] tag=7fd9449, index=0, offset=181c
    [junit] Test: L1, c695a307794c9590
    [junit] tag=7794c9, index=2c, offset=10
    [junit] Test: L2, ffffffffacb22c94
    [junit] tag=7d659, index=164, offset=14
    [junit] Test: DTLB, fffffffff0c7750e
    [junit] tag=7ff863b, index=0, offset=150e
    [junit] Test: L1, ffffffffebe1a06a
    [junit] tag=febe1a, index=3, offset=a
    [junit] Test: L2, e2e08937066117a6
    [junit] tag=38330, index=8bd, offset=6
    [junit] Test: DTLB, 2deb0f21401d0401
    [junit] tag=10a00e8, index=0, offset=401
    [junit] Test: L1, ffffffffa02911fc
    [junit] tag=fa0291, index=f, offset=1c
    [junit] Test: L2, ffffffff9e198ed6
    [junit] tag=7cf0c, index=c76, offset=16
    [junit] Test: DTLB, ffffffffb6e6ef82
    [junit] tag=7fdb737, index=0, offset=f82
    [junit] Test: L1, ffffffff94eb57a3
    [junit] tag=f94eb5, index=3d, offset=3
    [junit] Test: L2, 7c3108125288df28
    [junit] tag=12944, index=6f9, offset=8
    [junit] Test: DTLB, 1180513f6f537c26
    [junit] tag=1fb7a9b, index=0, offset=1c26
    [junit] Test: L1, ffffffffc8713797
    [junit] tag=fc8713, index=3c, offset=17
    [junit] Test: L2, 47c3643071773769
    [junit] tag=38bb, index=9bb, offset=9
    [junit] Test: DTLB, ffffffff969a137b
    [junit] tag=7fcb4d0, index=0, offset=137b
    [junit] Test: L1, 73e32079583bfa57
    [junit] tag=9583bf, index=52, offset=17
    [junit] Test: L2, ffffffff88b3328f
    [junit] tag=7c459, index=994, offset=f
    [junit] Test: DTLB, c72d88df03d96c72
    [junit] tag=6f81ecb, index=0, offset=c72
    [junit] Test: L1, ffffffff8b6d2085
    [junit] tag=f8b6d2, index=4, offset=5
    [junit] Test: L2, ffffffffd5115e4f
    [junit] tag=7ea88, index=af2, offset=f
    [junit] Test: DTLB, 32c7bfd6038f03c1
    [junit] tag=6b01c78, index=0, offset=3c1
    [junit] Test: L1, ffffffff99cb5b45
    [junit] tag=f99cb5, index=5a, offset=5
    [junit] Test: L2, ffffffffe171eaec
    [junit] tag=7f0b8, index=f57, offset=c
    [junit] Test: DTLB, ffffffff80ac6015
    [junit] tag=7fc0563, index=0, offset=15
    [junit] Test: L1, 18563970369d332
    [junit] tag=70369d, index=19, offset=12
    [junit] Test: L2, ffffffffabb3e777
    [junit] tag=7d5d9, index=f3b, offset=17
    [junit] Test: DTLB, 3bc40d2d5a70b645
    [junit] tag=16ad385, index=0, offset=1645
    [junit] Test: L1, 4f28481d07c1b96e
    [junit] tag=d07c1b, index=4b, offset=e
    [junit] Test: L2, 7a1f25c064ba05ca
    [junit] tag=325d, index=2e, offset=a
    [junit] Test: DTLB, 714065b7698336b8
    [junit] tag=5bb4c19, index=0, offset=16b8
    [junit] Test: L1, ea6829c561c0a64e
    [junit] tag=561c0a, index=32, offset=e
    [junit] Test: L2, a4c5a55d10336bc6
    [junit] tag=68819, index=b5e, offset=6
    [junit] Test: DTLB, f9a1975c61b3f4a2
    [junit] tag=2e30d9f, index=0, offset=14a2
    [junit] Test: L1, 3322c2fd0bcecbe1
    [junit] tag=d0bcec, index=5f, offset=1
    [junit] Test: L2, ffffffffea916176
    [junit] tag=7f548, index=b0b, offset=16
    [junit] Test: DTLB, ffffffffd5af4724
    [junit] tag=7fead7a, index=0, offset=724
    [junit] Test: L1, 72dd03392ab5ff8a
    [junit] tag=92ab5f, index=7c, offset=a
    [junit] Test: L2, ffffffffcee16c85
    [junit] tag=7e770, index=b64, offset=5
    [junit] Test: DTLB, ffffffffbd9324f4
    [junit] tag=7fdec99, index=0, offset=4f4
    [junit] Test: L1, 9049cc3746b3c7ef
    [junit] tag=746b3c, index=3f, offset=f
    [junit] Test: L2, fffffffff84f384a
    [junit] tag=7fc27, index=9c2, offset=a
    [junit] Test: DTLB, c7f5bc8047633b51
    [junit] tag=4023b19, index=0, offset=1b51
    [junit] Test: L1, 75d238974da046cb
    [junit] tag=74da04, index=36, offset=b
    [junit] Test: L2, e4119b335ceffb7e
    [junit] tag=1ae77, index=fdb, offset=1e
    [junit] Test: DTLB, ffffffffba85bd95
    [junit] tag=7fdd42d, index=0, offset=1d95
    [junit] Test: L1, ffffffffd16017ec
    [junit] tag=fd1601, index=3f, offset=c
    [junit] Test: L2, ffffffff9be92449
    [junit] tag=7cdf4, index=922, offset=9
    [junit] Test: DTLB, 43600ab81f7747f2
    [junit] tag=5c0fbba, index=0, offset=7f2
    [junit] Test: L1, ffffffffb6f84113
    [junit] tag=fb6f84, index=8, offset=13
    [junit] Test: L2, ffffffffa198bf5c
    [junit] tag=7d0cc, index=5fa, offset=1c
    [junit] Test: DTLB, 88967bc17b745d1b
    [junit] tag=60bdba2, index=0, offset=1d1b
    [junit] Test: L1, 10b56bec43296b46
    [junit] tag=c43296, index=5a, offset=6
    [junit] Test: L2, 516718e509c298de
    [junit] tag=284e1, index=4c6, offset=1e
    [junit] Test: DTLB, fffffffff29fe042
    [junit] tag=7ff94ff, index=0, offset=42
    [junit] Test: L1, ffffffff9e783628
    [junit] tag=f9e783, index=31, offset=8
    [junit] Test: L2, ffffffffdd6f303a
    [junit] tag=7eeb7, index=981, offset=1a
    [junit] Test: DTLB, 148c62f42a4b286c
    [junit] tag=7a15259, index=0, offset=86c
    [junit] Test: L1, 49c6e2b71fd839e9
    [junit] tag=71fd83, index=4f, offset=9
    [junit] Test: L2, ffffffffaee44aad
    [junit] tag=7d772, index=255, offset=d
    [junit] Test: DTLB, 51117e061a9cd829
    [junit] tag=30d4e6, index=0, offset=1829
    [junit] Test: L1, ffffffff84ad8264
    [junit] tag=f84ad8, index=13, offset=4
    [junit] Test: L2, c5dbc6ec5bdae596
    [junit] tag=62ded, index=72c, offset=16
    [junit] Test: DTLB, 63e5f99764c70994
    [junit] tag=4bb2638, index=0, offset=994
    [junit] Test: L1, ffffffffd5cfee52
    [junit] tag=fd5cfe, index=72, offset=12
    [junit] Test: L2, af39229731f95e68
    [junit] tag=398fc, index=af3, offset=8
    [junit] Test: DTLB, ffffffffe9256473
    [junit] tag=7ff492b, index=0, offset=473
    [junit] Test: L1, ffffffffbec13263
    [junit] tag=fbec13, index=13, offset=3
    [junit] Test: L2, a8fbadbb63152ce1
    [junit] tag=5b18a, index=967, offset=1
    [junit] Test: DTLB, 4bdd55553a96ecac
    [junit] tag=2a9d4b7, index=0, offset=cac
    [junit] Test: L1, ffffffff91aa7030
    [junit] tag=f91aa7, index=1, offset=10
    [junit] Test: L2, ffffffff96fc674c
    [junit] tag=7cb7e, index=33a, offset=c
    [junit] Test: DTLB, c9578944a6938a7
    [junit] tag=4a25349, index=0, offset=18a7
    [junit] Test: L1, fffffffff26c50ef
    [junit] tag=ff26c5, index=7, offset=f
    [junit] Test: L2, 3486def85b22ff1e
    [junit] tag=42d91, index=7f8, offset=1e
    [junit] Test: DTLB, e7f3a5e71c251224
    [junit] tag=738e128, index=0, offset=1224
    [junit] Test: L1, ffffffffba1e14f8
    [junit] tag=fba1e1, index=27, offset=18
    [junit] Test: L2, d5bfe78a0bebca97
    [junit] tag=505f5, index=e54, offset=17
    [junit] Test: DTLB, ffffffffa38ef154
    [junit] tag=7fd1c77, index=0, offset=1154
    [junit] Test: L1, ffffffff93b6be47
    [junit] tag=f93b6b, index=72, offset=7
    [junit] Test: L2, e5a6b9a11daceb82
    [junit] tag=8ed6, index=75c, offset=2
    [junit] Test: DTLB, d2042d7b041045b7
    [junit] tag=3d82082, index=0, offset=5b7
    [junit] Test: L1, aabd1ccd08ff968c
    [junit] tag=d08ff9, index=34, offset=c
    [junit] Test: L2, fffffffff444f1b5
    [junit] tag=7fa22, index=78d, offset=15
    [junit] Test: DTLB, ffffffffd3239e4f
    [junit] tag=7fe991c, index=0, offset=1e4f
    [junit] Test: L1, 74db4e7f595b73a6
    [junit] tag=f595b7, index=1d, offset=6
    [junit] Test: L2, 18d25ad16bed1a27
    [junit] tag=b5f6, index=8d1, offset=7
    [junit] Test: DTLB, 54f220806b2c1be2
    [junit] tag=4035960, index=0, offset=1be2
    [junit] Test: L1, ffffffffb94e61e3
    [junit] tag=fb94e6, index=f, offset=3
    [junit] Test: L2, fffffffff037fc77
    [junit] tag=7f81b, index=fe3, offset=17
    [junit] Test: DTLB, ad8187350768e8ce
    [junit] tag=1a83b47, index=0, offset=8ce
    [junit] Test: L1, ffffffffebc2b99a
    [junit] tag=febc2b, index=4c, offset=1a
    [junit] Test: L2, 2fa6a43362d55615
    [junit] tag=1b16a, index=ab0, offset=15
    [junit] Test: DTLB, e334ad0364fec842
    [junit] tag=1b27f6, index=0, offset=842
    [junit] Test: L1, 6eb913079e42f97
    [junit] tag=79e42, index=7c, offset=17
    [junit] Test: L2, ffffffffa40e83e8
    [junit] tag=7d207, index=41f, offset=8
    [junit] Test: DTLB, 814f4c3b38592504
    [junit] tag=1d9c2c9, index=0, offset=504
    [junit] Test: L1, ffffffffc63722d9
    [junit] tag=fc6372, index=16, offset=19
    [junit] Test: L2, ffffffffd1185b1c
    [junit] tag=7e88c, index=2d8, offset=1c
    [junit] Test: DTLB, ffffffff96e71c7e
    [junit] tag=7fcb738, index=0, offset=1c7e
    [junit] Test: L1, fffffffff5366efa
    [junit] tag=ff5366, index=77, offset=1a
    [junit] Test: L2, e290566c24f0de6b
    [junit] tag=61278, index=6f3, offset=b
    [junit] Test: DTLB, ec60d6d72c6742e1
    [junit] tag=6b9633a, index=0, offset=2e1
    [junit] Test: L1, ffffffff8d03fc27
    [junit] tag=f8d03f, index=61, offset=7
    [junit] Test: L2, 8a84d32e734a5eeb
    [junit] tag=739a5, index=2f7, offset=b
    [junit] Test: DTLB, e82896926c37a38d
    [junit] tag=49361bd, index=0, offset=38d
    [junit] Test: L1, ffffffffe742e779
    [junit] tag=fe742e, index=3b, offset=19
    [junit] Test: L2, ef3ba78201a10588
    [junit] tag=100d0, index=82c, offset=8
    [junit] Test: DTLB, ffffffffde535bda
    [junit] tag=7fef29a, index=0, offset=1bda
    [junit] Test: L1, ffffffffa375d5ee
    [junit] tag=fa375d, index=2f, offset=e
    [junit] Test: L2, ffffffffe60b4208
    [junit] tag=7f305, index=a10, offset=8
    [junit] Test: DTLB, ffffffffbc8a9d40
    [junit] tag=7fde454, index=0, offset=1d40
    [junit] Test: L1, fc87a9987b2bbc7d
    [junit] tag=87b2bb, index=63, offset=1d
    [junit] Test: L2, fffffffffba37978
    [junit] tag=7fdd1, index=bcb, offset=18
    [junit] Test: DTLB, 7612241e776beda1
    [junit] tag=f3bb5f, index=0, offset=da1
    [junit] Test: L1, 60e11ca328c8191d
    [junit] tag=328c81, index=48, offset=1d
    [junit] Test: L2, 333531d904979884
    [junit] tag=4824b, index=cc4, offset=4
    [junit] Test: DTLB, 9862120159556046
    [junit] tag=acaab, index=0, offset=46
    [junit] Test: L1, ffffffff87d72cf7
    [junit] tag=f87d72, index=67, offset=17
    [junit] Test: L2, ffffffffd108ae9f
    [junit] tag=7e884, index=574, offset=1f
    [junit] Test: DTLB, d766d1be3dcbad39
    [junit] tag=5f1ee5d, index=0, offset=d39
    [junit] Test: L1, 8a2a0e3362697c2e
    [junit] tag=362697, index=61, offset=e
    [junit] Test: L2, ffffffff80472bb4
    [junit] tag=7c023, index=95d, offset=14
    [junit] Test: DTLB, ffffffffacddd0d7
    [junit] tag=7fd66ee, index=0, offset=10d7
    [junit] Test: L1, 3d297c8b24171eac
    [junit] tag=b24171, index=75, offset=c
    [junit] Test: L2, ffffffffeac55108
    [junit] tag=7f562, index=a88, offset=8
    [junit] Test: DTLB, 633a17fd4743623d
    [junit] tag=7ea3a1b, index=0, offset=23d
    [junit] Test: L1, b781f934102d0b22
    [junit] tag=4102d0, index=59, offset=2
    [junit] Test: L2, be0d82c322077d17
    [junit] tag=19103, index=be8, offset=17
    [junit] Test: DTLB, ffffffffaab65a1d
    [junit] tag=7fd55b2, index=0, offset=1a1d
    [junit] Test: L1, 801fca4272946fb0
    [junit] tag=272946, index=7d, offset=10
    [junit] Test: L2, 8112ffeb7a8c528d
    [junit] tag=5bd46, index=294, offset=d
    [junit] Test: DTLB, 83eca4c915e6c8da
    [junit] tag=648af36, index=0, offset=8da
    [junit] Test: L1, ffffffffc5cc0409
    [junit] tag=fc5cc0, index=20, offset=9
    [junit] Test: L2, 518df308330b43d2
    [junit] tag=41985, index=a1e, offset=12
    [junit] Test: DTLB, fffffffffb5c4f2c
    [junit] tag=7ffdae2, index=0, offset=f2c
    [junit] Test: L1, 1b5ad34d46c63325
    [junit] tag=d46c63, index=19, offset=5
    [junit] Test: L2, ffffffffab1c010b
    [junit] tag=7d58e, index=8, offset=b
    [junit] Test: DTLB, ffffffff9ca5b38a
    [junit] tag=7fce52d, index=0, offset=138a
    [junit] Test: L1, ffffffffcb56a4a6
    [junit] tag=fcb56a, index=25, offset=6
    [junit] Test: L2, ffffffffb8c41f7c
    [junit] tag=7dc62, index=fb, offset=1c
    [junit] Test: DTLB, ffffffffc8c5963e
    [junit] tag=7fe462c, index=0, offset=163e
    [junit] Test: L1, 11239c2751b31076
    [junit] tag=751b31, index=3, offset=16
    [junit] Test: L2, ffffffffb6b8ed4d
    [junit] tag=7db5c, index=76a, offset=d
    [junit] Test: DTLB, 9ed66d447f005adb
    [junit] tag=223f802, index=0, offset=1adb
    [junit] Test: L1, e33acd866ffb1c2a
    [junit] tag=66ffb1, index=61, offset=a
    [junit] Test: L2, ffffffffd7fc75c6
    [junit] tag=7ebfe, index=3ae, offset=6
    [junit] Test: DTLB, 2b9008ef143a6892
    [junit] tag=778a1d3, index=0, offset=892
    [junit] Test: L1, fffffffff528211c
    [junit] tag=ff5282, index=8, offset=1c
    [junit] Test: L2, 66c3e9461e58f6f6
    [junit] tag=30f2c, index=7b7, offset=16
    [junit] Test: DTLB, ffffffffb1b70406
    [junit] tag=7fd8db8, index=0, offset=406
    [junit] Test: L1, 24e2ac20e872b11
    [junit] tag=20e872, index=58, offset=11
    [junit] Test: L2, f36661171fc6f2fa
    [junit] tag=38fe3, index=797, offset=1a
    [junit] Test: DTLB, ffffffffaeebaf3f
    [junit] tag=7fd775d, index=0, offset=f3f
    [junit] Test: L1, ffffffffae352b22
    [junit] tag=fae352, index=59, offset=2
    [junit] Test: L2, fffffffff5c4a088
    [junit] tag=7fae2, index=504, offset=8
    [junit] Test: DTLB, 98d9e86f618cdf22
    [junit] tag=37b0c66, index=0, offset=1f22
    [junit] Test: L1, ffffffff9923aa54
    [junit] tag=f9923a, index=52, offset=14
    [junit] Test: L2, ffffffffd0e16921
    [junit] tag=7e870, index=b49, offset=1
    [junit] Test: DTLB, ffffffff9ed143be
    [junit] tag=7fcf68a, index=0, offset=3be
    [junit] Test: L1, b7b1df681fd893d8
    [junit] tag=81fd89, index=1e, offset=18
    [junit] Test: L2, 6e3f254e6f2cfb91
    [junit] tag=73796, index=7dc, offset=11
    [junit] Test: DTLB, ffffffffdbeea636
    [junit] tag=7fedf75, index=0, offset=636
    [junit] Test: L1, c52a30ae0bdab666
    [junit] tag=e0bdab, index=33, offset=6
    [junit] Test: L2, 9a5cd230396c4e5a
    [junit] tag=1cb6, index=272, offset=1a
    [junit] Test: DTLB, 751569278fb1610
    [junit] tag=493c7d8, index=0, offset=1610
    [junit] Test: L1, ffffffffb03db2aa
    [junit] tag=fb03db, index=15, offset=a
    [junit] Test: L2, ffffffffa7e98203
    [junit] tag=7d3f4, index=c10, offset=3
    [junit] Test: DTLB, ffffffffee452781
    [junit] tag=7ff7229, index=0, offset=781
    [junit] Test: L1, ffffffffb807c233
    [junit] tag=fb807c, index=11, offset=13
    [junit] Test: L2, ffffffffa8aa67f5
    [junit] tag=7d455, index=33f, offset=15
    [junit] Test: DTLB, e6fcaf203dffa9a6
    [junit] tag=101effd, index=0, offset=9a6
    [junit] Test: L1, 69735522855f9c2
    [junit] tag=22855f, index=4e, offset=2
    [junit] Test: L2, 7d3a3ab45227aebb
    [junit] tag=22913, index=d75, offset=1b
    [junit] Test: DTLB, ffffffffef6bb3b4
    [junit] tag=7ff7b5d, index=0, offset=13b4
    [junit] Test: L1, ffffffffb5ed2a83
    [junit] tag=fb5ed2, index=54, offset=3
    [junit] Test: L2, a3c5ff5f3c6718f8
    [junit] tag=79e33, index=8c7, offset=18
    [junit] Test: DTLB, 170a6c1b6a8caec9
    [junit] tag=db5465, index=0, offset=ec9
    [junit] Test: L1, 55f31adb762efd54
    [junit] tag=b762ef, index=6a, offset=14
    [junit] Test: L2, ffffffffb30fa30a
    [junit] tag=7d987, index=d18, offset=a
    [junit] Test: DTLB, ab7f48e1726a9df8
    [junit] tag=70b9354, index=0, offset=1df8
    [junit] Test: L1, 9ce8189c46273023
    [junit] tag=c46273, index=1, offset=3
    [junit] Test: L2, db482b7a1180bafb
    [junit] tag=508c0, index=5d7, offset=1b
    [junit] Test: DTLB, ffffffff82ddc3c9
    [junit] tag=7fc16ee, index=0, offset=3c9
    [junit] Test: L1, a802627470979ab0
    [junit] tag=470979, index=55, offset=10
    [junit] Test: L2, ffffffff9404a495
    [junit] tag=7ca02, index=524, offset=15
    [junit] Test: DTLB, ffffffffbfc9e447
    [junit] tag=7fdfe4f, index=0, offset=447
    [junit] Test: L1, fffffffff957d227
    [junit] tag=ff957d, index=11, offset=7
    [junit] Test: L2, 7a0f23bb22963356
    [junit] tag=5914b, index=19a, offset=16
    [junit] Test: DTLB, ffffffff8e04a3df
    [junit] tag=7fc7025, index=0, offset=3df
    [junit] Test: L1, ffffffffb0fdbc25
    [junit] tag=fb0fdb, index=61, offset=5
    [junit] Test: L2, ffffffffc92e75ca
    [junit] tag=7e497, index=3ae, offset=a
    [junit] Test: DTLB, 8dca9f4b4a9c74e9
    [junit] tag=25a54e3, index=0, offset=14e9
    [junit] Test: L1, ffffffff88ab2e74
    [junit] tag=f88ab2, index=73, offset=14
    [junit] Test: L2, 8524ff377c31b926
    [junit] tag=3be18, index=dc9, offset=6
    [junit] Test: DTLB, ffffffff8f771930
    [junit] tag=7fc7bb8, index=0, offset=1930
    [junit] Test: L1, ffffffffb1793521
    [junit] tag=fb1793, index=29, offset=1
    [junit] Test: L2, abbe02527ed0327c
    [junit] tag=13f68, index=193, offset=1c
    [junit] Test: DTLB, ffffffffa68709a7
    [junit] tag=7fd3438, index=0, offset=9a7
    [junit] Test: L1, 88641d1f273f4375
    [junit] tag=f273f4, index=1b, offset=15
    [junit] Test: L2, 5636991833d4661d
    [junit] tag=419ea, index=330, offset=1d
    [junit] Test: DTLB, ec0439376b91fcde
    [junit] tag=1bb5c8f, index=0, offset=1cde
    [junit] Test: L1, ffffffffb84cf518
    [junit] tag=fb84cf, index=28, offset=18
    [junit] Test: L2, ffffffffe9e679ad
    [junit] tag=7f4f3, index=3cd, offset=d
    [junit] Test: DTLB, ffffffffba6a88cc
    [junit] tag=7fdd354, index=0, offset=8cc
    [junit] Test: L1, ffffffffe4b82853
    [junit] tag=fe4b82, index=42, offset=13
    [junit] Test: L2, 5379f9e37a2342da
    [junit] tag=1bd11, index=a16, offset=1a
    [junit] Test: DTLB, ffffffffdbc822b1
    [junit] tag=7fede41, index=0, offset=2b1
    [junit] Test: L1, e0225c550c911d8c
    [junit] tag=50c911, index=6c, offset=c
    [junit] Test: L2, ffffffffd0b8e6fa
    [junit] tag=7e85c, index=737, offset=1a
    [junit] Test: DTLB, 8949b477bf4fe13
    [junit] tag=23bdfa7, index=0, offset=1e13
    [junit] Test: L1, 8e43a15445c520e1
    [junit] tag=445c52, index=7, offset=1
    [junit] Test: L2, 25d70a862031e7c
    [junit] tag=43101, index=8f3, offset=1c
    [junit] Test: DTLB, ffffffff8543a466
    [junit] tag=7fc2a1d, index=0, offset=466
    [junit] Test: L1, ea86b2dc6ef51195
    [junit] tag=c6ef51, index=c, offset=15
    [junit] Test: L2, a78174b701e75a4f
    [junit] tag=380f3, index=ad2, offset=f
    [junit] Test: DTLB, 6159bd2043956990
    [junit] tag=1021cab, index=0, offset=990
    [junit] Test: L1, d11331fb3ea3b8c8
    [junit] tag=b3ea3b, index=46, offset=8
    [junit] Test: L2, e4443e0800dc8174
    [junit] tag=4006e, index=40b, offset=14
    [junit] Test: DTLB, 19d004b64d826838
    [junit] tag=5b26c13, index=0, offset=838
    [junit] Test: L1, ffffffff90121478
    [junit] tag=f90121, index=23, offset=18
    [junit] Test: L2, fffffffff4ed96b5
    [junit] tag=7fa76, index=cb5, offset=15
    [junit] Test: DTLB, 8c9d52ad669ceabd
    [junit] tag=56b34e7, index=0, offset=abd
    [junit] Test: L1, ffffffffe88660b6
    [junit] tag=fe8866, index=5, offset=16
    [junit] Test: L2, 909e0349364d2b92
    [junit] tag=49b26, index=95c, offset=12
    [junit] Test: DTLB, ffffffffe554a397
    [junit] tag=7ff2aa5, index=0, offset=397
    [junit] Test: L1, ffffffffe29b0bf8
    [junit] tag=fe29b0, index=5f, offset=18
    [junit] Test: L2, 48d9fb38543dc34f
    [junit] tag=42a1e, index=e1a, offset=f
    [junit] Test: DTLB, ffffffffbc8f8287
    [junit] tag=7fde47c, index=0, offset=287
    [junit] Test: L1, dca5bf0574ba694c
    [junit] tag=574ba6, index=4a, offset=c
    [junit] Test: L2, ffffffff85dcfaa4
    [junit] tag=7c2ee, index=7d5, offset=4
    [junit] Test: DTLB, fffffffff874eadb
    [junit] tag=7ffc3a7, index=0, offset=adb
    [junit] Test: L1, e04319ca4b0041a4
    [junit] tag=a4b004, index=d, offset=4
    [junit] Test: L2, 2d7cc8330963d837
    [junit] tag=184b1, index=ec1, offset=17
    [junit] Test: DTLB, 32e4f7ef4016962e
    [junit] tag=77a00b4, index=0, offset=162e
    [junit] Test: L1, ffffffffd864345e
    [junit] tag=fd8643, index=22, offset=1e
    [junit] Test: L2, ffffffff8378e7c2
    [junit] tag=7c1bc, index=73e, offset=2
    [junit] Test: DTLB, be208b4d266837be
    [junit] tag=2693341, index=0, offset=17be
    [junit] Test: L1, b0166c1168cfbe0c
    [junit] tag=168cfb, index=70, offset=c
    [junit] Test: L2, ffffffffb7935557
    [junit] tag=7dbc9, index=aaa, offset=17
    [junit] Test: DTLB, ffffffff9480daf3
    [junit] tag=7fca406, index=0, offset=1af3
    [junit] Test: L1, 561de32f43108aa8
    [junit] tag=f43108, index=55, offset=8
    [junit] Test: L2, 268f1985213c69d3
    [junit] tag=2909e, index=34e, offset=13
    [junit] Test: DTLB, ffffffff9ba4b187
    [junit] tag=7fcdd25, index=0, offset=1187
    [junit] Test: L1, ffffffff882d3046
    [junit] tag=f882d3, index=2, offset=6
    [junit] Test: L2, 112ef03f2ee799e7
    [junit] tag=79773, index=ccf, offset=7
    [junit] Test: DTLB, 939bb14b3e3eba90
    [junit] tag=259f1f5, index=0, offset=1a90
    [junit] Test: L1, ffffffffe2d12c98
    [junit] tag=fe2d12, index=64, offset=18
    [junit] Test: L2, e447391c5ac4c302
    [junit] tag=62d62, index=618, offset=2
    [junit] Test: DTLB, 369c6b1266af8373
    [junit] tag=93357c, index=0, offset=373
    [junit] Test: L1, eb2118a2feb2ed0
    [junit] tag=a2feb2, index=76, offset=10
    [junit] Test: L2, ffffffffcefdda80
    [junit] tag=7e77e, index=ed4, offset=0
    [junit] Test: DTLB, ffffffff80eb388a
    [junit] tag=7fc0759, index=0, offset=188a
    [junit] Test: L1, ffffffff813a3dea
    [junit] tag=f813a3, index=6f, offset=a
    [junit] Test: L2, ffffffffaf1e71ab
    [junit] tag=7d78f, index=38d, offset=b
    [junit] Test: DTLB, 43dbbf9565b115d4
    [junit] tag=4ab2d88, index=0, offset=15d4
    [junit] Test: L1, 4cd2c5714d48fecf
    [junit] tag=14d48f, index=76, offset=f
    [junit] Test: L2, 648366ef57088172
    [junit] tag=7ab84, index=40b, offset=12
    [junit] Test: DTLB, ffffffffcc2f44ae
    [junit] tag=7fe617a, index=0, offset=4ae
    [junit] Test: L1, 7040a9b443746ed1
    [junit] tag=443746, index=76, offset=11
    [junit] Test: L2, fffffffff3b98b3d
    [junit] tag=7f9dc, index=c59, offset=1d
    [junit] Test: DTLB, ffffffffadd0b372
    [junit] tag=7fd6e85, index=0, offset=1372
    [junit] Test: L1, ffffffffaaec4aa5
    [junit] tag=faaec4, index=55, offset=5
    [junit] Test: L2, 77e641104a4432c4
    [junit] tag=2522, index=196, offset=4
    [junit] Test: DTLB, ffffffffc95ab6db
    [junit] tag=7fe4ad5, index=0, offset=16db
    [junit] Test: L1, fffffffff31049bf
    [junit] tag=ff3104, index=4d, offset=1f
    [junit] Test: L2, ffffffffd4261f23
    [junit] tag=7ea13, index=f9, offset=3
    [junit] Test: DTLB, ffffffffab0185bd
    [junit] tag=7fd580c, index=0, offset=5bd
    [junit] Test: L1, c9520f6706a4f27d
    [junit] tag=706a4f, index=13, offset=1d
    [junit] Test: L2, e26c53ba29bcfaf3
    [junit] tag=514de, index=7d7, offset=13
    [junit] Test: DTLB, ffffffffcc427f54
    [junit] tag=7fe6213, index=0, offset=1f54
    [junit] Test: L1, 19ad1b523e5ba8bb
    [junit] tag=23e5ba, index=45, offset=1b
    [junit] Test: L2, ffffffffc6f4feff
    [junit] tag=7e37a, index=7f7, offset=1f
    [junit] Test: DTLB, 23877ceb09b8ede8
    [junit] tag=7584dc7, index=0, offset=de8
    [junit] Test: L1, 88c3410737f00466
    [junit] tag=737f00, index=23, offset=6
    [junit] Test: L2, ffffffffe6994450
    [junit] tag=7f34c, index=a22, offset=10
    [junit] Test: DTLB, fffffffff83f3cc9
    [junit] tag=7ffc1f9, index=0, offset=1cc9
    [junit] Test: L1, ffffffff826ecbc1
    [junit] tag=f826ec, index=5e, offset=1
    [junit] Test: L2, ffffffffe858a814
    [junit] tag=7f42c, index=540, offset=14
    [junit] Test: DTLB, ffffffffd5e11cd3
    [junit] tag=7feaf08, index=0, offset=1cd3
    [junit] Test: L1, ffffffffb275d1e2
    [junit] tag=fb275d, index=f, offset=2
    [junit] Test: L2, ffffffffe88ea687
    [junit] tag=7f447, index=534, offset=7
    [junit] Test: DTLB, ffffffff9939a0e0
    [junit] tag=7fcc9cd, index=0, offset=e0
    [junit] Test: L1, ffffffffa3b82ab7
    [junit] tag=fa3b82, index=55, offset=17
    [junit] Test: L2, 69927e786f4807ee
    [junit] tag=437a4, index=3f, offset=e
    [junit] Test: DTLB, 6881df75133c2587
    [junit] tag=3a899e1, index=0, offset=587
    [junit] Test: L1, ffffffffc170ad1e
    [junit] tag=fc170a, index=68, offset=1e
    [junit] Test: L2, d1019d584a5a2458
    [junit] tag=4252d, index=122, offset=18
    [junit] Test: DTLB, ffffffffe5af9781
    [junit] tag=7ff2d7c, index=0, offset=1781
    [junit] Test: L1, fffffffff4220ead
    [junit] tag=ff4220, index=75, offset=d
    [junit] Test: L2, 70368b52549f69e4
    [junit] tag=12a4f, index=b4f, offset=4
    [junit] Test: DTLB, f937d19f1307d87f
    [junit] tag=4f8983e, index=0, offset=187f
    [junit] Test: L1, 12c3d4cc0512e1e9
    [junit] tag=c0512e, index=f, offset=9
    [junit] Test: L2, ffffffffc1cbd7e0
    [junit] tag=7e0e5, index=ebf, offset=0
    [junit] Test: DTLB, ffffffffb0224ae4
    [junit] tag=7fd8112, index=0, offset=ae4
    [junit] Test: L1, fffffffffc5adc0e
    [junit] tag=ffc5ad, index=60, offset=e
    [junit] Test: L2, 60567bfd79fcf3a0
    [junit] tag=6bcfe, index=79d, offset=0
    [junit] Test: DTLB, ffffffffc375ebec
    [junit] tag=7fe1baf, index=0, offset=bec
    [junit] Test: L1, 83d64865588b8cc0
    [junit] tag=5588b8, index=66, offset=0
    [junit] Test: L2, ffffffffa321cd01
    [junit] tag=7d190, index=e68, offset=1
    [junit] Test: DTLB, ffffffff823664e8
    [junit] tag=7fc11b3, index=0, offset=4e8
    [junit] Test: L1, 4efc2a9f456732a8
    [junit] tag=f45673, index=15, offset=8
    [junit] Test: L2, ffffffffe5621fa3
    [junit] tag=7f2b1, index=fd, offset=3
    [junit] Test: DTLB, ffffffff8b1d6b45
    [junit] tag=7fc58eb, index=0, offset=b45
    [junit] Test: L1, ffffffffd683bc26
    [junit] tag=fd683b, index=61, offset=6
    [junit] Test: L2, d62963a008541710
    [junit] tag=42a, index=b8, offset=10
    [junit] Test: DTLB, fffffffff1b5462f
    [junit] tag=7ff8daa, index=0, offset=62f
    [junit] Test: L1, 14f45d6157dd0a07
    [junit] tag=157dd0, index=50, offset=7
    [junit] Test: L2, 1203adc7352bb07c
    [junit] tag=39a95, index=d83, offset=1c
    [junit] Test: DTLB, ffffffffbb8e3b3c
    [junit] tag=7fddc71, index=0, offset=1b3c
    [junit] Test: L1, 88c168450d5469c5
    [junit] tag=50d546, index=4e, offset=5
    [junit] Test: L2, 51463e864d564f19
    [junit] tag=326ab, index=278, offset=19
    [junit] Test: DTLB, e478a91b36e9779d
    [junit] tag=d9b74b, index=0, offset=179d
    [junit] Test: L1, 4220cd2517f4ff49
    [junit] tag=517f4f, index=7a, offset=9
    [junit] Test: L2, ffffffffdc23ba47
    [junit] tag=7ee11, index=dd2, offset=7
    [junit] Test: DTLB, ffffffffc9fa1183
    [junit] tag=7fe4fd0, index=0, offset=1183
    [junit] Test: L1, c96be012312a9be4
    [junit] tag=2312a9, index=5f, offset=4
    [junit] Test: L2, ffffffffb84db3e2
    [junit] tag=7dc26, index=d9f, offset=2
    [junit] Test: DTLB, fffffffff84c73ae
    [junit] tag=7ffc263, index=0, offset=13ae
    [junit] Test: L1, ecff7de87a3539d3
    [junit] tag=87a353, index=4e, offset=13
    [junit] Test: L2, 78eec7f401f0cee7
    [junit] tag=200f8, index=677, offset=7
    [junit] Test: DTLB, ffffffffddced3b7
    [junit] tag=7feee76, index=0, offset=13b7
    [junit] Test: L1, ffffffffc96051f3
    [junit] tag=fc9605, index=f, offset=13
    [junit] Test: L2, ffffffffef282b1e
    [junit] tag=7f794, index=158, offset=1e
    [junit] Test: DTLB, f57f34a6055c10a5
    [junit] tag=5302ae0, index=0, offset=10a5
    [junit] Test: L1, ffffffff8b8a3325
    [junit] tag=f8b8a3, index=19, offset=5
    [junit] Test: L2, 2ec99d9d6739ad95
    [junit] tag=6b39c, index=d6c, offset=15
    [junit] Test: DTLB, 5223abb0541aa7bc
    [junit] tag=582a0d5, index=0, offset=7bc
    [junit] Test: L1, 773304365a97c6c7
    [junit] tag=65a97c, index=36, offset=7
    [junit] Test: L2, 612a4c5419012735
    [junit] tag=20c80, index=939, offset=15
    [junit] Test: DTLB, ffffffffc1b325ed
    [junit] tag=7fe0d99, index=0, offset=5ed
    [junit] Test: L1, ffffffffa0956a3c
    [junit] tag=fa0956, index=51, offset=1c
    [junit] Test: L2, ffffffffd0576483
    [junit] tag=7e82b, index=b24, offset=3
    [junit] Test: DTLB, ffffffffef46d7c5
    [junit] tag=7ff7a36, index=0, offset=17c5
    [junit] Test: L1, ffffffffd51c0270
    [junit] tag=fd51c0, index=13, offset=10
    [junit] Test: L2, 47b7219b1d747d21
    [junit] tag=58eba, index=3e9, offset=1
    [junit] Test: DTLB, ffffffffcd7a866b
    [junit] tag=7fe6bd4, index=0, offset=66b
    [junit] Test: L1, ffffffff9ed9872e
    [junit] tag=f9ed98, index=39, offset=e
    [junit] Test: L2, e00d2fda1877ea0f
    [junit] tag=50c3b, index=f50, offset=f
    [junit] Test: DTLB, 1293f299685dc096
    [junit] tag=4cb42ee, index=0, offset=96
    [junit] Test: L1, cfc8fad70f931a3c
    [junit] tag=70f931, index=51, offset=1c
    [junit] Test: L2, ffffffff8b531756
    [junit] tag=7c5a9, index=8ba, offset=16
    [junit] Test: DTLB, ffffffffd0b08b6f
    [junit] tag=7fe8584, index=0, offset=b6f
    [junit] Test: L1, 11d623672a9e7e19
    [junit] tag=72a9e7, index=70, offset=19
    [junit] Test: L2, ffffffffb2fdf693
    [junit] tag=7d97e, index=fb4, offset=13
    [junit] Test: DTLB, ffffffff9b5cac4b
    [junit] tag=7fcdae5, index=0, offset=c4b
    [junit] Test: L1, ffffffff961fb558
    [junit] tag=f961fb, index=2a, offset=18
    [junit] Test: L2, ffffffff9c43853d
    [junit] tag=7ce21, index=c29, offset=1d
    [junit] Test: DTLB, ffffffffd6833b91
    [junit] tag=7feb419, index=0, offset=1b91
    [junit] Test: L1, ffffffff8a6ab84e
    [junit] tag=f8a6ab, index=42, offset=e
    [junit] Test: L2, ffffffffd5528db6
    [junit] tag=7eaa9, index=46d, offset=16
    [junit] Test: DTLB, dba5c6ff44d03458
    [junit] tag=7fa2681, index=0, offset=1458
    [junit] Test: L1, ffffffffffebba75
    [junit] tag=fffebb, index=53, offset=15
    [junit] Test: L2, ffffffff9a19b1c7
    [junit] tag=7cd0c, index=d8e, offset=7
    [junit] Test: DTLB, ffffffff81703f0f
    [junit] tag=7fc0b81, index=0, offset=1f0f
    [junit] Test: L1, 4ffcfa175bd9861f
    [junit] tag=75bd98, index=30, offset=1f
    [junit] Test: L2, 6dd675d0370246c3
    [junit] tag=1b81, index=236, offset=3
    [junit] Test: DTLB, ffffffffc2341a94
    [junit] tag=7fe11a0, index=0, offset=1a94
    [junit] Test: L1, ffffffffee208145
    [junit] tag=fee208, index=a, offset=5
    [junit] Test: L2, ffffffffe8ee4efe
    [junit] tag=7f477, index=277, offset=1e
    [junit] Test: DTLB, 69c27ebf239c178f
    [junit] tag=5f91ce0, index=0, offset=178f
    [junit] Test: L1, 65c14edd00399898
    [junit] tag=d00399, index=44, offset=18
    [junit] Test: L2, ffffffffeeab932d
    [junit] tag=7f755, index=c99, offset=d
    [junit] Test: DTLB, ffffffffa449994e
    [junit] tag=7fd224c, index=0, offset=194e
    [junit] Test: L1, 64e52c7e73c24a46
    [junit] tag=e73c24, index=52, offset=6
    [junit] Test: L2, 36b6111f7e147900
    [junit] tag=7bf0a, index=3c8, offset=0
    [junit] Test: DTLB, 705fc257106e3c8b
    [junit] tag=2b88371, index=0, offset=1c8b
    [junit] Test: L1, ffffffffab86fc71
    [junit] tag=fab86f, index=63, offset=11
    [junit] Test: L2, ffffffffe61d55d0
    [junit] tag=7f30e, index=aae, offset=10
    [junit] Test: DTLB, 72ee9e5b135e1967
    [junit] tag=2d89af0, index=0, offset=1967
    [junit] Test: L1, 923b267c09d6e620
    [junit] tag=c09d6e, index=31, offset=0
    [junit] Test: L2, 9c9592a639bccf47
    [junit] tag=31cde, index=67a, offset=7
    [junit] Test: DTLB, ace687d229aab6ff
    [junit] tag=6914d55, index=0, offset=16ff
    [junit] Test: L1, ffffffff864dfa5c
    [junit] tag=f864df, index=52, offset=1c
    [junit] Test: L2, ffffffffe8391452
    [junit] tag=7f41c, index=8a2, offset=12
    [junit] Test: DTLB, ffffffff8e50da8a
    [junit] tag=7fc7286, index=0, offset=1a8a
    [junit] Test: L1, 912608af457dc2d9
    [junit] tag=f457dc, index=16, offset=19
    [junit] Test: L2, 40b9494d7521fbd9
    [junit] tag=6ba90, index=fde, offset=19
    [junit] Test: DTLB, e4a8ca414544192a
    [junit] tag=20a2a20, index=0, offset=192a
    [junit] Test: L1, fffffffffd2d2278
    [junit] tag=ffd2d2, index=13, offset=18
    [junit] Test: L2, ffffffff8f42a639
    [junit] tag=7c7a1, index=531, offset=19
    [junit] Test: DTLB, fffffffffba07fcf
    [junit] tag=7ffdd03, index=0, offset=1fcf
    [junit] Test: L1, ffffffffc581fc36
    [junit] tag=fc581f, index=61, offset=16
    [junit] Test: L2, ffffffffab46610a
    [junit] tag=7d5a3, index=308, offset=a
    [junit] Test: DTLB, 65a4defd04f87dc7
    [junit] tag=7e827c3, index=0, offset=1dc7
    [junit] Test: L1, ffffffffc4654e4d
    [junit] tag=fc4654, index=72, offset=d
    [junit] Test: L2, ffffffffff36706f
    [junit] tag=7ff9b, index=383, offset=f
    [junit] Test: DTLB, 512ecd62387351c8
    [junit] tag=311c39a, index=0, offset=11c8
    [junit] Test: L1, ffffffffee0633fa
    [junit] tag=fee063, index=1f, offset=1a
    [junit] Test: L2, ffffffffd2e6adc1
    [junit] tag=7e973, index=56e, offset=1
    [junit] Test: DTLB, 4bfef76d339dec59
    [junit] tag=3699cef, index=0, offset=c59
    [junit] Test: L1, 44a04e9207b60ffa
    [junit] tag=207b60, index=7f, offset=1a
    [junit] Test: L2, ffffffffc531915c
    [junit] tag=7e298, index=c8a, offset=1c
    [junit] Test: DTLB, c7b953114a664491
    [junit] tag=8a5332, index=0, offset=491
    [junit] Test: L1, ffffffffeb36f5ab
    [junit] tag=feb36f, index=2d, offset=b
    [junit] Test: L2, 64a820be09851f1d
    [junit] tag=704c2, index=8f8, offset=1d
    [junit] Test: DTLB, ffffffffebea419a
    [junit] tag=7ff5f52, index=0, offset=19a
    [junit] Test: L1, ffffffffaab824e8
    [junit] tag=faab82, index=27, offset=8
    [junit] Test: L2, 72c00bd51bcf8305
    [junit] tag=28de7, index=c18, offset=5
    [junit] Test: DTLB, 9ae219b86d49d5be
    [junit] tag=5c36a4e, index=0, offset=15be
    [junit] Test: L1, d7e4b97d220bc315
    [junit] tag=d220bc, index=18, offset=15
    [junit] Test: L2, 42559721627e9e92
    [junit] tag=b13f, index=4f4, offset=12
    [junit] Test: DTLB, ffffffff9c9d92dd
    [junit] tag=7fce4ec, index=0, offset=12dd
    [junit] Test: L1, ffffffff90503e05
    [junit] tag=f90503, index=70, offset=5
    [junit] Test: L2, ffffffff86783ba9
    [junit] tag=7c33c, index=1dd, offset=9
    [junit] Test: DTLB, 58ea1fca77028736
    [junit] tag=653b814, index=0, offset=736
    [junit] Test: L1, ffffffffd461d4cf
    [junit] tag=fd461d, index=26, offset=f
    [junit] Test: L2, 419501324624fca5
    [junit] tag=12312, index=7e5, offset=5
    [junit] Test: DTLB, cdf088d53756777
    [junit] tag=46a9bab, index=0, offset=777
    [junit] Test: L1, 4163fd181a453a26
    [junit] tag=81a453, index=51, offset=6
    [junit] Test: L2, ffffffffc0ff909a
    [junit] tag=7e07f, index=c84, offset=1a
    [junit] Test: DTLB, ffffffff902ae2be
    [junit] tag=7fc8157, index=0, offset=2be
    [junit] Test: L1, ffffffffa006e788
    [junit] tag=fa006e, index=3c, offset=8
    [junit] Test: L2, ba9027bd0b943963
    [junit] tag=685ca, index=1cb, offset=3
    [junit] Test: DTLB, 5cc3e75275ef741f
    [junit] tag=293af7b, index=0, offset=141f
    [junit] Test: L1, fa41ebc047aa0537
    [junit] tag=47aa0, index=29, offset=17
    [junit] Test: L2, ffffffffc24689dd
    [junit] tag=7e123, index=44e, offset=1d
    [junit] Test: DTLB, 8dd5adfb2305ce17
    [junit] tag=7d9182e, index=0, offset=e17
    [junit] Test: L1, 5005536c30027679
    [junit] tag=c30027, index=33, offset=19
    [junit] Test: L2, cd63392459b77496
    [junit] tag=22cdb, index=ba4, offset=16
    [junit] Test: DTLB, c996ff613b242858
    [junit] tag=309d921, index=0, offset=858
    [junit] Test: L1, bc840a913035413
    [junit] tag=913035, index=20, offset=13
    [junit] Test: L2, 61f766fd64277043
    [junit] tag=6b213, index=b82, offset=3
    [junit] Test: DTLB, d878b2632660750e
    [junit] tag=3193303, index=0, offset=150e
    [junit] Test: L1, f0aec6d554c5652e
    [junit] tag=554c56, index=29, offset=e
    [junit] Test: L2, e7080e050e5c327b
    [junit] tag=2872e, index=193, offset=1b
    [junit] Test: DTLB, 7c0a223708fd57c3
    [junit] tag=1b847ea, index=0, offset=17c3
    [junit] Test: L1, f0bc9b91fbdca34
    [junit] tag=91fbdc, index=51, offset=14
    [junit] Test: L2, ffffffff809ce04a
    [junit] tag=7c04e, index=702, offset=a
    [junit] Test: DTLB, ffffffff95273f42
    [junit] tag=7fca939, index=0, offset=1f42
    [junit] Test: L1, ffffffffee73d771
    [junit] tag=fee73d, index=3b, offset=11
    [junit] Test: L2, 533174f929cda590
    [junit] tag=494e6, index=d2c, offset=10
    [junit] Test: DTLB, 5f52b31e503e2301
    [junit] tag=f281f1, index=0, offset=301
    [junit] Test: L1, fffffffff58ae77a
    [junit] tag=ff58ae, index=3b, offset=1a
    [junit] Test: L2, ffffffffdffc7311
    [junit] tag=7effe, index=398, offset=11
    [junit] Test: DTLB, fffffffff666b69f
    [junit] tag=7ffb335, index=0, offset=169f
    [junit] Test: L1, fffffffff4616826
    [junit] tag=ff4616, index=41, offset=6
    [junit] Test: L2, ffffffffab725fb6
    [junit] tag=7d5b9, index=2fd, offset=16
    [junit] Test: DTLB, ffffffffdb293a5d
    [junit] tag=7fed949, index=0, offset=1a5d
    [junit] Test: L1, ffffffffdf5a4d8b
    [junit] tag=fdf5a4, index=6c, offset=b
    [junit] Test: L2, dfda13c5090501ab
    [junit] tag=28482, index=80d, offset=b
    [junit] Test: DTLB, ffffffffc8a2a430
    [junit] tag=7fe4515, index=0, offset=430
    [junit] Test: L1, ffffffffec11ec90
    [junit] tag=fec11e, index=64, offset=10
    [junit] Test: L2, 32cb11b0423b96bf
    [junit] tag=211d, index=cb5, offset=1f
    [junit] Test: DTLB, 8b9418232a51408c
    [junit] tag=119528a, index=0, offset=8c
    [junit] Test: L1, ffffffffacbe9205
    [junit] tag=facbe9, index=10, offset=5
    [junit] Test: L2, 8fd205652052b9cc
    [junit] tag=29029, index=5ce, offset=c
    [junit] Test: DTLB, b2cc3351334d2910
    [junit] tag=2899a69, index=0, offset=910
    [junit] Test: L1, fffffffff228ab77
    [junit] tag=ff228a, index=5b, offset=17
    [junit] Test: L2, ffffffffdc78c537
    [junit] tag=7ee3c, index=629, offset=17
    [junit] Test: DTLB, ffffffff8791f804
    [junit] tag=7fc3c8f, index=0, offset=1804
    [junit] Test: L1, ffffffff828db070
    [junit] tag=f828db, index=3, offset=10
    [junit] Test: L2, 82a7f1e6640f1898
    [junit] tag=33207, index=8c4, offset=18
    [junit] Test: DTLB, ffffffff83af4263
    [junit] tag=7fc1d7a, index=0, offset=263
    [junit] Test: L1, fffffffff91dd549
    [junit] tag=ff91dd, index=2a, offset=9
    [junit] Test: L2, 28c9d8cb35f0cb0c
    [junit] tag=59af8, index=658, offset=c
    [junit] Test: DTLB, ffffffffcee8ed98
    [junit] tag=7fe7747, index=0, offset=d98
    [junit] Test: L1, 9cd70efb7f6b5272
    [junit] tag=b7f6b5, index=13, offset=12
    [junit] Test: L2, 5c00ce165ca2bca5
    [junit] tag=32e51, index=5e5, offset=5
    [junit] Test: DTLB, 6c987dc11bb8f80e
    [junit] tag=608ddc7, index=0, offset=180e
    [junit] Test: L1, c822168c6152725d
    [junit] tag=c61527, index=12, offset=1d
    [junit] Test: L2, e34e070452fd5697
    [junit] tag=2297e, index=ab4, offset=17
    [junit] Test: DTLB, 3c2f5341a2bbe4f
    [junit] tag=1a0d15d, index=0, offset=1e4f
    [junit] Test: L1, d2eb46e801385784
    [junit] tag=801385, index=3c, offset=4
    [junit] Test: L2, ffffffffb75fe8b3
    [junit] tag=7dbaf, index=f45, offset=13
    [junit] Test: DTLB, ffffffff80209027
    [junit] tag=7fc0104, index=0, offset=1027
    [junit] Test: L1, ffffffffda5b5ad0
    [junit] tag=fda5b5, index=56, offset=10
    [junit] Test: L2, e8908e5615d747d8
    [junit] tag=30aeb, index=a3e, offset=18
    [junit] Test: DTLB, 33e1a03735736f6
    [junit] tag=1b9ab9, index=0, offset=16f6
    [junit] Test: L1, ffffffffa707e249
    [junit] tag=fa707e, index=12, offset=9
    [junit] Test: L2, 8872db864fded2ec
    [junit] tag=327ef, index=697, offset=c
    [junit] Test: DTLB, ffffffff8464d068
    [junit] tag=7fc2326, index=0, offset=1068
    [junit] Test: L1, e613ab10109233f2
    [junit] tag=10923, index=1f, offset=12
    [junit] Test: L2, ffffffffe8cd5e1c
    [junit] tag=7f466, index=af0, offset=1c
    [junit] Test: DTLB, 25350ac057b1c928
    [junit] tag=602bd8e, index=0, offset=928
    [junit] Test: L1, 9e72aff879280b17
    [junit] tag=879280, index=58, offset=17
    [junit] Test: L2, a1b681165fb80c3d
    [junit] tag=32fdc, index=61, offset=1d
    [junit] Test: DTLB, 9415a19e61dfb26b
    [junit] tag=4f30efd, index=0, offset=126b
    [junit] Test: L1, fffffffffb19ded9
    [junit] tag=ffb19d, index=76, offset=19
    [junit] Test: L2, 761c168a14be59b2
    [junit] tag=50a5f, index=2cd, offset=12
    [junit] Test: DTLB, 614f21b666392cf8
    [junit] tag=5b331c9, index=0, offset=cf8
    [junit] Test: L1, f07dfd2d229cca3e
    [junit] tag=d229cc, index=51, offset=1e
    [junit] Test: L2, a0dcf5c752928e13
    [junit] tag=3a949, index=470, offset=13
    [junit] Test: DTLB, ffffffff92459994
    [junit] tag=7fc922c, index=0, offset=1994
    [junit] Test: L1, a80eb0bb7d6b00cd
    [junit] tag=b7d6b0, index=6, offset=d
    [junit] Test: L2, ffffffff83d360f9
    [junit] tag=7c1e9, index=b07, offset=19
    [junit] Test: DTLB, ffffffffcb186ef9
    [junit] tag=7fe58c3, index=0, offset=ef9
    [junit] Test: L1, f8ba0982430a22a7
    [junit] tag=2430a2, index=15, offset=7
    [junit] Test: L2, c319b177426e3b20
    [junit] tag=3a137, index=1d9, offset=0
    [junit] Test: DTLB, a286b5047df12d27
    [junit] tag=23ef89, index=0, offset=d27
    [junit] Test: L1, ffffffffd6c117f1
    [junit] tag=fd6c11, index=3f, offset=11
    [junit] Test: L2, ffffffff862cef76
    [junit] tag=7c316, index=77b, offset=16
    [junit] Test: DTLB, 3d8f0ac91253c65b
    [junit] tag=648929e, index=0, offset=65b
    [junit] Test: L1, ffffffffe56f4468
    [junit] tag=fe56f4, index=23, offset=8
    [junit] Test: L2, 4bb5583745e6184d
    [junit] tag=3a2f3, index=c2, offset=d
    [junit] Test: DTLB, ffffffffbf968697
    [junit] tag=7fdfcb4, index=0, offset=697
    [junit] Test: L1, ffffffffe6999057
    [junit] tag=fe6999, index=2, offset=17
    [junit] Test: L2, ffffffffbb4d6a9f
    [junit] tag=7dda6, index=b54, offset=1f
    [junit] Test: DTLB, 4983e6c9214557e0
    [junit] tag=6490a2a, index=0, offset=17e0
    [junit] Test: L1, ffffffffa306fc52
    [junit] tag=fa306f, index=62, offset=12
    [junit] Test: L2, b7f9e1050bde8821
    [junit] tag=285ef, index=441, offset=1
    [junit] Test: DTLB, b9555918470ee027
    [junit] tag=c23877, index=0, offset=27
    [junit] Test: L1, d489d96d7470c7f9
    [junit] tag=d7470c, index=3f, offset=19
    [junit] Test: L2, 17cfc8f02a87ac58
    [junit] tag=1543, index=d62, offset=18
    [junit] Test: DTLB, ffffffff827924f8
    [junit] tag=7fc13c9, index=0, offset=4f8
    [junit] Test: L1, 50dad3622d0fd69e
    [junit] tag=22d0fd, index=34, offset=1e
    [junit] Test: L2, ffffffffdcf66b3b
    [junit] tag=7ee7b, index=359, offset=1b
    [junit] Test: DTLB, 6d43011930a7a4e1
    [junit] tag=c9853d, index=0, offset=4e1
    [junit] Test: L1, ffffffffd2a72387
    [junit] tag=fd2a72, index=1c, offset=7
    [junit] Test: L2, ffffffffe40f7845
    [junit] tag=7f207, index=bc2, offset=5
    [junit] Test: DTLB, e516f4f8713c5233
    [junit] tag=7c389e2, index=0, offset=1233
    [junit] Test: L1, ffffffffc9043c49
    [junit] tag=fc9043, index=62, offset=9
    [junit] Test: L2, 256ca0462bd42b33
    [junit] tag=315ea, index=159, offset=13
    [junit] Test: DTLB, d420e92169a39743
    [junit] tag=10b4d1c, index=0, offset=1743
    [junit] Test: L1, fffffffff43ac82f
    [junit] tag=ff43ac, index=41, offset=f
    [junit] Test: L2, cb32fdbf27e5ff83
    [junit] tag=793f2, index=ffc, offset=3
    [junit] Test: DTLB, ffffffffe440e9f4
    [junit] tag=7ff2207, index=0, offset=9f4
    [junit] Test: L1, 1cdff5d95b1bcd1a
    [junit] tag=95b1bc, index=68, offset=1a
    [junit] Test: L2, fffffffff10e6cd5
    [junit] tag=7f887, index=366, offset=15
    [junit] Test: DTLB, e72b11c36b5863e9
    [junit] tag=61b5ac3, index=0, offset=3e9
    [junit] Test: L1, d96ab41b0390a98b
    [junit] tag=b0390a, index=4c, offset=b
    [junit] Test: L2, 8ce6545d7faa905c
    [junit] tag=6bfd5, index=482, offset=1c
    [junit] Test: DTLB, ffffffffc8e7f456
    [junit] tag=7fe473f, index=0, offset=1456
    [junit] Test: L1, 3cab4e40622bbd16
    [junit] tag=622bb, index=68, offset=16
    [junit] Test: L2, ca14f0ec2bbf28fd
    [junit] tag=615df, index=947, offset=1d
    [junit] Test: DTLB, 597b436b60261d08
    [junit] tag=35b0130, index=0, offset=1d08
    [junit] Test: L1, 1773276d4863ef34
    [junit] tag=d4863e, index=79, offset=14
    [junit] Test: L2, 77d9f9e55fe7e49c
    [junit] tag=2aff3, index=f24, offset=1c
    [junit] Test: DTLB, ffffffff94fea08c
    [junit] tag=7fca7f5, index=0, offset=8c
    [junit] Test: L1, ffffffffeea18ca3
    [junit] tag=feea18, index=65, offset=3
    [junit] Test: L2, ffffffff855f95cd
    [junit] tag=7c2af, index=cae, offset=d
    [junit] Test: DTLB, ffffffffcccc8db6
    [junit] tag=7fe6664, index=0, offset=db6
    [junit] Test: L1, 69f0e89756ca28b5
    [junit] tag=756ca2, index=45, offset=15
    [junit] Test: L2, fffffffff7f36ab7
    [junit] tag=7fbf9, index=b55, offset=17
    [junit] Test: DTLB, 89a5512875283fbb
    [junit] tag=143a941, index=0, offset=1fbb
    [junit] Test: L1, 740a262115920ac3
    [junit] tag=115920, index=56, offset=3
    [junit] Test: L2, ffffffffb9b627e2
    [junit] tag=7dcdb, index=13f, offset=2
    [junit] Test: DTLB, 6dea8aec4d30db43
    [junit] tag=7626986, index=0, offset=1b43
    [junit] Test: L1, ffffffffd1ed660a
    [junit] tag=fd1ed6, index=30, offset=a
    [junit] Test: L2, 8dd73f961a553fc5
    [junit] tag=30d2a, index=9fe, offset=5
    [junit] Test: DTLB, 99f2dd5448d3b95c
    [junit] tag=2a2469d, index=0, offset=195c
    [junit] Test: L1, 4eed3b6e390ebf3c
    [junit] tag=e390eb, index=79, offset=1c
    [junit] Test: L2, ffffffffc9a35013
    [junit] tag=7e4d1, index=a80, offset=13
    [junit] Test: DTLB, f305a81d1448acb7
    [junit] tag=e8a245, index=0, offset=cb7
    [junit] Test: L1, 53116eb472da355
    [junit] tag=b472da, index=1a, offset=15
    [junit] Test: L2, 3adbdfdc58c172c4
    [junit] tag=62c60, index=b96, offset=4
    [junit] Test: DTLB, 97b4b5ac7c7f0596
    [junit] tag=563e3f8, index=0, offset=596
    [junit] Test: L1, ffffffffc2e55efe
    [junit] tag=fc2e55, index=77, offset=1e
    [junit] Test: L2, 92bfaaa02b0fcaa
    [junit] tag=50158, index=7e5, offset=a
    [junit] Test: DTLB, ffffffff90ed85f4
    [junit] tag=7fc876c, index=0, offset=5f4
    [junit] Test: L1, ffffffffaf1de7f6
    [junit] tag=faf1de, index=3f, offset=16
    [junit] Test: L2, ffffffffe1ffb4e1
    [junit] tag=7f0ff, index=da7, offset=1
    [junit] Test: DTLB, 94008659001748d3
    [junit] tag=2c800ba, index=0, offset=8d3
    [junit] Test: L1, ffffffffdcc1e789
    [junit] tag=fdcc1e, index=3c, offset=9
    [junit] Test: L2, ffffffff8df959bc
    [junit] tag=7c6fc, index=acd, offset=1c
    [junit] Test: DTLB, 623c1db874197a89
    [junit] tag=5c3a0cb, index=0, offset=1a89
    [junit] Test: L1, 99a297a72efb1720
    [junit] tag=72efb1, index=39, offset=0
    [junit] Test: L2, d035ce4b324e4e85
    [junit] tag=59927, index=274, offset=5
    [junit] Test: DTLB, cc24fa11cacbaec
    [junit] tag=508e565, index=0, offset=1aec
    [junit] Test: L1, ffffffffeaf7a9d1
    [junit] tag=feaf7a, index=4e, offset=11
    [junit] Test: L2, ffffffffd5f42228
    [junit] tag=7eafa, index=111, offset=8
    [junit] Test: DTLB, ffffffff96c85ca3
    [junit] tag=7fcb642, index=0, offset=1ca3
    [junit] Test: L1, ffffffffb90c1fba
    [junit] tag=fb90c1, index=7d, offset=1a
    [junit] Test: L2, ffffffffdb3c99fc
    [junit] tag=7ed9e, index=4cf, offset=1c
    [junit] Test: DTLB, ffffffffa48953df
    [junit] tag=7fd244a, index=0, offset=13df
    [junit] Test: L1, ffffffffe268dad9
    [junit] tag=fe268d, index=56, offset=19
    [junit] Test: L2, 21fe50de1bca1961
    [junit] tag=70de5, index=cb, offset=1
    [junit] Test: DTLB, 7c17513d1b9a5ad5
    [junit] tag=1e8dcd2, index=0, offset=1ad5
    [junit] Test: L1, ffffffffbfee0cd2
    [junit] tag=fbfee0, index=66, offset=12
    [junit] Test: L2, 76211e637f1b4a1
    [junit] tag=31bf8, index=da5, offset=1
    [junit] Test: DTLB, c72113b01fd0d220
    [junit] tag=580fe86, index=0, offset=1220
    [junit] Test: L1, 404386af694dd698
    [junit] tag=f694dd, index=34, offset=18
    [junit] Test: L2, 760f6abb0a01534c
    [junit] tag=58500, index=a9a, offset=c
    [junit] Test: DTLB, ffffffffbe279947
    [junit] tag=7fdf13c, index=0, offset=1947
    [junit] Test: L1, ffffffffafde8b7c
    [junit] tag=fafde8, index=5b, offset=1c
    [junit] Test: L2, dfa469607012252e
    [junit] tag=3809, index=129, offset=e
    [junit] Test: DTLB, 8ebb9ec1568a6d73
    [junit] tag=60ab453, index=0, offset=d73
    [junit] Test: L1, 62017234583fc29f
    [junit] tag=4583fc, index=14, offset=1f
    [junit] Test: L2, ffffffffc3189881
    [junit] tag=7e18c, index=4c4, offset=1
    [junit] Test: DTLB, 6bc7e4a6698ee4ba
    [junit] tag=5334c77, index=0, offset=4ba
    [junit] Test: L1, ffffffffe9a5ec8c
    [junit] tag=fe9a5e, index=64, offset=c
    [junit] Test: L2, ffffffffe7c1ce39
    [junit] tag=7f3e0, index=e71, offset=19
    [junit] Test: DTLB, ffffffffba8d66e8
    [junit] tag=7fdd46b, index=0, offset=6e8
    [junit] Test: L1, cbd9d163036d2cfa
    [junit] tag=3036d2, index=67, offset=1a
    [junit] Test: L2, b573ec673e6a7913
    [junit] tag=39f35, index=3c8, offset=13
    [junit] Test: DTLB, ffffffffa3a24958
    [junit] tag=7fd1d12, index=0, offset=958
    [junit] Test: L1, bbafeee62af47977
    [junit] tag=62af47, index=4b, offset=17
    [junit] Test: L2, 333980700d267754
    [junit] tag=693, index=3ba, offset=14
    [junit] Test: DTLB, ffffffffe2b6abb9
    [junit] tag=7ff15b5, index=0, offset=bb9
    [junit] Test: L1, d849df8b2140c65c
    [junit] tag=b2140c, index=32, offset=1c
    [junit] Test: L2, 748355d26272563
    [junit] tag=69313, index=92b, offset=3
    [junit] Test: DTLB, ffffffffa90d4240
    [junit] tag=7fd486a, index=0, offset=240
    [junit] Test: L1, 59835894d386a9c
    [junit] tag=94d386, index=54, offset=1c
    [junit] Test: L2, 15d7d86705e812e7
    [junit] tag=382f4, index=97, offset=7
    [junit] Test: DTLB, ffffffffbee4d4ad
    [junit] tag=7fdf726, index=0, offset=14ad
    [junit] Test: L1, ffffffffe54b3a69
    [junit] tag=fe54b3, index=53, offset=9
    [junit] Test: L2, ffffffffd0c80f95
    [junit] tag=7e864, index=7c, offset=15
    [junit] Test: DTLB, 3f407cdc60c1aa17
    [junit] tag=6e3060d, index=0, offset=a17
    [junit] Test: L1, ffffffffa9731356
    [junit] tag=fa9731, index=1a, offset=16
    [junit] Test: L2, fffffffff515ed9b
    [junit] tag=7fa8a, index=f6c, offset=1b
    [junit] Test: DTLB, ffffffffb1a84aab
    [junit] tag=7fd8d42, index=0, offset=aab
    [junit] Test: L1, 5a3df0c261b5c96a
    [junit] tag=261b5c, index=4b, offset=a
    [junit] Test: L2, ffffffffd77d1486
    [junit] tag=7ebbe, index=8a4, offset=6
    [junit] Test: DTLB, ffffffffd2b4d481
    [junit] tag=7fe95a6, index=0, offset=1481
    [junit] Test: L1, ffffffffb51a8da8
    [junit] tag=fb51a8, index=6d, offset=8
    [junit] Test: L2, ffffffffd094c3fe
    [junit] tag=7e84a, index=61f, offset=1e
    [junit] Test: DTLB, 676df9c522def073
    [junit] tag=62916f7, index=0, offset=1073
    [junit] Test: L1, ffffffffbbdad8fe
    [junit] tag=fbbdad, index=47, offset=1e
    [junit] Test: L2, ffffffff8b6e75f3
    [junit] tag=7c5b7, index=3af, offset=13
    [junit] Test: DTLB, fffffffff3891ec6
    [junit] tag=7ff9c48, index=0, offset=1ec6
    [junit] Test: L1, fffffffff548a239
    [junit] tag=ff548a, index=11, offset=19
    [junit] Test: L2, ffffffff8269f162
    [junit] tag=7c134, index=f8b, offset=2
    [junit] Test: DTLB, ffffffffad188ebe
    [junit] tag=7fd68c4, index=0, offset=ebe
    [junit] Test: L1, e9c41a9e29699d94
    [junit] tag=e29699, index=6c, offset=14
    [junit] Test: L2, ffffffffea238c4e
    [junit] tag=7f511, index=c62, offset=e
    [junit] Test: DTLB, ce722493296a09d9
    [junit] tag=4994b50, index=0, offset=9d9
    [junit] Test: L1, 519bc8700ac2cd37
    [junit] tag=ac2c, index=69, offset=17
    [junit] Test: L2, c59047795a54929f
    [junit] tag=4ad2a, index=494, offset=1f
    [junit] Test: DTLB, fffffffffd778dc5
    [junit] tag=7ffebbc, index=0, offset=dc5
    [junit] Test: L1, f643a75d75f29547
    [junit] tag=d75f29, index=2a, offset=7
    [junit] Test: L2, ffffffff88a4540a
    [junit] tag=7c452, index=2a0, offset=a
    [junit] Test: DTLB, bd1be7301507f582
    [junit] tag=180a83f, index=0, offset=1582
    [junit] Test: L1, 5fc9852f0a74ec28
    [junit] tag=f0a74e, index=61, offset=8
    [junit] Test: L2, ffffffff9fea7933
    [junit] tag=7cff5, index=3c9, offset=13
    [junit] Test: DTLB, e2ee98e04c5831de
    [junit] tag=70262c1, index=0, offset=11de
    [junit] Test: L1, 488fb78548f8a3ee
    [junit] tag=548f8a, index=1f, offset=e
    [junit] Test: L2, ffffffffb047d6e6
    [junit] tag=7d823, index=eb7, offset=6
    [junit] Test: DTLB, fb49b7663a868d3a
    [junit] tag=331d434, index=0, offset=d3a
    [junit] Test: L1, c214071b4ca895bd
    [junit] tag=b4ca89, index=2d, offset=1d
    [junit] Test: L2, ac0e8af71dc1733f
    [junit] tag=38ee0, index=b99, offset=1f
    [junit] Test: DTLB, 77a8d8191841bf85
    [junit] tag=c8c20d, index=0, offset=1f85
    [junit] Test: L1, c59c18ce069dbc9e
    [junit] tag=e069db, index=64, offset=1e
    [junit] Test: L2, ffffffffb45fe508
    [junit] tag=7da2f, index=f28, offset=8
    [junit] Test: DTLB, ffffffffbdb5f3df
    [junit] tag=7fdedaf, index=0, offset=13df
    [junit] Test: L1, 2c3117b213291e65
    [junit] tag=213291, index=73, offset=5
    [junit] Test: L2, fffffffffc1ac5fb
    [junit] tag=7fe0d, index=62f, offset=1b
    [junit] Test: DTLB, ffffffffdaaa2637
    [junit] tag=7fed551, index=0, offset=637
    [junit] Test: L1, ffffffffa38d5e40
    [junit] tag=fa38d5, index=72, offset=0
    [junit] Test: L2, ffffffffbcc00d7b
    [junit] tag=7de60, index=6b, offset=1b
    [junit] Test: DTLB, fffffffff8a53ce1
    [junit] tag=7ffc529, index=0, offset=1ce1
    [junit] Test: L1, f57d84993c536b1f
    [junit] tag=93c536, index=58, offset=1f
    [junit] Test: L2, 9ce76c2f7bfa2a5b
    [junit] tag=7bdfd, index=152, offset=1b
    [junit] Test: DTLB, 7bccd4af2e919068
    [junit] tag=579748c, index=0, offset=1068
    [junit] Test: L1, dc0601134e618f26
    [junit] tag=34e618, index=79, offset=6
    [junit] Test: L2, fffffffff1caadf1
    [junit] tag=7f8e5, index=56f, offset=11
    [junit] Test: DTLB, ffffffffdc1a36aa
    [junit] tag=7fee0d1, index=0, offset=16aa
    [junit] Test: L1, a92491f70299d732
    [junit] tag=70299d, index=39, offset=12
    [junit] Test: L2, c31a862b421c3b04
    [junit] tag=5a10e, index=1d8, offset=4
    [junit] Test: DTLB, ffffffff928c0147
    [junit] tag=7fc9460, index=0, offset=147
    [junit] Test: L1, ffffffffeb42c59f
    [junit] tag=feb42c, index=2c, offset=1f
    [junit] Test: L2, a6cdcdfe370ef77d
    [junit] tag=71b87, index=7bb, offset=1d
    [junit] Test: DTLB, ffffffffdf0467c0
    [junit] tag=7fef823, index=0, offset=7c0
    [junit] Test: L1, 671fd6ff4d503a97
    [junit] tag=f4d503, index=54, offset=17
    [junit] Test: L2, fffffffff78c3460
    [junit] tag=7fbc6, index=1a3, offset=0
    [junit] Test: DTLB, a86a915024802d1
    [junit] tag=a81240, index=0, offset=2d1
    [junit] Test: L1, d69d94047c1c94f1
    [junit] tag=47c1c9, index=27, offset=11
    [junit] Test: L2, ffffffffbdc01ac0
    [junit] tag=7dee0, index=d6, offset=0
    [junit] Test: DTLB, ffffffff906e51f3
    [junit] tag=7fc8372, index=0, offset=11f3
    [junit] Test: L1, ffffffffca3ca388
    [junit] tag=fca3ca, index=1c, offset=8
    [junit] Test: L2, 4b7cd2702dfb7dd8
    [junit] tag=16fd, index=bee, offset=18
    [junit] Test: DTLB, 55f5cf9c43066258
    [junit] tag=4e21833, index=0, offset=258
    [junit] Test: L1, f57e06973755b149
    [junit] tag=73755b, index=a, offset=9
    [junit] Test: L2, 11fc42076d959479
    [junit] tag=3b6ca, index=ca3, offset=19
    [junit] Test: DTLB, ffffffffa600c633
    [junit] tag=7fd3006, index=0, offset=633
    [junit] Test: L1, ffffffffebda93ea
    [junit] tag=febda9, index=1f, offset=a
    [junit] Test: L2, 59ce102d10f555e1
    [junit] tag=6887a, index=aaf, offset=1
    [junit] Test: DTLB, ffffffffd16f25b4
    [junit] tag=7fe8b79, index=0, offset=5b4
    [junit] Test: L1, 1bfbe9e561130f9a
    [junit] tag=561130, index=7c, offset=1a
    [junit] Test: L2, ffffffffd0a331bb
    [junit] tag=7e851, index=98d, offset=1b
    [junit] Test: DTLB, ffffffffdd7d7b32
    [junit] tag=7feebeb, index=0, offset=1b32
    [junit] Test: L1, ffffffff8e0ba2b6
    [junit] tag=f8e0ba, index=15, offset=16
    [junit] Test: L2, ffffffff92b7c1e4
    [junit] tag=7c95b, index=e0f, offset=4
    [junit] Test: DTLB, 87bee1ed7e4d530b
    [junit] tag=76bf26a, index=0, offset=130b
    [junit] Test: L1, 1394302172706254
    [junit] tag=172706, index=12, offset=14
    [junit] Test: L2, ffffffff98ec3f80
    [junit] tag=7cc76, index=1fc, offset=0
    [junit] Test: DTLB, ffffffff81a0a2e7
    [junit] tag=7fc0d05, index=0, offset=2e7
    [junit] Test: L1, ffffffffa2a6f6da
    [junit] tag=fa2a6f, index=36, offset=1a
    [junit] Test: L2, ffffffff9f276797
    [junit] tag=7cf93, index=b3c, offset=17
    [junit] Test: DTLB, ffffffffceb8719a
    [junit] tag=7fe75c3, index=0, offset=119a
    [junit] Test: L1, fffffffffe3ae621
    [junit] tag=ffe3ae, index=31, offset=1
    [junit] Test: L2, 396b07e60ca2ed78
    [junit] tag=30651, index=76b, offset=18
    [junit] Test: DTLB, ffffffffad08ae22
    [junit] tag=7fd6845, index=0, offset=e22
    [junit] Test: L1, 3a8a4c3847e9d39e
    [junit] tag=847e9d, index=1c, offset=1e
    [junit] Test: L2, ffffffffcb397fa4
    [junit] tag=7e59c, index=bfd, offset=4
    [junit] Test: DTLB, 35fd9cfc58f317fa
    [junit] tag=7e2c798, index=0, offset=17fa
    [junit] Test: L1, ffffffffd5ac41a4
    [junit] tag=fd5ac4, index=d, offset=4
    [junit] Test: L2, fffffffff1615c30
    [junit] tag=7f8b0, index=ae1, offset=10
    [junit] Test: DTLB, 33774d9c3b1e9af3
    [junit] tag=4e1d8f4, index=0, offset=1af3
    [junit] Test: L1, ffffffffda245031
    [junit] tag=fda245, index=1, offset=11
    [junit] Test: L2, 7d2c83d17d8bd9b1
    [junit] tag=bec5, index=ecd, offset=11
    [junit] Test: DTLB, fffffffffd5482f6
    [junit] tag=7ffeaa4, index=0, offset=2f6
    [junit] Test: L1, fbeb08bf53a096cf
    [junit] tag=f53a09, index=36, offset=f
    [junit] Test: L2, ffffffffaa6c24d5
    [junit] tag=7d536, index=126, offset=15
    [junit] Test: DTLB, 75bada6e3bc2f252
    [junit] tag=371de17, index=0, offset=1252
    [junit] Test: L1, 9ffda8fc53c13943
    [junit] tag=c53c13, index=4a, offset=3
    [junit] Test: L2, 76b718a47f0e1c37
    [junit] tag=23f87, index=e1, offset=17
    [junit] Test: DTLB, ffffffffb5433fef
    [junit] tag=7fdaa19, index=0, offset=1fef
    [junit] Test: L1, eaf559615c86147b
    [junit] tag=15c861, index=23, offset=1b
    [junit] Test: L2, 4ac4f30a504ee719
    [junit] tag=52827, index=738, offset=19
    [junit] Test: DTLB, ffffffffbbd05d08
    [junit] tag=7fdde82, index=0, offset=1d08
    [junit] Test: L1, ffffffffc6f04012
    [junit] tag=fc6f04, index=0, offset=12
    [junit] Test: L2, 7f83af8574a5997a
    [junit] tag=2ba52, index=ccb, offset=1a
    [junit] Test: DTLB, bef5dc25772d5a66
    [junit] tag=12bb96a, index=0, offset=1a66
    [junit] Test: L1, fffffffffb79460f
    [junit] tag=ffb794, index=30, offset=f
    [junit] Test: L2, ffffffff8ffccacd
    [junit] tag=7c7fe, index=656, offset=d
    [junit] Test: DTLB, ffffffffd979b3f6
    [junit] tag=7fecbcd, index=0, offset=13f6
    [junit] Test: L1, ffffffffdf2ee467
    [junit] tag=fdf2ee, index=23, offset=7
    [junit] Test: L2, 706aa5843da4eb11
    [junit] tag=21ed2, index=758, offset=11
    [junit] Test: DTLB, ffffffffd73cec37
    [junit] tag=7feb9e7, index=0, offset=c37
    [junit] Test: L1, ffffffff9b005823
    [junit] tag=f9b005, index=41, offset=3
    [junit] Test: L2, 14d526b06d951a7f
    [junit] tag=36ca, index=8d3, offset=1f
    [junit] Test: DTLB, ffffffffeddd39e4
    [junit] tag=7ff6ee9, index=0, offset=19e4
    [junit] Test: L1, ffffffffaf7a6fed
    [junit] tag=faf7a6, index=7f, offset=d
    [junit] Test: L2, 4559222904396b5e
    [junit] tag=4821c, index=b5a, offset=1e
    [junit] Test: DTLB, 8e1b31f5223a09ea
    [junit] tag=7a911d0, index=0, offset=9ea
    [junit] Test: L1, ffffffffcf34b787
    [junit] tag=fcf34b, index=3c, offset=7
    [junit] Test: L2, ffffffffed8fcf0e
    [junit] tag=7f6c7, index=e78, offset=e
    [junit] Test: DTLB, fffffffff4785cec
    [junit] tag=7ffa3c2, index=0, offset=1cec
    [junit] Test: L1, ffffffffda357cc6
    [junit] tag=fda357, index=66, offset=6
    [junit] Test: L2, ffffffffef1a8e09
    [junit] tag=7f78d, index=470, offset=9
    [junit] Test: DTLB, 7f1f5db09862a35
    [junit] tag=6d84c31, index=0, offset=a35
    [junit] Test: L1, 6aed794c332a4087
    [junit] tag=c332a4, index=4, offset=7
    [junit] Test: L2, fffffffff65cfdb7
    [junit] tag=7fb2e, index=7ed, offset=17
    [junit] Test: DTLB, ffffffffc0d8e12a
    [junit] tag=7fe06c7, index=0, offset=12a
    [junit] Test: L1, ffffffffb378888d
    [junit] tag=fb3788, index=44, offset=d
    [junit] Test: L2, abdd2a2f731266c0
    [junit] tag=7b989, index=336, offset=0
    [junit] Test: DTLB, ffffffff83e59db6
    [junit] tag=7fc1f2c, index=0, offset=1db6
    [junit] Test: L1, 15a12dc15a65280a
    [junit] tag=15a652, index=40, offset=a
    [junit] Test: L2, ffffffff8d1bff73
    [junit] tag=7c68d, index=ffb, offset=13
    [junit] Test: DTLB, ffffffffb7723811
    [junit] tag=7fdbb91, index=0, offset=1811
    [junit] Test: L1, ffffffffad90d690
    [junit] tag=fad90d, index=34, offset=10
    [junit] Test: L2, 9c22d14a3ac5c3da
    [junit] tag=51d62, index=e1e, offset=1a
    [junit] Test: DTLB, ffffffffd3e23839
    [junit] tag=7fe9f11, index=0, offset=1839
    [junit] Test: L1, ffffffffecf32dc0
    [junit] tag=fecf32, index=6e, offset=0
    [junit] Test: L2, 96be27b279e7a7cb
    [junit] tag=13cf3, index=d3e, offset=b
    [junit] Test: DTLB, 456b8cc2625d1e0
    [junit] tag=661312e, index=0, offset=11e0
    [junit] Test: L1, 7ed203d673436278
    [junit] tag=673436, index=13, offset=18
    [junit] Test: L2, ffffffffa6fd3dd0
    [junit] tag=7d37e, index=9ee, offset=10
    [junit] Test: DTLB, ee55fd195843e551
    [junit] tag=cac21f, index=0, offset=551
    [junit] Test: L1, 27ec0e24250d7097
    [junit] tag=4250d7, index=4, offset=17
    [junit] Test: L2, ffffffffc626c1cf
    [junit] tag=7e313, index=60e, offset=f
    [junit] Test: DTLB, ffffffffe99d785d
    [junit] tag=7ff4ceb, index=0, offset=185d
    [junit] Test: L1, 458afa902001e5c9
    [junit] tag=2001e, index=2e, offset=9
    [junit] Test: L2, ffffffff81394abd
    [junit] tag=7c09c, index=a55, offset=1d
    [junit] Test: DTLB, 6516ca1d07cf4576
    [junit] tag=e83e7a, index=0, offset=576
    [junit] Test: L1, cff798421fcc0d10
    [junit] tag=21fcc0, index=68, offset=10
    [junit] Test: L2, 788738fc1f5e5609
    [junit] tag=60faf, index=2b0, offset=9
    [junit] Test: DTLB, 673826443f9fe79b
    [junit] tag=221fcff, index=0, offset=79b
    [junit] Test: L1, 6ed4396b692085c4
    [junit] tag=b69208, index=2e, offset=4
    [junit] Test: L2, fffffffffd891c26
    [junit] tag=7fec4, index=8e1, offset=6
    [junit] Test: DTLB, f986e35f4b7fa664
    [junit] tag=2fa5bfd, index=0, offset=664
    [junit] Test: L1, ffffffffb317fcb6
    [junit] tag=fb317f, index=65, offset=16
    [junit] Test: L2, 9334cdf67b467e9e
    [junit] tag=33da3, index=3f4, offset=1e
    [junit] Test: DTLB, 76ac1cc86a45dac3
    [junit] tag=643522e, index=0, offset=1ac3
    [junit] Test: L1, c228d71d1ce25a0a
    [junit] tag=d1ce25, index=50, offset=a
    [junit] Test: L2, 4b54eabb058494b1
    [junit] tag=582c2, index=4a5, offset=11
    [junit] Test: DTLB, ffffffff987e2704
    [junit] tag=7fcc3f1, index=0, offset=704
    [junit] Test: L1, ffffffffa0e01699
    [junit] tag=fa0e01, index=34, offset=19
    [junit] Test: L2, ca172fec3dd80933
    [junit] tag=61eec, index=49, offset=13
    [junit] Test: DTLB, b51de17a371130b2
    [junit] tag=3d1b889, index=0, offset=10b2
    [junit] Test: L1, 7cd273333fb3cbee
    [junit] tag=33fb3c, index=5f, offset=e
    [junit] Test: L2, ffffffffa2335090
    [junit] tag=7d119, index=a84, offset=10
    [junit] Test: DTLB, 67ae9a2a7cc67a6b
    [junit] tag=153e633, index=0, offset=1a6b
    [junit] Test: L1, 3488e7ae3bfa7d0c
    [junit] tag=e3bfa7, index=68, offset=c
    [junit] Test: L2, ffffffffb3ac6c44
    [junit] tag=7d9d6, index=362, offset=4
    [junit] Test: DTLB, ffffffffd89e14cb
    [junit] tag=7fec4f0, index=0, offset=14cb
    [junit] Test: L1, 6a6cddf212f24856
    [junit] tag=212f24, index=42, offset=16
    [junit] Test: L2, 56c07bd12f284399
    [junit] tag=9794, index=21c, offset=19
    [junit] Test: DTLB, ac2a295275806e0c
    [junit] tag=293ac03, index=0, offset=e0c
    [junit] Test: L1, ffffffffad2a2de9
    [junit] tag=fad2a2, index=6f, offset=9
    [junit] Test: L2, ffffffff809e0cff
    [junit] tag=7c04f, index=67, offset=1f
    [junit] Test: DTLB, ffffffffbe3d8f6a
    [junit] tag=7fdf1ec, index=0, offset=f6a
    [junit] Test: L1, ba85163d0c43c363
    [junit] tag=d0c43c, index=1b, offset=3
    [junit] Test: L2, ffffffff96b829cb
    [junit] tag=7cb5c, index=14e, offset=b
    [junit] Test: DTLB, ffffffffe5922ba3
    [junit] tag=7ff2c91, index=0, offset=ba3
    [junit] Test: L1, ffffffffaae6b4da
    [junit] tag=faae6b, index=26, offset=1a
    [junit] Test: L2, ffffffff97d13380
    [junit] tag=7cbe8, index=99c, offset=0
    [junit] Test: DTLB, ffffffffdf17126a
    [junit] tag=7fef8b8, index=0, offset=126a
    [junit] Test: L1, 5ecc967207239d8c
    [junit] tag=207239, index=6c, offset=c
    [junit] Test: L2, c1d466836c4c8dc7
    [junit] tag=1b626, index=46e, offset=7
    [junit] Test: DTLB, ffffffffe0fd935c
    [junit] tag=7ff07ec, index=0, offset=135c
    [junit] Test: L1, ffffffffab52d56a
    [junit] tag=fab52d, index=2b, offset=a
    [junit] Test: L2, 815185563f7bffba
    [junit] tag=31fbd, index=ffd, offset=1a
    [junit] Test: DTLB, 6a4646774830a3f5
    [junit] tag=3ba4185, index=0, offset=3f5
    [junit] Test: L1, 5f97590956a80ef1
    [junit] tag=956a80, index=77, offset=11
    [junit] Test: L2, cb0264ad5c93d9ff
    [junit] tag=6ae49, index=ecf, offset=1f
    [junit] Test: DTLB, 95255d4153b1b549
    [junit] tag=20a9d8d, index=0, offset=1549
    [junit] Test: L1, a30b8b46253b86d9
    [junit] tag=6253b8, index=36, offset=19
    [junit] Test: L2, ffffffffee0a979c
    [junit] tag=7f705, index=4bc, offset=1c
    [junit] Test: DTLB, 2d751cd55481b5b4
    [junit] tag=6aaa40d, index=0, offset=15b4
    [junit] Test: L1, 9d9a81e94ae775e2
    [junit] tag=94ae77, index=2f, offset=2
    [junit] Test: L2, ffffffffeb4e7b64
    [junit] tag=7f5a7, index=3db, offset=4
    [junit] Test: DTLB, ffffffff94acf073
    [junit] tag=7fca567, index=0, offset=1073
    [junit] Test: L1, 89d2258911d5e774
    [junit] tag=911d5e, index=3b, offset=14
    [junit] Test: L2, ffffffff8907632f
    [junit] tag=7c483, index=b19, offset=f
    [junit] Test: DTLB, b5ae02541cda8d87
    [junit] tag=2a0e6d4, index=0, offset=d87
    [junit] Test: L1, ffffffffc87de6e4
    [junit] tag=fc87de, index=37, offset=4
    [junit] Test: L2, ffffffffdea07bfb
    [junit] tag=7ef50, index=3df, offset=1b
    [junit] Test: DTLB, ffffffff8fca7c64
    [junit] tag=7fc7e53, index=0, offset=1c64
    [junit] Test: L1, ffffffffef519dd6
    [junit] tag=fef519, index=6e, offset=16
    [junit] Test: L2, ffffffffc8f865ab
    [junit] tag=7e47c, index=32d, offset=b
    [junit] Test: DTLB, f5ad4c102f13b04a
    [junit] tag=81789d, index=0, offset=104a
    [junit] Test: L1, ffffffff997a156e
    [junit] tag=f997a1, index=2b, offset=e
    [junit] Test: L2, ffffffff80d0e534
    [junit] tag=7c068, index=729, offset=14
    [junit] Test: DTLB, a283eaa7566f3f68
    [junit] tag=53ab379, index=0, offset=1f68
    [junit] Test: L1, 4ac31f3f43066fed
    [junit] tag=f43066, index=7f, offset=d
    [junit] Test: L2, 74c17d334e6d01a9
    [junit] tag=1a736, index=80d, offset=9
    [junit] Test: DTLB, ffffffffefc73467
    [junit] tag=7ff7e39, index=0, offset=1467
    [junit] Test: L1, 41169a98776f179e
    [junit] tag=8776f1, index=3c, offset=1e
    [junit] Test: L2, ffffffffc4f20919
    [junit] tag=7e279, index=48, offset=19
    [junit] Test: DTLB, ffffffffd97babd3
    [junit] tag=7fecbdd, index=0, offset=bd3
    [junit] Test: L1, ffffffff88e43c5e
    [junit] tag=f88e43, index=62, offset=1e
    [junit] Test: L2, 53f907ba1c7acad4
    [junit] tag=50e3d, index=656, offset=14
    [junit] Test: DTLB, ffffffffa2ed130b
    [junit] tag=7fd1768, index=0, offset=130b
    [junit] Test: L1, 3fa81ffd1c409614
    [junit] tag=d1c409, index=30, offset=14
    [junit] Test: L2, ffffffff89b12dee
    [junit] tag=7c4d8, index=96f, offset=e
    [junit] Test: DTLB, 3952a2750e5d994
    [junit] tag=13a872e, index=0, offset=1994
    [junit] Test: L1, ffffffffde9ba506
    [junit] tag=fde9ba, index=28, offset=6
    [junit] Test: L2, ffffffff8d0acf77
    [junit] tag=7c685, index=67b, offset=17
    [junit] Test: DTLB, ffffffffc1bce18f
    [junit] tag=7fe0de7, index=0, offset=18f
    [junit] Test: L1, ffffffff9e3d1d16
    [junit] tag=f9e3d1, index=68, offset=16
    [junit] Test: L2, 2ef43a3a57954ca5
    [junit] tag=52bca, index=a65, offset=5
    [junit] Test: DTLB, ffffffff9352687b
    [junit] tag=7fc9a93, index=0, offset=87b
    [junit] Test: L1, 8aa821042b2eab5b
    [junit] tag=42b2ea, index=5a, offset=1b
    [junit] Test: L2, 74743cce548ac9e9
    [junit] tag=72a45, index=64f, offset=9
    [junit] Test: DTLB, ffffffffb8c5c9eb
    [junit] tag=7fdc62e, index=0, offset=9eb
    [junit] Test: L1, ffffffffd2a1acac
    [junit] tag=fd2a1a, index=65, offset=c
    [junit] Test: L2, ffffffff92d0023b
    [junit] tag=7c968, index=11, offset=1b
    [junit] Test: DTLB, ffffffffa330ae8c
    [junit] tag=7fd1985, index=0, offset=e8c
    [junit] Test: L1, ffffffff8a830809
    [junit] tag=f8a830, index=40, offset=9
    [junit] Test: L2, ffffffff9fba1623
    [junit] tag=7cfdd, index=b1, offset=3
    [junit] Test: DTLB, b74c9bfe232b1e26
    [junit] tag=7f11958, index=0, offset=1e26
    [junit] Test: L1, ffffffffcc0a3de5
    [junit] tag=fcc0a3, index=6f, offset=5
    [junit] Test: L2, ffffffff9c4a095c
    [junit] tag=7ce25, index=4a, offset=1c
    [junit] Test: DTLB, 737a1015718bdcb5
    [junit] tag=ab8c5e, index=0, offset=1cb5
    [junit] Test: L1, 5376d6a33635e177
    [junit] tag=33635e, index=b, offset=17
    [junit] Test: L2, 7fc744d0063f1bcb
    [junit] tag=31f, index=8de, offset=b
    [junit] Test: DTLB, ffffffffe85e7605
    [junit] tag=7ff42f3, index=0, offset=1605
    [junit] Test: L1, ffffffffc6d27071
    [junit] tag=fc6d27, index=3, offset=11
    [junit] Test: L2, ffffffffeea70365
    [junit] tag=7f753, index=81b, offset=5
    [junit] Test: DTLB, ad5fc351633e5dc2
    [junit] tag=28b19f2, index=0, offset=1dc2
    [junit] Test: L1, e74023730afb006e
    [junit] tag=30afb0, index=3, offset=e
    [junit] Test: L2, ffffffffd468ecf8
    [junit] tag=7ea34, index=767, offset=18
    [junit] Test: DTLB, ffffffff9ee0205c
    [junit] tag=7fcf701, index=0, offset=5c
    [junit] Test: L1, ffffffffae789b6b
    [junit] tag=fae789, index=5b, offset=b
    [junit] Test: L2, d4c2f47949ac0de4
    [junit] tag=4a4d6, index=6f, offset=4
    [junit] Test: DTLB, ffffffff8323454f
    [junit] tag=7fc191a, index=0, offset=54f
    [junit] Test: L1, 9687f67a22104e25
    [junit] tag=a22104, index=71, offset=5
    [junit] Test: L2, 918438a220c71df1
    [junit] tag=11063, index=8ef, offset=11
    [junit] Test: DTLB, ffffffffb1819bc9
    [junit] tag=7fd8c0c, index=0, offset=1bc9
    [junit] Test: L1, 9c6bdfd9486a110d
    [junit] tag=9486a1, index=8, offset=d
    [junit] Test: L2, f43fd31b77ad633b
    [junit] tag=5bbd6, index=b19, offset=1b
    [junit] Test: DTLB, 8bd21a6e256cced7
    [junit] tag=3712b66, index=0, offset=ed7
    [junit] Test: L1, ffffffff9a872cc2
    [junit] tag=f9a872, index=66, offset=2
    [junit] Test: L2, ffffffff91f85d5b
    [junit] tag=7c8fc, index=2ea, offset=1b
    [junit] Test: DTLB, ffffffffaffee3da
    [junit] tag=7fd7ff7, index=0, offset=3da
    [junit] Test: L1, a92e333a5beabb4b
    [junit] tag=a5beab, index=5a, offset=b
    [junit] Test: L2, ffffffff82446143
    [junit] tag=7c122, index=30a, offset=3
    [junit] Test: DTLB, 88cdf7037b91646d
    [junit] tag=1bdc8b, index=0, offset=46d
    [junit] Test: L1, f36ad40b05625043
    [junit] tag=b05625, index=2, offset=3
    [junit] Test: L2, 6e97f49a0e91275c
    [junit] tag=50748, index=93a, offset=1c
    [junit] Test: DTLB, ffffffffcd08bac2
    [junit] tag=7fe6845, index=0, offset=1ac2
    [junit] Test: L1, ffffffff8fc4c258
    [junit] tag=f8fc4c, index=12, offset=18
    [junit] Test: L2, fffffffff7b5a1af
    [junit] tag=7fbda, index=d0d, offset=f
    [junit] Test: DTLB, fffffffff7906ead
    [junit] tag=7ffbc83, index=0, offset=ead
    [junit] Test: L1, ffffffffe8e4dc84
    [junit] tag=fe8e4d, index=64, offset=4
    [junit] Test: L2, 88d39f2c156b8313
    [junit] tag=60ab5, index=c18, offset=13
    [junit] Test: DTLB, ffffffffd85ce07b
    [junit] tag=7fec2e7, index=0, offset=7b
    [junit] Test: L1, ffffffffb2a7ffce
    [junit] tag=fb2a7f, index=7e, offset=e
    [junit] Test: L2, 7f5b4453196c3095
    [junit] tag=18cb6, index=184, offset=15
    [junit] Test: DTLB, 5564e17761bba071
    [junit] tag=3bb0ddd, index=0, offset=71
    [junit] Test: L1, d0774cf346884015
    [junit] tag=346884, index=0, offset=15
    [junit] Test: L2, 5cd2a4d153ee32c5
    [junit] tag=a9f7, index=196, offset=5
    [junit] Test: DTLB, ffffffffdde6e9e2
    [junit] tag=7feef37, index=0, offset=9e2
    [junit] Test: L1, 1b44780124dafcc2
    [junit] tag=124daf, index=66, offset=2
    [junit] Test: L2, ffffffffa55f7b44
    [junit] tag=7d2af, index=bda, offset=4
    [junit] Test: DTLB, ef341f260f113b63
    [junit] tag=1307889, index=0, offset=1b63
    [junit] Test: L1, ffffffffad8cfad5
    [junit] tag=fad8cf, index=56, offset=15
    [junit] Test: L2, c00ffc1920ab702e
    [junit] tag=49055, index=b81, offset=e
    [junit] Test: DTLB, d609a17f40026a8c
    [junit] tag=3fa0013, index=0, offset=a8c
    [junit] Test: L1, ffffffff9b5d325c
    [junit] tag=f9b5d3, index=12, offset=1c
    [junit] Test: L2, 1bd069bd62a424b8
    [junit] tag=6b152, index=125, offset=18
    [junit] Test: DTLB, ffffffff9ca822b8
    [junit] tag=7fce541, index=0, offset=2b8
    [junit] Test: L1, ffffffffd4a6b31f
    [junit] tag=fd4a6b, index=18, offset=1f
    [junit] Test: L2, 7b2fedbb6d6eb1c6
    [junit] tag=5b6b7, index=58e, offset=6
    [junit] Test: DTLB, 7a30cbdd64e4f165
    [junit] tag=6eb2727, index=0, offset=1165
    [junit] Test: L1, ffffffffd567e059
    [junit] tag=fd567e, index=2, offset=19
    [junit] Test: L2, 2fcbf81617a744ce
    [junit] tag=30bd3, index=a26, offset=e
    [junit] Test: DTLB, 1e6d27a63508ecf5
    [junit] tag=531a847, index=0, offset=cf5
    [junit] Test: L1, afa646fd102325bb
    [junit] tag=d10232, index=2d, offset=1b
    [junit] Test: L2, 58cafaa117a4426c
    [junit] tag=8bd2, index=213, offset=c
    [junit] Test: DTLB, d8661f2e5a77a9d9
    [junit] tag=172d3bd, index=0, offset=9d9
    [junit] Test: L1, fffffffff146fa1a
    [junit] tag=ff146f, index=50, offset=1a
    [junit] Test: L2, ffffffffe6117b77
    [junit] tag=7f308, index=bdb, offset=17
    [junit] Test: DTLB, 51e8f3254c4ce47c
    [junit] tag=12a6267, index=0, offset=47c
    [junit] Test: L1, 12d5517311369d06
    [junit] tag=311369, index=68, offset=6
    [junit] Test: L2, bfc7edf10daa769d
    [junit] tag=86d5, index=3b4, offset=1d
    [junit] Test: DTLB, ffffffff914b97d0
    [junit] tag=7fc8a5c, index=0, offset=17d0
    [junit] Test: L1, fffffffffcef7498
    [junit] tag=ffcef7, index=24, offset=18
    [junit] Test: L2, ffffffffb453a9b3
    [junit] tag=7da29, index=d4d, offset=13
    [junit] Test: DTLB, ffffffffc57b076f
    [junit] tag=7fe2bd8, index=0, offset=76f
    [junit] Test: L1, ffffffffb6ff3d8c
    [junit] tag=fb6ff3, index=6c, offset=c
    [junit] Test: L2, ac0df9a669858dae
    [junit] tag=334c2, index=c6d, offset=e
    [junit] Test: DTLB, ffffffffb3a3626e
    [junit] tag=7fd9d1b, index=0, offset=26e
    [junit] Test: L1, aa540be552a0d5c9
    [junit] tag=552a0d, index=2e, offset=9
    [junit] Test: L2, 5f538aa22a6d7ddc
    [junit] tag=11536, index=bee, offset=1c
    [junit] Test: DTLB, ffffffff82d244fb
    [junit] tag=7fc1692, index=0, offset=4fb
    [junit] Test: L1, 554ee4777062ff27
    [junit] tag=77062f, index=79, offset=7
    [junit] Test: L2, a3a42c6409dee61e
    [junit] tag=204ef, index=730, offset=1e
    [junit] Test: DTLB, ca692fb951ecbf81
    [junit] tag=5ca8f65, index=0, offset=1f81
    [junit] Test: L1, fffffffff365fa50
    [junit] tag=ff365f, index=52, offset=10
    [junit] Test: L2, ffffffffb5635fee
    [junit] tag=7dab1, index=aff, offset=e
    [junit] Test: DTLB, ed0b85b406be5410
    [junit] tag=5a035f2, index=0, offset=1410
    [junit] Test: L1, ffffffff941c4bb2
    [junit] tag=f941c4, index=5d, offset=12
    [junit] Test: L2, 7399d92b5e55e280
    [junit] tag=5af2a, index=f14, offset=0
    [junit] Test: DTLB, ffffffffab0482c0
    [junit] tag=7fd5824, index=0, offset=2c0
    [junit] Test: L1, fffffffff3060aca
    [junit] tag=ff3060, index=56, offset=a
    [junit] Test: L2, a94e64e96f5c7314
    [junit] tag=4b7ae, index=398, offset=14
    [junit] Test: DTLB, 4d39fd765a2c4415
    [junit] tag=3b2d162, index=0, offset=415
    [junit] Test: L1, ffffffffc50bcc39
    [junit] tag=fc50bc, index=61, offset=19
    [junit] Test: L2, ffffffffd4ee36da
    [junit] tag=7ea77, index=1b6, offset=1a
    [junit] Test: DTLB, 206e4ba403c52ce6
    [junit] tag=5201e29, index=0, offset=ce6
    [junit] Test: L1, 35a6fbd341736ee3
    [junit] tag=341736, index=77, offset=3
    [junit] Test: L2, 965cbaeb716a69fa
    [junit] tag=5b8b5, index=34f, offset=1a
    [junit] Test: DTLB, 1f973161617741d1
    [junit] tag=30b0bba, index=0, offset=1d1
    [junit] Test: L1, ffffffff92767589
    [junit] tag=f92767, index=2c, offset=9
    [junit] Test: L2, 73059d8675b67e82
    [junit] tag=33adb, index=3f4, offset=2
    [junit] Test: DTLB, ffffffffd0878866
    [junit] tag=7fe843c, index=0, offset=866
    [junit] Test: L1, 6fe9564d42cae804
    [junit] tag=d42cae, index=40, offset=4
    [junit] Test: L2, ffffffffbee80452
    [junit] tag=7df74, index=22, offset=12
    [junit] Test: DTLB, ffffffffcbe32e2e
    [junit] tag=7fe5f19, index=0, offset=e2e
    [junit] Test: L1, a9e428f272e9db5e
    [junit] tag=272e9d, index=5a, offset=1e
    [junit] Test: L2, ffffffffb2635068
    [junit] tag=7d931, index=a83, offset=8
    [junit] Test: DTLB, ce0095e872c8adec
    [junit] tag=7439645, index=0, offset=dec
    [junit] Test: L1, aa8d74862c0c536a
    [junit] tag=62c0c5, index=1b, offset=a
    [junit] Test: L2, 1ef3bb4a168abc12
    [junit] tag=50b45, index=5e0, offset=12
    [junit] Test: DTLB, ffffffffa6e5921a
    [junit] tag=7fd372c, index=0, offset=121a
    [junit] Test: L1, 32ce1c833df81318
    [junit] tag=33df81, index=18, offset=18
    [junit] Test: L2, 7e7f936e441f1d9f
    [junit] tag=7220f, index=8ec, offset=1f
    [junit] Test: DTLB, 73643f54349c07de
    [junit] tag=2a1a4e0, index=0, offset=7de
    [junit] Test: L1, ffffffffb3988ad6
    [junit] tag=fb3988, index=56, offset=16
    [junit] Test: L2, ffffffff8d305fb9
    [junit] tag=7c698, index=2fd, offset=19
    [junit] Test: DTLB, 7399a18448103b3e
    [junit] tag=4224081, index=0, offset=1b3e
    [junit] Test: L1, c5afebdd75741a78
    [junit] tag=d75741, index=53, offset=18
    [junit] Test: L2, ffffffff8b13db80
    [junit] tag=7c589, index=edc, offset=0
    [junit] Test: DTLB, df5d993c0d90ab5a
    [junit] tag=1e06c85, index=0, offset=b5a
    [junit] Test: L1, fa1f08f2d02d9f6
    [junit] tag=f2d02d, index=4f, offset=16
    [junit] Test: L2, a75792ef2094c6ec
    [junit] tag=7904a, index=637, offset=c
    [junit] Test: DTLB, d4a7ff55597229d2
    [junit] tag=2aacb91, index=0, offset=9d2
    [junit] Test: L1, fffffffffb1767cb
    [junit] tag=ffb176, index=3e, offset=b
    [junit] Test: L2, e2f8e81132395b4a
    [junit] tag=991c, index=ada, offset=a
    [junit] Test: DTLB, fdfb8d4e2538d4b7
    [junit] tag=27129c6, index=0, offset=14b7
    [junit] Test: L1, c20a45ba14d73658
    [junit] tag=a14d73, index=32, offset=18
    [junit] Test: L2, ffffffffd036ba2b
    [junit] tag=7e81b, index=5d1, offset=b
    [junit] Test: DTLB, ffffffffd0551564
    [junit] tag=7fe82a8, index=0, offset=1564
    [junit] Test: L1, ffffffffe9774ccd
    [junit] tag=fe9774, index=66, offset=d
    [junit] Test: L2, ffffffffab2b1e35
    [junit] tag=7d595, index=8f1, offset=15
    [junit] Test: DTLB, 19479d2620e36976
    [junit] tag=131071b, index=0, offset=976
    [junit] Test: L1, dc0c3f5d73e222eb
    [junit] tag=d73e22, index=17, offset=b
    [junit] Test: L2, ffffffff8f361557
    [junit] tag=7c79b, index=aa, offset=17
    [junit] Test: DTLB, ffffffff81757fea
    [junit] tag=7fc0bab, index=0, offset=1fea
    [junit] Test: L1, ffffffffae8498c9
    [junit] tag=fae849, index=46, offset=9
    [junit] Test: L2, ffffffff983997ff
    [junit] tag=7cc1c, index=cbf, offset=1f
    [junit] Test: DTLB, ffffffff9aec838d
    [junit] tag=7fcd764, index=0, offset=38d
    [junit] Test: L1, 59555f602bf1014b
    [junit] tag=2bf10, index=a, offset=b
    [junit] Test: L2, ffffffff96a0d945
    [junit] tag=7cb50, index=6ca, offset=5
    [junit] Test: DTLB, 635b3e96d1905fb
    [junit] tag=74b68c8, index=0, offset=5fb
    [junit] Test: L1, 596250444f94ce82
    [junit] tag=44f94c, index=74, offset=2
    [junit] Test: L2, 8036704e555f914b
    [junit] tag=72aaf, index=c8a, offset=b
    [junit] Test: DTLB, e977e9e329988ee
    [junit] tag=4f194cc, index=0, offset=8ee
    [junit] Test: L1, 84f4745e714584a4
    [junit] tag=e71458, index=25, offset=4
    [junit] Test: L2, ab3ed2b130efbed0
    [junit] tag=9877, index=df6, offset=10
    [junit] Test: DTLB, 2fee8db4541bdab1
    [junit] tag=5a2a0de, index=0, offset=1ab1
    [junit] Test: L1, b04f091f7e6c8ffc
    [junit] tag=f7e6c8, index=7f, offset=1c
    [junit] Test: L2, dc3257cd45583b0e
    [junit] tag=6a2ac, index=1d8, offset=e
    [junit] Test: DTLB, aabf07104e400442
    [junit] tag=827200, index=0, offset=442
    [junit] Test: L1, ffffffffccbac87c
    [junit] tag=fccbac, index=43, offset=1c
    [junit] Test: L2, d9ddb0475bcbc3da
    [junit] tag=3ade5, index=e1e, offset=1a
    [junit] Test: DTLB, d5f28c5e6f258745
    [junit] tag=2f3792c, index=0, offset=745
    [junit] Test: L1, ffffffff8d86020f
    [junit] tag=f8d860, index=10, offset=f
    [junit] Test: L2, 7d9dbeae31d2365f
    [junit] tag=718e9, index=1b2, offset=1f
    [junit] Test: DTLB, ffffffffa8e6225b
    [junit] tag=7fd4731, index=0, offset=25b
    [junit] Test: L1, ffffffffe699f0eb
    [junit] tag=fe699f, index=7, offset=b
    [junit] Test: L2, c0b8979e21a2c9d0
    [junit] tag=710d1, index=64e, offset=10
    [junit] Test: DTLB, 58c38cc947ac3b9f
    [junit] tag=64a3d61, index=0, offset=1b9f
    [junit] Test: L1, ffffffffd3f9a818
    [junit] tag=fd3f9a, index=40, offset=18
    [junit] Test: L2, ffffffff8f1e2dbe
    [junit] tag=7c78f, index=16d, offset=1e
    [junit] Test: DTLB, 7b771c432c0e6e8a
    [junit] tag=2196073, index=0, offset=e8a
    [junit] Test: L1, ffffffffce5a2a70
    [junit] tag=fce5a2, index=53, offset=10
    [junit] Test: L2, a8c6cb846cdb6a01
    [junit] tag=2366d, index=b50, offset=1
    [junit] Test: DTLB, ffffffffe37ec060
    [junit] tag=7ff1bf6, index=0, offset=60
    [junit] Test: L1, 148628ec23ebf9fb
    [junit] tag=c23ebf, index=4f, offset=1b
    [junit] Test: L2, 89979bb92f927aee
    [junit] tag=497c9, index=3d7, offset=e
    [junit] Test: DTLB, 59419fd159aef544
    [junit] tag=68acd77, index=0, offset=1544
    [junit] Test: L1, f6ce0ca1690a207b
    [junit] tag=1690a2, index=3, offset=1b
    [junit] Test: L2, ffffffffa2f0be6a
    [junit] tag=7d178, index=5f3, offset=a
    [junit] Test: DTLB, 7463131c46c0bb3d
    [junit] tag=e23605, index=0, offset=1b3d
    [junit] Test: L1, ffffffffb2fdb5fe
    [junit] tag=fb2fdb, index=2f, offset=1e
    [junit] Test: L2, 81ed5d03a4072eb
    [junit] tag=1d20, index=397, offset=b
    [junit] Test: DTLB, b877df927d21dd56
    [junit] tag=493e90e, index=0, offset=1d56
    [junit] Test: L1, c45153ec618d1cd3
    [junit] tag=c618d1, index=66, offset=13
    [junit] Test: L2, b25f3c34327fc35
    [junit] tag=1a193, index=fe1, offset=15
    [junit] Test: DTLB, ffffffffdd3d4110
    [junit] tag=7fee9ea, index=0, offset=110
    [junit] Test: L1, ffffffffbffbba3c
    [junit] tag=fbffbb, index=51, offset=1c
    [junit] Test: L2, d4e0a13569b43565
    [junit] tag=2b4da, index=1ab, offset=5
    [junit] Test: DTLB, ffffffffb3a3c1f2
    [junit] tag=7fd9d1e, index=0, offset=1f2
    [junit] Test: L1, ffffffff92cb4c51
    [junit] tag=f92cb4, index=62, offset=11
    [junit] Test: L2, 34ba4b7a36177c54
    [junit] tag=51b0b, index=be2, offset=14
    [junit] Test: DTLB, cb30c2fe61a3fa91
    [junit] tag=7f30d1f, index=0, offset=1a91
    [junit] Test: L1, 1a9ee88d0a2c9f30
    [junit] tag=d0a2c9, index=79, offset=10
    [junit] Test: L2, fffffffffe9804e8
    [junit] tag=7ff4c, index=27, offset=8
    [junit] Test: DTLB, eeb8902616e62112
    [junit] tag=130b731, index=0, offset=112
    [junit] Test: L1, ffffffffd2f95abb
    [junit] tag=fd2f95, index=55, offset=1b
    [junit] Test: L2, cf1bca4b067ee501
    [junit] tag=5833f, index=728, offset=1
    [junit] Test: DTLB, 99be24891da65d5e
    [junit] tag=448ed32, index=0, offset=1d5e
    [junit] Test: L1, a9dcfb9f0271087f
    [junit] tag=f02710, index=43, offset=1f
    [junit] Test: L2, a3be8acd328e36a0
    [junit] tag=69947, index=1b5, offset=0
    [junit] Test: DTLB, ffffffffef94e05f
    [junit] tag=7ff7ca7, index=0, offset=5f
    [junit] Test: L1, ffffffff87cb3d85
    [junit] tag=f87cb3, index=6c, offset=5
    [junit] Test: L2, ee95626575ae938d
    [junit] tag=2bad7, index=49c, offset=d
    [junit] Test: DTLB, 7a431fc02a659ace
    [junit] tag=601532c, index=0, offset=1ace
    [junit] Test: L1, ffffffffb9616070
    [junit] tag=fb9616, index=3, offset=10
    [junit] Test: L2, ffffffffed7dcdff
    [junit] tag=7f6be, index=e6f, offset=1f
    [junit] Test: DTLB, ffffffff9901140e
    [junit] tag=7fcc808, index=0, offset=140e
    [junit] Test: L1, c763130b3452b059
    [junit] tag=b3452b, index=2, offset=19
    [junit] Test: L2, 6b19d595069fff30
    [junit] tag=2834f, index=ff9, offset=10
    [junit] Test: DTLB, ffffffff95b97c24
    [junit] tag=7fcadcb, index=0, offset=1c24
    [junit] Test: L1, ffffffffc2202f4b
    [junit] tag=fc2202, index=7a, offset=b
    [junit] Test: L2, fffffffffc73c0e3
    [junit] tag=7fe39, index=e07, offset=3
    [junit] Test: DTLB, ad7effdc61c0590d
    [junit] tag=6e30e02, index=0, offset=190d
    [junit] Test: L1, ffffffffda0130fa
    [junit] tag=fda013, index=7, offset=1a
    [junit] Test: L2, af5ca8a168cbf289
    [junit] tag=b465, index=f94, offset=9
    [junit] Test: DTLB, ffffffff82a2cce9
    [junit] tag=7fc1516, index=0, offset=ce9
    [junit] Test: L1, ffffffffc68554b5
    [junit] tag=fc6855, index=25, offset=15
    [junit] Test: L2, ffffffffc9b6707d
    [junit] tag=7e4db, index=383, offset=1d
    [junit] Test: DTLB, ffffffffb252372c
    [junit] tag=7fd9291, index=0, offset=172c
    [junit] Test: L1, 264e17e8563038ea
    [junit] tag=856303, index=47, offset=a
    [junit] Test: L2, fffffffffc18f53e
    [junit] tag=7fe0c, index=7a9, offset=1e
    [junit] Test: DTLB, 1db6767b44f3ccce
    [junit] tag=3da279e, index=0, offset=cce
    [junit] Test: L1, fcd94b8242428f36
    [junit] tag=242428, index=79, offset=16
    [junit] Test: L2, d2d5f62a2fd7f976
    [junit] tag=517eb, index=fcb, offset=16
    [junit] Test: DTLB, ffffffffeb31cbb6
    [junit] tag=7ff598e, index=0, offset=bb6
    [junit] Test: L1, fffffffff1533b54
    [junit] tag=ff1533, index=5a, offset=14
    [junit] Test: L2, ad16a0b81a73757a
    [junit] tag=40d39, index=bab, offset=1a
    [junit] Test: DTLB, ffffffffa8a328b0
    [junit] tag=7fd4519, index=0, offset=8b0
    [junit] Test: L1, ce58597153ce8a0e
    [junit] tag=153ce8, index=50, offset=e
    [junit] Test: L2, ffffffffe6decee6
    [junit] tag=7f36f, index=677, offset=6
    [junit] Test: DTLB, f2b94d2f35f75714
    [junit] tag=179afba, index=0, offset=1714
    [junit] Test: L1, ffffffffe1455edf
    [junit] tag=fe1455, index=76, offset=1f
    [junit] Test: L2, 19843b5500d34737
    [junit] tag=28069, index=a39, offset=17
    [junit] Test: DTLB, c0b670820aae174d
    [junit] tag=4105570, index=0, offset=174d
    [junit] Test: L1, 9fcfe9f419e58cdd
    [junit] tag=419e58, index=66, offset=1d
    [junit] Test: L2, ffffffff8041e38f
    [junit] tag=7c020, index=f1c, offset=f
    [junit] Test: DTLB, ffffffffec1c3dc9
    [junit] tag=7ff60e1, index=0, offset=1dc9
    [junit] Test: L1, 22a200830598dae8
    [junit] tag=30598d, index=57, offset=8
    [junit] Test: L2, ffffffff8e1feb75
    [junit] tag=7c70f, index=f5b, offset=15
    [junit] Test: DTLB, fffffffffd029014
    [junit] tag=7ffe814, index=0, offset=1014
    [junit] Test: L1, ffffffffeb15784b
    [junit] tag=feb157, index=42, offset=b
    [junit] Test: L2, ffffffff8601df0a
    [junit] tag=7c300, index=ef8, offset=a
    [junit] Test: DTLB, fbe14ae04f03a888
    [junit] tag=702781d, index=0, offset=888
    [junit] Test: L1, ffffffff870b0a39
    [junit] tag=f870b0, index=51, offset=19
    [junit] Test: L2, ffffffffdeb6c7b8
    [junit] tag=7ef5b, index=63d, offset=18
    [junit] Test: DTLB, 96ce0c360b37d2f
    [junit] tag=61b059b, index=0, offset=1d2f
    [junit] Test: L1, ffffffffb315bb35
    [junit] tag=fb315b, index=59, offset=15
    [junit] Test: L2, ffffffffb2e148c0
    [junit] tag=7d970, index=a46, offset=0
    [junit] Test: DTLB, 56e2ecc32f56b20c
    [junit] tag=6197ab5, index=0, offset=120c
    [junit] Test: L1, e22df558377fb136
    [junit] tag=8377fb, index=9, offset=16
    [junit] Test: L2, ffffffffa845fb1b
    [junit] tag=7d422, index=fd8, offset=1b
    [junit] Test: DTLB, fffffffff74aed48
    [junit] tag=7ffba57, index=0, offset=d48
    [junit] Test: L1, 73d6f65f1f0d9415
    [junit] tag=f1f0d9, index=20, offset=15
    [junit] Test: L2, fffffffff1093cf2
    [junit] tag=7f884, index=9e7, offset=12
    [junit] Test: DTLB, ffffffffacac308d
    [junit] tag=7fd6561, index=0, offset=108d
    [junit] Test: L1, b9a970a64547c349
    [junit] tag=64547c, index=1a, offset=9
    [junit] Test: L2, 674544fc5547977e
    [junit] tag=62aa3, index=cbb, offset=1e
    [junit] Test: DTLB, ef81f5e97df5ee7e
    [junit] tag=74befaf, index=0, offset=e7e
    [junit] Test: L1, 37aaf3af3dee77d7
    [junit] tag=f3dee7, index=3e, offset=17
    [junit] Test: L2, b753c6645aecf3b4
    [junit] tag=22d76, index=79d, offset=14
    [junit] Test: DTLB, ffffffff9a2fa28a
    [junit] tag=7fcd17d, index=0, offset=28a
    [junit] Test: L1, e47de195660f98ce
    [junit] tag=5660f9, index=46, offset=e
    [junit] Test: L2, e00340c5736eab36
    [junit] tag=2b9b7, index=559, offset=16
    [junit] Test: DTLB, ffffffffe510f435
    [junit] tag=7ff2887, index=0, offset=1435
    [junit] Test: L1, ffffffffcba38d98
    [junit] tag=fcba38, index=6c, offset=18
    [junit] Test: L2, ffffffffa7fc40a4
    [junit] tag=7d3fe, index=205, offset=4
    [junit] Test: DTLB, ffffffffe02bb620
    [junit] tag=7ff015d, index=0, offset=1620
    [junit] Test: L1, ffffffffed5ea79b
    [junit] tag=fed5ea, index=3c, offset=1b
    [junit] Test: L2, c3eba44e4a614fb6
    [junit] tag=72530, index=a7d, offset=16
    [junit] Test: DTLB, 178fd5537dfb5866
    [junit] tag=29befda, index=0, offset=1866
    [junit] Test: L1, ffffffff8aa5d5e9
    [junit] tag=f8aa5d, index=2f, offset=9
    [junit] Test: L2, ffffffff8c32b2a6
    [junit] tag=7c619, index=595, offset=6
    [junit] Test: DTLB, ffffffffe1380dc5
    [junit] tag=7ff09c0, index=0, offset=dc5
    [junit] Test: L1, 9dbd5fc4298035f1
    [junit] tag=429803, index=2f, offset=11
    [junit] Test: L2, 4d794f110d530a23
    [junit] tag=86a9, index=851, offset=3
    [junit] Test: DTLB, 84694f4c51af99bf
    [junit] tag=2628d7c, index=0, offset=19bf
    [junit] Test: L1, 3b5cf87f195537a0
    [junit] tag=f19553, index=3d, offset=0
    [junit] Test: L2, 47a0d15e4324175c
    [junit] tag=72192, index=ba, offset=1c
    [junit] Test: DTLB, ffffffffb2725b6e
    [junit] tag=7fd9392, index=0, offset=1b6e
    [junit] Test: L1, 80af8d2e4927dcba
    [junit] tag=e4927d, index=65, offset=1a
    [junit] Test: L2, fffffffff2c830b1
    [junit] tag=7f964, index=185, offset=11
    [junit] Test: DTLB, ffffffff99600f84
    [junit] tag=7fccb00, index=0, offset=f84
    [junit] Test: L1, 253e6bd3014e048f
    [junit] tag=3014e0, index=24, offset=f
    [junit] Test: L2, ffffffffe7776fb9
    [junit] tag=7f3bb, index=b7d, offset=19
    [junit] Test: DTLB, caeaf7eb1a4ab79d
    [junit] tag=758d255, index=0, offset=179d
    [junit] Test: L1, ffffffffe13ea417
    [junit] tag=fe13ea, index=20, offset=17
    [junit] Test: L2, 8b41874878ff41ca
    [junit] tag=43c7f, index=a0e, offset=a
    [junit] Test: DTLB, 3e9e7a2801f9cdf0
    [junit] tag=1400fce, index=0, offset=df0
    [junit] Test: L1, d6a8072d35e7c914
    [junit] tag=d35e7c, index=48, offset=14
    [junit] Test: L2, 7faa2a6f6323cc79
    [junit] tag=7b191, index=e63, offset=19
    [junit] Test: DTLB, 1d9c2c921d8e7dda
    [junit] tag=490ec73, index=0, offset=1dda
    [junit] Test: L1, ffffffffd7ed1755
    [junit] tag=fd7ed1, index=3a, offset=15
    [junit] Test: L2, ffffffffbde9536d
    [junit] tag=7def4, index=a9b, offset=d
    [junit] Test: DTLB, 5579eab80dbd31e6
    [junit] tag=5c06de9, index=0, offset=11e6
    [junit] Test: L1, ffffffffb5d1db69
    [junit] tag=fb5d1d, index=5b, offset=9
    [junit] Test: L2, ffffffffe27356e7
    [junit] tag=7f139, index=ab7, offset=7
    [junit] Test: DTLB, 9f4d47a570531d30
    [junit] tag=52b8298, index=0, offset=1d30
    [junit] Test: L1, 992fa91868c86ec2
    [junit] tag=868c86, index=76, offset=2
    [junit] Test: L2, 1fa7d9711346f1a2
    [junit] tag=89a3, index=78d, offset=2
    [junit] Test: DTLB, ffffffff8a6a7171
    [junit] tag=7fc5353, index=0, offset=1171
    [junit] Test: L1, 147005a9174475b0
    [junit] tag=917447, index=2d, offset=10
    [junit] Test: L2, d536e4746dd63cde
    [junit] tag=236eb, index=1e6, offset=1e
    [junit] Test: DTLB, ffffffffb83fee2e
    [junit] tag=7fdc1ff, index=0, offset=e2e
    [junit] Test: L1, ffffffffe368cbe4
    [junit] tag=fe368c, index=5f, offset=4
    [junit] Test: L2, bfda96c619b9228e
    [junit] tag=30cdc, index=914, offset=e
    [junit] Test: DTLB, ffffffffca0fbf42
    [junit] tag=7fe507d, index=0, offset=1f42
    [junit] Test: L1, ffffffff8ad1e032
    [junit] tag=f8ad1e, index=1, offset=12
    [junit] Test: L2, ffffffff994981fe
    [junit] tag=7cca4, index=c0f, offset=1e
    [junit] Test: DTLB, ffffffff8cc8be54
    [junit] tag=7fc6645, index=0, offset=1e54
    [junit] Test: L1, ffffffffcbc2031d
    [junit] tag=fcbc20, index=18, offset=1d
    [junit] Test: L2, 14a6224c205125c7
    [junit] tag=61028, index=92e, offset=7
    [junit] Test: DTLB, 462c3f1f41147958
    [junit] tag=fa08a3, index=0, offset=1958
    [junit] Test: L1, ffffffffe774c599
    [junit] tag=fe774c, index=2c, offset=19
    [junit] Test: L2, 54f7802b7d17b221
    [junit] tag=5be8b, index=d91, offset=1
    [junit] Test: DTLB, 2bbe53af7b9f8c7e
    [junit] tag=57bdcfc, index=0, offset=c7e
    [junit] Test: L1, ffffffffcc474bb9
    [junit] tag=fcc474, index=5d, offset=19
    [junit] Test: L2, e18a3f4e41cf1c19
    [junit] tag=720e7, index=8e0, offset=19
    [junit] Test: DTLB, ffffffffcaed9050
    [junit] tag=7fe576c, index=0, offset=1050
    [junit] Test: L1, ffffffffa89d37a8
    [junit] tag=fa89d3, index=3d, offset=8
    [junit] Test: L2, 1789b7f63ac246e9
    [junit] tag=31d61, index=237, offset=9
    [junit] Test: DTLB, ffffffffc74e112c
    [junit] tag=7fe3a70, index=0, offset=112c
    [junit] Test: L1, 907883893575ee44
    [junit] tag=93575e, index=72, offset=4
    [junit] Test: L2, ffffffffe6257977
    [junit] tag=7f312, index=bcb, offset=17
    [junit] Test: DTLB, ffffffffc6a129dd
    [junit] tag=7fe3509, index=0, offset=9dd
    [junit] Test: L1, 765abf3e58b66c81
    [junit] tag=e58b66, index=64, offset=1
    [junit] Test: L2, ffffffff995c4bd2
    [junit] tag=7ccae, index=25e, offset=12
    [junit] Test: DTLB, ffffffffcb3311d8
    [junit] tag=7fe5998, index=0, offset=11d8
    [junit] Test: L1, ffffffffd890c452
    [junit] tag=fd890c, index=22, offset=12
    [junit] Test: L2, ffffffff8ca523cd
    [junit] tag=7c652, index=91e, offset=d
    [junit] Test: DTLB, ec16aa76242ca6bd
    [junit] tag=3b12165, index=0, offset=6bd
    [junit] Test: L1, ffffffff8c889b29
    [junit] tag=f8c889, index=59, offset=9
    [junit] Test: L2, fffffffffd294f27
    [junit] tag=7fe94, index=a79, offset=7
    [junit] Test: DTLB, 80c2e200785bfb58
    [junit] tag=3c2df, index=0, offset=1b58
    [junit] Test: L1, 3ac90acb5e6b9d5c
    [junit] tag=b5e6b9, index=6a, offset=1c
    [junit] Test: L2, 39ab5d4217ee65d4
    [junit] tag=10bf7, index=32e, offset=14
    [junit] Test: DTLB, ffffffffd812256e
    [junit] tag=7fec091, index=0, offset=56e
    [junit] Test: L1, ffffffffdf79143c
    [junit] tag=fdf791, index=21, offset=1c
    [junit] Test: L2, ffffffffa306e97d
    [junit] tag=7d183, index=74b, offset=1d
    [junit] Test: DTLB, ffffffff8d6f0146
    [junit] tag=7fc6b78, index=0, offset=146
    [junit] Test: L1, c76ee2aa61171648
    [junit] tag=a61171, index=32, offset=8
    [junit] Test: L2, ffffffffc99eefdf
    [junit] tag=7e4cf, index=77e, offset=1f
    [junit] Test: DTLB, 893e6433176f14e3
    [junit] tag=198bb78, index=0, offset=14e3
    [junit] Test: L1, 21b28e6b003dbd7a
    [junit] tag=b003db, index=6b, offset=1a
    [junit] Test: L2, 95e607d77491ee29
    [junit] tag=3ba48, index=f71, offset=9
    [junit] Test: DTLB, c692e229709cc8e4
    [junit] tag=14b84e6, index=0, offset=8e4
    [junit] Test: L1, ffffffffee5c2b63
    [junit] tag=fee5c2, index=5b, offset=3
    [junit] Test: L2, ffffffffefe2b1a2
    [junit] tag=7f7f1, index=58d, offset=2
    [junit] Test: DTLB, 61be28642ebc276c
    [junit] tag=32175e1, index=0, offset=76c
    [junit] Test: L1, 397c0ddd45f39294
    [junit] tag=d45f39, index=14, offset=14
    [junit] Test: L2, fffffffffc9f5461
    [junit] tag=7fe4f, index=aa3, offset=1
    [junit] Test: DTLB, 7c9ba57262cce7e8
    [junit] tag=3931667, index=0, offset=7e8
    [junit] Test: L1, 1d39bab70f71a4ad
    [junit] tag=70f71a, index=25, offset=d
    [junit] Test: L2, ffffffffcd865adf
    [junit] tag=7e6c3, index=2d6, offset=1f
    [junit] Test: DTLB, 2edfbb412ea8ceb8
    [junit] tag=2097546, index=0, offset=eb8
    [junit] Test: L1, ffffffff81faa334
    [junit] tag=f81faa, index=19, offset=14
    [junit] Test: L2, ffffffffa6c95a42
    [junit] tag=7d364, index=ad2, offset=2
    [junit] Test: DTLB, ffffffff84aa256e
    [junit] tag=7fc2551, index=0, offset=56e
    [junit] Test: L1, ffffffffb6616773
    [junit] tag=fb6616, index=3b, offset=13
    [junit] Test: L2, fbb179535b001594
    [junit] tag=1ad80, index=ac, offset=14
    [junit] Test: DTLB, 6b491b9f5d553ba4
    [junit] tag=4faeaa9, index=0, offset=1ba4
    [junit] Test: L1, ffffffffb4088fd3
    [junit] tag=fb4088, index=7e, offset=13
    [junit] Test: L2, ffffffffa50236e3
    [junit] tag=7d281, index=1b7, offset=3
    [junit] Test: DTLB, ffffffffc923da63
    [junit] tag=7fe491e, index=0, offset=1a63
    [junit] Test: L1, c705eba90043d77a
    [junit] tag=90043d, index=3b, offset=1a
    [junit] Test: L2, fffffffff9597530
    [junit] tag=7fcac, index=ba9, offset=10
    [junit] Test: DTLB, ffffffffb772ccbf
    [junit] tag=7fdbb96, index=0, offset=cbf
    [junit] Test: L1, 936589f04673418a
    [junit] tag=46734, index=c, offset=a
    [junit] Test: L2, fffffffff13b78ed
    [junit] tag=7f89d, index=bc7, offset=d
    [junit] Test: DTLB, 8f98a6b912480eb9
    [junit] tag=5c89240, index=0, offset=eb9
    [junit] Test: L1, c15e14f67cd176ce
    [junit] tag=67cd17, index=36, offset=e
    [junit] Test: L2, a83b405369ffe42
    [junit] tag=29b4f, index=ff2, offset=2
    [junit] Test: DTLB, ffffffff9661ad7d
    [junit] tag=7fcb30d, index=0, offset=d7d
    [junit] Test: L1, 229b078676e6ad9
    [junit] tag=8676e6, index=56, offset=19
    [junit] Test: L2, 7e6f37831b45c08d
    [junit] tag=18da2, index=e04, offset=d
    [junit] Test: DTLB, 55798ab3b43d7cb
    [junit] tag=559da1e, index=0, offset=17cb
    [junit] Test: L1, 9769835d7926f51b
    [junit] tag=d7926f, index=28, offset=1b
    [junit] Test: L2, ffffffffabc8062c
    [junit] tag=7d5e4, index=31, offset=c
    [junit] Test: DTLB, 9be65c3735992b3d
    [junit] tag=1b9acc9, index=0, offset=b3d
    [junit] Test: L1, f761698847850b35
    [junit] tag=847850, index=59, offset=15
    [junit] Test: L2, 2027e395683733a8
    [junit] tag=2b41b, index=99d, offset=8
    [junit] Test: DTLB, ffffffffa08aaa26
    [junit] tag=7fd0455, index=0, offset=a26
    [junit] Test: L1, ffffffffafdb2770
    [junit] tag=fafdb2, index=3b, offset=10
    [junit] Test: L2, ffffffff857c9e2e
    [junit] tag=7c2be, index=4f1, offset=e
    [junit] Test: DTLB, ffffffffdd75e51b
    [junit] tag=7feebaf, index=0, offset=51b
    [junit] Test: L1, ffffffffae814220
    [junit] tag=fae814, index=11, offset=0
    [junit] Test: L2, 47c02f6e1f345e50
    [junit] tag=70f9a, index=2f2, offset=10
    [junit] Test: DTLB, ffffffffaf8afa4a
    [junit] tag=7fd7c57, index=0, offset=1a4a
    [junit] Test: L1, 21bc4ee125ae26d7
    [junit] tag=125ae2, index=36, offset=17
    [junit] Test: L2, cfce9cd13cc7ddfc
    [junit] tag=9e63, index=eef, offset=1c
    [junit] Test: DTLB, ffffffff8303ee17
    [junit] tag=7fc181f, index=0, offset=e17
    [junit] Test: L1, ffffffff8f8a9f8d
    [junit] tag=f8f8a9, index=7c, offset=d
    [junit] Test: L2, ffffffffef487ffa
    [junit] tag=7f7a4, index=3ff, offset=1a
    [junit] Test: DTLB, ffffffffbe4309e7
    [junit] tag=7fdf218, index=0, offset=9e7
    [junit] Test: L1, 98c9a8490a68a160
    [junit] tag=90a68a, index=b, offset=0
    [junit] Test: L2, d7c3c84f7aa2a436
    [junit] tag=7bd51, index=521, offset=16
    [junit] Test: DTLB, bda705b64c2c43d7
    [junit] tag=5b26162, index=0, offset=3d7
    [junit] Test: L1, 6d9d70db7ac3513e
    [junit] tag=b7ac35, index=9, offset=1e
    [junit] Test: L2, ffffffff83bf1635
    [junit] tag=7c1df, index=8b1, offset=15
    [junit] Test: DTLB, ffffffff9adbb0fd
    [junit] tag=7fcd6dd, index=0, offset=10fd
    [junit] Test: L1, ffffffffefc77253
    [junit] tag=fefc77, index=12, offset=13
    [junit] Test: L2, 3761ebf63d278596
    [junit] tag=31e93, index=c2c, offset=16
    [junit] Test: DTLB, ffffffff807b26ba
    [junit] tag=7fc03d9, index=0, offset=6ba
    [junit] Test: L1, ffffffff962410c2
    [junit] tag=f96241, index=6, offset=2
    [junit] Test: L2, 6902c52d6732aef9
    [junit] tag=6b399, index=577, offset=19
    [junit] Test: DTLB, ffffffffd97b722e
    [junit] tag=7fecbdb, index=0, offset=122e
    [junit] Test: L1, ffffffffdbf7db67
    [junit] tag=fdbf7d, index=5b, offset=7
    [junit] Test: L2, 9fda31344a589e6e
    [junit] tag=2252c, index=4f3, offset=e
    [junit] Test: DTLB, ffffffffb0e7194f
    [junit] tag=7fd8738, index=0, offset=194f
    [junit] Test: L1, ffffffffdb6f57e4
    [junit] tag=fdb6f5, index=3f, offset=4
    [junit] Test: L2, 982a688734270116
    [junit] tag=39a13, index=808, offset=16
    [junit] Test: DTLB, ffffffffa0d737c2
    [junit] tag=7fd06b9, index=0, offset=17c2
    [junit] Test: L1, ffffffffe4896c71
    [junit] tag=fe4896, index=63, offset=11
    [junit] Test: L2, fffffffff522f2a4
    [junit] tag=7fa91, index=795, offset=4
    [junit] Test: DTLB, ffffffffc27d8210
    [junit] tag=7fe13ec, index=0, offset=210
    [junit] Test: L1, ffffffff9290b9ee
    [junit] tag=f9290b, index=4f, offset=e
    [junit] Test: L2, ffffffff977c31d6
    [junit] tag=7cbbe, index=18e, offset=16
    [junit] Test: DTLB, b3cbd2d2381ccc2b
    [junit] tag=691c0e6, index=0, offset=c2b
    [junit] Test: L1, 15d0eda4625949b6
    [junit] tag=462594, index=4d, offset=16
    [junit] Test: L2, ffffffff9a553a49
    [junit] tag=7cd2a, index=9d2, offset=9
    [junit] Test: DTLB, ffffffffed135776
    [junit] tag=7ff689a, index=0, offset=1776
    [junit] Test: L1, 822814cc73653e94
    [junit] tag=c73653, index=74, offset=14
    [junit] Test: L2, ffffffffd9a24ad5
    [junit] tag=7ecd1, index=256, offset=15
    [junit] Test: DTLB, b566403842ae3d93
    [junit] tag=1c21571, index=0, offset=1d93
    [junit] Test: L1, 3f03308f782c15ac
    [junit] tag=f782c1, index=2d, offset=c
    [junit] Test: L2, ffffffffc0f231bb
    [junit] tag=7e079, index=18d, offset=1b
    [junit] Test: DTLB, caf03fac5cc048a5
    [junit] tag=562e602, index=0, offset=8a5
    [junit] Test: L1, ffffffffe5aeff40
    [junit] tag=fe5aef, index=7a, offset=0
    [junit] Test: L2, ffffffffa88495ec
    [junit] tag=7d442, index=4af, offset=c
    [junit] Test: DTLB, 7993eabc72d73af6
    [junit] tag=5e396b9, index=0, offset=1af6
    [junit] Test: L1, 7d6c376e1d88d603
    [junit] tag=e1d88d, index=30, offset=3
    [junit] Test: L2, ffffffffd2dbd112
    [junit] tag=7e96d, index=e88, offset=12
    [junit] Test: DTLB, ffffffff8236552c
    [junit] tag=7fc11b2, index=0, offset=152c
    [junit] Test: L1, ffffffffeebabc1e
    [junit] tag=feebab, index=60, offset=1e
    [junit] Test: L2, 961603497924a8a1
    [junit] tag=4bc92, index=545, offset=1
    [junit] Test: DTLB, ffffffff822e04bc
    [junit] tag=7fc1170, index=0, offset=4bc
    [junit] Test: L1, fffffffff45f2b40
    [junit] tag=ff45f2, index=5a, offset=0
    [junit] Test: L2, ec06e870474f8e09
    [junit] tag=23a7, index=c70, offset=9
    [junit] Test: DTLB, ffffffff92c1f50b
    [junit] tag=7fc960f, index=0, offset=150b
    [junit] Test: L1, c0b846a158fe5118
    [junit] tag=158fe5, index=8, offset=18
    [junit] Test: L2, 9c7792d73725e6a2
    [junit] tag=39b92, index=f35, offset=2
    [junit] Test: DTLB, 4450f7e013621cdc
    [junit] tag=7009b10, index=0, offset=1cdc
    [junit] Test: L1, b2f3abd64c5ec282
    [junit] tag=64c5ec, index=14, offset=2
    [junit] Test: L2, ffffffffb3dcb259
    [junit] tag=7d9ee, index=592, offset=19
    [junit] Test: DTLB, dfe5277134c3bb02
    [junit] tag=389a61d, index=0, offset=1b02
    [junit] Test: L1, 4f512bc804cb51e2
    [junit] tag=804cb5, index=f, offset=2
    [junit] Test: L2, ffffffff89fd36f1
    [junit] tag=7c4fe, index=9b7, offset=11
    [junit] Test: DTLB, 489cad3750da8a87
    [junit] tag=1ba86d4, index=0, offset=a87
    [junit] Test: L1, 9efea5375ff3781c
    [junit] tag=75ff37, index=40, offset=1c
    [junit] Test: L2, c3be35c42b0ec1df
    [junit] tag=21587, index=60e, offset=1f
    [junit] Test: DTLB, 295d506b60262d47
    [junit] tag=35b0131, index=0, offset=d47
    [junit] Test: L1, 8dea32d456fae18f
    [junit] tag=456fae, index=c, offset=f
    [junit] Test: L2, ffffffff93837056
    [junit] tag=7c9c1, index=b82, offset=16
    [junit] Test: DTLB, 87454a2a685e5e60
    [junit] tag=15342f2, index=0, offset=1e60
    [junit] Test: L1, 31054ce267c8c62
    [junit] tag=e267c8, index=63, offset=2
    [junit] Test: L2, ffffffffd346e2f3
    [junit] tag=7e9a3, index=717, offset=13
    [junit] Test: DTLB, 6f2eee4d34b785c2
    [junit] tag=269a5bc, index=0, offset=5c2
    [junit] Test: L1, ffffffffb058e403
    [junit] tag=fb058e, index=20, offset=3
    [junit] Test: L2, ce243762361a0d87
    [junit] tag=11b0d, index=6c, offset=7
    [junit] Test: DTLB, 9945742c0daa9a43
    [junit] tag=1606d54, index=0, offset=1a43
    [junit] Test: L1, ffffffffe9bdb6bd
    [junit] tag=fe9bdb, index=35, offset=1d
    [junit] Test: L2, db7c714545184564
    [junit] tag=2a28c, index=22b, offset=4
    [junit] Test: DTLB, 93d0a83b734ca829
    [junit] tag=1db9a65, index=0, offset=829
    [junit] Test: L1, ffffffffebef8d48
    [junit] tag=febef8, index=6a, offset=8
    [junit] Test: L2, ffffffffa38269a1
    [junit] tag=7d1c1, index=34d, offset=1
    [junit] Test: DTLB, ffffffffb71bd101
    [junit] tag=7fdb8de, index=0, offset=1101
    [junit] Test: L1, ffffffffe2bcd587
    [junit] tag=fe2bcd, index=2c, offset=7
    [junit] Test: L2, fffffffff7bef1e2
    [junit] tag=7fbdf, index=78f, offset=2
    [junit] Test: DTLB, ffffffffb00049fe
    [junit] tag=7fd8002, index=0, offset=9fe
    [junit] Test: L1, 66dc07e262089951
    [junit] tag=262089, index=4a, offset=11
    [junit] Test: L2, fffffffffd10e2ab
    [junit] tag=7fe88, index=715, offset=b
    [junit] Test: DTLB, ffffffffca30c3f4
    [junit] tag=7fe5186, index=0, offset=3f4
    [junit] Test: L1, ef5babcd7d8fd28d
    [junit] tag=d7d8fd, index=14, offset=d
    [junit] Test: L2, ffffffff9b9484c7
    [junit] tag=7cdca, index=426, offset=7
    [junit] Test: DTLB, fffffffff5e1f368
    [junit] tag=7ffaf0f, index=0, offset=1368
    [junit] Test: L1, d6e2e8ef52cf2247
    [junit] tag=f52cf2, index=12, offset=7
    [junit] Test: L2, ffffffffbc681f25
    [junit] tag=7de34, index=f9, offset=5
    [junit] Test: DTLB, 6b2685b65c3a0158
    [junit] tag=5b2e1d0, index=0, offset=158
    [junit] Test: L1, ffffffffa2351c5f
    [junit] tag=fa2351, index=62, offset=1f
    [junit] Test: L2, ffffffffd28738f4
    [junit] tag=7e943, index=9c7, offset=14
    [junit] Test: DTLB, b3d35f341ac50014
    [junit] tag=1a0d628, index=0, offset=14
    [junit] Test: L1, 87b267815f18fe07
    [junit] tag=15f18f, index=70, offset=7
    [junit] Test: L2, 584a40c92bd19437
    [junit] tag=495e8, index=ca1, offset=17
    [junit] Test: DTLB, cdaa487878fbd588
    [junit] tag=3c3c7de, index=0, offset=1588
    [junit] Test: L1, 513e98b4f88350e
    [junit] tag=b4f883, index=28, offset=e
    [junit] Test: L2, ffffffffd4d89b2c
    [junit] tag=7ea6c, index=4d9, offset=c
    [junit] Test: DTLB, 26f3c45b539c61bc
    [junit] tag=2da9ce3, index=0, offset=1bc
    [junit] Test: L1, ffffffffb8d62c8e
    [junit] tag=fb8d62, index=64, offset=e
    [junit] Test: L2, 464f41625bec6a3e
    [junit] tag=12df6, index=351, offset=1e
    [junit] Test: DTLB, fe3fbbde6d9dab1f
    [junit] tag=6f36ced, index=0, offset=b1f
    [junit] Test: L1, ffffffffe35b5ab7
    [junit] tag=fe35b5, index=55, offset=17
    [junit] Test: L2, ac7ba4b63a69aa7a
    [junit] tag=31d34, index=d53, offset=1a
    [junit] Test: DTLB, fff6c94d55f2443f
    [junit] tag=26aaf92, index=0, offset=43f
    [junit] Test: L1, de9cb18611f866a8
    [junit] tag=611f86, index=35, offset=8
    [junit] Test: L2, 8e56baf87252c45e
    [junit] tag=43929, index=622, offset=1e
    [junit] Test: DTLB, 508a86a5b9a8fea
    [junit] tag=352dcd4, index=0, offset=fea
    [junit] Test: L1, 8d3c67e966e45034
    [junit] tag=966e45, index=1, offset=14
    [junit] Test: L2, 7822015252a1e888
    [junit] tag=12950, index=f44, offset=8
    [junit] Test: DTLB, c32221ae74354639
    [junit] tag=573a1aa, index=0, offset=639
    [junit] Test: L1, ffffffff887a7c7f
    [junit] tag=f887a7, index=63, offset=1f
    [junit] Test: L2, 9bdf13632b5db80c
    [junit] tag=195ae, index=dc0, offset=c
    [junit] Test: DTLB, 99e6dcf573ea5fdb
    [junit] tag=7ab9f52, index=0, offset=1fdb
    [junit] Test: L1, ffffffff8b467196
    [junit] tag=f8b467, index=c, offset=16
    [junit] Test: L2, ffffffffb07ed51f
    [junit] tag=7d83f, index=6a8, offset=1f
    [junit] Test: DTLB, ffffffffb990c975
    [junit] tag=7fdcc86, index=0, offset=975
    [junit] Test: L1, ffffffffa18d781c
    [junit] tag=fa18d7, index=40, offset=1c
    [junit] Test: L2, 280a859a0394ff07
    [junit] tag=501ca, index=7f8, offset=7
    [junit] Test: DTLB, 3e98ef6948352f2e
    [junit] tag=34a41a9, index=0, offset=f2e
    [junit] Test: L1, a038e3e46e93f595
    [junit] tag=46e93f, index=2c, offset=15
    [junit] Test: L2, 197a5f310eee69d1
    [junit] tag=8777, index=34e, offset=11
    [junit] Test: DTLB, ffffffffbb87f1a1
    [junit] tag=7fddc3f, index=0, offset=11a1
    [junit] Test: L1, ffffffff9d164362
    [junit] tag=f9d164, index=1b, offset=2
    [junit] Test: L2, ffffffffa0963e52
    [junit] tag=7d04b, index=1f2, offset=12
    [junit] Test: DTLB, 7b29b1293a09763e
    [junit] tag=149d04b, index=0, offset=163e
    [junit] Test: L1, 9eaf604fb263eb
    [junit] tag=4fb26, index=1f, offset=b
    [junit] Test: L2, 7b4d9f231e2997f9
    [junit] tag=18f14, index=cbf, offset=19
    [junit] Test: DTLB, d20ebe47275a964b
    [junit] tag=2393ad4, index=0, offset=164b
    [junit] Test: L1, ffffffffc1182db9
    [junit] tag=fc1182, index=6d, offset=19
    [junit] Test: L2, fffffffffe423779
    [junit] tag=7ff21, index=1bb, offset=19
    [junit] Test: DTLB, f3a63be36fa22622
    [junit] tag=71b7d11, index=0, offset=622
    [junit] Test: L1, ffffffff8ffabc7b
    [junit] tag=f8ffab, index=63, offset=1b
    [junit] Test: L2, 6e42f5787d5132e8
    [junit] tag=43ea8, index=997, offset=8
    [junit] Test: DTLB, 83673186658a9b8e
    [junit] tag=4332c54, index=0, offset=1b8e
    [junit] Test: L1, ffffffff8265e38b
    [junit] tag=f8265e, index=1c, offset=b
    [junit] Test: L2, ffffffffb9b01300
    [junit] tag=7dcd8, index=98, offset=0
    [junit] Test: DTLB, fffffffff729378c
    [junit] tag=7ffb949, index=0, offset=178c
    [junit] Test: L1, fffffffffaa67004
    [junit] tag=ffaa67, index=0, offset=4
    [junit] Test: L2, ced3ddca7842bb64
    [junit] tag=53c21, index=5db, offset=4
    [junit] Test: DTLB, ffffffff924baa5b
    [junit] tag=7fc925d, index=0, offset=a5b
    [junit] Test: L1, dac5e3cf111f9f85
    [junit] tag=f111f9, index=7c, offset=5
    [junit] Test: L2, b08e81fa35cfb47d
    [junit] tag=51ae7, index=da3, offset=1d
    [junit] Test: DTLB, bfc541822e80827b
    [junit] tag=4117404, index=0, offset=27b
    [junit] Test: L1, b419164b0892fcb0
    [junit] tag=b0892f, index=65, offset=10
    [junit] Test: L2, ffffffffad4a970e
    [junit] tag=7d6a5, index=4b8, offset=e
    [junit] Test: DTLB, 875e3a9d51354b27
    [junit] tag=4ea89aa, index=0, offset=b27
    [junit] Test: L1, 13f574d12226fc67
    [junit] tag=12226f, index=63, offset=7
    [junit] Test: L2, e1f479dd50a5f230
    [junit] tag=6a852, index=f91, offset=10
    [junit] Test: DTLB, 3e90419160b6a150
    [junit] tag=48b05b5, index=0, offset=150
    [junit] Test: L1, bd5b776929d732cd
    [junit] tag=929d73, index=16, offset=d
    [junit] Test: L2, ffffffff861dd110
    [junit] tag=7c30e, index=e88, offset=10
    [junit] Test: DTLB, ffffffffc6d1e7d0
    [junit] tag=7fe368f, index=0, offset=7d0
    [junit] Test: L1, dfdc496017610ee5
    [junit] tag=17610, index=77, offset=5
    [junit] Test: L2, ffffffffb19104d4
    [junit] tag=7d8c8, index=826, offset=14
    [junit] Test: DTLB, ffffffff8c8740c2
    [junit] tag=7fc643a, index=0, offset=c2
    [junit] Test: L1, ffffffffdb6f7468
    [junit] tag=fdb6f7, index=23, offset=8
    [junit] Test: L2, cfeba79c739cdeff
    [junit] tag=639ce, index=6f7, offset=1f
    [junit] Test: DTLB, ffffffffa0cf4f82
    [junit] tag=7fd067a, index=0, offset=f82
    [junit] Test: L1, ffffffff97e723bd
    [junit] tag=f97e72, index=1d, offset=1d
    [junit] Test: L2, 65fab45f6d250d08
    [junit] tag=7b692, index=868, offset=8
    [junit] Test: DTLB, ffffffffe4398f72
    [junit] tag=7ff21cc, index=0, offset=f72
    [junit] Test: L1, ffffffffb5f2dbf8
    [junit] tag=fb5f2d, index=5f, offset=18
    [junit] Test: L2, 6782a0e2036f4518
    [junit] tag=101b7, index=a28, offset=18
    [junit] Test: DTLB, 37a41c8476994b10
    [junit] tag=423b4ca, index=0, offset=b10
    [junit] Test: L1, ffffffffe41af566
    [junit] tag=fe41af, index=2b, offset=6
    [junit] Test: L2, 43969f9101654201
    [junit] tag=80b2, index=a10, offset=1
    [junit] Test: DTLB, 872cc63255299734
    [junit] tag=192a94c, index=0, offset=1734
    [junit] Test: L1, 396dd175212809bb
    [junit] tag=521280, index=4d, offset=1b
    [junit] Test: L2, ffffffff812e5af9
    [junit] tag=7c097, index=2d7, offset=19
    [junit] Test: DTLB, ffffffffe01a017f
    [junit] tag=7ff00d0, index=0, offset=17f
    [junit] Test: L1, ffffffffdee41a70
    [junit] tag=fdee41, index=53, offset=10
    [junit] Test: L2, ffffffff9faa402c
    [junit] tag=7cfd5, index=201, offset=c
    [junit] Test: DTLB, 1408f6176d9aab57
    [junit] tag=bb6cd5, index=0, offset=b57
    [junit] Test: L1, ffffffff89c71a99
    [junit] tag=f89c71, index=54, offset=19
    [junit] Test: L2, ffffffff9e111335
    [junit] tag=7cf08, index=899, offset=15
    [junit] Test: DTLB, ffffffffb7288e60
    [junit] tag=7fdb944, index=0, offset=e60
    [junit] Test: L1, 409b14cc473f61fb
    [junit] tag=c473f6, index=f, offset=1b
    [junit] Test: L2, ffffffffe94fc5e9
    [junit] tag=7f4a7, index=e2f, offset=9
    [junit] Test: DTLB, 1f088d0213aba098
    [junit] tag=109d5d, index=0, offset=98
    [junit] Test: L1, d6179a041d2cd78b
    [junit] tag=41d2cd, index=3c, offset=b
    [junit] Test: L2, 25ea4432747206fe
    [junit] tag=13a39, index=37, offset=1e
    [junit] Test: DTLB, ffffffffff684ada
    [junit] tag=7fffb42, index=0, offset=ada
    [junit] Test: L1, cd08b32b4c3f8656
    [junit] tag=b4c3f8, index=32, offset=16
    [junit] Test: L2, 2d693d1b2f406fa8
    [junit] tag=597a0, index=37d, offset=8
    [junit] Test: DTLB, dfa5d01939d7290d
    [junit] tag=c9ceb9, index=0, offset=90d
    [junit] Test: L1, fffffffffe4e90eb
    [junit] tag=ffe4e9, index=7, offset=b
    [junit] Test: L2, ffffffffc05d9b58
    [junit] tag=7e02e, index=cda, offset=18
    [junit] Test: DTLB, fffffffff4597be9
    [junit] tag=7ffa2cb, index=0, offset=1be9
    [junit] Test: L1, 2540a68a42e681be
    [junit] tag=a42e68, index=d, offset=1e
    [junit] Test: L2, e28dbf22764b22cb
    [junit] tag=13b25, index=916, offset=b
    [junit] Test: DTLB, 8a9a33e62006cdfc
    [junit] tag=7310036, index=0, offset=dfc
    [junit] Test: L1, fffffffff4dedd6a
    [junit] tag=ff4ded, index=6b, offset=a
    [junit] Test: L2, ffffffffd3e49563
    [junit] tag=7e9f2, index=4ab, offset=3
    [junit] Test: DTLB, ffffffffd6350c58
    [junit] tag=7feb1a8, index=0, offset=c58
    [junit] Test: L1, 961edbcb4f21d5e2
    [junit] tag=b4f21d, index=2f, offset=2
    [junit] Test: L2, ffffffffcd0d97e1
    [junit] tag=7e686, index=cbf, offset=1
    [junit] Test: DTLB, fa747a1203794d03
    [junit] tag=901bca, index=0, offset=d03
    [junit] Test: L1, b2f7e2c37b4fe469
    [junit] tag=37b4fe, index=23, offset=9
    [junit] Test: L2, ffffffff9a776e2b
    [junit] tag=7cd3b, index=b71, offset=b
    [junit] Test: DTLB, 91fdb7db58d07d83
    [junit] tag=6dac683, index=0, offset=1d83
    [junit] Test: L1, ffffffff93ea64ac
    [junit] tag=f93ea6, index=25, offset=c
    [junit] Test: L2, a55462b7745f0387
    [junit] tag=3ba2f, index=81c, offset=7
    [junit] Test: DTLB, 2bbbdf3361038c53
    [junit] tag=19b081c, index=0, offset=c53
    [junit] Test: L1, ffffffffb7a1eb12
    [junit] tag=fb7a1e, index=58, offset=12
    [junit] Test: L2, ffffffffdd40b2f5
    [junit] tag=7eea0, index=597, offset=15
    [junit] Test: DTLB, 6c904570372d80ce
    [junit] tag=381b96c, index=0, offset=ce
    [junit] Test: L1, ffffffff9775fb22
    [junit] tag=f9775f, index=59, offset=2
    [junit] Test: L2, ffffffffeb94313f
    [junit] tag=7f5ca, index=189, offset=1f
    [junit] Test: DTLB, ffffffff82719c6d
    [junit] tag=7fc138c, index=0, offset=1c6d
    [junit] Test: L1, ffffffff8875293c
    [junit] tag=f88752, index=49, offset=1c
    [junit] Test: L2, d6f7407f46de2b06
    [junit] tag=7a36f, index=158, offset=6
    [junit] Test: DTLB, 51bb27133e5d649c
    [junit] tag=99f2eb, index=0, offset=49c
    [junit] Test: L1, f10739717a2a0abf
    [junit] tag=17a2a0, index=55, offset=1f
    [junit] Test: L2, ffffffffa10bce31
    [junit] tag=7d085, index=e71, offset=11
    [junit] Test: DTLB, e821bb9a5738bf93
    [junit] tag=4d2b9c5, index=0, offset=1f93
    [junit] Test: L1, ce22e3fc7ee002af
    [junit] tag=c7ee00, index=15, offset=f
    [junit] Test: L2, ffffffff9ef2cb13
    [junit] tag=7cf79, index=658, offset=13
    [junit] Test: DTLB, 974961565d8fbee4
    [junit] tag=2b2ec7d, index=0, offset=1ee4
    [junit] Test: L1, 2789e2df27438ada
    [junit] tag=f27438, index=56, offset=1a
    [junit] Test: L2, ffffffffdbd5b8ea
    [junit] tag=7edea, index=dc7, offset=a
    [junit] Test: DTLB, 86f5937e08191ed4
    [junit] tag=3f040c8, index=0, offset=1ed4
    [junit] Test: L1, 92b3884c39d752c7
    [junit] tag=c39d75, index=16, offset=7
    [junit] Test: L2, fffffffff19d7fb7
    [junit] tag=7f8ce, index=bfd, offset=17
    [junit] Test: DTLB, ffffffffb401eaae
    [junit] tag=7fda00f, index=0, offset=aae
    [junit] Test: L1, dc84d2b028a47852
    [junit] tag=28a47, index=42, offset=12
    [junit] Test: L2, 97c833be10e0bcae
    [junit] tag=70870, index=5e5, offset=e
    [junit] Test: DTLB, ffffffffeea5672e
    [junit] tag=7ff752b, index=0, offset=72e
    [junit] Test: L1, ffffffffc3460d10
    [junit] tag=fc3460, index=68, offset=10
    [junit] Test: L2, 29a62f17385e6d49
    [junit] tag=39c2f, index=36a, offset=9
    [junit] Test: DTLB, 8de9fc7d4c0bd1d2
    [junit] tag=3ea605e, index=0, offset=11d2
    [junit] Test: L1, ffffffff8dc9fced
    [junit] tag=f8dc9f, index=67, offset=d
    [junit] Test: L2, 55daa1307b0100e4
    [junit] tag=3d80, index=807, offset=4
    [junit] Test: DTLB, ffffffffdffec4a4
    [junit] tag=7fefff6, index=0, offset=4a4
    [junit] Test: L1, ffffffffba5c110a
    [junit] tag=fba5c1, index=8, offset=a
    [junit] Test: L2, ffffffffdf49e4e3
    [junit] tag=7efa4, index=f27, offset=3
    [junit] Test: DTLB, ffffffffca0b953d
    [junit] tag=7fe505c, index=0, offset=153d
    [junit] Test: L1, d3536e2d4845fdba
    [junit] tag=d4845f, index=6d, offset=1a
    [junit] Test: L2, ffffffffc5f23521
    [junit] tag=7e2f9, index=1a9, offset=1
    [junit] Test: DTLB, ffffffff94e23fd8
    [junit] tag=7fca711, index=0, offset=1fd8
    [junit] Test: L1, ac39eee30dc10bc1
    [junit] tag=30dc10, index=5e, offset=1
    [junit] Test: L2, 2380358655752337
    [junit] tag=32aba, index=919, offset=17
    [junit] Test: DTLB, 27e1f2021de59df8
    [junit] tag=10ef2c, index=0, offset=1df8
    [junit] Test: L1, 4b9715a458fefee9
    [junit] tag=458fef, index=77, offset=9
    [junit] Test: L2, ffffffff9af6c97c
    [junit] tag=7cd7b, index=64b, offset=1c
    [junit] Test: DTLB, fffffffff76fa6fa
    [junit] tag=7ffbb7d, index=0, offset=6fa
    [junit] Test: L1, e3f5a5b97acad04c
    [junit] tag=97acad, index=2, offset=c
    [junit] Test: L2, 64eeaf652a529621
    [junit] tag=29529, index=4b1, offset=1
    [junit] Test: DTLB, 6e0905c84c113aba
    [junit] tag=6426089, index=0, offset=1aba
    [junit] Test: L1, fffffffff6318d01
    [junit] tag=ff6318, index=68, offset=1
    [junit] Test: L2, ffffffffb923498e
    [junit] tag=7dc91, index=a4c, offset=e
    [junit] Test: DTLB, 1315175d0aee5f7f
    [junit] tag=2e85772, index=0, offset=1f7f
    [junit] Test: L1, ffffffffeadad4b1
    [junit] tag=feadad, index=25, offset=11
    [junit] Test: L2, ffffffffed05ff65
    [junit] tag=7f682, index=ffb, offset=5
    [junit] Test: DTLB, ffffffffae14c4a9
    [junit] tag=7fd70a6, index=0, offset=4a9
    [junit] Test: L1, ffffffffcee744e0
    [junit] tag=fcee74, index=27, offset=0
    [junit] Test: L2, ffffffff900f1663
    [junit] tag=7c807, index=8b3, offset=3
    [junit] Test: DTLB, fe1dae5276790a77
    [junit] tag=293b3c8, index=0, offset=a77
    [junit] Test: L1, ffffffffac325736
    [junit] tag=fac325, index=39, offset=16
    [junit] Test: L2, e6a6cc727b751111
    [junit] tag=13dba, index=888, offset=11
    [junit] Test: DTLB, cb181f14179bf80c
    [junit] tag=a0bcdf, index=0, offset=180c
    [junit] Test: L1, ffffffff8f408206
    [junit] tag=f8f408, index=10, offset=6
    [junit] Test: L2, ffffffffe387fb59
    [junit] tag=7f1c3, index=fda, offset=19
    [junit] Test: DTLB, 2c6b8d243e778c45
    [junit] tag=121f3bc, index=0, offset=c45
    [junit] Test: L1, c5e7fc4d373866ca
    [junit] tag=d37386, index=36, offset=a
    [junit] Test: L2, ffffffffef97e542
    [junit] tag=7f7cb, index=f2a, offset=2
    [junit] Test: DTLB, ffffffffd74a3e37
    [junit] tag=7feba51, index=0, offset=1e37
    [junit] Test: L1, fffffffffdc171c3
    [junit] tag=ffdc17, index=e, offset=3
    [junit] Test: L2, fffffffff58d2ae5
    [junit] tag=7fac6, index=957, offset=5
    [junit] Test: DTLB, ffffffffb1973990
    [junit] tag=7fd8cb9, index=0, offset=1990
    [junit] Test: L1, b3ba39673d497a8e
    [junit] tag=73d497, index=54, offset=e
    [junit] Test: L2, a9b4325b5989aff3
    [junit] tag=5acc4, index=d7f, offset=13
    [junit] Test: DTLB, ffffffffdd96a061
    [junit] tag=7feecb5, index=0, offset=61
    [junit] Test: L1, fffffffff314dbb7
    [junit] tag=ff314d, index=5d, offset=17
    [junit] Test: L2, 64165f240b68c1e
    [junit] tag=1205b, index=460, offset=1e
    [junit] Test: DTLB, ffffffff8c047004
    [junit] tag=7fc6023, index=0, offset=1004
    [junit] Test: L1, 963c3b4f007e087b
    [junit] tag=f007e0, index=43, offset=1b
    [junit] Test: L2, f9ce86b60bcd0f26
    [junit] tag=305e6, index=879, offset=6
    [junit] Test: DTLB, ffffffffc45f14d4
    [junit] tag=7fe22f8, index=0, offset=14d4
    [junit] Test: L1, ffffffffe6a98fac
    [junit] tag=fe6a98, index=7d, offset=c
    [junit] Test: L2, ffffffffc2e90b5c
    [junit] tag=7e174, index=85a, offset=1c
    [junit] Test: DTLB, 7c5ce16521180f2c
    [junit] tag=32908c0, index=0, offset=f2c
    [junit] Test: L1, fc82dc1b54e3eb07
    [junit] tag=b54e3e, index=58, offset=7
    [junit] Test: L2, fffffffff9c7ef2d
    [junit] tag=7fce3, index=f79, offset=d
    [junit] Test: DTLB, 53445d261db6ca0e
    [junit] tag=130edb6, index=0, offset=a0e
    [junit] Test: L1, 7bafef650962ff29
    [junit] tag=50962f, index=79, offset=9
    [junit] Test: L2, a6ed89bb620c584b
    [junit] tag=5b106, index=2c2, offset=b
    [junit] Test: DTLB, ffffffffc3079710
    [junit] tag=7fe183c, index=0, offset=1710
    [junit] Test: L1, ffffffff8d3d7813
    [junit] tag=f8d3d7, index=40, offset=13
    [junit] Test: L2, ffffffffb1d79c34
    [junit] tag=7d8eb, index=ce1, offset=14
    [junit] Test: DTLB, ffffffffe0286878
    [junit] tag=7ff0143, index=0, offset=878
    [junit] Test: L1, ffffffffb88d8c91
    [junit] tag=fb88d8, index=64, offset=11
    [junit] Test: L2, 4f26c26951063c41
    [junit] tag=4a883, index=1e2, offset=1
    [junit] Test: DTLB, e1c104e3098a8df8
    [junit] tag=7184c54, index=0, offset=df8
    [junit] Test: L1, 5bd8da1a081454bd
    [junit] tag=a08145, index=25, offset=1d
    [junit] Test: L2, ffffffff8b573a18
    [junit] tag=7c5ab, index=9d0, offset=18
    [junit] Test: DTLB, ffffffff8c052ada
    [junit] tag=7fc6029, index=0, offset=ada
    [junit] Test: L1, c47a9b57c348654
    [junit] tag=57c348, index=32, offset=14
    [junit] Test: L2, 93b42cd5540098e
    [junit] tag=6aaa0, index=4c, offset=e
    [junit] Test: DTLB, ffffffffa04e9c6f
    [junit] tag=7fd0274, index=0, offset=1c6f
    [junit] Test: L1, 5fc8f1dc4e6295ad
    [junit] tag=c4e629, index=2d, offset=d
    [junit] Test: L2, ffffffffb8892189
    [junit] tag=7dc44, index=90c, offset=9
    [junit] Test: DTLB, 17347f317151d0c5
    [junit] tag=18b8a8e, index=0, offset=10c5
    [junit] Test: L1, 54e213fd168ff3a8
    [junit] tag=d168ff, index=1d, offset=8
    [junit] Test: L2, 53c0daef46c4935f
    [junit] tag=7a362, index=49a, offset=1f
    [junit] Test: DTLB, ffffffffab6052f7
    [junit] tag=7fd5b02, index=0, offset=12f7
    [junit] Test: L1, fffffffffe280151
    [junit] tag=ffe280, index=a, offset=11
    [junit] Test: L2, ffffffff93f19eab
    [junit] tag=7c9f8, index=cf5, offset=b
    [junit] Test: DTLB, e33e3c1e01b6b463
    [junit] tag=f00db5, index=0, offset=1463
    [junit] Test: L1, fffffffff856522f
    [junit] tag=ff8565, index=11, offset=f
    [junit] Test: L2, ffffffffffa731f4
    [junit] tag=7ffd3, index=98f, offset=14
    [junit] Test: DTLB, ffffffffff827884
    [junit] tag=7fffc13, index=0, offset=1884
    [junit] Test: L1, ffffffffea44d436
    [junit] tag=fea44d, index=21, offset=16
    [junit] Test: L2, ffffffff9e67e874
    [junit] tag=7cf33, index=f43, offset=14
    [junit] Test: DTLB, b32bdf681dfdbb52
    [junit] tag=340efed, index=0, offset=1b52
    [junit] Test: L1, ffffffff94e9233b
    [junit] tag=f94e92, index=19, offset=1b
    [junit] Test: L2, ffffffffcecff913
    [junit] tag=7e767, index=fc8, offset=13
    [junit] Test: DTLB, 986a98e4514d3f2e
    [junit] tag=7228a69, index=0, offset=1f2e
    [junit] Test: L1, ffffffffd6dee342
    [junit] tag=fd6dee, index=1a, offset=2
    [junit] Test: L2, ffffffffc232509f
    [junit] tag=7e119, index=284, offset=1f
    [junit] Test: DTLB, ffffffffe7fbb341
    [junit] tag=7ff3fdd, index=0, offset=1341
    [junit] Test: L1, d521c29810863c50
    [junit] tag=810863, index=62, offset=10
    [junit] Test: L2, ffffffff9cd1733a
    [junit] tag=7ce68, index=b99, offset=1a
    [junit] Test: DTLB, 8f84186d5e7128c2
    [junit] tag=36af389, index=0, offset=8c2
    [junit] Test: L1, 4ee730082583076e
    [junit] tag=825830, index=3b, offset=e
    [junit] Test: L2, 23f84f07313b7aa1
    [junit] tag=3989d, index=bd5, offset=1
    [junit] Test: DTLB, 9a84a365f8231bf
    [junit] tag=1b2fc11, index=0, offset=11bf
    [junit] Test: L1, fffffffff6e0b1c2
    [junit] tag=ff6e0b, index=e, offset=2
    [junit] Test: L2, fd5fb057299fb51e
    [junit] tag=394cf, index=da8, offset=1e
    [junit] Test: DTLB, 9120f8254a08bc7b
    [junit] tag=12a5045, index=0, offset=1c7b
    [junit] Test: L1, d2025f7103f8f64f
    [junit] tag=103f8f, index=32, offset=f
    [junit] Test: L2, aea7775917f30d6e
    [junit] tag=48bf9, index=86b, offset=e
    [junit] Test: DTLB, ffffffffc98e7d9a
    [junit] tag=7fe4c73, index=0, offset=1d9a
    [junit] Test: L1, f6009187538bbd1d
    [junit] tag=7538bb, index=68, offset=1d
    [junit] Test: L2, ffffffffc82356af
    [junit] tag=7e411, index=ab5, offset=f
    [junit] Test: DTLB, ffffffffb94ef4f4
    [junit] tag=7fdca77, index=0, offset=14f4
    [junit] Test: L1, c63c64ea31d95652
    [junit] tag=a31d95, index=32, offset=12
    [junit] Test: L2, d892eaf6441cf6bc
    [junit] tag=3220e, index=7b5, offset=1c
    [junit] Test: DTLB, 55d32eaa23b12ca8
    [junit] tag=5511d89, index=0, offset=ca8
    [junit] Test: L1, 649e10b334cadd90
    [junit] tag=334cad, index=6c, offset=10
    [junit] Test: L2, ffffffff82e54a51
    [junit] tag=7c172, index=a52, offset=11
    [junit] Test: DTLB, ffffffffef6018f3
    [junit] tag=7ff7b00, index=0, offset=18f3
    [junit] Test: L1, c5949827749e5314
    [junit] tag=7749e5, index=18, offset=14
    [junit] Test: L2, 67b4b25c358e4de4
    [junit] tag=61ac7, index=26f, offset=4
    [junit] Test: DTLB, ffffffffe1242422
    [junit] tag=7ff0921, index=0, offset=422
    [junit] Test: L1, fffffffff5b3b1a2
    [junit] tag=ff5b3b, index=d, offset=2
    [junit] Test: L2, ffffffff8404ed3c
    [junit] tag=7c202, index=769, offset=1c
    [junit] Test: DTLB, c78a689b3dc5756f
    [junit] tag=4d9ee2b, index=0, offset=156f
    [junit] Test: L1, ffffffffc74a0baa
    [junit] tag=fc74a0, index=5d, offset=a
    [junit] Test: L2, f82c316a1318b69c
    [junit] tag=5098c, index=5b4, offset=1c
    [junit] Test: DTLB, 4022189773f71535
    [junit] tag=4bb9fb8, index=0, offset=1535
    [junit] Test: L1, fffffffff7d8db9b
    [junit] tag=ff7d8d, index=5c, offset=1b
    [junit] Test: L2, c62e03e366db9dd0
    [junit] tag=1b36d, index=cee, offset=10
    [junit] Test: DTLB, 7a101ab2268863b9
    [junit] tag=5913443, index=0, offset=3b9
    [junit] Test: L1, 91329996486a7ce3
    [junit] tag=6486a7, index=67, offset=3
    [junit] Test: L2, ff15eebe2848176f
    [junit] tag=71424, index=bb, offset=f
    [junit] Test: DTLB, ce62591f12445c7b
    [junit] tag=f89222, index=0, offset=1c7b
    [junit] Test: L1, ffffffff89d6e11f
    [junit] tag=f89d6e, index=8, offset=1f
    [junit] Test: L2, 6fa6fc9233aa49d5
    [junit] tag=119d5, index=24e, offset=15
    [junit] Test: DTLB, ffffffffcd335821
    [junit] tag=7fe699a, index=0, offset=1821
    [junit] Test: L1, e2d3577d2ec689e9
    [junit] tag=d2ec68, index=4f, offset=9
    [junit] Test: L2, 9aa564a70c2dde05
    [junit] tag=38616, index=ef0, offset=5
    [junit] Test: DTLB, ffffffff97bf9c75
    [junit] tag=7fcbdfc, index=0, offset=1c75
    [junit] Test: L1, bc7af71919552281
    [junit] tag=919552, index=14, offset=1
    [junit] Test: L2, ffffffff9976920e
    [junit] tag=7ccbb, index=490, offset=e
    [junit] Test: DTLB, ffffffff92d9446e
    [junit] tag=7fc96ca, index=0, offset=46e
    [junit] Test: L1, 324c95122fc3dc56
    [junit] tag=22fc3d, index=62, offset=16
    [junit] Test: L2, ffffffffdba8fafc
    [junit] tag=7edd4, index=7d7, offset=1c
    [junit] Test: DTLB, ffffffff98fb7454
    [junit] tag=7fcc7db, index=0, offset=1454
    [junit] Test: L1, 83ee7cb333ef8976
    [junit] tag=333ef8, index=4b, offset=16
    [junit] Test: L2, ffffffffbbf7a8a9
    [junit] tag=7ddfb, index=d45, offset=9
    [junit] Test: DTLB, ffffffffedbf0a26
    [junit] tag=7ff6df8, index=0, offset=a26
    [junit] Test: L1, ffffffffd017f7c1
    [junit] tag=fd017f, index=3e, offset=1
    [junit] Test: L2, 40f1ce0c24d91860
    [junit] tag=6126c, index=8c3, offset=0
    [junit] Test: DTLB, ffffffffae32acaf
    [junit] tag=7fd7195, index=0, offset=caf
    [junit] Test: L1, 7f4b7e34229671a4
    [junit] tag=422967, index=d, offset=4
    [junit] Test: L2, adbef07f6136a75b
    [junit] tag=7b09b, index=53a, offset=1b
    [junit] Test: DTLB, efea9e9e559744a5
    [junit] tag=4f2acba, index=0, offset=4a5
    [junit] Test: L1, ffffffffab110cbb
    [junit] tag=fab110, index=65, offset=1b
    [junit] Test: L2, ffffffff9b7918fa
    [junit] tag=7cdbc, index=8c7, offset=1a
    [junit] Test: DTLB, ba22eda85169e25d
    [junit] tag=5428b4f, index=0, offset=25d
    [junit] Test: L1, 20a68ae7451b0f8f
    [junit] tag=7451b0, index=7c, offset=f
    [junit] Test: L2, ffffffffba21dd66
    [junit] tag=7dd10, index=eeb, offset=6
    [junit] Test: DTLB, 6a71f0410acf151
    [junit] tag=208567, index=0, offset=1151
    [junit] Test: L1, 1078cfad2b3d45a1
    [junit] tag=d2b3d4, index=2d, offset=1
    [junit] Test: L2, d8002913331edd72
    [junit] tag=1998f, index=6eb, offset=12
    [junit] Test: DTLB, 3f7e9e4f0d24ca3c
    [junit] tag=2786926, index=0, offset=a3c
    [junit] Test: L1, 4c7897d50579d9b1
    [junit] tag=50579d, index=4d, offset=11
    [junit] Test: L2, 5ae1d98b3bedb87a
    [junit] tag=59df6, index=dc3, offset=1a
    [junit] Test: DTLB, ffffffffdaf694eb
    [junit] tag=7fed7b4, index=0, offset=14eb
    [junit] Test: L1, ffffffffed28ebd4
    [junit] tag=fed28e, index=5e, offset=14
    [junit] Test: L2, ffffffffd8adb1a7
    [junit] tag=7ec56, index=d8d, offset=7
    [junit] Test: DTLB, ffffffffb8fc225f
    [junit] tag=7fdc7e1, index=0, offset=25f
    [junit] Test: L1, 9fbe46155b4bb579
    [junit] tag=55b4bb, index=2b, offset=19
    [junit] Test: L2, fffffffff42e2d1b
    [junit] tag=7fa17, index=168, offset=1b
    [junit] Test: DTLB, ffffffffdb33e608
    [junit] tag=7fed99f, index=0, offset=608
    [junit] Test: L1, ffffffffaeade16f
    [junit] tag=faeade, index=b, offset=f
    [junit] Test: L2, 2c26700435f633f0
    [junit] tag=21afb, index=19f, offset=10
    [junit] Test: DTLB, ffffffffe30a6a0c
    [junit] tag=7ff1853, index=0, offset=a0c
    [junit] Test: L1, 1326b3df19144be7
    [junit] tag=f19144, index=5f, offset=7
    [junit] Test: L2, 2ab989bc4acf83ce
    [junit] tag=62567, index=c1e, offset=e
    [junit] Test: DTLB, ffffffffc6b55164
    [junit] tag=7fe35aa, index=0, offset=1164
    [junit] Test: L1, 1465986a4ca274d8
    [junit] tag=a4ca27, index=26, offset=18
    [junit] Test: L2, ffffffffee0ea109
    [junit] tag=7f707, index=508, offset=9
    [junit] Test: DTLB, 749c6d0854e7f47c
    [junit] tag=42a73f, index=0, offset=147c
    [junit] Test: L1, 45d73eb214fb6dab
    [junit] tag=214fb6, index=6d, offset=b
    [junit] Test: L2, d2e50a042394d0e3
    [junit] tag=211ca, index=687, offset=3
    [junit] Test: DTLB, ffffffffdf16f050
    [junit] tag=7fef8b7, index=0, offset=1050
    [junit] Test: L1, ebc71bb57200e776
    [junit] tag=57200e, index=3b, offset=16
    [junit] Test: L2, ffffffffa581f674
    [junit] tag=7d2c0, index=fb3, offset=14
    [junit] Test: DTLB, ffffffffe0e983f0
    [junit] tag=7ff074c, index=0, offset=3f0
    [junit] Test: L1, 6073cd80792483d7
    [junit] tag=79248, index=1e, offset=17
    [junit] Test: L2, 7dff4c656fb4b5b0
    [junit] tag=2b7da, index=5ad, offset=10
    [junit] Test: DTLB, 52b3f149000acbab
    [junit] tag=2480056, index=0, offset=bab
    [junit] Test: L1, f3496e0a014d5ae5
    [junit] tag=a014d5, index=57, offset=5
    [junit] Test: L2, ffffffff8b669894
    [junit] tag=7c5b3, index=4c4, offset=14
    [junit] Test: DTLB, bb4e95760a1ca72b
    [junit] tag=3b050e5, index=0, offset=72b
    [junit] Test: L1, 90aea7b96ed27356
    [junit] tag=96ed27, index=1a, offset=16
    [junit] Test: L2, ffffffffd2255344
    [junit] tag=7e912, index=a9a, offset=4
    [junit] Test: DTLB, 765172983a70b1d5
    [junit] tag=4c1d385, index=0, offset=11d5
    [junit] Test: L1, ffffffffc1c9afeb
    [junit] tag=fc1c9a, index=7f, offset=b
    [junit] Test: L2, ffffffff90eefd55
    [junit] tag=7c877, index=7ea, offset=15
    [junit] Test: DTLB, b9e7931855958f5b
    [junit] tag=c2acac, index=0, offset=f5b
    [junit] Test: L1, 2887a0b8078ddcaf
    [junit] tag=8078dd, index=65, offset=f
    [junit] Test: L2, 8209b5145e7125dc
    [junit] tag=22f38, index=92e, offset=1c
    [junit] Test: DTLB, a0bb054815b3a45a
    [junit] tag=240ad9d, index=0, offset=45a
    [junit] Test: L1, 1047fc1611e056d4
    [junit] tag=611e05, index=36, offset=14
    [junit] Test: L2, e82aa085cb0e0d0
    [junit] tag=42e58, index=706, offset=10
    [junit] Test: DTLB, ae7ce9b70f8b9ea1
    [junit] tag=5b87c5c, index=0, offset=1ea1
    [junit] Test: L1, 5314f5b5515229d0
    [junit] tag=551522, index=4e, offset=10
    [junit] Test: L2, b2e39e63296ccc71
    [junit] tag=194b6, index=663, offset=11
    [junit] Test: DTLB, ffffffffab0c5fdd
    [junit] tag=7fd5862, index=0, offset=1fdd
    [junit] Test: L1, cddc2fa40739eea5
    [junit] tag=40739e, index=75, offset=5
    [junit] Test: L2, ffffffffa3d5f6f9
    [junit] tag=7d1ea, index=fb7, offset=19
    [junit] Test: DTLB, fffffffffc298928
    [junit] tag=7ffe14c, index=0, offset=928
    [junit] Test: L1, ffffffffeb453cc4
    [junit] tag=feb453, index=66, offset=4
    [junit] Test: L2, d0780c220b06b463
    [junit] tag=10583, index=5a3, offset=3
    [junit] Test: DTLB, ffffffffaf5b7e47
    [junit] tag=7fd7adb, index=0, offset=1e47
    [junit] Test: L1, f129c8dd515330db
    [junit] tag=d51533, index=6, offset=1b
    [junit] Test: L2, ffffffffdaba9455
    [junit] tag=7ed5d, index=4a2, offset=15
    [junit] Test: DTLB, 303183e350175716
    [junit] tag=71a80ba, index=0, offset=1716
    [junit] Test: L1, 711bce1f40e5357a
    [junit] tag=f40e53, index=2b, offset=1a
    [junit] Test: L2, 7619384c62cde1b7
    [junit] tag=63166, index=f0d, offset=17
    [junit] Test: DTLB, fb1dd9e56e432506
    [junit] tag=72b7219, index=0, offset=506
    [junit] Test: L1, ffffffff988eb74a
    [junit] tag=f988eb, index=3a, offset=a
    [junit] Test: L2, fb9f9d7d6e5390b1
    [junit] tag=6b729, index=c85, offset=11
    [junit] Test: DTLB, 5820315b73e8cef7
    [junit] tag=2db9f46, index=0, offset=ef7
    [junit] Test: L1, ffffffffb895fab4
    [junit] tag=fb895f, index=55, offset=14
    [junit] Test: L2, f1477d556cf64e7f
    [junit] tag=2b67b, index=273, offset=1f
    [junit] Test: DTLB, 77c828690d13dcb7
    [junit] tag=348689e, index=0, offset=1cb7
    [junit] Test: L1, fa7b0a46852f3c7
    [junit] tag=46852f, index=1e, offset=7
    [junit] Test: L2, 8f269282454768a8
    [junit] tag=122a3, index=b45, offset=8
    [junit] Test: DTLB, ffffffffd0dc7c62
    [junit] tag=7fe86e3, index=0, offset=1c62
    [junit] Test: L1, dba876e550623b4b
    [junit] tag=550623, index=5a, offset=b
    [junit] Test: L2, 6249ab87254c3de3
    [junit] tag=392a6, index=1ef, offset=3
    [junit] Test: DTLB, ffffffffd83a1e91
    [junit] tag=7fec1d0, index=0, offset=1e91
    [junit] Test: L1, d74df4d366964c36
    [junit] tag=366964, index=61, offset=16
    [junit] Test: L2, 25bb662d08743f30
    [junit] tag=6843a, index=1f9, offset=10
    [junit] Test: DTLB, ffffffffc3c5cd40
    [junit] tag=7fe1e2e, index=0, offset=d40
    [junit] Test: L1, ffffffffc47614df
    [junit] tag=fc4761, index=26, offset=1f
    [junit] Test: L2, ffffffffe4719555
    [junit] tag=7f238, index=caa, offset=15
    [junit] Test: DTLB, ffffffff8fd45dfa
    [junit] tag=7fc7ea2, index=0, offset=1dfa
    [junit] Test: L1, ffffffffdcca2e16
    [junit] tag=fdcca2, index=70, offset=16
    [junit] Test: L2, ffffffff95cb3f86
    [junit] tag=7cae5, index=9fc, offset=6
    [junit] Test: DTLB, 530db6363fbe4845
    [junit] tag=1b1fdf2, index=0, offset=845
    [junit] Test: L1, ffffffff86cb202c
    [junit] tag=f86cb2, index=1, offset=c
    [junit] Test: L2, ffffffffec1bf5d6
    [junit] tag=7f60d, index=fae, offset=16
    [junit] Test: DTLB, ffffffff987e8290
    [junit] tag=7fcc3f4, index=0, offset=290
    [junit] Test: L1, ffffffffcb6d1e05
    [junit] tag=fcb6d1, index=70, offset=5
    [junit] Test: L2, ffffffffbaa5fa9b
    [junit] tag=7dd52, index=fd4, offset=1b
    [junit] Test: DTLB, ffffffff9458335c
    [junit] tag=7fca2c1, index=0, offset=135c
    [junit] Test: L1, 84c74e2e39738245
    [junit] tag=e39738, index=12, offset=5
    [junit] Test: L2, ffffffffc8ed27e6
    [junit] tag=7e476, index=93f, offset=6
    [junit] Test: DTLB, 446726a6254ca361
    [junit] tag=5312a65, index=0, offset=361
    [junit] Test: L1, ffffffffdef22c9d
    [junit] tag=fdef22, index=64, offset=1d
    [junit] Test: L2, ffffffffe47c39ce
    [junit] tag=7f23e, index=1ce, offset=e
    [junit] Test: DTLB, ffffffffb78ed0e2
    [junit] tag=7fdbc76, index=0, offset=10e2
    [junit] Test: L1, ffffffff80fb5048
    [junit] tag=f80fb5, index=2, offset=8
    [junit] Test: L2, ffffffffb3146edc
    [junit] tag=7d98a, index=376, offset=1c
    [junit] Test: DTLB, fffffffff1942ca3
    [junit] tag=7ff8ca1, index=0, offset=ca3
    [junit] Test: L1, 54f9ab5e173547ae
    [junit] tag=e17354, index=3d, offset=e
    [junit] Test: L2, ffffffffd5bb8c32
    [junit] tag=7eadd, index=c61, offset=12
    [junit] Test: DTLB, ffffffffc4055d59
    [junit] tag=7fe202a, index=0, offset=1d59
    [junit] Test: L1, 45332f4b14d59a1c
    [junit] tag=b14d59, index=50, offset=1c
    [junit] Test: L2, 9a5bf019222c4056
    [junit] tag=49116, index=202, offset=16
    [junit] Test: DTLB, fffffffff6e9f689
    [junit] tag=7ffb74f, index=0, offset=1689
    [junit] Test: L1, ffffffffd6367765
    [junit] tag=fd6367, index=3b, offset=5
    [junit] Test: L2, ffffffffcb5a2cb0
    [junit] tag=7e5ad, index=165, offset=10
    [junit] Test: DTLB, ffffffffe33b1973
    [junit] tag=7ff19d8, index=0, offset=1973
    [junit] Test: L1, 7600a54f026e084f
    [junit] tag=f026e0, index=42, offset=f
    [junit] Test: L2, ffffffffe6b204fe
    [junit] tag=7f359, index=27, offset=1e
    [junit] Test: DTLB, ffffffffe59b8679
    [junit] tag=7ff2cdc, index=0, offset=679
    [junit] Test: L1, 80b967036b75291d
    [junit] tag=36b752, index=48, offset=1d
    [junit] Test: L2, 4c0920f17dbf4ccc
    [junit] tag=bedf, index=a66, offset=c
    [junit] Test: DTLB, f0e5f2034d08112a
    [junit] tag=1a6840, index=0, offset=112a
    [junit] Test: L1, ffffffffb2ffc905
    [junit] tag=fb2ffc, index=48, offset=5
    [junit] Test: L2, 54edda32444e6f2c
    [junit] tag=12227, index=379, offset=c
    [junit] Test: DTLB, 853419451d26296f
    [junit] tag=228e931, index=0, offset=96f
    [junit] Test: L1, c1f050363e8ee5d7
    [junit] tag=63e8ee, index=2e, offset=17
    [junit] Test: L2, 21536cce279fc8cf
    [junit] tag=713cf, index=e46, offset=f
    [junit] Test: DTLB, ffffffffbf847651
    [junit] tag=7fdfc23, index=0, offset=1651
    [junit] Test: L1, bcb51af475cefb3d
    [junit] tag=475cef, index=59, offset=1d
    [junit] Test: L2, ffffffffbb4db557
    [junit] tag=7dda6, index=daa, offset=17
    [junit] Test: DTLB, 742f26f907d58e4e
    [junit] tag=7c83eac, index=0, offset=e4e
    [junit] Test: L1, ffffffffca19d90e
    [junit] tag=fca19d, index=48, offset=e
    [junit] Test: L2, ffffffffed266c29
    [junit] tag=7f693, index=361, offset=9
    [junit] Test: DTLB, 475050ce09503b33
    [junit] tag=6704a81, index=0, offset=1b33
    [junit] Test: L1, 1cca8a4e1ff9f1c3
    [junit] tag=e1ff9f, index=e, offset=3
    [junit] Test: L2, ffffffff890d6949
    [junit] tag=7c486, index=b4a, offset=9
    [junit] Test: DTLB, ffffffff8f20ddd4
    [junit] tag=7fc7906, index=0, offset=1dd4
    [junit] Test: L1, 56cff1e309b328a
    [junit] tag=e309b3, index=14, offset=a
    [junit] Test: L2, ffffffffbd338828
    [junit] tag=7de99, index=c41, offset=8
    [junit] Test: DTLB, bfe6832d55d36ee7
    [junit] tag=16aae9b, index=0, offset=ee7
    [junit] Test: L1, 87a36b8c6b318886
    [junit] tag=c6b318, index=44, offset=6
    [junit] Test: L2, ffffffffb69d2d68
    [junit] tag=7db4e, index=96b, offset=8
    [junit] Test: DTLB, e1f503a80ba2657f
    [junit] tag=5405d13, index=0, offset=57f
    [junit] Test: L1, f7ce6ab454181ac1
    [junit] tag=454181, index=56, offset=1
    [junit] Test: L2, fffffffff1fb9697
    [junit] tag=7f8fd, index=cb4, offset=17
    [junit] Test: DTLB, ffffffffd8a3223d
    [junit] tag=7fec519, index=0, offset=23d
    [junit] Test: L1, ffffffffba2251c6
    [junit] tag=fba225, index=e, offset=6
    [junit] Test: L2, ffffffffdd045e5a
    [junit] tag=7ee82, index=2f2, offset=1a
    [junit] Test: DTLB, 2ca9588f6944c3cf
    [junit] tag=47b4a26, index=0, offset=3cf
    [junit] Test: L1, ffffffffd5d68c5d
    [junit] tag=fd5d68, index=62, offset=1d
    [junit] Test: L2, ffffffffc9a9c27e
    [junit] tag=7e4d4, index=e13, offset=1e
    [junit] Test: DTLB, ffffffffce892f63
    [junit] tag=7fe7449, index=0, offset=f63
    [junit] Test: L1, ffffffffb4bfc9cc
    [junit] tag=fb4bfc, index=4e, offset=c
    [junit] Test: L2, fffffffff7febf79
    [junit] tag=7fbff, index=5fb, offset=19
    [junit] Test: DTLB, 546b6b7476d2256
    [junit] tag=5ba3b69, index=0, offset=256
    [junit] Test: L1, ffffffffc1d5302d
    [junit] tag=fc1d53, index=1, offset=d
    [junit] Test: L2, 7f4eb5f85ea254b2
    [junit] tag=42f51, index=2a5, offset=12
    [junit] Test: DTLB, cc202e5b44820002
    [junit] tag=2da2410, index=0, offset=2
    [junit] Test: L1, ffffffffacd5fea6
    [junit] tag=facd5f, index=75, offset=6
    [junit] Test: L2, ffffffffa19629ef
    [junit] tag=7d0cb, index=14f, offset=f
    [junit] Test: DTLB, 3ec52db71d8c709d
    [junit] tag=5b8ec63, index=0, offset=109d
    [junit] Test: L1, ffffffffc8a00383
    [junit] tag=fc8a00, index=1c, offset=3
    [junit] Test: L2, ffffffff855dd07d
    [junit] tag=7c2ae, index=e83, offset=1d
    [junit] Test: DTLB, 398775f21de360f6
    [junit] tag=790ef1b, index=0, offset=f6
    [junit] Test: L1, d8a3d03f2bceedea
    [junit] tag=f2bcee, index=6f, offset=a
    [junit] Test: L2, ffffffffe031d5b7
    [junit] tag=7f018, index=ead, offset=17
    [junit] Test: DTLB, 8010c6f62744ff0b
    [junit] tag=7b13a27, index=0, offset=1f0b
    [junit] Test: L1, ffffffffc1f5d461
    [junit] tag=fc1f5d, index=23, offset=1
    [junit] Test: L2, f25374221cd34af6
    [junit] tag=10e69, index=a57, offset=16
    [junit] Test: DTLB, ffffffffa569067a
    [junit] tag=7fd2b48, index=0, offset=67a
    [junit] Test: L1, 1fa3e048149175fe
    [junit] tag=814917, index=2f, offset=1e
    [junit] Test: L2, ffffffff93f7f6d6
    [junit] tag=7c9fb, index=fb6, offset=16
    [junit] Test: DTLB, 6ea86ce71726c90
    [junit] tag=6738b93, index=0, offset=c90
    [junit] Test: L1, a4cde93b21d17d0a
    [junit] tag=b21d17, index=68, offset=a
    [junit] Test: L2, ffffffff9a7e1819
    [junit] tag=7cd3f, index=c0, offset=19
    [junit] Test: DTLB, ffffffffe909df80
    [junit] tag=7ff484e, index=0, offset=1f80
    [junit] Test: L1, 2cff2e33ccf799
    [junit] tag=e33ccf, index=3c, offset=19
    [junit] Test: L2, 8fa9bd32036c23e9
    [junit] tag=101b6, index=11f, offset=9
    [junit] Test: DTLB, 4a8883747ecf93cc
    [junit] tag=3a3f67c, index=0, offset=13cc
    [junit] Test: L1, ffffffffa76a5654
    [junit] tag=fa76a5, index=32, offset=14
    [junit] Test: L2, 3b947c911d8b86e1
    [junit] tag=8ec5, index=c37, offset=1
    [junit] Test: DTLB, ffffffffea9d4f3c
    [junit] tag=7ff54ea, index=0, offset=f3c
    [junit] Test: L1, 580581ba51b56b42
    [junit] tag=a51b56, index=5a, offset=2
    [junit] Test: L2, ffffffffd3513a9d
    [junit] tag=7e9a8, index=9d4, offset=1d
    [junit] Test: DTLB, 65bd71537f3e516f
    [junit] tag=29bf9f2, index=0, offset=116f
    [junit] Test: L1, e9703b750d53edf7
    [junit] tag=50d53e, index=6f, offset=17
    [junit] Test: L2, ffffffff8c710987
    [junit] tag=7c638, index=84c, offset=7
    [junit] Test: DTLB, ffffffffa1b48dcf
    [junit] tag=7fd0da4, index=0, offset=dcf
    [junit] Test: L1, 15f866ce4838429b
    [junit] tag=e48384, index=14, offset=1b
    [junit] Test: L2, 7c589cb104a2ba39
    [junit] tag=8251, index=5d1, offset=19
    [junit] Test: DTLB, 4bced3f1314761ba
    [junit] tag=7898a3b, index=0, offset=1ba
    [junit] Test: L1, ffffffff9ebf8207
    [junit] tag=f9ebf8, index=10, offset=7
    [junit] Test: L2, efa5882b67a4821e
    [junit] tag=5b3d2, index=410, offset=1e
    [junit] Test: DTLB, ffffffff95fa15ba
    [junit] tag=7fcafd0, index=0, offset=15ba
    [junit] Test: L1, ffffffffa399df81
    [junit] tag=fa399d, index=7c, offset=1
    [junit] Test: L2, ffffffffad8231a7
    [junit] tag=7d6c1, index=18d, offset=7
    [junit] Test: DTLB, ffffffffb84b7c7d
    [junit] tag=7fdc25b, index=0, offset=1c7d
    [junit] Test: L1, b7eeebfa2e57f39e
    [junit] tag=a2e57f, index=1c, offset=1e
    [junit] Test: L2, 1c87226217140166
    [junit] tag=10b8a, index=b, offset=6
    [junit] Test: DTLB, 9df2b6c6a3b08fd
    [junit] tag=36351d8, index=0, offset=8fd
    [junit] Test: L1, ffffffffbc0da9c6
    [junit] tag=fbc0da, index=4e, offset=6
    [junit] Test: L2, a42b92ff10df056f
    [junit] tag=7886f, index=82b, offset=f
    [junit] Test: DTLB, 258f648a14c780de
    [junit] tag=450a63c, index=0, offset=de
    [junit] Test: L1, ffffffff9b7375e8
    [junit] tag=f9b737, index=2f, offset=8
    [junit] Test: L2, 93b676cc271c3cd8
    [junit] tag=6138e, index=1e6, offset=18
    [junit] Test: DTLB, b108569a7732f1a6
    [junit] tag=4d3b997, index=0, offset=11a6
    [junit] Test: L1, ffffffffc40b6363
    [junit] tag=fc40b6, index=1b, offset=3
    [junit] Test: L2, 3adc05e469ef8a1c
    [junit] tag=234f7, index=c50, offset=1c
    [junit] Test: DTLB, fffffffff81698cc
    [junit] tag=7ffc0b4, index=0, offset=18cc
    [junit] Test: L1, b8cc24b6362d9118
    [junit] tag=6362d9, index=8, offset=18
    [junit] Test: L2, b430bea06764eb36
    [junit] tag=33b2, index=759, offset=16
    [junit] Test: DTLB, fffffffffa41cb60
    [junit] tag=7ffd20e, index=0, offset=b60
    [junit] Test: L1, d7a76e414fb7902b
    [junit] tag=14fb79, index=1, offset=b
    [junit] Test: L2, ffffffff87ed0d93
    [junit] tag=7c3f6, index=86c, offset=13
    [junit] Test: DTLB, a102bc1d1eae1941
    [junit] tag=e8f570, index=0, offset=1941
    [junit] Test: L1, 7eab4e0b6446fc26
    [junit] tag=b6446f, index=61, offset=6
    [junit] Test: L2, ffffffffaab79be9
    [junit] tag=7d55b, index=cdf, offset=9
    [junit] Test: DTLB, ffffffff8ac31d2e
    [junit] tag=7fc5618, index=0, offset=1d2e
    [junit] Test: L1, f2d7fe070a03907f
    [junit] tag=70a039, index=3, offset=1f
    [junit] Test: L2, ffffffffc5993666
    [junit] tag=7e2cc, index=9b3, offset=6
    [junit] Test: DTLB, 3fb78e8328028f89
    [junit] tag=4194014, index=0, offset=f89
    [junit] Test: L1, ffffffff977d9788
    [junit] tag=f977d9, index=3c, offset=8
    [junit] Test: L2, ffffffff85e2e066
    [junit] tag=7c2f1, index=703, offset=6
    [junit] Test: DTLB, 340ea39c3a6bdc9c
    [junit] tag=4e1d35e, index=0, offset=1c9c
    [junit] Test: L1, dc93edad1784f8b1
    [junit] tag=d1784f, index=45, offset=11
    [junit] Test: L2, c33e6a5874683f55
    [junit] tag=43a34, index=1fa, offset=15
    [junit] Test: DTLB, f01ded270e8d6cdd
    [junit] tag=138746b, index=0, offset=cdd
    [junit] Test: L1, e194d38322eed30c
    [junit] tag=322eed, index=18, offset=c
    [junit] Test: L2, ffffffffcb9be68c
    [junit] tag=7e5cd, index=f34, offset=c
    [junit] Test: DTLB, e47b350a7e524778
    [junit] tag=53f292, index=0, offset=778
    [junit] Test: L1, ffffffffd71e3716
    [junit] tag=fd71e3, index=38, offset=16
    [junit] Test: L2, ea6b11da7513ac66
    [junit] tag=53a89, index=d63, offset=6
    [junit] Test: DTLB, ffffffff8b06e733
    [junit] tag=7fc5837, index=0, offset=733
    [junit] Test: L1, ffffffffd122ccd5
    [junit] tag=fd122c, index=66, offset=15
    [junit] Test: L2, 7f473c0034c25c01
    [junit] tag=1a61, index=2e0, offset=1
    [junit] Test: DTLB, 3430f8bb4c146b09
    [junit] tag=5da60a3, index=0, offset=b09
    [junit] Test: L1, ffffffffcd3b9c7b
    [junit] tag=fcd3b9, index=63, offset=1b
    [junit] Test: L2, d340897f20987fb4
    [junit] tag=7904c, index=3fd, offset=14
    [junit] Test: DTLB, ffffffff9c0b7386
    [junit] tag=7fce05b, index=0, offset=1386
    [junit] Test: L1, eddc87a332966145
    [junit] tag=332966, index=a, offset=5
    [junit] Test: L2, ffffffffedf247e9
    [junit] tag=7f6f9, index=23f, offset=9
    [junit] Test: DTLB, ec10078547df955c
    [junit] tag=42a3efc, index=0, offset=155c
    [junit] Test: L1, ffffffff94619115
    [junit] tag=f94619, index=8, offset=15
    [junit] Test: L2, 92e05ae836edfc70
    [junit] tag=41b76, index=fe3, offset=10
    [junit] Test: DTLB, 525f07a34ebbb34e
    [junit] tag=51a75dd, index=0, offset=134e
    [junit] Test: L1, ffffffffe7920eff
    [junit] tag=fe7920, index=77, offset=1f
    [junit] Test: L2, ffffffff9cf0baa3
    [junit] tag=7ce78, index=5d5, offset=3
    [junit] Test: DTLB, ffffffffa8617d88
    [junit] tag=7fd430b, index=0, offset=1d88
    [junit] Test: L1, fffffffff78a9deb
    [junit] tag=ff78a9, index=6f, offset=b
    [junit] Test: L2, ffffffffb7511ead
    [junit] tag=7dba8, index=8f5, offset=d
    [junit] Test: DTLB, dc9fdb865835b701
    [junit] tag=432c1ad, index=0, offset=1701
    [junit] Test: L1, ffffffffe7ec4a26
    [junit] tag=fe7ec4, index=51, offset=6
    [junit] Test: L2, 486ba6811a4ec51
    [junit] tag=408d2, index=762, offset=11
    [junit] Test: DTLB, 71c7e65235fd1b83
    [junit] tag=291afe8, index=0, offset=1b83
    [junit] Test: L1, fffffffff7eec4f0
    [junit] tag=ff7eec, index=27, offset=10
    [junit] Test: L2, b7f10fdc46c5d581
    [junit] tag=62362, index=eac, offset=1
    [junit] Test: DTLB, 99c37e3262bf845c
    [junit] tag=19315fc, index=0, offset=45c
    [junit] Test: L1, d49b21771b80af34
    [junit] tag=71b80a, index=79, offset=14
    [junit] Test: L2, ffffffff928a9ced
    [junit] tag=7c945, index=4e7, offset=d
    [junit] Test: DTLB, 2ba9ee9f60558df2
    [junit] tag=4fb02ac, index=0, offset=df2
    [junit] Test: L1, ffffffffc3d6acc4
    [junit] tag=fc3d6a, index=66, offset=4
    [junit] Test: L2, dd157dac06125dfc
    [junit] tag=60309, index=2ef, offset=1c
    [junit] Test: DTLB, ffffffff9c06bd88
    [junit] tag=7fce035, index=0, offset=1d88
    [junit] Test: L1, bf5755f077403dc6
    [junit] tag=77403, index=6e, offset=6
    [junit] Test: L2, c9f256c27dac2490
    [junit] tag=13ed6, index=124, offset=10
    [junit] Test: DTLB, b0f1875e0442b3ab
    [junit] tag=2f02215, index=0, offset=13ab
    [junit] Test: L1, fffffffff9cdc0d2
    [junit] tag=ff9cdc, index=6, offset=12
    [junit] Test: L2, 6c27367167585f78
    [junit] tag=b3ac, index=2fb, offset=18
    [junit] Test: DTLB, ffffffff9fa1b959
    [junit] tag=7fcfd0d, index=0, offset=1959
    [junit] Test: L1, 68ba9c1b1edbafe1
    [junit] tag=b1edba, index=7f, offset=1
    [junit] Test: L2, ffffffffff16f71d
    [junit] tag=7ff8b, index=7b8, offset=1d
    [junit] Test: DTLB, ffffffffd6f885dc
    [junit] tag=7feb7c4, index=0, offset=5dc
    [junit] Test: L1, 93d2323f735d01b0
    [junit] tag=f735d0, index=d, offset=10
    [junit] Test: L2, d56160ab013f024a
    [junit] tag=5809f, index=812, offset=a
    [junit] Test: DTLB, ffffffffbc90fe15
    [junit] tag=7fde487, index=0, offset=1e15
    [junit] Test: L1, ffffffffa1a1492c
    [junit] tag=fa1a14, index=49, offset=c
    [junit] Test: L2, ffffffffe9df15df
    [junit] tag=7f4ef, index=8ae, offset=1f
    [junit] Test: DTLB, ffffffffe92a972c
    [junit] tag=7ff4954, index=0, offset=172c
    [junit] Test: L1, ffffffffd5bef159
    [junit] tag=fd5bef, index=a, offset=19
    [junit] Test: L2, ffffffffbe5259e3
    [junit] tag=7df29, index=2cf, offset=3
    [junit] Test: DTLB, adf5d3c40e79a4bf
    [junit] tag=62073cd, index=0, offset=4bf
    [junit] Test: L1, b5307e96489efa96
    [junit] tag=6489ef, index=54, offset=16
    [junit] Test: L2, ffffffff87862741
    [junit] tag=7c3c3, index=13a, offset=1
    [junit] Test: DTLB, ed49c50b4abaa402
    [junit] tag=5a55d5, index=0, offset=402
    [junit] Test: L1, ffffffffdbc1e007
    [junit] tag=fdbc1e, index=0, offset=7
    [junit] Test: L2, fffffffffaa3a53e
    [junit] tag=7fd51, index=d29, offset=1e
    [junit] Test: DTLB, 863419874e38cc84
    [junit] tag=43a71c6, index=0, offset=c84
    [junit] Test: L1, ffffffff9708243c
    [junit] tag=f97082, index=21, offset=1c
    [junit] Test: L2, ffffffffc2244bee
    [junit] tag=7e112, index=25f, offset=e
    [junit] Test: DTLB, ffffffffaef1c9b3
    [junit] tag=7fd778e, index=0, offset=9b3
    [junit] Test: L1, be3d50e054144c58
    [junit] tag=54144, index=62, offset=18
    [junit] Test: L2, f33d94d465a4b0ed
    [junit] tag=232d2, index=587, offset=d
    [junit] Test: DTLB, fffffffffa772c58
    [junit] tag=7ffd3b9, index=0, offset=c58
    [junit] Test: L1, 69d2bb1c2becd991
    [junit] tag=c2becd, index=4c, offset=11
    [junit] Test: L2, 7dbf4bf622bf1d36
    [junit] tag=3115f, index=8e9, offset=16
    [junit] Test: DTLB, 89f7760f1d783c69
    [junit] tag=78ebc1, index=0, offset=1c69
    [junit] Test: L1, 788ceaf46338bcea
    [junit] tag=46338b, index=67, offset=a
    [junit] Test: L2, 48e8e89f7b4dffa3
    [junit] tag=7bda6, index=ffd, offset=3
    [junit] Test: DTLB, ffffffff92f2e11a
    [junit] tag=7fc9797, index=0, offset=11a
    [junit] Test: L1, c782eff102aa127f
    [junit] tag=102aa1, index=13, offset=1f
    [junit] Test: L2, 8c5457581287b8c5
    [junit] tag=40943, index=dc6, offset=5
    [junit] Test: DTLB, 73036bd44d8e57a8
    [junit] tag=6a26c72, index=0, offset=17a8
    [junit] Test: L1, fffffffff4d81f23
    [junit] tag=ff4d81, index=79, offset=3
    [junit] Test: L2, ffffffffeb9001c2
    [junit] tag=7f5c8, index=e, offset=2
    [junit] Test: DTLB, ffffffffef97b6ae
    [junit] tag=7ff7cbd, index=0, offset=16ae
    [junit] Test: L1, ffffffffc52964e9
    [junit] tag=fc5296, index=27, offset=9
    [junit] Test: L2, ffffffffa5c87444
    [junit] tag=7d2e4, index=3a2, offset=4
    [junit] Test: DTLB, ffffffff8e75a07d
    [junit] tag=7fc73ad, index=0, offset=7d
    [junit] Test: L1, 2e2441b63878be53
    [junit] tag=63878b, index=72, offset=13
    [junit] Test: L2, fffffffffb1ebec7
    [junit] tag=7fd8f, index=5f6, offset=7
    [junit] Test: DTLB, 9ec7c1e95e08e431
    [junit] tag=74af047, index=0, offset=431
    [junit] Test: L1, ffffffffb244859d
    [junit] tag=fb2448, index=2c, offset=1d
    [junit] Test: L2, 4115b3db209a61d3
    [junit] tag=5904d, index=30e, offset=13
    [junit] Test: DTLB, ffffffffc9d5e1f7
    [junit] tag=7fe4eaf, index=0, offset=1f7
    [junit] Test: L1, cf8473110772b5a4
    [junit] tag=10772b, index=2d, offset=4
    [junit] Test: L2, 60bf66643d8b53ee
    [junit] tag=21ec5, index=a9f, offset=e
    [junit] Test: DTLB, d8434d1c68ca3eb8
    [junit] tag=e34651, index=0, offset=1eb8
    [junit] Test: L1, 33f514eb77e495c9
    [junit] tag=b77e49, index=2e, offset=9
    [junit] Test: L2, cc158eb33943e918
    [junit] tag=19ca1, index=f48, offset=18
    [junit] Test: DTLB, ffffffffb3a33870
    [junit] tag=7fd9d19, index=0, offset=1870
    [junit] Test: L1, ffffffffb19b756f
    [junit] tag=fb19b7, index=2b, offset=f
    [junit] Test: L2, 2b2acc9a765e88ed
    [junit] tag=53b2f, index=447, offset=d
    [junit] Test: DTLB, ffffffffa6774a20
    [junit] tag=7fd33ba, index=0, offset=a20
    [junit] Test: L1, 88a475e82ec3a2d9
    [junit] tag=82ec3a, index=16, offset=19
    [junit] Test: L2, e21300ec6f8248c1
    [junit] tag=637c1, index=246, offset=1
    [junit] Test: DTLB, fffffffffc354a3e
    [junit] tag=7ffe1aa, index=0, offset=a3e
    [junit] Test: L1, ffffffffc8ddb62c
    [junit] tag=fc8ddb, index=31, offset=c
    [junit] Test: L2, a7c8901672efe3a2
    [junit] tag=33977, index=f1d, offset=2
    [junit] Test: DTLB, ffffffff9fff204c
    [junit] tag=7fcfff9, index=0, offset=4c
    [junit] Test: L1, fffffffff5303c5a
    [junit] tag=ff5303, index=62, offset=1a
    [junit] Test: L2, f0b688f6553ba177
    [junit] tag=32a9d, index=d0b, offset=17
    [junit] Test: DTLB, 22f4644c4dda6331
    [junit] tag=2626ed3, index=0, offset=331
    [junit] Test: L1, ffffffffc49bb3b7
    [junit] tag=fc49bb, index=1d, offset=17
    [junit] Test: L2, ffffffffae50b157
    [junit] tag=7d728, index=58a, offset=17
    [junit] Test: DTLB, f99c554203a9875d
    [junit] tag=2101d4c, index=0, offset=75d
    [junit] Test: L1, 16b21d8c7864e48b
    [junit] tag=c7864e, index=24, offset=b
    [junit] Test: L2, 3a0dbe8378003cba
    [junit] tag=1bc00, index=1e5, offset=1a
    [junit] Test: DTLB, ffffffff9fde842f
    [junit] tag=7fcfef4, index=0, offset=42f
    [junit] Test: L1, 1ca1520c55634e43
    [junit] tag=c55634, index=72, offset=3
    [junit] Test: L2, 110bf4e777b1d76d
    [junit] tag=3bbd8, index=ebb, offset=d
    [junit] Test: DTLB, 94f74a072fbed11e
    [junit] tag=397df6, index=0, offset=111e
    [junit] Test: L1, 77edb68578dcaf77
    [junit] tag=578dca, index=7b, offset=17
    [junit] Test: L2, fdc30ad1747341cb
    [junit] tag=ba39, index=a0e, offset=b
    [junit] Test: DTLB, ffffffffaa38ea25
    [junit] tag=7fd51c7, index=0, offset=a25
    [junit] Test: L1, ffffffffe9618532
    [junit] tag=fe9618, index=29, offset=12
    [junit] Test: L2, ffffffffba275be2
    [junit] tag=7dd13, index=adf, offset=2
    [junit] Test: DTLB, 23ae67b50a6ca478
    [junit] tag=5a85365, index=0, offset=478
    [junit] Test: L1, ffffffff9500f8ed
    [junit] tag=f9500f, index=47, offset=d
    [junit] Test: L2, ffffffffa125af1f
    [junit] tag=7d092, index=d78, offset=1f
    [junit] Test: DTLB, ffffffffd236c5a5
    [junit] tag=7fe91b6, index=0, offset=5a5
    [junit] Test: L1, f556183b7c4ed17a
    [junit] tag=b7c4ed, index=b, offset=1a
    [junit] Test: L2, 8b77b39c4d9d5a71
    [junit] tag=626ce, index=ad3, offset=11
    [junit] Test: DTLB, d45982c4022bef7b
    [junit] tag=620115f, index=0, offset=f7b
    [junit] Test: L1, 443abcc3336bbf11
    [junit] tag=3336bb, index=78, offset=11
    [junit] Test: L2, 2c9dc0ad1b6cf0d9
    [junit] tag=68db6, index=786, offset=19
    [junit] Test: DTLB, de7dc9d871c353b5
    [junit] tag=6c38e1a, index=0, offset=13b5
    [junit] Test: L1, c041800448b171e0
    [junit] tag=448b17, index=f, offset=0
    [junit] Test: L2, ffffffffbaeef313
    [junit] tag=7dd77, index=798, offset=13
    [junit] Test: DTLB, ffffffffd571c824
    [junit] tag=7feab8e, index=0, offset=824
    [junit] Test: L1, ffffffffd2f0a1a5
    [junit] tag=fd2f0a, index=d, offset=5
    [junit] Test: L2, d10d74c11532d646
    [junit] tag=8a99, index=6b2, offset=6
    [junit] Test: DTLB, d9c5b1a30e5a8bfe
    [junit] tag=51872d4, index=0, offset=bfe
    [junit] Test: L1, f5959698425347ea
    [junit] tag=842534, index=3f, offset=a
    [junit] Test: L2, 6cf012e2579218dc
    [junit] tag=12bc9, index=c6, offset=1c
    [junit] Test: DTLB, ffffffffa93671b2
    [junit] tag=7fd49b3, index=0, offset=11b2
    [junit] Test: L1, ffffffff9d08a91d
    [junit] tag=f9d08a, index=48, offset=1d
    [junit] Test: L2, fffffffffc20ed94
    [junit] tag=7fe10, index=76c, offset=14
    [junit] Test: DTLB, 97a7b24d5c2bee7f
    [junit] tag=26ae15f, index=0, offset=e7f
    [junit] Test: L1, 27eaf77620cc0a25
    [junit] tag=620cc0, index=51, offset=5
    [junit] Test: L2, ffffffffbc92ff20
    [junit] tag=7de49, index=7f9, offset=0
    [junit] Test: DTLB, ffffffffa2cbe4be
    [junit] tag=7fd165f, index=0, offset=4be
    [junit] Test: L1, 57a4c679682743ed
    [junit] tag=968274, index=1f, offset=d
    [junit] Test: L2, ca623bb34fa680e1
    [junit] tag=1a7d3, index=407, offset=1
    [junit] Test: DTLB, 41e9d64c2a099b33
    [junit] tag=261504c, index=0, offset=1b33
    [junit] Test: L1, 2e98cad004039186
    [junit] tag=4039, index=c, offset=6
    [junit] Test: L2, ffffffffc8000422
    [junit] tag=7e400, index=21, offset=2
    [junit] Test: DTLB, ffffffffdabb7ee5
    [junit] tag=7fed5db, index=0, offset=1ee5
    [junit] Test: L1, ffffffffc621c158
    [junit] tag=fc621c, index=a, offset=18
    [junit] Test: L2, ffffffff892a9df7
    [junit] tag=7c495, index=4ef, offset=17
    [junit] Test: DTLB, ffffffffb031e5b3
    [junit] tag=7fd818f, index=0, offset=5b3
    [junit] Test: L1, ffffffffa40e8f24
    [junit] tag=fa40e8, index=79, offset=4
    [junit] Test: L2, 831d626968642b85
    [junit] tag=4b432, index=15c, offset=5
    [junit] Test: DTLB, ffffffffa141f352
    [junit] tag=7fd0a0f, index=0, offset=1352
    [junit] Test: L1, ffffffffe869c029
    [junit] tag=fe869c, index=1, offset=9
    [junit] Test: L2, ffffffffbee3a3e3
    [junit] tag=7df71, index=d1f, offset=3
    [junit] Test: DTLB, ffffffffa0a26cff
    [junit] tag=7fd0513, index=0, offset=cff
    [junit] Test: L1, ffffffff986dc706
    [junit] tag=f986dc, index=38, offset=6
    [junit] Test: L2, f120eda3270290a3
    [junit] tag=19381, index=485, offset=3
    [junit] Test: DTLB, ffffffffa28d2680
    [junit] tag=7fd1469, index=0, offset=680
    [junit] Test: L1, ffffffff99d46dc0
    [junit] tag=f99d46, index=6e, offset=0
    [junit] Test: L2, 82a6eba8152fa2f9
    [junit] tag=40a97, index=d17, offset=19
    [junit] Test: DTLB, 11ed3529044887d0
    [junit] tag=1482244, index=0, offset=7d0
    [junit] Test: L1, bc7459862e6480fa
    [junit] tag=62e648, index=7, offset=1a
    [junit] Test: L2, 9e07b90a685a3995
    [junit] tag=5342d, index=1cc, offset=15
    [junit] Test: DTLB, bcef71fb722540e6
    [junit] tag=7db912a, index=0, offset=e6
    [junit] Test: L1, 81886bbd0d10913f
    [junit] tag=d0d109, index=9, offset=1f
    [junit] Test: L2, ffffffffa14afc0f
    [junit] tag=7d0a5, index=7e0, offset=f
    [junit] Test: DTLB, ffffffff8958f3a6
    [junit] tag=7fc4ac7, index=0, offset=13a6
    [junit] Test: L1, fffffffffb369c9f
    [junit] tag=ffb369, index=64, offset=1f
    [junit] Test: L2, ffffffffbd2d58f1
    [junit] tag=7de96, index=ac7, offset=11
    [junit] Test: DTLB, 872ed25f2c5e4c44
    [junit] tag=2f962f2, index=0, offset=c44
    [junit] Test: L1, ffffffff8f779013
    [junit] tag=f8f779, index=0, offset=13
    [junit] Test: L2, fffffffff47a7898
    [junit] tag=7fa3d, index=3c4, offset=18
    [junit] Test: DTLB, fffffffff98a8170
    [junit] tag=7ffcc54, index=0, offset=170
    [junit] Test: L1, 413cd8af0b1f4e84
    [junit] tag=f0b1f4, index=74, offset=4
    [junit] Test: L2, f1e408cd5d4b2932
    [junit] tag=6aea5, index=949, offset=12
    [junit] Test: DTLB, 343c43f27b7fa437
    [junit] tag=793dbfd, index=0, offset=437
    [junit] Test: L1, 5e7845eb6013f52b
    [junit] tag=b6013f, index=29, offset=b
    [junit] Test: L2, ffffffffe5d452fc
    [junit] tag=7f2ea, index=297, offset=1c
    [junit] Test: DTLB, 702f12d80bce6fb1
    [junit] tag=6c05e73, index=0, offset=fb1
    [junit] Test: L1, 884f170625b3929d
    [junit] tag=625b39, index=14, offset=1d
    [junit] Test: L2, ffffffffd668b0a0
    [junit] tag=7eb34, index=585, offset=0
    [junit] Test: DTLB, 174aaf49205c5eef
    [junit] tag=24902e2, index=0, offset=1eef
    [junit] Test: L1, c78c6cce009cf286
    [junit] tag=e009cf, index=14, offset=6
    [junit] Test: L2, 1d46222b0796575f
    [junit] tag=583cb, index=2ba, offset=1f
    [junit] Test: DTLB, 71d9609d66095135
    [junit] tag=4eb304a, index=0, offset=1135
    [junit] Test: L1, ffffffff830d8fe4
    [junit] tag=f830d8, index=7f, offset=4
    [junit] Test: L2, ffffffffd313868e
    [junit] tag=7e989, index=c34, offset=e
    [junit] Test: DTLB, ffffffff896d8f64
    [junit] tag=7fc4b6c, index=0, offset=f64
    [junit] Test: L1, ffffffffbc415c69
    [junit] tag=fbc415, index=63, offset=9
    [junit] Test: L2, ffffffff904aa929
    [junit] tag=7c825, index=549, offset=9
    [junit] Test: DTLB, ffffffff94fcf437
    [junit] tag=7fca7e7, index=0, offset=1437
    [junit] Test: L1, ffffffffabfa4511
    [junit] tag=fabfa4, index=28, offset=11
    [junit] Test: L2, 6c025f3f48425317
    [junit] tag=7a421, index=298, offset=17
    [junit] Test: DTLB, ffffffffa83aad4a
    [junit] tag=7fd41d5, index=0, offset=d4a
    [junit] Test: L1, 48f40564191e7f57
    [junit] tag=4191e7, index=7a, offset=17
    [junit] Test: L2, ffffffffd6911566
    [junit] tag=7eb48, index=8ab, offset=6
    [junit] Test: DTLB, fffffffffd3e62c4
    [junit] tag=7ffe9f3, index=0, offset=2c4
    [junit] Test: L1, da6629e25f686383
    [junit] tag=25f686, index=1c, offset=3
    [junit] Test: L2, ffffffffdebea6a3
    [junit] tag=7ef5f, index=535, offset=3
    [junit] Test: DTLB, d7e85d8253b141de
    [junit] tag=4129d8a, index=0, offset=1de
    [junit] Test: L1, ffffffff952234d8
    [junit] tag=f95223, index=26, offset=18
    [junit] Test: L2, 77e83ba14062e136
    [junit] tag=a031, index=709, offset=16
    [junit] Test: DTLB, ffffffffa8a3118d
    [junit] tag=7fd4518, index=0, offset=118d
    [junit] Test: L1, f396ead3087600c8
    [junit] tag=308760, index=6, offset=8
    [junit] Test: L2, fffffffff711f4bf
    [junit] tag=7fb88, index=fa5, offset=1f
    [junit] Test: DTLB, a7d19cdb28658e02
    [junit] tag=6d9432c, index=0, offset=e02
    [junit] Test: L1, 70f225b40fd1e6cd
    [junit] tag=40fd1e, index=36, offset=d
    [junit] Test: L2, ffffffffb05fd9d6
    [junit] tag=7d82f, index=ece, offset=16
    [junit] Test: DTLB, 8813867d06531285
    [junit] tag=3e83298, index=0, offset=1285
    [junit] Test: L1, ffffffffa0e3984d
    [junit] tag=fa0e39, index=42, offset=d
    [junit] Test: L2, 7c9080a2303783ce
    [junit] tag=1181b, index=c1e, offset=e
    [junit] Test: DTLB, 2f2ea665051fe2fa
    [junit] tag=32828ff, index=0, offset=2fa
    [junit] Test: L1, cca790eb147ac36b
    [junit] tag=b147ac, index=1b, offset=b
    [junit] Test: L2, 3ca38a04794d04c7
    [junit] tag=23ca6, index=826, offset=7
    [junit] Test: DTLB, ffffffffe9870c8f
    [junit] tag=7ff4c38, index=0, offset=c8f
    [junit] Test: L1, ffffffffb55ec0ef
    [junit] tag=fb55ec, index=7, offset=f
    [junit] Test: L2, ffffffffabdc36c8
    [junit] tag=7d5ee, index=1b6, offset=8
    [junit] Test: DTLB, ffffffffe076ab3a
    [junit] tag=7ff03b5, index=0, offset=b3a
    [junit] Test: L1, e5fb2fff37d6f551
    [junit] tag=f37d6f, index=2a, offset=11
    [junit] Test: L2, 9c1efc6c0dbc3295
    [junit] tag=606de, index=194, offset=15
    [junit] Test: DTLB, 71b675e0705bd458
    [junit] tag=70382de, index=0, offset=1458
    [junit] Test: L1, 96c4850e5bf9baa8
    [junit] tag=e5bf9b, index=55, offset=8
    [junit] Test: L2, ffffffff92475ffc
    [junit] tag=7c923, index=aff, offset=1c
    [junit] Test: DTLB, ffffffffa08cdca8
    [junit] tag=7fd0466, index=0, offset=1ca8
    [junit] Test: L1, ffffffffc7e0e949
    [junit] tag=fc7e0e, index=4a, offset=9
    [junit] Test: L2, 5d37bf8744ef28fe
    [junit] tag=3a277, index=947, offset=1e
    [junit] Test: DTLB, 4d29ec4b162dc009
    [junit] tag=258b16e, index=0, offset=9
    [junit] Test: L1, 14bd237005d50e15
    [junit] tag=5d50, index=70, offset=15
    [junit] Test: L2, fcf1fe4b13edf368
    [junit] tag=589f6, index=f9b, offset=8
    [junit] Test: DTLB, 770e415a1cc7bd59
    [junit] tag=2d0e63d, index=0, offset=1d59
    [junit] Test: L1, 9cb8154c3b3ff760
    [junit] tag=c3b3ff, index=3b, offset=0
    [junit] Test: L2, ffffffffd9bc1882
    [junit] tag=7ecde, index=c4, offset=2
    [junit] Test: DTLB, 694161171865c933
    [junit] tag=b8c32e, index=0, offset=933
    [junit] Test: L1, 6b2e09041afee04c
    [junit] tag=41afee, index=2, offset=c
    [junit] Test: L2, ae2e524908c8a0b2
    [junit] tag=48464, index=505, offset=12
    [junit] Test: DTLB, 7ae2a6d178a8e70d
    [junit] tag=68bc547, index=0, offset=70d
    [junit] Test: L1, ffffffffe0fa5f01
    [junit] tag=fe0fa5, index=78, offset=1
    [junit] Test: L2, d5b216c303e19804
    [junit] tag=181f0, index=cc0, offset=4
    [junit] Test: DTLB, 6ee5ec343978b9ba
    [junit] tag=1a1cbc5, index=0, offset=19ba
    [junit] Test: L1, ffffffffc63d9d70
    [junit] tag=fc63d9, index=6b, offset=10
    [junit] Test: L2, 207cd9e15f01afe4
    [junit] tag=af80, index=d7f, offset=4
    [junit] Test: DTLB, ffffffffb41b06f1
    [junit] tag=7fda0d8, index=0, offset=6f1
    [junit] Test: L1, ffffffff9434f212
    [junit] tag=f9434f, index=10, offset=12
    [junit] Test: L2, ffffffffb0dd1511
    [junit] tag=7d86e, index=8a8, offset=11
    [junit] Test: DTLB, 282b7be70c53a8f
    [junit] tag=5f38629, index=0, offset=1a8f
    [junit] Test: L1, fffffffffae08a0f
    [junit] tag=ffae08, index=50, offset=f
    [junit] Test: L2, ffffffff84c1d43e
    [junit] tag=7c260, index=ea1, offset=1e
    [junit] Test: DTLB, 2f0d6d7d787a7e95
    [junit] tag=3ebc3d3, index=0, offset=1e95
    [junit] Test: L1, dde118e32d22501f
    [junit] tag=32d225, index=0, offset=1f
    [junit] Test: L2, ffffffffa5006818
    [junit] tag=7d280, index=340, offset=18
    [junit] Test: DTLB, 2b2072b00d0d1a24
    [junit] tag=5806868, index=0, offset=1a24
    [junit] Test: L1, 9108955235a6bfaa
    [junit] tag=235a6b, index=7d, offset=a
    [junit] Test: L2, fffffffffdc9c03f
    [junit] tag=7fee4, index=e01, offset=1f
    [junit] Test: DTLB, ffffffffd731120f
    [junit] tag=7feb988, index=0, offset=120f
    [junit] Test: L1, 655a8d461f89f26
    [junit] tag=461f89, index=79, offset=6
    [junit] Test: L2, ffffffff85d41adb
    [junit] tag=7c2ea, index=d6, offset=1b
    [junit] Test: DTLB, ffffffffebcb6dcd
    [junit] tag=7ff5e5b, index=0, offset=dcd
    [junit] Test: L1, 80ff71a65db8853f
    [junit] tag=65db88, index=29, offset=1f
    [junit] Test: L2, 3d460e4909f9b89d
    [junit] tag=484fc, index=dc4, offset=1d
    [junit] Test: DTLB, ffffffffd3d5ffbf
    [junit] tag=7fe9eaf, index=0, offset=1fbf
    [junit] Test: L1, ffffffff9ecbdb07
    [junit] tag=f9ecbd, index=58, offset=7
    [junit] Test: L2, ffffffffc5129e60
    [junit] tag=7e289, index=4f3, offset=0
    [junit] Test: DTLB, ffffffff8ca55575
    [junit] tag=7fc652a, index=0, offset=1575
    [junit] Test: L1, ffffffff9bd00501
    [junit] tag=f9bd00, index=28, offset=1
    [junit] Test: L2, ffffffffdb49d6aa
    [junit] tag=7eda4, index=eb5, offset=a
    [junit] Test: DTLB, ffffffffc6b6a613
    [junit] tag=7fe35b5, index=0, offset=613
    [junit] Test: L1, cda20e517e1556d4
    [junit] tag=17e155, index=36, offset=14
    [junit] Test: L2, 96d340866417201c
    [junit] tag=3320b, index=900, offset=1c
    [junit] Test: DTLB, 3c2cf2625a2ca852
    [junit] tag=312d165, index=0, offset=852
    [junit] Test: L1, ffffffffaeb4ad19
    [junit] tag=faeb4a, index=68, offset=19
    [junit] Test: L2, ffffffffb83103e3
    [junit] tag=7dc18, index=81f, offset=3
    [junit] Test: DTLB, 646c774c2ea8b7f1
    [junit] tag=2617545, index=0, offset=17f1
    [junit] Test: L1, ffffffffeaf0dbf0
    [junit] tag=feaf0d, index=5f, offset=10
    [junit] Test: L2, 59b79a620c963109
    [junit] tag=1064b, index=188, offset=9
    [junit] Test: DTLB, 22a9c6075166e206
    [junit] tag=3a8b37, index=0, offset=206
    [junit] Test: L1, fffffffff5b11d64
    [junit] tag=ff5b11, index=6b, offset=4
    [junit] Test: L2, ffffffff901c6351
    [junit] tag=7c80e, index=31a, offset=11
    [junit] Test: DTLB, 780e665e126914c7
    [junit] tag=2f09348, index=0, offset=14c7
    [junit] Test: L1, ffffffffa37cc92e
    [junit] tag=fa37cc, index=49, offset=e
    [junit] Test: L2, ffffffff96e5804a
    [junit] tag=7cb72, index=c02, offset=a
    [junit] Test: DTLB, ffffffffbdc10d54
    [junit] tag=7fdee08, index=0, offset=d54
    [junit] Test: L1, 621746de51191cc5
    [junit] tag=e51191, index=66, offset=5
    [junit] Test: L2, ffffffffa44ed32e
    [junit] tag=7d227, index=699, offset=e
    [junit] Test: DTLB, ffffffffa8ce502f
    [junit] tag=7fd4672, index=0, offset=102f
    [junit] Test: L1, 5e0834ae6bf80992
    [junit] tag=e6bf80, index=4c, offset=12
    [junit] Test: L2, ffffffffaaa863d6
    [junit] tag=7d554, index=31e, offset=16
    [junit] Test: DTLB, 7a1312a4620498bd
    [junit] tag=5231024, index=0, offset=18bd
    [junit] Test: L1, a0baac0e36338db6
    [junit] tag=e36338, index=6d, offset=16
    [junit] Test: L2, ffffffffe30bfb78
    [junit] tag=7f185, index=fdb, offset=18
    [junit] Test: DTLB, 730b11ae149166c0
    [junit] tag=570a48b, index=0, offset=6c0
    [junit] Test: L1, 431a533a3d9cf924
    [junit] tag=a3d9cf, index=49, offset=4
    [junit] Test: L2, fadf021550482d60
    [junit] tag=2a824, index=16b, offset=0
    [junit] Test: DTLB, fffffffff046f716
    [junit] tag=7ff8237, index=0, offset=1716
    [junit] Test: L1, 659e2f2d3bf90d36
    [junit] tag=d3bf90, index=69, offset=16
    [junit] Test: L2, d0f43195f9977a4
    [junit] tag=4afcc, index=bbd, offset=4
    [junit] Test: DTLB, ffffffffc5130e89
    [junit] tag=7fe2898, index=0, offset=e89
    [junit] Test: L1, ffffffff87da7e4d
    [junit] tag=f87da7, index=72, offset=d
    [junit] Test: L2, fffffffffe0ec78c
    [junit] tag=7ff07, index=63c, offset=c
    [junit] Test: DTLB, fffffffffe580190
    [junit] tag=7fff2c0, index=0, offset=190
    [junit] Test: L1, 7d65e52b73bd050b
    [junit] tag=b73bd0, index=28, offset=b
    [junit] Test: L2, b272e96c19cb50ea
    [junit] tag=60ce5, index=a87, offset=a
    [junit] Test: DTLB, ffffffffffc76cc7
    [junit] tag=7fffe3b, index=0, offset=cc7
    [junit] Test: L1, ffffffff8421aac2
    [junit] tag=f8421a, index=56, offset=2
    [junit] Test: L2, 74d823d16bd4bab2
    [junit] tag=b5ea, index=5d5, offset=12
    [junit] Test: DTLB, 6b29bcbb79f75160
    [junit] tag=5dbcfba, index=0, offset=1160
    [junit] Test: L1, ffffffffff2a1cf7
    [junit] tag=fff2a1, index=67, offset=17
    [junit] Test: L2, 2a0b0e0e3f9e7388
    [junit] tag=71fcf, index=39c, offset=8
    [junit] Test: DTLB, 13761220257974da
    [junit] tag=1012bcb, index=0, offset=14da
    [junit] Test: L1, 3f6ae8a822759502
    [junit] tag=822759, index=28, offset=2
    [junit] Test: L2, ffffffffab243b59
    [junit] tag=7d592, index=1da, offset=19
    [junit] Test: DTLB, ffffffffda9872b3
    [junit] tag=7fed4c3, index=0, offset=12b3
    [junit] Test: L1, ffffffff987311bd
    [junit] tag=f98731, index=d, offset=1d
    [junit] Test: L2, 277a620e05451b16
    [junit] tag=702a2, index=8d8, offset=16
    [junit] Test: DTLB, e723cc447b32731b
    [junit] tag=223d993, index=0, offset=131b
    [junit] Test: L1, bd988a806cfc06c8
    [junit] tag=6cfc0, index=36, offset=8
    [junit] Test: L2, ffffffff929b1942
    [junit] tag=7c94d, index=8ca, offset=2
    [junit] Test: DTLB, fffffffffcc2c049
    [junit] tag=7ffe616, index=0, offset=49
    [junit] Test: L1, ffffffffb3d06834
    [junit] tag=fb3d06, index=41, offset=14
    [junit] Test: L2, ffffffffbabf10bd
    [junit] tag=7dd5f, index=885, offset=1d
    [junit] Test: DTLB, ffffffffd5af3db0
    [junit] tag=7fead79, index=0, offset=1db0
    [junit] Test: L1, ffffffff8a196a7b
    [junit] tag=f8a196, index=53, offset=1b
    [junit] Test: L2, b20d9014123a87f1
    [junit] tag=2091d, index=43f, offset=11
    [junit] Test: DTLB, 6da2fb345f604c59
    [junit] tag=1a2fb02, index=0, offset=c59
    [junit] Test: L1, d56fb6a358d88f81
    [junit] tag=358d88, index=7c, offset=1
    [junit] Test: L2, ffffffffff63e5c4
    [junit] tag=7ffb1, index=f2e, offset=4
    [junit] Test: DTLB, d71af6d02cd0c292
    [junit] tag=6816686, index=0, offset=292
    [junit] Test: L1, ffffffffef71ad66
    [junit] tag=fef71a, index=6b, offset=6
    [junit] Test: L2, c21a496250773ee
    [junit] tag=31283, index=b9f, offset=e
    [junit] Test: DTLB, ffffffff96575f4c
    [junit] tag=7fcb2ba, index=0, offset=1f4c
    [junit] Test: L1, ffffffff859df997
    [junit] tag=f859df, index=4c, offset=17
    [junit] Test: L2, ffffffff8fa334de
    [junit] tag=7c7d1, index=9a6, offset=1e
    [junit] Test: DTLB, beecdf664757aee
    [junit] tag=7b323ab, index=0, offset=1aee
    [junit] Test: L1, ffffffffd828dfee
    [junit] tag=fd828d, index=7f, offset=e
    [junit] Test: L2, ffffffffac2e742b
    [junit] tag=7d617, index=3a1, offset=b
    [junit] Test: DTLB, ffffffffbaebca69
    [junit] tag=7fdd75e, index=0, offset=a69
    [junit] Test: L1, ffffffff9f471c38
    [junit] tag=f9f471, index=61, offset=18
    [junit] Test: L2, fa96dec97fe760e6
    [junit] tag=4bff3, index=b07, offset=6
    [junit] Test: DTLB, ffffffff9efd9907
    [junit] tag=7fcf7ec, index=0, offset=1907
    [junit] Test: L1, ffffffffb0a90808
    [junit] tag=fb0a90, index=40, offset=8
    [junit] Test: L2, ffffffffc250ee1c
    [junit] tag=7e128, index=770, offset=1c
    [junit] Test: DTLB, 9faff09e71382e80
    [junit] tag=4f389c1, index=0, offset=e80
    [junit] Test: L1, ffffffffbb7d5517
    [junit] tag=fbb7d5, index=28, offset=17
    [junit] Test: L2, ffffffffd333accd
    [junit] tag=7e999, index=d66, offset=d
    [junit] Test: DTLB, ffffffffeab73f54
    [junit] tag=7ff55b9, index=0, offset=1f54
    [junit] Test: L1, ffffffffd6d9ad49
    [junit] tag=fd6d9a, index=6a, offset=9
    [junit] Test: L2, ffffffffbe70d701
    [junit] tag=7df38, index=6b8, offset=1
    [junit] Test: DTLB, ffffffffc8fc3c39
    [junit] tag=7fe47e1, index=0, offset=1c39
    [junit] Test: L1, ffffffff9299e94a
    [junit] tag=f9299e, index=4a, offset=a
    [junit] Test: L2, ffffffffbb11906d
    [junit] tag=7dd88, index=c83, offset=d
    [junit] Test: DTLB, 6e3ac20a2cbe65cb
    [junit] tag=5165f3, index=0, offset=5cb
    [junit] Test: L1, ffffffff8eb58e76
    [junit] tag=f8eb58, index=73, offset=16
    [junit] Test: L2, f49a30ec3ccfea5e
    [junit] tag=61e67, index=f52, offset=1e
    [junit] Test: DTLB, ffffffff861f1050
    [junit] tag=7fc30f8, index=0, offset=1050
    [junit] Test: L1, ffffffffe37bf406
    [junit] tag=fe37bf, index=20, offset=6
    [junit] Test: L2, fffffffff15141a7
    [junit] tag=7f8a8, index=a0d, offset=7
    [junit] Test: DTLB, ffffffff89315e6c
    [junit] tag=7fc498a, index=0, offset=1e6c
    [junit] Test: L1, 5a7b431e45c2edc3
    [junit] tag=e45c2e, index=6e, offset=3
    [junit] Test: L2, 8a026a8154e45cf8
    [junit] tag=aa72, index=2e7, offset=18
    [junit] Test: DTLB, 903e958a30eaa83b
    [junit] tag=4518755, index=0, offset=83b
    [junit] Test: L1, 5e4f1e18238553
    [junit] tag=e18238, index=2a, offset=13
    [junit] Test: L2, ffffffff847c14bb
    [junit] tag=7c23e, index=a5, offset=1b
    [junit] Test: DTLB, fffffffff482c91e
    [junit] tag=7ffa416, index=0, offset=91e
    [junit] Test: L1, ffffffff8eceb83e
    [junit] tag=f8eceb, index=41, offset=1e
    [junit] Test: L2, d269d44436268b8f
    [junit] tag=21b13, index=45c, offset=f
    [junit] Test: DTLB, fffffffffa2654c8
    [junit] tag=7ffd132, index=0, offset=14c8
    [junit] Test: L1, 47ec8bfe1912d344
    [junit] tag=e1912d, index=1a, offset=4
    [junit] Test: L2, 421e96795ddcccbe
    [junit] tag=4aeee, index=665, offset=1e
    [junit] Test: DTLB, 5997d7f00a50956d
    [junit] tag=7805284, index=0, offset=156d
    [junit] Test: L1, ffffffffbdfae6e0
    [junit] tag=fbdfae, index=37, offset=0
    [junit] Test: L2, a10ae7b8436df087
    [junit] tag=421b6, index=f84, offset=7
    [junit] Test: DTLB, ffffffffc9be45d6
    [junit] tag=7fe4df2, index=0, offset=5d6
    [junit] Test: L1, ffffffffd91fa3a9
    [junit] tag=fd91fa, index=1d, offset=9
    [junit] Test: L2, 60bfa7cd148feebd
    [junit] tag=68a47, index=f75, offset=1d
    [junit] Test: DTLB, ffffffffcdb5c16a
    [junit] tag=7fe6dae, index=0, offset=16a
    [junit] Test: L1, ffffffffe8b0c82e
    [junit] tag=fe8b0c, index=41, offset=e
    [junit] Test: L2, 4793d78946762176
    [junit] tag=4a33b, index=10b, offset=16
    [junit] Test: DTLB, ffffffff8beb72b6
    [junit] tag=7fc5f5b, index=0, offset=12b6
    [junit] Test: L1, a04e6990163e4d4b
    [junit] tag=163e4, index=6a, offset=b
    [junit] Test: L2, ffffffff80f23b31
    [junit] tag=7c079, index=1d9, offset=11
    [junit] Test: DTLB, 564781666b105fb6
    [junit] tag=3335882, index=0, offset=1fb6
    [junit] Test: L1, ffffffffb6c66e9f
    [junit] tag=fb6c66, index=74, offset=1f
    [junit] Test: L2, ffffffffd197ea08
    [junit] tag=7e8cb, index=f50, offset=8
    [junit] Test: DTLB, ffffffff9c7bce7a
    [junit] tag=7fce3de, index=0, offset=e7a
    [junit] Test: L1, ffffffffbd5b7e4a
    [junit] tag=fbd5b7, index=72, offset=a
    [junit] Test: L2, e4a8b91c1abc7826
    [junit] tag=60d5e, index=3c1, offset=6
    [junit] Test: DTLB, 56f96b96dfaf6a4
    [junit] tag=5cb6fd7, index=0, offset=16a4
    [junit] Test: L1, 57ac1b028ea116f
    [junit] tag=28ea1, index=b, offset=f
    [junit] Test: L2, 54f7aea470d318ee
    [junit] tag=23869, index=8c7, offset=e
    [junit] Test: DTLB, 43b5101776f22476
    [junit] tag=bbb791, index=0, offset=476
    [junit] Test: L1, ffffffff888fe18f
    [junit] tag=f888fe, index=c, offset=f
    [junit] Test: L2, 4b47c935526f1915
    [junit] tag=2a937, index=8c8, offset=15
    [junit] Test: DTLB, ffffffff8bbdc5a9
    [junit] tag=7fc5dee, index=0, offset=5a9
    [junit] Test: L1, ffffffffcee65adc
    [junit] tag=fcee65, index=56, offset=1c
    [junit] Test: L2, 18abe8fe7278ab81
    [junit] tag=7393c, index=55c, offset=1
    [junit] Test: DTLB, 266b44de421bf54a
    [junit] tag=6f210df, index=0, offset=154a
    [junit] Test: L1, e6c96b0e5dd200b7
    [junit] tag=e5dd20, index=5, offset=17
    [junit] Test: L2, ffffffffd7b66386
    [junit] tag=7ebdb, index=31c, offset=6
    [junit] Test: DTLB, fffffffff6f709e2
    [junit] tag=7ffb7b8, index=0, offset=9e2
    [junit] Test: L1, ffffffff820d031d
    [junit] tag=f820d0, index=18, offset=1d
    [junit] Test: L2, fffffffff7d8bebf
    [junit] tag=7fbec, index=5f5, offset=1f
    [junit] Test: DTLB, ffffffffc348fdbf
    [junit] tag=7fe1a47, index=0, offset=1dbf
    [junit] Test: L1, ffffffffed59c9cc
    [junit] tag=fed59c, index=4e, offset=c
    [junit] Test: L2, 515293661aba658e
    [junit] tag=30d5d, index=32c, offset=e
    [junit] Test: DTLB, ffffffffc7c4c164
    [junit] tag=7fe3e26, index=0, offset=164
    [junit] Test: L1, ffffffffd258e0ac
    [junit] tag=fd258e, index=5, offset=c
    [junit] Test: L2, ffffffffb61fa553
    [junit] tag=7db0f, index=d2a, offset=13
    [junit] Test: DTLB, 3f4f62ef13d3b6e0
    [junit] tag=7789e9d, index=0, offset=16e0
    [junit] Test: L1, ffffffff80107f3c
    [junit] tag=f80107, index=79, offset=1c
    [junit] Test: L2, 1f95a97655262f1f
    [junit] tag=32a93, index=178, offset=1f
    [junit] Test: DTLB, ffffffff8187818a
    [junit] tag=7fc0c3c, index=0, offset=18a
    [junit] Test: L1, ffffffffe3f55912
    [junit] tag=fe3f55, index=48, offset=12
    [junit] Test: L2, ffffffffdd607b5b
    [junit] tag=7eeb0, index=3da, offset=1b
    [junit] Test: DTLB, 665626424a1ca6e4
    [junit] tag=21250e5, index=0, offset=6e4
    [junit] Test: L1, ffffffffd6a08a4c
    [junit] tag=fd6a08, index=52, offset=c
    [junit] Test: L2, b94ce0f53f2acb29
    [junit] tag=29f95, index=659, offset=9
    [junit] Test: DTLB, ffffffffba094f2b
    [junit] tag=7fdd04a, index=0, offset=f2b
    [junit] Test: L1, ffffffffa2285026
    [junit] tag=fa2285, index=1, offset=6
    [junit] Test: L2, 78c353583af71264
    [junit] tag=41d7b, index=893, offset=4
    [junit] Test: DTLB, ffffffff9cac9775
    [junit] tag=7fce564, index=0, offset=1775
    [junit] Test: L1, ffffffffa514ea74
    [junit] tag=fa514e, index=53, offset=14
    [junit] Test: L2, 506d30564cc9011d
    [junit] tag=32664, index=808, offset=1d
    [junit] Test: DTLB, ffffffffa9ea4c64
    [junit] tag=7fd4f52, index=0, offset=c64
    [junit] Test: L1, ffffffffc2f6e62c
    [junit] tag=fc2f6e, index=31, offset=c
    [junit] Test: L2, 1fb6f80944bd5afa
    [junit] tag=4a25e, index=ad7, offset=1a
    [junit] Test: DTLB, afec3cc315a4587c
    [junit] tag=618ad22, index=0, offset=187c
    [junit] Test: L1, 36e66b2d0088b679
    [junit] tag=d0088b, index=33, offset=19
    [junit] Test: L2, ffffffffbf72d725
    [junit] tag=7dfb9, index=6b9, offset=5
    [junit] Test: DTLB, ffffffffc6dfcdfa
    [junit] tag=7fe36fe, index=0, offset=dfa
    [junit] Test: L1, ffffffffdee7c18a
    [junit] tag=fdee7c, index=c, offset=a
    [junit] Test: L2, ffffffffa465811e
    [junit] tag=7d232, index=c08, offset=1e
    [junit] Test: DTLB, ffffffffbab5e61b
    [junit] tag=7fdd5af, index=0, offset=61b
    [junit] Test: L1, ffffffffca6394d6
    [junit] tag=fca639, index=26, offset=16
    [junit] Test: L2, 3d8690aa52fef469
    [junit] tag=5297f, index=7a3, offset=9
    [junit] Test: DTLB, 888cbfa871633e77
    [junit] tag=5438b19, index=0, offset=1e77
    [junit] Test: L1, ffffffff8691d3f8
    [junit] tag=f8691d, index=1f, offset=18
    [junit] Test: L2, bbed7cd542d7b06b
    [junit] tag=2a16b, index=d83, offset=b
    [junit] Test: DTLB, f93a6dfa6e691d84
    [junit] tag=7d37348, index=0, offset=1d84
    [junit] Test: L1, 8b5f19a773ca3018
    [junit] tag=773ca3, index=0, offset=18
    [junit] Test: L2, ffffffffe2bf796b
    [junit] tag=7f15f, index=bcb, offset=b
    [junit] Test: DTLB, ffffffffe006a478
    [junit] tag=7ff0035, index=0, offset=478
    [junit] Test: L1, ffffffff9cd7a132
    [junit] tag=f9cd7a, index=9, offset=12
    [junit] Test: L2, ffffffffc5262f13
    [junit] tag=7e293, index=178, offset=13
    [junit] Test: DTLB, ffffffffeed04d4f
    [junit] tag=7ff7682, index=0, offset=d4f
    [junit] Test: L1, ffffffffc81df3ca
    [junit] tag=fc81df, index=1e, offset=a
    [junit] Test: L2, ffffffffdfbb04c1
    [junit] tag=7efdd, index=826, offset=1
    [junit] Test: DTLB, 8d459ac318830b5f
    [junit] tag=618c418, index=0, offset=b5f
    [junit] Test: L1, 40f2296640f504ec
    [junit] tag=640f50, index=27, offset=c
    [junit] Test: L2, ffffffff966460c1
    [junit] tag=7cb32, index=306, offset=1
    [junit] Test: DTLB, 848fefdf3c7e422d
    [junit] tag=6f9e3f2, index=0, offset=22d
    [junit] Test: L1, f5436d5f6f1702a1
    [junit] tag=f6f170, index=15, offset=1
    [junit] Test: L2, ffffffff9af661a4
    [junit] tag=7cd7b, index=30d, offset=4
    [junit] Test: DTLB, 4e8adb2b3ea5989f
    [junit] tag=159f52c, index=0, offset=189f
    [junit] Test: L1, ffffffff998e081f
    [junit] tag=f998e0, index=40, offset=1f
    [junit] Test: L2, ffffffffd4f543cc
    [junit] tag=7ea7a, index=a1e, offset=c
    [junit] Test: DTLB, ecfdac875355997a
    [junit] tag=43a9aac, index=0, offset=197a
    [junit] Test: L1, 5a6f9a111794dd49
    [junit] tag=11794d, index=6a, offset=9
    [junit] Test: L2, ffffffff8fc5bce4
    [junit] tag=7c7e2, index=de7, offset=4
    [junit] Test: DTLB, 233816c1091f1804
    [junit] tag=60848f8, index=0, offset=1804
    [junit] Test: L1, ffffffffdee89f4d
    [junit] tag=fdee89, index=7a, offset=d
    [junit] Test: L2, 38a53aab1b5bf196
    [junit] tag=58dad, index=f8c, offset=16
    [junit] Test: DTLB, d10ef3b04f0e4284
    [junit] tag=5827872, index=0, offset=284
    [junit] Test: L1, ffffffffbf5fa32a
    [junit] tag=fbf5fa, index=19, offset=a
    [junit] Test: L2, 5e030ea14f4f679
    [junit] tag=50a7a, index=7b3, offset=19
    [junit] Test: DTLB, ffffffffbaf84a51
    [junit] tag=7fdd7c2, index=0, offset=a51
    [junit] Test: L1, f4dab88b022f1396
    [junit] tag=b022f1, index=1c, offset=16
    [junit] Test: L2, fffffffff0d82257
    [junit] tag=7f86c, index=112, offset=17
    [junit] Test: DTLB, c3beb72a52751b93
    [junit] tag=15293a8, index=0, offset=1b93
    [junit] Test: L1, ffffffffacc56594
    [junit] tag=facc56, index=2c, offset=14
    [junit] Test: L2, ffffffff94dec73b
    [junit] tag=7ca6f, index=639, offset=1b
    [junit] Test: DTLB, ffffffffba6dc2fa
    [junit] tag=7fdd36e, index=0, offset=2fa
    [junit] Test: L1, f0c853eb7a5ee640
    [junit] tag=b7a5ee, index=32, offset=0
    [junit] Test: L2, 30a63cf16eefb22e
    [junit] tag=b777, index=d91, offset=e
    [junit] Test: DTLB, ffffffffd8c9af4f
    [junit] tag=7fec64d, index=0, offset=f4f
    [junit] Test: L1, ffffffffc042cddb
    [junit] tag=fc042c, index=6e, offset=1b
    [junit] Test: L2, cccef5fa0efc10a1
    [junit] tag=5077e, index=85, offset=1
    [junit] Test: DTLB, 89ada847030b5d7b
    [junit] tag=238185a, index=0, offset=1d7b
    [junit] Test: L1, ffffffffb51aa135
    [junit] tag=fb51aa, index=9, offset=15
    [junit] Test: L2, c16389c0092abc4a
    [junit] tag=495, index=5e2, offset=a
    [junit] Test: DTLB, 74a5b9ca0bcd77ae
    [junit] tag=6505e6b, index=0, offset=17ae
    [junit] Test: L1, 94cc8ee3346ce2bb
    [junit] tag=3346ce, index=15, offset=1b
    [junit] Test: L2, acec5ace2600e1e3
    [junit] tag=71300, index=70f, offset=3
    [junit] Test: DTLB, ffffffff8b6fee6d
    [junit] tag=7fc5b7f, index=0, offset=e6d
    [junit] Test: L1, 466bc98410cc94b1
    [junit] tag=410cc9, index=25, offset=11
    [junit] Test: L2, ffffffffa42b770b
    [junit] tag=7d215, index=bb8, offset=b
    [junit] Test: DTLB, b587cfd428d1b718
    [junit] tag=6a1468d, index=0, offset=1718
    [junit] Test: L1, a063a26c184ff79f
    [junit] tag=c184ff, index=3c, offset=1f
    [junit] Test: L2, 8fff914f4f0919f8
    [junit] tag=7a784, index=8cf, offset=18
    [junit] Test: DTLB, ffffffffd20048ab
    [junit] tag=7fe9002, index=0, offset=8ab
    [junit] Test: L1, 42caa91c3919760b
    [junit] tag=c39197, index=30, offset=b
    [junit] Test: L2, fffffffffc0775a4
    [junit] tag=7fe03, index=bad, offset=4
    [junit] Test: DTLB, 41b033af078abb74
    [junit] tag=5783c55, index=0, offset=1b74
    [junit] Test: L1, 9e4db90288e4a26
    [junit] tag=288e4, index=51, offset=6
    [junit] Test: L2, ffffffff8a2d589e
    [junit] tag=7c516, index=ac4, offset=1e
    [junit] Test: DTLB, 46a5e84a46a9173b
    [junit] tag=2523548, index=0, offset=173b
    [junit] Test: L1, ffffffffb6c5d769
    [junit] tag=fb6c5d, index=3b, offset=9
    [junit] Test: L2, ffffffffbe0f56d2
    [junit] tag=7df07, index=ab6, offset=12
    [junit] Test: DTLB, d8a6b48b4c7dec47
    [junit] tag=45a63ef, index=0, offset=c47
    [junit] Test: L1, d609dc0a188163ca
    [junit] tag=a18816, index=1e, offset=a
    [junit] Test: L2, c85e73f2596dd4f8
    [junit] tag=12cb6, index=ea7, offset=18
    [junit] Test: DTLB, 399c7e0f40d3c7
    [junit] tag=3f07a06, index=0, offset=13c7
    [junit] Test: L1, ffffffffa0a644bb
    [junit] tag=fa0a64, index=25, offset=1b
    [junit] Test: L2, ffffffffc0b18f26
    [junit] tag=7e058, index=c79, offset=6
    [junit] Test: DTLB, 4e3c5d1c313c6d93
    [junit] tag=e189e3, index=0, offset=d93
    [junit] Test: L1, ffffffff93b3dbf2
    [junit] tag=f93b3d, index=5f, offset=12
    [junit] Test: L2, ffffffffcb5176c1
    [junit] tag=7e5a8, index=bb6, offset=1
    [junit] Test: DTLB, 48f4cc341dcad96d
    [junit] tag=1a0ee56, index=0, offset=196d
    [junit] Test: L1, 181bc5d929885778
    [junit] tag=929885, index=3b, offset=18
    [junit] Test: L2, ffffffffcf938be8
    [junit] tag=7e7c9, index=c5f, offset=8
    [junit] Test: DTLB, ffffffffecc8aa7a
    [junit] tag=7ff6645, index=0, offset=a7a
    [junit] Test: L1, ffffffffb96d3942
    [junit] tag=fb96d3, index=4a, offset=2
    [junit] Test: L2, ffffffff8d303c12
    [junit] tag=7c698, index=1e0, offset=12
    [junit] Test: DTLB, 6470c491594503ff
    [junit] tag=48aca28, index=0, offset=3ff
    [junit] Test: L1, 72461eca01c5aed3
    [junit] tag=a01c5a, index=76, offset=13
    [junit] Test: L2, ffffffffbec5f9b4
    [junit] tag=7df62, index=fcd, offset=14
    [junit] Test: DTLB, ffffffffae0b59fb
    [junit] tag=7fd705a, index=0, offset=19fb
    [junit] Test: L1, 3eacdad530152299
    [junit] tag=530152, index=14, offset=19
    [junit] Test: L2, c27e242209049216
    [junit] tag=10482, index=490, offset=16
    [junit] Test: DTLB, fffffffffbab959f
    [junit] tag=7ffdd5c, index=0, offset=159f
    [junit] Test: L1, ffffffffde1c3be8
    [junit] tag=fde1c3, index=5f, offset=8
    [junit] Test: L2, ffffffffe5d5740f
    [junit] tag=7f2ea, index=ba0, offset=f
    [junit] Test: DTLB, ffffffffa3acd390
    [junit] tag=7fd1d66, index=0, offset=1390
    [junit] Test: L1, 90caf5d5537fab71
    [junit] tag=5537fa, index=5b, offset=11
    [junit] Test: L2, ffffffffcccdf813
    [junit] tag=7e666, index=fc0, offset=13
    [junit] Test: DTLB, 361a7be3337d72aa
    [junit] tag=7199beb, index=0, offset=12aa
    [junit] Test: L1, 1ab48f7d4f43c359
    [junit] tag=d4f43c, index=1a, offset=19
    [junit] Test: L2, ffffffff8a188e42
    [junit] tag=7c50c, index=472, offset=2
    [junit] Test: DTLB, ffffffffee31c575
    [junit] tag=7ff718e, index=0, offset=575
    [junit] Test: L1, c973bc3c7ea3d0f4
    [junit] tag=c7ea3d, index=7, offset=14
    [junit] Test: L2, ffffffff9b79fd5a
    [junit] tag=7cdbc, index=fea, offset=1a
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,266 sec
    [junit] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,266 sec
    [junit] ------------- Standard Output ---------------
    [junit] Test: DTLB, ffffffffdafc2ff7
    [junit] tag=7fed7e1, index=0, offset=ff7
    [junit] Test: L1, ffffffff9e10d5a4
    [junit] tag=f9e10d, index=2d, offset=4
    [junit] Test: L2, 521270865eb88a2d
    [junit] tag=32f5c, index=451, offset=d
    [junit] Test: DTLB, 59ae81255f0e9113
    [junit] tag=12af874, index=0, offset=1113
    [junit] Test: L1, c5c7a797441c2cc5
    [junit] tag=7441c2, index=66, offset=5
    [junit] Test: L2, ffffffffcef337d7
    [junit] tag=7e779, index=9be, offset=17
    [junit] Test: DTLB, 69f957f32e300696
    [junit] tag=7997180, index=0, offset=696
    [junit] Test: L1, 2642d0bb77bc5ff2
    [junit] tag=b77bc5, index=7f, offset=12
    [junit] Test: L2, 228da1c463709103
    [junit] tag=231b8, index=488, offset=3
    [junit] Test: DTLB, ffffffffbe2ccab6
    [junit] tag=7fdf166, index=0, offset=ab6
    [junit] Test: L1, ffffffffd861c39e
    [junit] tag=fd861c, index=1c, offset=1e
    [junit] Test: L2, 91c3b97b1630ad7b
    [junit] tag=58b18, index=56b, offset=1b
    [junit] Test: DTLB, fffffffffa47f53c
    [junit] tag=7ffd23f, index=0, offset=153c
    [junit] Test: L1, ffffffff98381938
    [junit] tag=f98381, index=49, offset=18
    [junit] Test: L2, 2968c08d5db55368
    [junit] tag=6aeda, index=a9b, offset=8
    [junit] Test: DTLB, ffffffffd38fde1b
    [junit] tag=7fe9c7e, index=0, offset=1e1b
    [junit] Test: L1, ffffffffb9bf7940
    [junit] tag=fb9bf7, index=4a, offset=0
    [junit] Test: L2, ffffffffa40298a0
    [junit] tag=7d201, index=4c5, offset=0
    [junit] Test: DTLB, b2e39a7f1d8556a3
    [junit] tag=3f8ec2a, index=0, offset=16a3
    [junit] Test: L1, 46021907033acf9
    [junit] tag=7033a, index=67, offset=19
    [junit] Test: L2, ffffffff9fb6cc2b
    [junit] tag=7cfdb, index=661, offset=b
    [junit] Test: DTLB, 5fa38561717c1c8b
    [junit] tag=30b8be0, index=0, offset=1c8b
    [junit] Test: L1, ffffffffea045bf4
    [junit] tag=fea045, index=5f, offset=14
    [junit] Test: L2, ffffffffe6154388
    [junit] tag=7f30a, index=a1c, offset=8
    [junit] Test: DTLB, ffffffffa3e958e8
    [junit] tag=7fd1f4a, index=0, offset=18e8
    [junit] Test: L1, ffffffff9601ae95
    [junit] tag=f9601a, index=74, offset=15
    [junit] Test: L2, ffffffffe248d11e
    [junit] tag=7f124, index=688, offset=1e
    [junit] Test: DTLB, 1050f2222a128969
    [junit] tag=1115094, index=0, offset=969
    [junit] Test: L1, ffffffff8447950b
    [junit] tag=f84479, index=28, offset=b
    [junit] Test: L2, dd1483651a10581d
    [junit] tag=28d08, index=2c0, offset=1d
    [junit] Test: DTLB, 43a910087223f2cc
    [junit] tag=43911f, index=0, offset=12cc
    [junit] Test: L1, ffffffffafba7814
    [junit] tag=fafba7, index=40, offset=14
    [junit] Test: L2, a416c3665c29b5c4
    [junit] tag=32e14, index=dae, offset=4
    [junit] Test: DTLB, ffffffffc67be4ae
    [junit] tag=7fe33df, index=0, offset=4ae
    [junit] Test: L1, ceb1ea433c3b93f
    [junit] tag=433c3b, index=49, offset=1f
    [junit] Test: L2, ffffffff8876e1c7
    [junit] tag=7c43b, index=70e, offset=7
    [junit] Test: DTLB, ffffffffba585247
    [junit] tag=7fdd2c2, index=0, offset=1247
    [junit] Test: L1, 3689a355747090e8
    [junit] tag=574709, index=7, offset=8
    [junit] Test: L2, ffffffff9575181c
    [junit] tag=7caba, index=8c0, offset=1c
    [junit] Test: DTLB, 643c7280b99827c
    [junit] tag=1405ccc, index=0, offset=27c
    [junit] Test: L1, ffffffffd75646b1
    [junit] tag=fd7564, index=35, offset=11
    [junit] Test: L2, a71b79bc62f839ae
    [junit] tag=6317c, index=1cd, offset=e
    [junit] Test: DTLB, c6e20d3624ce728
    [junit] tag=69b1267, index=0, offset=728
    [junit] Test: L1, 102457ed6055612f
    [junit] tag=d60556, index=9, offset=f
    [junit] Test: L2, ffffffff995223c5
    [junit] tag=7cca9, index=11e, offset=5
    [junit] Test: DTLB, ffffffffb85fefb1
    [junit] tag=7fdc2ff, index=0, offset=fb1
    [junit] Test: L1, ffffffffd0bf8ba6
    [junit] tag=fd0bf8, index=5d, offset=6
    [junit] Test: L2, 2edd874760ad8820
    [junit] tag=3b056, index=c41, offset=0
    [junit] Test: DTLB, 46535b6c1dddf2f8
    [junit] tag=360eeef, index=0, offset=12f8
    [junit] Test: L1, 898c8fe04aa98766
    [junit] tag=4aa98, index=3b, offset=6
    [junit] Test: L2, 6dc4bfad7a010390
    [junit] tag=6bd00, index=81c, offset=10
    [junit] Test: DTLB, ffffffffbffbe757
    [junit] tag=7fdffdf, index=0, offset=757
    [junit] Test: L1, a3022ded01e6e66c
    [junit] tag=d01e6e, index=33, offset=c
    [junit] Test: L2, f0632c15aa83811
    [junit] tag=ad54, index=1c0, offset=11
    [junit] Test: DTLB, dafa50b557870d46
    [junit] tag=5aabc38, index=0, offset=d46
    [junit] Test: L1, ffffffffd3f3ae91
    [junit] tag=fd3f3a, index=74, offset=11
    [junit] Test: L2, 36d6ffc64c16769
    [junit] tag=63260, index=b3b, offset=9
    [junit] Test: DTLB, 9c073e316e708678
    [junit] tag=18b7384, index=0, offset=678
    [junit] Test: L1, ffffffffd21b2b3c
    [junit] tag=fd21b2, index=59, offset=1c
    [junit] Test: L2, 5c11795304667bc1
    [junit] tag=18233, index=3de, offset=1
    [junit] Test: DTLB, ffffffff8cddc554
    [junit] tag=7fc66ee, index=0, offset=554
    [junit] Test: L1, ffffffffdfd2f6ba
    [junit] tag=fdfd2f, index=35, offset=1a
    [junit] Test: L2, be05416c10e763c6
    [junit] tag=60873, index=b1e, offset=6
    [junit] Test: DTLB, fffffffff7a95ac0
    [junit] tag=7ffbd4a, index=0, offset=1ac0
    [junit] Test: L1, e566597418b0dcd1
    [junit] tag=418b0d, index=66, offset=11
    [junit] Test: L2, bbfba5f95e981a02
    [junit] tag=4af4c, index=d0, offset=2
    [junit] Test: DTLB, c97d28c14943b456
    [junit] tag=60a4a1d, index=0, offset=1456
    [junit] Test: L1, ffffffff93c41b4f
    [junit] tag=f93c41, index=5a, offset=f
    [junit] Test: L2, d222943d4f45d92d
    [junit] tag=6a7a2, index=ec9, offset=d
    [junit] Test: DTLB, d39575d37fc6bd1b
    [junit] tag=69bfe35, index=0, offset=1d1b
    [junit] Test: L1, ffffffffce575329
    [junit] tag=fce575, index=19, offset=9
    [junit] Test: L2, ffffffff9e1ed6ae
    [junit] tag=7cf0f, index=6b5, offset=e
    [junit] Test: DTLB, ffffffffe2a2c360
    [junit] tag=7ff1516, index=0, offset=360
    [junit] Test: L1, 6f4048fe2e8af295
    [junit] tag=e2e8af, index=14, offset=15
    [junit] Test: L2, ffffffffc9c2637d
    [junit] tag=7e4e1, index=31b, offset=1d
    [junit] Test: DTLB, 139d11de6f65be94
    [junit] tag=6f37b2d, index=0, offset=1e94
    [junit] Test: L1, f7140c7400ec4cf1
    [junit] tag=400ec4, index=67, offset=11
    [junit] Test: L2, ac20432ceda2a3
    [junit] tag=19676, index=d15, offset=3
    [junit] Test: DTLB, ffffffffbd34df15
    [junit] tag=7fde9a6, index=0, offset=1f15
    [junit] Test: L1, fffffffff7de347c
    [junit] tag=ff7de3, index=23, offset=1c
    [junit] Test: L2, f1bdfda97fdb2b16
    [junit] tag=4bfed, index=958, offset=16
    [junit] Test: DTLB, d7d434440ec8ec4
    [junit] tag=2220764, index=0, offset=ec4
    [junit] Test: L1, ffffffffec410517
    [junit] tag=fec410, index=28, offset=17
    [junit] Test: L2, ffffffff8cc20532
    [junit] tag=7c661, index=29, offset=12
    [junit] Test: DTLB, 37cc44864bf99330
    [junit] tag=4325fcc, index=0, offset=1330
    [junit] Test: L1, 7ed04a7e315ae453
    [junit] tag=e315ae, index=22, offset=13
    [junit] Test: L2, ffffffffb4d7f9d8
    [junit] tag=7da6b, index=fce, offset=18
    [junit] Test: DTLB, ffffffffbb079dac
    [junit] tag=7fdd83c, index=0, offset=1dac
    [junit] Test: L1, 756240e840ddae36
    [junit] tag=840dda, index=71, offset=16
    [junit] Test: L2, ffffffffee27e3b3
    [junit] tag=7f713, index=f1d, offset=13
    [junit] Test: DTLB, 83fd18f71924c128
    [junit] tag=7b8c926, index=0, offset=128
    [junit] Test: L1, ffffffff9c98a3f0
    [junit] tag=f9c98a, index=1f, offset=10
    [junit] Test: L2, 67749e0a3b9e9606
    [junit] tag=51dcf, index=4b0, offset=6
    [junit] Test: DTLB, 2c64c8ca0e027f8c
    [junit] tag=6507013, index=0, offset=1f8c
    [junit] Test: L1, e3bd51e11d61e6f9
    [junit] tag=11d61e, index=37, offset=19
    [junit] Test: L2, 812efaaa4ea18f77
    [junit] tag=52750, index=c7b, offset=17
    [junit] Test: DTLB, ffffffffbf149c5f
    [junit] tag=7fdf8a4, index=0, offset=1c5f
    [junit] Test: L1, ffffffffacbdd601
    [junit] tag=facbdd, index=30, offset=1
    [junit] Test: L2, ffffffff93c8ecf2
    [junit] tag=7c9e4, index=767, offset=12
    [junit] Test: DTLB, bf26236562048818
    [junit] tag=32b1024, index=0, offset=818
    [junit] Test: L1, ffffffffee92a6a7
    [junit] tag=fee92a, index=35, offset=7
    [junit] Test: L2, fffffffff1d8a8b4
    [junit] tag=7f8ec, index=545, offset=14
    [junit] Test: DTLB, 49f3d9646dd6d36e
    [junit] tag=3236eb6, index=0, offset=136e
    [junit] Test: L1, 641611f866b46864
    [junit] tag=866b46, index=43, offset=4
    [junit] Test: L2, ffffffff9b2e97c5
    [junit] tag=7cd97, index=4be, offset=5
    [junit] Test: DTLB, ffffffffbb6a4c4d
    [junit] tag=7fddb52, index=0, offset=c4d
    [junit] Test: L1, ffffffffca981d3a
    [junit] tag=fca981, index=69, offset=1a
    [junit] Test: L2, 50a8b735635fd1a4
    [junit] tag=2b1af, index=e8d, offset=4
    [junit] Test: DTLB, ffffffff8e592eaa
    [junit] tag=7fc72c9, index=0, offset=eaa
    [junit] Test: L1, 9bf371e83a0e3cfc
    [junit] tag=83a0e3, index=67, offset=1c
    [junit] Test: L2, ffffffff8075e83d
    [junit] tag=7c03a, index=f41, offset=1d
    [junit] Test: DTLB, ffffffff9ad34496
    [junit] tag=7fcd69a, index=0, offset=496
    [junit] Test: L1, ffffffff8dc5ab41
    [junit] tag=f8dc5a, index=5a, offset=1
    [junit] Test: L2, ffffffff8d76fc1a
    [junit] tag=7c6bb, index=7e0, offset=1a
    [junit] Test: DTLB, 54e3d30c4d616525
    [junit] tag=626b0b, index=0, offset=525
    [junit] Test: L1, ffffffffde33a774
    [junit] tag=fde33a, index=3b, offset=14
    [junit] Test: L2, 1e7afda8490c2c15
    [junit] tag=42486, index=160, offset=15
    [junit] Test: DTLB, e260cdfb1871cc67
    [junit] tag=7d8c38e, index=0, offset=c67
    [junit] Test: L1, 634696de7febbd52
    [junit] tag=e7febb, index=6a, offset=12
    [junit] Test: L2, fffffffff8a6e8b6
    [junit] tag=7fc53, index=745, offset=16
    [junit] Test: DTLB, ffffffffb23a19dc
    [junit] tag=7fd91d0, index=0, offset=19dc
    [junit] Test: L1, ffffffffb74f2af5
    [junit] tag=fb74f2, index=57, offset=15
    [junit] Test: L2, 1acacd1b02a0e5e7
    [junit] tag=58150, index=72f, offset=7
    [junit] Test: DTLB, 7880a15a4827da60
    [junit] tag=2d2413e, index=0, offset=1a60
    [junit] Test: L1, 7d679f1a4cd6d82d
    [junit] tag=a4cd6d, index=41, offset=d
    [junit] Test: L2, f6caaa585c763e90
    [junit] tag=42e3b, index=1f4, offset=10
    [junit] Test: DTLB, ffffffffc982c00a
    [junit] tag=7fe4c16, index=0, offset=a
    [junit] Test: L1, ffffffffac51e6ff
    [junit] tag=fac51e, index=37, offset=1f
    [junit] Test: L2, ffffffffa4d8f962
    [junit] tag=7d26c, index=7cb, offset=2
    [junit] Test: DTLB, 7f99574f210e0b83
    [junit] tag=2790870, index=0, offset=b83
    [junit] Test: L1, fffffffff5cb9a69
    [junit] tag=ff5cb9, index=53, offset=9
    [junit] Test: L2, ffffffffd6be4239
    [junit] tag=7eb5f, index=211, offset=19
    [junit] Test: DTLB, 179f2def39992fb0
    [junit] tag=779ccc9, index=0, offset=fb0
    [junit] Test: L1, fffffffff6fcc7c3
    [junit] tag=ff6fcc, index=3e, offset=3
    [junit] Test: L2, c04e4fdc53f92ecc
    [junit] tag=629fc, index=976, offset=c
    [junit] Test: DTLB, ffffffffb366beb8
    [junit] tag=7fd9b35, index=0, offset=1eb8
    [junit] Test: L1, ecceace03484983d
    [junit] tag=34849, index=41, offset=1d
    [junit] Test: L2, ffffffff9e29f252
    [junit] tag=7cf14, index=f92, offset=12
    [junit] Test: DTLB, fffffffff39d18e5
    [junit] tag=7ff9ce8, index=0, offset=18e5
    [junit] Test: L1, ffffffffc80616b7
    [junit] tag=fc8061, index=35, offset=17
    [junit] Test: L2, ffffffff90b1b116
    [junit] tag=7c858, index=d88, offset=16
    [junit] Test: DTLB, ece4997535617792
    [junit] tag=3a9ab0b, index=0, offset=1792
    [junit] Test: L1, ffffffffb7f3da14
    [junit] tag=fb7f3d, index=50, offset=14
    [junit] Test: L2, bc07e89c34383a91
    [junit] tag=61a1c, index=1d4, offset=11
    [junit] Test: DTLB, ffffffffb7675da7
    [junit] tag=7fdbb3a, index=0, offset=1da7
    [junit] Test: L1, ffffffffdb3a5e19
    [junit] tag=fdb3a5, index=70, offset=19
    [junit] Test: L2, 775bcd72744b1c70
    [junit] tag=13a25, index=8e3, offset=10
    [junit] Test: DTLB, f0c1f80875257756
    [junit] tag=43a92b, index=0, offset=1756
    [junit] Test: L1, ffffffffa8ab5e19
    [junit] tag=fa8ab5, index=70, offset=19
    [junit] Test: L2, 618341b17b2622e4
    [junit] tag=bd93, index=117, offset=4
    [junit] Test: DTLB, 4507bfe975258b5f
    [junit] tag=74ba92c, index=0, offset=b5f
    [junit] Test: L1, fefeae695361e8ed
    [junit] tag=95361e, index=47, offset=d
    [junit] Test: L2, c0ccb9d167f5577e
    [junit] tag=b3fa, index=abb, offset=1e
    [junit] Test: DTLB, 686ea7c508077078
    [junit] tag=628403b, index=0, offset=1078
    [junit] Test: L1, 959bc58d7764ca1f
    [junit] tag=d7764c, index=50, offset=1f
    [junit] Test: L2, ffffffffe4f77cd4
    [junit] tag=7f27b, index=be6, offset=14
    [junit] Test: DTLB, ffffffffa60030f6
    [junit] tag=7fd3001, index=0, offset=10f6
    [junit] Test: L1, 12dad02e2c9ac870
    [junit] tag=e2c9ac, index=43, offset=10
    [junit] Test: L2, 82af4b0b05cff5b0
    [junit] tag=582e7, index=fad, offset=10
    [junit] Test: DTLB, c5bdb63159c22549
    [junit] tag=18ace11, index=0, offset=549
    [junit] Test: L1, f6a9936c4354e016
    [junit] tag=c4354e, index=0, offset=16
    [junit] Test: L2, 7320058c7b14bd00
    [junit] tag=63d8a, index=5e8, offset=0
    [junit] Test: DTLB, ea054ce562cc980d
    [junit] tag=72b1664, index=0, offset=180d
    [junit] Test: L1, ffffffff98b80505
    [junit] tag=f98b80, index=28, offset=5
    [junit] Test: L2, 7449d10e2a0d51d6
    [junit] tag=71506, index=a8e, offset=16
    [junit] Test: DTLB, ee929a764da53146
    [junit] tag=3b26d29, index=0, offset=1146
    [junit] Test: L1, ffffffffb3a81d90
    [junit] tag=fb3a81, index=6c, offset=10
    [junit] Test: L2, ffffffffd0ec66cb
    [junit] tag=7e876, index=336, offset=b
    [junit] Test: DTLB, ffffffffb624897f
    [junit] tag=7fdb124, index=0, offset=97f
    [junit] Test: L1, c247884479f23ca3
    [junit] tag=479f23, index=65, offset=3
    [junit] Test: L2, ffffffffda57ee2c
    [junit] tag=7ed2b, index=f71, offset=c
    [junit] Test: DTLB, ffffffff8ceb6d28
    [junit] tag=7fc675b, index=0, offset=d28
    [junit] Test: L1, ffffffffa9173ac5
    [junit] tag=fa9173, index=56, offset=5
    [junit] Test: L2, fffffffff46d4e32
    [junit] tag=7fa36, index=a71, offset=12
    [junit] Test: DTLB, ffffffff9504d0fd
    [junit] tag=7fca826, index=0, offset=10fd
    [junit] Test: L1, 54bbc7e76d888a30
    [junit] tag=76d888, index=51, offset=10
    [junit] Test: L2, 14fe8703489e1783
    [junit] tag=1a44f, index=bc, offset=3
    [junit] Test: DTLB, ffffffff83a0f663
    [junit] tag=7fc1d07, index=0, offset=1663
    [junit] Test: L1, 9bc754142ab2cd38
    [junit] tag=42ab2c, index=69, offset=18
    [junit] Test: L2, fffffffff0392e98
    [junit] tag=7f81c, index=974, offset=18
    [junit] Test: DTLB, ba6ef90d29991553
    [junit] tag=694cc8, index=0, offset=1553
    [junit] Test: L1, cece980c6b678110
    [junit] tag=c6b678, index=8, offset=10
    [junit] Test: L2, ffffffffae093d8a
    [junit] tag=7d704, index=9ec, offset=a
    [junit] Test: DTLB, ffffffffcca0d27a
    [junit] tag=7fe6506, index=0, offset=127a
    [junit] Test: L1, ffffffff97f88a17
    [junit] tag=f97f88, index=50, offset=17
    [junit] Test: L2, ffffffff9681bb04
    [junit] tag=7cb40, index=dd8, offset=4
    [junit] Test: DTLB, a5fee79d3f966635
    [junit] tag=4e9fcb3, index=0, offset=635
    [junit] Test: L1, fffffffff47e0e94
    [junit] tag=ff47e0, index=74, offset=14
    [junit] Test: L2, 711663681fd61c33
    [junit] tag=40feb, index=e1, offset=13
    [junit] Test: DTLB, ffffffffaead7640
    [junit] tag=7fd756b, index=0, offset=1640
    [junit] Test: L1, d6f934017e6301e9
    [junit] tag=17e630, index=f, offset=9
    [junit] Test: L2, 2751bdfe64964b6d
    [junit] tag=7324b, index=25b, offset=d
    [junit] Test: DTLB, 6fdbaa2a3b2662dd
    [junit] tag=151d933, index=0, offset=2dd
    [junit] Test: L1, 9e65d9760ac1b662
    [junit] tag=60ac1b, index=33, offset=2
    [junit] Test: L2, ffffffffce4232bf
    [junit] tag=7e721, index=195, offset=1f
    [junit] Test: DTLB, ffffffffb4977f6d
    [junit] tag=7fda4bb, index=0, offset=1f6d
    [junit] Test: L1, 8a227d834b63025f
    [junit] tag=34b630, index=12, offset=1f
    [junit] Test: L2, 187643cf4921ba2f
    [junit] tag=7a490, index=dd1, offset=f
    [junit] Test: DTLB, 7d50c4681ce0ea96
    [junit] tag=340e707, index=0, offset=a96
    [junit] Test: L1, ffffffffc6340992
    [junit] tag=fc6340, index=4c, offset=12
    [junit] Test: L2, ffffffffeff7ca87
    [junit] tag=7f7fb, index=e54, offset=7
    [junit] Test: DTLB, ffffffffc13342f4
    [junit] tag=7fe099a, index=0, offset=2f4
    [junit] Test: L1, 408f9c05225e490f
    [junit] tag=5225e4, index=48, offset=f
    [junit] Test: L2, ffffffff9010db9c
    [junit] tag=7c808, index=6dc, offset=1c
    [junit] Test: DTLB, d4c0eb692093cd4f
    [junit] tag=349049e, index=0, offset=d4f
    [junit] Test: L1, ffffffff96bcae5e
    [junit] tag=f96bca, index=72, offset=1e
    [junit] Test: L2, d18001f97daaa051
    [junit] tag=4bed5, index=502, offset=11
    [junit] Test: DTLB, fffffffff3e478e1
    [junit] tag=7ff9f23, index=0, offset=18e1
    [junit] Test: L1, ffffffffb52b764f
    [junit] tag=fb52b7, index=32, offset=f
    [junit] Test: L2, ffffffff85697550
    [junit] tag=7c2b4, index=baa, offset=10
    [junit] Test: DTLB, 97e5112171df943
    [junit] tag=90b8ef, index=0, offset=1943
    [junit] Test: L1, ffffffffd23674fb
    [junit] tag=fd2367, index=27, offset=1b
    [junit] Test: L2, ffffffff9153416b
    [junit] tag=7c8a9, index=a0b, offset=b
    [junit] Test: DTLB, ffffffff9aba6ce9
    [junit] tag=7fcd5d3, index=0, offset=ce9
    [junit] Test: L1, ba00a61a729f537e
    [junit] tag=a729f5, index=1b, offset=1e
    [junit] Test: L2, ffffffffc33d27ec
    [junit] tag=7e19e, index=93f, offset=c
    [junit] Test: DTLB, ffffffffd36964d9
    [junit] tag=7fe9b4b, index=0, offset=4d9
    [junit] Test: L1, 8d295b684137f5b2
    [junit] tag=84137f, index=2d, offset=12
    [junit] Test: L2, ffffffff9018fd23
    [junit] tag=7c80c, index=7e9, offset=3
    [junit] Test: DTLB, f1eaf8c07333d2cb
    [junit] tag=603999e, index=0, offset=12cb
    [junit] Test: L1, 4ac0d7971b355e84
    [junit] tag=71b355, index=74, offset=4
    [junit] Test: L2, 5ab53bb14c7e2f21
    [junit] tag=a63f, index=179, offset=1
    [junit] Test: DTLB, ffffffff95eb7136
    [junit] tag=7fcaf5b, index=0, offset=1136
    [junit] Test: L1, 6bbf84f5541d88ae
    [junit] tag=5541d8, index=45, offset=e
    [junit] Test: L2, ffffffffab1d009a
    [junit] tag=7d58e, index=804, offset=1a
    [junit] Test: DTLB, 63ebd3b240299b41
    [junit] tag=592014c, index=0, offset=1b41
    [junit] Test: L1, ffffffff8e29581d
    [junit] tag=f8e295, index=40, offset=1d
    [junit] Test: L2, ffffffff8df96e99
    [junit] tag=7c6fc, index=b74, offset=19
    [junit] Test: DTLB, ffffffffd6f6a78d
    [junit] tag=7feb7b5, index=0, offset=78d
    [junit] Test: L1, ffffffff80f706d7
    [junit] tag=f80f70, index=36, offset=17
    [junit] Test: L2, c3dec9f15b43b1a5
    [junit] tag=ada1, index=d8d, offset=5
    [junit] Test: DTLB, 607bc274602f3f14
    [junit] tag=3a30179, index=0, offset=1f14
    [junit] Test: L1, 7a56b9266151aae5
    [junit] tag=66151a, index=57, offset=5
    [junit] Test: L2, b973cb02059ada8e
    [junit] tag=102cd, index=6d4, offset=e
    [junit] Test: DTLB, c1f7043e2a36e281
    [junit] tag=1f151b7, index=0, offset=281
    [junit] Test: L1, 784715ca3dc61834
    [junit] tag=a3dc61, index=41, offset=14
    [junit] Test: L2, ffffffffda3047b9
    [junit] tag=7ed18, index=23d, offset=19
    [junit] Test: DTLB, a01d41a24750f9df
    [junit] tag=5123a87, index=0, offset=19df
    [junit] Test: L1, ffffffffc2cc0da6
    [junit] tag=fc2cc0, index=6d, offset=6
    [junit] Test: L2, fffffffff4b162ad
    [junit] tag=7fa58, index=b15, offset=d
    [junit] Test: DTLB, ffffffff8cbe641c
    [junit] tag=7fc65f3, index=0, offset=41c
    [junit] Test: L1, ffffffff97eea8bd
    [junit] tag=f97eea, index=45, offset=1d
    [junit] Test: L2, 76c1887f1694a236
    [junit] tag=78b4a, index=511, offset=16
    [junit] Test: DTLB, a139a0830e038da3
    [junit] tag=418701c, index=0, offset=da3
    [junit] Test: L1, 97ad5efb379b610d
    [junit] tag=b379b6, index=8, offset=d
    [junit] Test: L2, ffffffff9919663c
    [junit] tag=7cc8c, index=b31, offset=1c
    [junit] Test: DTLB, d71651582acdebc1
    [junit] tag=2c1566f, index=0, offset=bc1
    [junit] Test: L1, fb7042116a9ebadb
    [junit] tag=16a9eb, index=56, offset=1b
    [junit] Test: L2, c7dd56aa3f84fb6a
    [junit] tag=51fc2, index=7db, offset=a
    [junit] Test: DTLB, 6c1f298333c4ccf8
    [junit] tag=4199e26, index=0, offset=cf8
    [junit] Test: L1, ffffffffa8ecb0bf
    [junit] tag=fa8ecb, index=5, offset=1f
    [junit] Test: L2, f2ab1541721ebd4
    [junit] tag=20b90, index=f5e, offset=14
    [junit] Test: DTLB, ffffffffa0a8b262
    [junit] tag=7fd0545, index=0, offset=1262
    [junit] Test: L1, b44801d5318a97cd
    [junit] tag=5318a9, index=3e, offset=d
    [junit] Test: L2, 35f6309c4f968792
    [junit] tag=627cb, index=43c, offset=12
    [junit] Test: DTLB, fffffffffc9f95f9
    [junit] tag=7ffe4fc, index=0, offset=15f9
    [junit] Test: L1, 2f1797744a9c96c9
    [junit] tag=44a9c9, index=36, offset=9
    [junit] Test: L2, ffffffffa97e3324
    [junit] tag=7d4bf, index=199, offset=4
    [junit] Test: DTLB, ffffffff8a49d795
    [junit] tag=7fc524e, index=0, offset=1795
    [junit] Test: L1, ffffffffd0c7c0ed
    [junit] tag=fd0c7c, index=7, offset=d
    [junit] Test: L2, ffffffffc6968c78
    [junit] tag=7e34b, index=463, offset=18
    [junit] Test: DTLB, abb934f931d14335
    [junit] tag=7c98e8a, index=0, offset=335
    [junit] Test: L1, ffffffffc0629c11
    [junit] tag=fc0629, index=60, offset=11
    [junit] Test: L2, 2e2c471f1331e309
    [junit] tag=78998, index=f18, offset=9
    [junit] Test: DTLB, b9eb808841d59200
    [junit] tag=4420eac, index=0, offset=1200
    [junit] Test: L1, fffffffff8d55068
    [junit] tag=ff8d55, index=3, offset=8
    [junit] Test: L2, ffffffff81efad24
    [junit] tag=7c0f7, index=d69, offset=4
    [junit] Test: DTLB, ffffffff86eff352
    [junit] tag=7fc377f, index=0, offset=1352
    [junit] Test: L1, fffffffff1da33a5
    [junit] tag=ff1da3, index=1d, offset=5
    [junit] Test: L2, 255ac23c393d6ebb
    [junit] tag=61c9e, index=b75, offset=1b
    [junit] Test: DTLB, 12a225e31f73cb1c
    [junit] tag=718fb9e, index=0, offset=b1c
    [junit] Test: L1, c3e062e348f49bec
    [junit] tag=348f49, index=5f, offset=c
    [junit] Test: L2, ffffffffdf68d9c4
    [junit] tag=7efb4, index=6ce, offset=4
    [junit] Test: DTLB, ffffffffe1e2b2dd
    [junit] tag=7ff0f15, index=0, offset=12dd
    [junit] Test: L1, b1379dcf25cf5e3e
    [junit] tag=f25cf5, index=71, offset=1e
    [junit] Test: L2, ffffffffda4e1ba3
    [junit] tag=7ed27, index=dd, offset=3
    [junit] Test: DTLB, fffffffff3e95487
    [junit] tag=7ff9f4a, index=0, offset=1487
    [junit] Test: L1, ffffffff9435a750
    [junit] tag=f9435a, index=3a, offset=10
    [junit] Test: L2, ffffffff85db6c4f
    [junit] tag=7c2ed, index=b62, offset=f
    [junit] Test: DTLB, 6543595821d90d35
    [junit] tag=2c10ec8, index=0, offset=d35
    [junit] Test: L1, ffffffffa66255f2
    [junit] tag=fa6625, index=2f, offset=12
    [junit] Test: L2, fe6452e904c4b9e2
    [junit] tag=48262, index=5cf, offset=2
    [junit] Test: DTLB, a029a19c5783cf23
    [junit] tag=4e2bc1e, index=0, offset=f23
    [junit] Test: L1, df58728c151e7b87
    [junit] tag=c151e7, index=5c, offset=7
    [junit] Test: L2, ffffffffb20922ab
    [junit] tag=7d904, index=915, offset=b
    [junit] Test: DTLB, ffffffffc57c1422
    [junit] tag=7fe2be0, index=0, offset=1422
    [junit] Test: L1, ffffffffdb2c5aee
    [junit] tag=fdb2c5, index=57, offset=e
    [junit] Test: L2, 7724d48e3a1ad5f9
    [junit] tag=71d0d, index=6af, offset=19
    [junit] Test: DTLB, 7d1420492c33a198
    [junit] tag=249619d, index=0, offset=198
    [junit] Test: L1, d4ed91b4558a144a
    [junit] tag=4558a1, index=22, offset=a
    [junit] Test: L2, 4d205bbc3652e54e
    [junit] tag=61b29, index=72a, offset=e
    [junit] Test: DTLB, ffffffff87e69df5
    [junit] tag=7fc3f34, index=0, offset=1df5
    [junit] Test: L1, ffffffff9299c1fe
    [junit] tag=f9299c, index=f, offset=1e
    [junit] Test: L2, fffffffff1e2fcb7
    [junit] tag=7f8f1, index=7e5, offset=17
    [junit] Test: DTLB, ffffffff81aaa787
    [junit] tag=7fc0d55, index=0, offset=787
    [junit] Test: L1, ffffffffb5f52a5f
    [junit] tag=fb5f52, index=52, offset=1f
    [junit] Test: L2, ffffffffe8e3adef
    [junit] tag=7f471, index=d6f, offset=f
    [junit] Test: DTLB, 805c9bbb75925840
    [junit] tag=5dbac92, index=0, offset=1840
    [junit] Test: L1, ffffffffbf8c87d9
    [junit] tag=fbf8c8, index=3e, offset=19
    [junit] Test: L2, ffffffff95a0f54f
    [junit] tag=7cad0, index=7aa, offset=f
    [junit] Test: DTLB, 9efc987d3ccfae65
    [junit] tag=3e9e67d, index=0, offset=e65
    [junit] Test: L1, 32fd66a92cebf084
    [junit] tag=92cebf, index=4, offset=4
    [junit] Test: L2, 62d683fe5e1ff894
    [junit] tag=72f0f, index=fc4, offset=14
    [junit] Test: DTLB, ffffffffe98921de
    [junit] tag=7ff4c49, index=0, offset=1de
    [junit] Test: L1, ffffffffaa5a1ef9
    [junit] tag=faa5a1, index=77, offset=19
    [junit] Test: L2, 90fc60b171ad61cb
    [junit] tag=b8d6, index=b0e, offset=b
    [junit] Test: DTLB, ef92ad6b2c2e69a7
    [junit] tag=3596173, index=0, offset=9a7
    [junit] Test: L1, 3321896622a76fa8
    [junit] tag=622a76, index=7d, offset=8
    [junit] Test: L2, ab42557a4d7b1f00
    [junit] tag=526bd, index=8f8, offset=0
    [junit] Test: DTLB, ffffffffca7acecc
    [junit] tag=7fe53d6, index=0, offset=ecc
    [junit] Test: L1, ffffffff9eec5a35
    [junit] tag=f9eec5, index=51, offset=15
    [junit] Test: L2, fa95b76d3e264dda
    [junit] tag=69f13, index=26e, offset=1a
    [junit] Test: DTLB, cdb7f6971e02b1e5
    [junit] tag=4b8f015, index=0, offset=11e5
    [junit] Test: L1, ffffffff86eda94b
    [junit] tag=f86eda, index=4a, offset=b
    [junit] Test: L2, ffffffffe9d21506
    [junit] tag=7f4e9, index=a8, offset=6
    [junit] Test: DTLB, ffffffff93a341b7
    [junit] tag=7fc9d1a, index=0, offset=1b7
    [junit] Test: L1, ffffffff8a42a335
    [junit] tag=f8a42a, index=19, offset=15
    [junit] Test: L2, ffffffffd4832a73
    [junit] tag=7ea41, index=953, offset=13
    [junit] Test: DTLB, ffffffffb6380f43
    [junit] tag=7fdb1c0, index=0, offset=f43
    [junit] Test: L1, ffffffffa880468a
    [junit] tag=fa8804, index=34, offset=a
    [junit] Test: L2, f7a592746aa49780
    [junit] tag=23552, index=4bc, offset=0
    [junit] Test: DTLB, fffffffff4bec1c4
    [junit] tag=7ffa5f6, index=0, offset=1c4
    [junit] Test: L1, ffffffffb47dddd6
    [junit] tag=fb47dd, index=6e, offset=16
    [junit] Test: L2, ffffffff9f7fcd52
    [junit] tag=7cfbf, index=e6a, offset=12
    [junit] Test: DTLB, ffffffffbec65618
    [junit] tag=7fdf632, index=0, offset=1618
    [junit] Test: L1, bb55757f7d680f22
    [junit] tag=f7d680, index=79, offset=2
    [junit] Test: L2, ffffffffc08eaecb
    [junit] tag=7e047, index=576, offset=b
    [junit] Test: DTLB, 782ea5270b2968b4
    [junit] tag=138594b, index=0, offset=8b4
    [junit] Test: L1, fffffffffc71c14a
    [junit] tag=ffc71c, index=a, offset=a
    [junit] Test: L2, ffffffff9dd26e4c
    [junit] tag=7cee9, index=372, offset=c
    [junit] Test: DTLB, 9a49639052a84882
    [junit] tag=4829542, index=0, offset=882
    [junit] Test: L1, 409c1cb023f9881a
    [junit] tag=23f98, index=40, offset=1a
    [junit] Test: L2, b3d780643da856d1
    [junit] tag=21ed4, index=2b6, offset=11
    [junit] Test: DTLB, fffffffff113bea2
    [junit] tag=7ff889d, index=0, offset=1ea2
    [junit] Test: L1, ffffffffe52becaf
    [junit] tag=fe52be, index=65, offset=f
    [junit] Test: L2, fde0625f0b881a88
    [junit] tag=785c4, index=d4, offset=8
    [junit] Test: DTLB, abb107c51ad9b371
    [junit] tag=628d6cd, index=0, offset=1371
    [junit] Test: L1, ffffffffcb4a4027
    [junit] tag=fcb4a4, index=1, offset=7
    [junit] Test: L2, b4499d69491ac720
    [junit] tag=4a48d, index=639, offset=0
    [junit] Test: DTLB, ffffffffda91731f
    [junit] tag=7fed48b, index=0, offset=131f
    [junit] Test: L1, 74582e3236ef3440
    [junit] tag=236ef3, index=22, offset=0
    [junit] Test: L2, fffffffffafce980
    [junit] tag=7fd7e, index=74c, offset=0
    [junit] Test: DTLB, 72baadb20f2e5ee2
    [junit] tag=5907972, index=0, offset=1ee2
    [junit] Test: L1, fd6b4b672ae3d6cf
    [junit] tag=72ae3d, index=36, offset=f
    [junit] Test: L2, fffffffffa82249f
    [junit] tag=7fd41, index=124, offset=1f
    [junit] Test: DTLB, ffffffffa1d611cb
    [junit] tag=7fd0eb0, index=0, offset=11cb
    [junit] Test: L1, ffffffff95e2c0bd
    [junit] tag=f95e2c, index=5, offset=1d
    [junit] Test: L2, ffffffffd464f94c
    [junit] tag=7ea32, index=7ca, offset=c
    [junit] Test: DTLB, d60fafbd7a2ec3d1
    [junit] tag=5ebd176, index=0, offset=3d1
    [junit] Test: L1, 77d16ad63fab3770
    [junit] tag=63fab3, index=3b, offset=10
    [junit] Test: L2, 688ba39765fb0ac7
    [junit] tag=3b2fd, index=856, offset=7
    [junit] Test: DTLB, 15d205735b2d22c0
    [junit] tag=39ad969, index=0, offset=2c0
    [junit] Test: L1, ffffffffe3863ebb
    [junit] tag=fe3863, index=75, offset=1b
    [junit] Test: L2, 3a7d228f6b7e433c
    [junit] tag=7b5bf, index=219, offset=1c
    [junit] Test: DTLB, 2e147a4956fceb04
    [junit] tag=24ab7e7, index=0, offset=b04
    [junit] Test: L1, c8461fbf4b2da6d8
    [junit] tag=f4b2da, index=36, offset=18
    [junit] Test: L2, ffffffffec7ee189
    [junit] tag=7f63f, index=70c, offset=9
    [junit] Test: DTLB, 5d0d27bd2a8ed1b7
    [junit] tag=5e95476, index=0, offset=11b7
    [junit] Test: L1, ffffffffd49bffcd
    [junit] tag=fd49bf, index=7e, offset=d
    [junit] Test: L2, ffffffff881d3af8
    [junit] tag=7c40e, index=9d7, offset=18
    [junit] Test: DTLB, ffffffff915052e4
    [junit] tag=7fc8a82, index=0, offset=12e4
    [junit] Test: L1, ecfd434c5e4356fb
    [junit] tag=c5e435, index=37, offset=1b
    [junit] Test: L2, 4ad7b35667cb6c06
    [junit] tag=333e5, index=b60, offset=6
    [junit] Test: DTLB, 9a67b8f37f7e08d
    [junit] tag=479bfbf, index=0, offset=8d
    [junit] Test: L1, ffffffff9d3fbbe1
    [junit] tag=f9d3fb, index=5f, offset=1
    [junit] Test: L2, ffffffffcced468d
    [junit] tag=7e676, index=a34, offset=d
    [junit] Test: DTLB, 5b217bb853215b41
    [junit] tag=5c2990a, index=0, offset=1b41
    [junit] Test: L1, ffffffffbed2c55a
    [junit] tag=fbed2c, index=2a, offset=1a
    [junit] Test: L2, c1070662b425ace
    [junit] tag=315a1, index=2d6, offset=e
    [junit] Test: DTLB, ffffffffad11437c
    [junit] tag=7fd688a, index=0, offset=37c
    [junit] Test: L1, ffffffff80976b64
    [junit] tag=f80976, index=5b, offset=4
    [junit] Test: L2, 658b9919560834c8
    [junit] tag=4ab04, index=1a6, offset=8
    [junit] Test: DTLB, 22764d881906cbb5
    [junit] tag=440c836, index=0, offset=bb5
    [junit] Test: L1, dd1751bb25f4e285
    [junit] tag=b25f4e, index=14, offset=5
    [junit] Test: L2, fad30d57436eb8ca
    [junit] tag=3a1b7, index=5c6, offset=a
    [junit] Test: DTLB, f4ce62de20e758ca
    [junit] tag=6f1073a, index=0, offset=18ca
    [junit] Test: L1, aaeed57c52423613
    [junit] tag=c52423, index=30, offset=13
    [junit] Test: L2, ffffffffb3e02474
    [junit] tag=7d9f0, index=123, offset=14
    [junit] Test: DTLB, a83e50b3421742b3
    [junit] tag=59a10ba, index=0, offset=2b3
    [junit] Test: L1, 790fced5744c60a4
    [junit] tag=5744c6, index=5, offset=4
    [junit] Test: L2, 207636b114f51c58
    [junit] tag=8a7a, index=8e2, offset=18
    [junit] Test: DTLB, e8fc1e15f6aefed
    [junit] tag=70afb57, index=0, offset=fed
    [junit] Test: L1, ffffffffc85e8b27
    [junit] tag=fc85e8, index=59, offset=7
    [junit] Test: L2, 2e9c37f140c970ee
    [junit] tag=a064, index=b87, offset=e
    [junit] Test: DTLB, cde157317e355302
    [junit] tag=18bf1aa, index=0, offset=1302
    [junit] Test: L1, ffffffffef86ce51
    [junit] tag=fef86c, index=72, offset=11
    [junit] Test: L2, ffffffffc2173681
    [junit] tag=7e10b, index=9b4, offset=1
    [junit] Test: DTLB, 54d2b9da37d30978
    [junit] tag=6d1be98, index=0, offset=978
    [junit] Test: L1, 2d238b782b80917b
    [junit] tag=82b809, index=b, offset=1b
    [junit] Test: L2, 818a907c0cf1eecd
    [junit] tag=60678, index=f76, offset=d
    [junit] Test: DTLB, d34d4704acfc932
    [junit] tag=382567e, index=0, offset=932
    [junit] Test: L1, ffffffffb0307f57
    [junit] tag=fb0307, index=7a, offset=17
    [junit] Test: L2, 62a1695e09224266
    [junit] tag=70491, index=213, offset=6
    [junit] Test: DTLB, ff5c06a23bc46bcd
    [junit] tag=511de23, index=0, offset=bcd
    [junit] Test: L1, ffffffffc6be57f4
    [junit] tag=fc6be5, index=3f, offset=14
    [junit] Test: L2, ffffffffcddac154
    [junit] tag=7e6ed, index=60a, offset=14
    [junit] Test: DTLB, ffffffffd4043636
    [junit] tag=7fea021, index=0, offset=1636
    [junit] Test: L1, fffffffff5ea00c6
    [junit] tag=ff5ea0, index=6, offset=6
    [junit] Test: L2, ffffffffaca397ba
    [junit] tag=7d651, index=cbd, offset=1a
    [junit] Test: DTLB, 8ffefc9652835ad0
    [junit] tag=4b2941a, index=0, offset=1ad0
    [junit] Test: L1, ee38473c688fa3be
    [junit] tag=c688fa, index=1d, offset=1e
    [junit] Test: L2, 5a37575833217e14
    [junit] tag=41990, index=bf0, offset=14
    [junit] Test: DTLB, 4dc1e52623f96bdc
    [junit] tag=1311fcb, index=0, offset=bdc
    [junit] Test: L1, ffffffff9e41898b
    [junit] tag=f9e418, index=4c, offset=b
    [junit] Test: L2, 1feeb94d3952880f
    [junit] tag=69ca9, index=440, offset=f
    [junit] Test: DTLB, bb446ab17292885b
    [junit] tag=58b9494, index=0, offset=85b
    [junit] Test: L1, ffffffffe76e16c1
    [junit] tag=fe76e1, index=36, offset=1
    [junit] Test: L2, 8a59b222f555085
    [junit] tag=117aa, index=a84, offset=5
    [junit] Test: DTLB, ffffffffca949aaf
    [junit] tag=7fe54a4, index=0, offset=1aaf
    [junit] Test: L1, 1fba105220e2a240
    [junit] tag=220e2a, index=12, offset=0
    [junit] Test: L2, 6a06a1da72318fba
    [junit] tag=53918, index=c7d, offset=1a
    [junit] Test: DTLB, ffffffff9cae0c40
    [junit] tag=7fce570, index=0, offset=c40
    [junit] Test: L1, ffffffff81e52733
    [junit] tag=f81e52, index=39, offset=13
    [junit] Test: L2, 36eb7391a4b0beb
    [junit] tag=48d25, index=85f, offset=b
    [junit] Test: DTLB, ffffffffab2ba5e1
    [junit] tag=7fd595d, index=0, offset=5e1
    [junit] Test: L1, 9f8ce7744efd3126
    [junit] tag=44efd3, index=9, offset=6
    [junit] Test: L2, ffffffffe848386e
    [junit] tag=7f424, index=1c3, offset=e
    [junit] Test: DTLB, ffffffffbda22fef
    [junit] tag=7fded11, index=0, offset=fef
    [junit] Test: L1, b554a6eb5d00ceb7
    [junit] tag=b5d00c, index=75, offset=17
    [junit] Test: L2, 895d98ac020fdbb6
    [junit] tag=60107, index=edd, offset=16
    [junit] Test: DTLB, 94d240243228f07c
    [junit] tag=1219147, index=0, offset=107c
    [junit] Test: L1, 121e386a007c9c7a
    [junit] tag=a007c9, index=63, offset=1a
    [junit] Test: L2, ffffffff8a4b4cdc
    [junit] tag=7c525, index=a66, offset=1c
    [junit] Test: DTLB, ffffffff92bce63e
    [junit] tag=7fc95e7, index=0, offset=63e
    [junit] Test: L1, ffffffffdcc6af58
    [junit] tag=fdcc6a, index=7a, offset=18
    [junit] Test: L2, ffffffffb81a21db
    [junit] tag=7dc0d, index=10e, offset=1b
    [junit] Test: DTLB, fffffffffacad053
    [junit] tag=7ffd656, index=0, offset=1053
    [junit] Test: L1, f30d6b5b58bdb012
    [junit] tag=b58bdb, index=0, offset=12
    [junit] Test: L2, ffffffff9634c6e6
    [junit] tag=7cb1a, index=637, offset=6
    [junit] Test: DTLB, ffffffffcbe7c951
    [junit] tag=7fe5f3e, index=0, offset=951
    [junit] Test: L1, ffffffffe9d59937
    [junit] tag=fe9d59, index=49, offset=17
    [junit] Test: L2, e9fef7f11ded127
    [junit] tag=788ef, index=689, offset=7
    [junit] Test: DTLB, 5d61b81a6dbc66bd
    [junit] tag=d36de3, index=0, offset=6bd
    [junit] Test: L1, ffffffffa6859683
    [junit] tag=fa6859, index=34, offset=3
    [junit] Test: L2, ffffffff9111680e
    [junit] tag=7c888, index=b40, offset=e
    [junit] Test: DTLB, 6d89ddbc22dde40c
    [junit] tag=5e116ef, index=0, offset=40c
    [junit] Test: L1, fffffffff88bf6e9
    [junit] tag=ff88bf, index=37, offset=9
    [junit] Test: L2, d16655ee361bc3fd
    [junit] tag=71b0d, index=e1f, offset=1d
    [junit] Test: DTLB, ac07268223fa179a
    [junit] tag=4111fd0, index=0, offset=179a
    [junit] Test: L1, 48df65ef4c42bc04
    [junit] tag=f4c42b, index=60, offset=4
    [junit] Test: L2, ffffffff8aa55c5f
    [junit] tag=7c552, index=ae2, offset=1f
    [junit] Test: DTLB, f373d58976f59474
    [junit] tag=44bb7ac, index=0, offset=1474
    [junit] Test: L1, ffffffff88468aba
    [junit] tag=f88468, index=55, offset=1a
    [junit] Test: L2, d9112e293e49291e
    [junit] tag=49f24, index=948, offset=1e
    [junit] Test: DTLB, 4de840447e91ead7
    [junit] tag=223f48f, index=0, offset=ad7
    [junit] Test: L1, fffffffff1701fdd
    [junit] tag=ff1701, index=7e, offset=1d
    [junit] Test: L2, ffffffff88fbc0d2
    [junit] tag=7c47d, index=e06, offset=12
    [junit] Test: DTLB, db9c3576513e6c38
    [junit] tag=3b289f3, index=0, offset=c38
    [junit] Test: L1, ffffffffdb6aad43
    [junit] tag=fdb6aa, index=6a, offset=3
    [junit] Test: L2, ffffffff8a93b91a
    [junit] tag=7c549, index=dc8, offset=1a
    [junit] Test: DTLB, 96fba7a6614f0b8a
    [junit] tag=5330a78, index=0, offset=b8a
    [junit] Test: L1, ffffffff8414d237
    [junit] tag=f8414d, index=11, offset=17
    [junit] Test: L2, 46c6ec8f7ba0f491
    [junit] tag=7bdd0, index=7a4, offset=11
    [junit] Test: DTLB, ffffffffc32f7b60
    [junit] tag=7fe197b, index=0, offset=1b60
    [junit] Test: L1, a793cc565dc7e115
    [junit] tag=65dc7e, index=8, offset=15
    [junit] Test: L2, 719e82071363be93
    [junit] tag=389b1, index=df4, offset=13
    [junit] Test: DTLB, ffffffff871cec55
    [junit] tag=7fc38e7, index=0, offset=c55
    [junit] Test: L1, ffffffffffd43027
    [junit] tag=fffd43, index=1, offset=7
    [junit] Test: L2, 561353871e1ba11c
    [junit] tag=38f0d, index=d08, offset=1c
    [junit] Test: DTLB, 39be261d2c27d4d2
    [junit] tag=e9613e, index=0, offset=14d2
    [junit] Test: L1, ffffffffaa35546c
    [junit] tag=faa355, index=23, offset=c
    [junit] Test: L2, ffffffff863b5e00
    [junit] tag=7c31d, index=af0, offset=0
    [junit] Test: DTLB, 1590a644640d1f2
    [junit] tag=3223206, index=0, offset=11f2
    [junit] Test: L1, fffffffff54b33a1
    [junit] tag=ff54b3, index=1d, offset=1
    [junit] Test: L2, 95daf1e058ce5f5f
    [junit] tag=2c67, index=2fa, offset=1f
    [junit] Test: DTLB, 6d3b105465203ce2
    [junit] tag=2a32901, index=0, offset=1ce2
    [junit] Test: L1, ffffffffa2a64c30
    [junit] tag=fa2a64, index=61, offset=10
    [junit] Test: L2, eedb2e02132bfd33
    [junit] tag=10995, index=fe9, offset=13
    [junit] Test: DTLB, ffffffffb210cbb5
    [junit] tag=7fd9086, index=0, offset=bb5
    [junit] Test: L1, ffffffffb3246bca
    [junit] tag=fb3246, index=5e, offset=a
    [junit] Test: L2, ceadd4c5433a970d
    [junit] tag=2a19d, index=4b8, offset=d
    [junit] Test: DTLB, f4895f3b71029c72
    [junit] tag=1db8814, index=0, offset=1c72
    [junit] Test: L1, 32bd2442739a2870
    [junit] tag=2739a2, index=43, offset=10
    [junit] Test: L2, c664eeb73ce98a95
    [junit] tag=39e74, index=c54, offset=15
    [junit] Test: DTLB, 8966f6b178dd2b78
    [junit] tag=58bc6e9, index=0, offset=b78
    [junit] Test: L1, b8fa13f100a36d0f
    [junit] tag=100a36, index=68, offset=f
    [junit] Test: L2, ad6037a318c955c7
    [junit] tag=18c64, index=aae, offset=7
    [junit] Test: DTLB, fffffffff12b7500
    [junit] tag=7ff895b, index=0, offset=1500
    [junit] Test: L1, 2a00b235599256fd
    [junit] tag=559925, index=37, offset=1d
    [junit] Test: L2, 763433e9552af28a
    [junit] tag=4aa95, index=794, offset=a
    [junit] Test: DTLB, fffffffffb227e1c
    [junit] tag=7ffd913, index=0, offset=1e1c
    [junit] Test: L1, ffffffffecb279a4
    [junit] tag=fecb27, index=4d, offset=4
    [junit] Test: L2, fffffffff1500d03
    [junit] tag=7f8a8, index=68, offset=3
    [junit] Test: DTLB, 20acdeee402590a4
    [junit] tag=772012c, index=0, offset=10a4
    [junit] Test: L1, 70d998f71f80c4fd
    [junit] tag=71f80c, index=27, offset=1d
    [junit] Test: L2, ffffffff95254838
    [junit] tag=7ca92, index=a41, offset=18
    [junit] Test: DTLB, ffffffffa2935d1c
    [junit] tag=7fd149a, index=0, offset=1d1c
    [junit] Test: L1, 6b3446e26ad2b70a
    [junit] tag=26ad2b, index=38, offset=a
    [junit] Test: L2, fffffffffdec0aa1
    [junit] tag=7fef6, index=55, offset=1
    [junit] Test: DTLB, 5a428d4e10eca767
    [junit] tag=2708765, index=0, offset=767
    [junit] Test: L1, ffffffffb09e9ebe
    [junit] tag=fb09e9, index=75, offset=1e
    [junit] Test: L2, fffffffffee00cda
    [junit] tag=7ff70, index=66, offset=1a
    [junit] Test: DTLB, c6e2855d6e4de640
    [junit] tag=2eb726f, index=0, offset=640
    [junit] Test: L1, fc97697e28abefdb
    [junit] tag=e28abe, index=7e, offset=1b
    [junit] Test: L2, ffffffffe6877f0d
    [junit] tag=7f343, index=bf8, offset=d
    [junit] Test: DTLB, ffffffffe4abd7b4
    [junit] tag=7ff255e, index=0, offset=17b4
    [junit] Test: L1, ffffffffb84df2fe
    [junit] tag=fb84df, index=17, offset=1e
    [junit] Test: L2, 2e149a1c70889555
    [junit] tag=63844, index=4aa, offset=15
    [junit] Test: DTLB, f2614bce4f19be1b
    [junit] tag=67278cd, index=0, offset=1e1b
    [junit] Test: L1, c1dda70199bf0f8
    [junit] tag=199bf, index=7, offset=18
    [junit] Test: L2, 9412de0703716074
    [junit] tag=381b8, index=b03, offset=14
    [junit] Test: DTLB, ffffffffa9412834
    [junit] tag=7fd4a09, index=0, offset=834
    [junit] Test: L1, ffffffffe999b0ab
    [junit] tag=fe999b, index=5, offset=b
    [junit] Test: L2, a044de514d403289
    [junit] tag=a6a0, index=194, offset=9
    [junit] Test: DTLB, ffffffff8a6a1281
    [junit] tag=7fc5350, index=0, offset=1281
    [junit] Test: L1, ffffffffc2ba1594
    [junit] tag=fc2ba1, index=2c, offset=14
    [junit] Test: L2, 7ba3da3378cd2326
    [junit] tag=1bc66, index=919, offset=6
    [junit] Test: DTLB, 457311161054fa06
    [junit] tag=b082a7, index=0, offset=1a06
    [junit] Test: L1, 24086a8c174e9b0a
    [junit] tag=c174e9, index=58, offset=a
    [junit] Test: L2, bac7c7e841f2838b
    [junit] tag=420f9, index=41c, offset=b
    [junit] Test: DTLB, fef1405576829cec
    [junit] tag=2abb414, index=0, offset=1cec
    [junit] Test: L1, 4413efaf46c5ebf3
    [junit] tag=f46c5e, index=5f, offset=13
    [junit] Test: L2, ffffffffaaf7b662
    [junit] tag=7d57b, index=db3, offset=2
    [junit] Test: DTLB, 2e83c47258399059
    [junit] tag=392c1cc, index=0, offset=1059
    [junit] Test: L1, 22ad35ca769d733d
    [junit] tag=a769d7, index=19, offset=1d
    [junit] Test: L2, ffffffff8d37dc04
    [junit] tag=7c69b, index=ee0, offset=4
    [junit] Test: DTLB, ffffffffb1fc9343
    [junit] tag=7fd8fe4, index=0, offset=1343
    [junit] Test: L1, ffffffffa658b437
    [junit] tag=fa658b, index=21, offset=17
    [junit] Test: L2, ffffffffe9ae2be8
    [junit] tag=7f4d7, index=15f, offset=8
    [junit] Test: DTLB, ffffffffce4ba346
    [junit] tag=7fe725d, index=0, offset=346
    [junit] Test: L1, 33d6855755c6d283
    [junit] tag=755c6d, index=14, offset=3
    [junit] Test: L2, c23be41373c4e809
    [junit] tag=1b9e2, index=740, offset=9
    [junit] Test: DTLB, ffffffff8d4be434
    [junit] tag=7fc6a5f, index=0, offset=434
    [junit] Test: L1, 5fc614077830f8d6
    [junit] tag=77830f, index=46, offset=16
    [junit] Test: L2, fffffffff822505a
    [junit] tag=7fc11, index=282, offset=1a
    [junit] Test: DTLB, ffffffff9ad7ceab
    [junit] tag=7fcd6be, index=0, offset=eab
    [junit] Test: L1, ffffffff95708944
    [junit] tag=f95708, index=4a, offset=4
    [junit] Test: L2, ffffffff9942a20f
    [junit] tag=7cca1, index=510, offset=f
    [junit] Test: DTLB, 823694c3165d9299
    [junit] tag=618b2ec, index=0, offset=1299
    [junit] Test: L1, ffffffffe62a1d09
    [junit] tag=fe62a1, index=68, offset=9
    [junit] Test: L2, ffffffffc8da0c59
    [junit] tag=7e46d, index=62, offset=19
    [junit] Test: DTLB, 3497e6ec0dbe0ed1
    [junit] tag=7606df0, index=0, offset=ed1
    [junit] Test: L1, ffffffff9f2ac500
    [junit] tag=f9f2ac, index=28, offset=0
    [junit] Test: L2, 3cf6b88b0e288e38
    [junit] tag=58714, index=471, offset=18
    [junit] Test: DTLB, ffffffffb6fe1b4e
    [junit] tag=7fdb7f0, index=0, offset=1b4e
    [junit] Test: L1, ffffffffc3d94226
    [junit] tag=fc3d94, index=11, offset=6
    [junit] Test: L2, 1df83cb73e609391
    [junit] tag=39f30, index=49c, offset=11
    [junit] Test: DTLB, ffffffff9d2d0a9f
    [junit] tag=7fce968, index=0, offset=a9f
    [junit] Test: L1, fffffffffe9e7c53
    [junit] tag=ffe9e7, index=62, offset=13
    [junit] Test: L2, ffffffffd0d155a3
    [junit] tag=7e868, index=aad, offset=3
    [junit] Test: DTLB, 9caf6321007dd2e6
    [junit] tag=10803ee, index=0, offset=12e6
    [junit] Test: L1, e49885453d930743
    [junit] tag=53d930, index=3a, offset=3
    [junit] Test: L2, c214854010352684
    [junit] tag=81a, index=934, offset=4
    [junit] Test: DTLB, 174fd2e303e3cfd9
    [junit] tag=7181f1e, index=0, offset=fd9
    [junit] Test: L1, c84fe30f78284e20
    [junit] tag=f78284, index=71, offset=0
    [junit] Test: L2, 61557549186e6235
    [junit] tag=48c37, index=311, offset=15
    [junit] Test: DTLB, 7700fcd011451921
    [junit] tag=6808a28, index=0, offset=1921
    [junit] Test: L1, c54d554b5787cb29
    [junit] tag=b5787c, index=59, offset=9
    [junit] Test: L2, ffffffff9dc82a60
    [junit] tag=7cee4, index=153, offset=0
    [junit] Test: DTLB, bdc3ff9165f535c9
    [junit] tag=48b2fa9, index=0, offset=15c9
    [junit] Test: L1, ffffffff9ef78052
    [junit] tag=f9ef78, index=2, offset=12
    [junit] Test: L2, ffffffff91aff8e4
    [junit] tag=7c8d7, index=fc7, offset=4
    [junit] Test: DTLB, e5faaf1a46598b08
    [junit] tag=d232cc, index=0, offset=b08
    [junit] Test: L1, ffffffffb25bab8b
    [junit] tag=fb25ba, index=5c, offset=b
    [junit] Test: L2, ffffffffaf5c8e0b
    [junit] tag=7d7ae, index=470, offset=b
    [junit] Test: DTLB, ffffffff9db0449c
    [junit] tag=7fced82, index=0, offset=49c
    [junit] Test: L1, eaf1cf932469cbcc
    [junit] tag=32469c, index=5e, offset=c
    [junit] Test: L2, ffffffffb8d3ea68
    [junit] tag=7dc69, index=f53, offset=8
    [junit] Test: DTLB, 747de87925ac129c
    [junit] tag=3c92d60, index=0, offset=129c
    [junit] Test: L1, ffffffffe5a6db7d
    [junit] tag=fe5a6d, index=5b, offset=1d
    [junit] Test: L2, ffffffff98add62e
    [junit] tag=7cc56, index=eb1, offset=e
    [junit] Test: DTLB, ffffffffe8069d20
    [junit] tag=7ff4034, index=0, offset=1d20
    [junit] Test: L1, ffffffff85c6ae57
    [junit] tag=f85c6a, index=72, offset=17
    [junit] Test: L2, ffffffff8c2bbfbf
    [junit] tag=7c615, index=dfd, offset=1f
    [junit] Test: DTLB, ffffffffc33c6091
    [junit] tag=7fe19e3, index=0, offset=91
    [junit] Test: L1, d835f6274d819ae4
    [junit] tag=74d819, index=57, offset=4
    [junit] Test: L2, ffffffffd830867d
    [junit] tag=7ec18, index=433, offset=1d
    [junit] Test: DTLB, ffffffffe014ecdc
    [junit] tag=7ff00a7, index=0, offset=cdc
    [junit] Test: L1, e66f82b509b23c91
    [junit] tag=509b23, index=64, offset=11
    [junit] Test: L2, ffffffff8f40ea98
    [junit] tag=7c7a0, index=754, offset=18
    [junit] Test: DTLB, 4ca886057df96027
    [junit] tag=2befcb, index=0, offset=27
    [junit] Test: L1, cf8830506a570603
    [junit] tag=6a570, index=30, offset=3
    [junit] Test: L2, ffffffffc9176f63
    [junit] tag=7e48b, index=b7b, offset=3
    [junit] Test: DTLB, ffffffffd5021f10
    [junit] tag=7fea810, index=0, offset=1f10
    [junit] Test: L1, ffffffffc395b921
    [junit] tag=fc395b, index=49, offset=1
    [junit] Test: L2, 188d2cba742f6e45
    [junit] tag=53a17, index=b72, offset=5
    [junit] Test: DTLB, 3561eed750846622
    [junit] tag=6ba8423, index=0, offset=622
    [junit] Test: L1, 35a380ff63936770
    [junit] tag=f63936, index=3b, offset=10
    [junit] Test: L2, 85c810e17ba573ac
    [junit] tag=bdd2, index=b9d, offset=c
    [junit] Test: DTLB, ffffffff859ddefe
    [junit] tag=7fc2cee, index=0, offset=1efe
    [junit] Test: L1, 298a06a52ba08509
    [junit] tag=52ba08, index=28, offset=9
    [junit] Test: L2, cbf6a31f265d6e1c
    [junit] tag=7932e, index=b70, offset=1c
    [junit] Test: DTLB, ffffffffbb1ff039
    [junit] tag=7fdd8ff, index=0, offset=1039
    [junit] Test: L1, ffffffff8458d6b6
    [junit] tag=f8458d, index=35, offset=16
    [junit] Test: L2, 1b7bc4a61c2e578d
    [junit] tag=30e17, index=2bc, offset=d
    [junit] Test: DTLB, ffffffff89674e88
    [junit] tag=7fc4b3a, index=0, offset=e88
    [junit] Test: L1, 47e2c2171fd111d9
    [junit] tag=71fd11, index=e, offset=19
    [junit] Test: L2, bed709b61095e757
    [junit] tag=3084a, index=f3a, offset=17
    [junit] Test: DTLB, fffffffff0fd262a
    [junit] tag=7ff87e9, index=0, offset=62a
    [junit] Test: L1, 36ad02336f90d8c2
    [junit] tag=36f90d, index=46, offset=2
    [junit] Test: L2, 8206667c0e5fb711
    [junit] tag=6072f, index=db8, offset=11
    [junit] Test: DTLB, ffffffff8ca2b971
    [junit] tag=7fc6515, index=0, offset=1971
    [junit] Test: L1, 54c7ae3627745cd3
    [junit] tag=627745, index=66, offset=13
    [junit] Test: L2, ffffffffffc369d7
    [junit] tag=7ffe1, index=b4e, offset=17
    [junit] Test: DTLB, ffffffffd91294fd
    [junit] tag=7fec894, index=0, offset=14fd
    [junit] Test: L1, e41448686e0adbff
    [junit] tag=86e0ad, index=5f, offset=1f
    [junit] Test: L2, ffffffffadec8705
    [junit] tag=7d6f6, index=438, offset=5
    [junit] Test: DTLB, ffffffffdd80d4bd
    [junit] tag=7feec06, index=0, offset=14bd
    [junit] Test: L1, 79cc2dce4fc72109
    [junit] tag=e4fc72, index=8, offset=9
    [junit] Test: L2, ffffffffb3e3ee09
    [junit] tag=7d9f1, index=f70, offset=9
    [junit] Test: DTLB, 7c4340c82ab04383
    [junit] tag=6415582, index=0, offset=383
    [junit] Test: L1, ffffffffc17a0b35
    [junit] tag=fc17a0, index=59, offset=15
    [junit] Test: L2, c7882f1565498497
    [junit] tag=2b2a4, index=c24, offset=17
    [junit] Test: DTLB, ffffffff8a80ad24
    [junit] tag=7fc5405, index=0, offset=d24
    [junit] Test: L1, 244ec5f3124c6c22
    [junit] tag=3124c6, index=61, offset=2
    [junit] Test: L2, ffffffff99fc8ab0
    [junit] tag=7ccfe, index=455, offset=10
    [junit] Test: DTLB, 5ccb7b440ad5d1b5
    [junit] tag=22056ae, index=0, offset=11b5
    [junit] Test: L1, ffffffffbf9c52a4
    [junit] tag=fbf9c5, index=15, offset=4
    [junit] Test: L2, fc85ba7c32166030
    [junit] tag=6190b, index=301, offset=10
    [junit] Test: DTLB, 27b5eb211d556c88
    [junit] tag=108eaab, index=0, offset=c88
    [junit] Test: L1, ffffffff81f777d4
    [junit] tag=f81f77, index=3e, offset=14
    [junit] Test: L2, ffffffffaf6ff2a7
    [junit] tag=7d7b7, index=f95, offset=7
    [junit] Test: DTLB, ffffffffd522c5d4
    [junit] tag=7fea916, index=0, offset=5d4
    [junit] Test: L1, 519c386f0578c72f
    [junit] tag=f0578c, index=39, offset=f
    [junit] Test: L2, ffffffffa9648ee9
    [junit] tag=7d4b2, index=477, offset=9
    [junit] Test: DTLB, fffffffffac80680
    [junit] tag=7ffd640, index=0, offset=680
    [junit] Test: L1, 3428a2292078d615
    [junit] tag=92078d, index=30, offset=15
    [junit] Test: L2, 599695a90d876844
    [junit] tag=486c3, index=b42, offset=4
    [junit] Test: DTLB, 3312825d4233602c
    [junit] tag=2ea119b, index=0, offset=2c
    [junit] Test: L1, ffffffffdae6cbfe
    [junit] tag=fdae6c, index=5f, offset=1e
    [junit] Test: L2, 1050590b7387ca8a
    [junit] tag=5b9c3, index=e54, offset=a
    [junit] Test: DTLB, 261896d0303e5ee8
    [junit] tag=68181f2, index=0, offset=1ee8
    [junit] Test: L1, ffffffffa7dcf52c
    [junit] tag=fa7dcf, index=29, offset=c
    [junit] Test: L2, 87422c7e5ab914de
    [junit] tag=72d5c, index=8a6, offset=1e
    [junit] Test: DTLB, 8bd295c159fd1371
    [junit] tag=60acfe8, index=0, offset=1371
    [junit] Test: L1, ffffffffff54a11d
    [junit] tag=fff54a, index=8, offset=1d
    [junit] Test: L2, 1792dbf27c189346
    [junit] tag=13e0c, index=49a, offset=6
    [junit] Test: DTLB, 8dd121b07b1d4fd8
    [junit] tag=583d8ea, index=0, offset=fd8
    [junit] Test: L1, fe7fe6e8089cd0fc
    [junit] tag=8089cd, index=7, offset=1c
    [junit] Test: L2, ffffffffd00302e8
    [junit] tag=7e801, index=817, offset=8
    [junit] Test: DTLB, 12391af4463a2fb0
    [junit] tag=7a231d1, index=0, offset=fb0
    [junit] Test: L1, ba98da0e12a705e1
    [junit] tag=e12a70, index=2f, offset=1
    [junit] Test: L2, ffffffffcd8313f5
    [junit] tag=7e6c1, index=89f, offset=15
    [junit] Test: DTLB, 51950de01ccb1574
    [junit] tag=700e658, index=0, offset=1574
    [junit] Test: L1, ffffffffb624a539
    [junit] tag=fb624a, index=29, offset=19
    [junit] Test: L2, 4560ab6650a891e
    [junit] tag=33285, index=448, offset=1e
    [junit] Test: DTLB, e3876d061bb4c52
    [junit] tag=6830dda, index=0, offset=c52
    [junit] Test: L1, a14788b3313d712f
    [junit] tag=3313d7, index=9, offset=f
    [junit] Test: L2, 9c2439e67cc2ec5
    [junit] tag=733e6, index=176, offset=5
    [junit] Test: DTLB, 3d1c30ef1d7c4efc
    [junit] tag=778ebe2, index=0, offset=efc
    [junit] Test: L1, 18cafcbc5838594e
    [junit] tag=c58385, index=4a, offset=e
    [junit] Test: L2, ffffffff98c67a7d
    [junit] tag=7cc63, index=3d3, offset=1d
    [junit] Test: DTLB, ffffffffd13ae207
    [junit] tag=7fe89d7, index=0, offset=207
    [junit] Test: L1, bc51cc9a0e8b66c6
    [junit] tag=a0e8b6, index=36, offset=6
    [junit] Test: L2, ffffffff8f31851d
    [junit] tag=7c798, index=c28, offset=1d
    [junit] Test: DTLB, 4f7de42454349d01
    [junit] tag=122a1a4, index=0, offset=1d01
    [junit] Test: L1, a1a2f2df47f28248
    [junit] tag=f47f28, index=12, offset=8
    [junit] Test: L2, ca2c36a46dea2ef4
    [junit] tag=236f5, index=177, offset=14
    [junit] Test: DTLB, ffffffff88434702
    [junit] tag=7fc421a, index=0, offset=702
    [junit] Test: L1, 51c76d2b19c8d125
    [junit] tag=b19c8d, index=9, offset=5
    [junit] Test: L2, 5c231a8d1cba1e53
    [junit] tag=68e5d, index=f2, offset=13
    [junit] Test: DTLB, ffffffff8946a2cc
    [junit] tag=7fc4a35, index=0, offset=2cc
    [junit] Test: L1, ffffffffde143d1d
    [junit] tag=fde143, index=68, offset=1d
    [junit] Test: L2, ffffffffe2bd9777
    [junit] tag=7f15e, index=cbb, offset=17
    [junit] Test: DTLB, ffffffffcca504bf
    [junit] tag=7fe6528, index=0, offset=4bf
    [junit] Test: L1, ffffffffc0e41fae
    [junit] tag=fc0e41, index=7d, offset=e
    [junit] Test: L2, 652870217c046572
    [junit] tag=be02, index=32b, offset=12
    [junit] Test: DTLB, fffffffffdf77b15
    [junit] tag=7ffefbb, index=0, offset=1b15
    [junit] Test: L1, ffffffffec4bbcc2
    [junit] tag=fec4bb, index=66, offset=2
    [junit] Test: L2, 3756eb3c13a580c5
    [junit] tag=609d2, index=c06, offset=5
    [junit] Test: DTLB, ffffffffd776c4a6
    [junit] tag=7febbb6, index=0, offset=4a6
    [junit] Test: L1, fffffffff7394470
    [junit] tag=ff7394, index=23, offset=10
    [junit] Test: L2, da038eee18640485
    [junit] tag=70c32, index=24, offset=5
    [junit] Test: DTLB, ffffffffb289381c
    [junit] tag=7fd9449, index=0, offset=181c
    [junit] Test: L1, c695a307794c9590
    [junit] tag=7794c9, index=2c, offset=10
    [junit] Test: L2, ffffffffacb22c94
    [junit] tag=7d659, index=164, offset=14
    [junit] Test: DTLB, fffffffff0c7750e
    [junit] tag=7ff863b, index=0, offset=150e
    [junit] Test: L1, ffffffffebe1a06a
    [junit] tag=febe1a, index=3, offset=a
    [junit] Test: L2, e2e08937066117a6
    [junit] tag=38330, index=8bd, offset=6
    [junit] Test: DTLB, 2deb0f21401d0401
    [junit] tag=10a00e8, index=0, offset=401
    [junit] Test: L1, ffffffffa02911fc
    [junit] tag=fa0291, index=f, offset=1c
    [junit] Test: L2, ffffffff9e198ed6
    [junit] tag=7cf0c, index=c76, offset=16
    [junit] Test: DTLB, ffffffffb6e6ef82
    [junit] tag=7fdb737, index=0, offset=f82
    [junit] Test: L1, ffffffff94eb57a3
    [junit] tag=f94eb5, index=3d, offset=3
    [junit] Test: L2, 7c3108125288df28
    [junit] tag=12944, index=6f9, offset=8
    [junit] Test: DTLB, 1180513f6f537c26
    [junit] tag=1fb7a9b, index=0, offset=1c26
    [junit] Test: L1, ffffffffc8713797
    [junit] tag=fc8713, index=3c, offset=17
    [junit] Test: L2, 47c3643071773769
    [junit] tag=38bb, index=9bb, offset=9
    [junit] Test: DTLB, ffffffff969a137b
    [junit] tag=7fcb4d0, index=0, offset=137b
    [junit] Test: L1, 73e32079583bfa57
    [junit] tag=9583bf, index=52, offset=17
    [junit] Test: L2, ffffffff88b3328f
    [junit] tag=7c459, index=994, offset=f
    [junit] Test: DTLB, c72d88df03d96c72
    [junit] tag=6f81ecb, index=0, offset=c72
    [junit] Test: L1, ffffffff8b6d2085
    [junit] tag=f8b6d2, index=4, offset=5
    [junit] Test: L2, ffffffffd5115e4f
    [junit] tag=7ea88, index=af2, offset=f
    [junit] Test: DTLB, 32c7bfd6038f03c1
    [junit] tag=6b01c78, index=0, offset=3c1
    [junit] Test: L1, ffffffff99cb5b45
    [junit] tag=f99cb5, index=5a, offset=5
    [junit] Test: L2, ffffffffe171eaec
    [junit] tag=7f0b8, index=f57, offset=c
    [junit] Test: DTLB, ffffffff80ac6015
    [junit] tag=7fc0563, index=0, offset=15
    [junit] Test: L1, 18563970369d332
    [junit] tag=70369d, index=19, offset=12
    [junit] Test: L2, ffffffffabb3e777
    [junit] tag=7d5d9, index=f3b, offset=17
    [junit] Test: DTLB, 3bc40d2d5a70b645
    [junit] tag=16ad385, index=0, offset=1645
    [junit] Test: L1, 4f28481d07c1b96e
    [junit] tag=d07c1b, index=4b, offset=e
    [junit] Test: L2, 7a1f25c064ba05ca
    [junit] tag=325d, index=2e, offset=a
    [junit] Test: DTLB, 714065b7698336b8
    [junit] tag=5bb4c19, index=0, offset=16b8
    [junit] Test: L1, ea6829c561c0a64e
    [junit] tag=561c0a, index=32, offset=e
    [junit] Test: L2, a4c5a55d10336bc6
    [junit] tag=68819, index=b5e, offset=6
    [junit] Test: DTLB, f9a1975c61b3f4a2
    [junit] tag=2e30d9f, index=0, offset=14a2
    [junit] Test: L1, 3322c2fd0bcecbe1
    [junit] tag=d0bcec, index=5f, offset=1
    [junit] Test: L2, ffffffffea916176
    [junit] tag=7f548, index=b0b, offset=16
    [junit] Test: DTLB, ffffffffd5af4724
    [junit] tag=7fead7a, index=0, offset=724
    [junit] Test: L1, 72dd03392ab5ff8a
    [junit] tag=92ab5f, index=7c, offset=a
    [junit] Test: L2, ffffffffcee16c85
    [junit] tag=7e770, index=b64, offset=5
    [junit] Test: DTLB, ffffffffbd9324f4
    [junit] tag=7fdec99, index=0, offset=4f4
    [junit] Test: L1, 9049cc3746b3c7ef
    [junit] tag=746b3c, index=3f, offset=f
    [junit] Test: L2, fffffffff84f384a
    [junit] tag=7fc27, index=9c2, offset=a
    [junit] Test: DTLB, c7f5bc8047633b51
    [junit] tag=4023b19, index=0, offset=1b51
    [junit] Test: L1, 75d238974da046cb
    [junit] tag=74da04, index=36, offset=b
    [junit] Test: L2, e4119b335ceffb7e
    [junit] tag=1ae77, index=fdb, offset=1e
    [junit] Test: DTLB, ffffffffba85bd95
    [junit] tag=7fdd42d, index=0, offset=1d95
    [junit] Test: L1, ffffffffd16017ec
    [junit] tag=fd1601, index=3f, offset=c
    [junit] Test: L2, ffffffff9be92449
    [junit] tag=7cdf4, index=922, offset=9
    [junit] Test: DTLB, 43600ab81f7747f2
    [junit] tag=5c0fbba, index=0, offset=7f2
    [junit] Test: L1, ffffffffb6f84113
    [junit] tag=fb6f84, index=8, offset=13
    [junit] Test: L2, ffffffffa198bf5c
    [junit] tag=7d0cc, index=5fa, offset=1c
    [junit] Test: DTLB, 88967bc17b745d1b
    [junit] tag=60bdba2, index=0, offset=1d1b
    [junit] Test: L1, 10b56bec43296b46
    [junit] tag=c43296, index=5a, offset=6
    [junit] Test: L2, 516718e509c298de
    [junit] tag=284e1, index=4c6, offset=1e
    [junit] Test: DTLB, fffffffff29fe042
    [junit] tag=7ff94ff, index=0, offset=42
    [junit] Test: L1, ffffffff9e783628
    [junit] tag=f9e783, index=31, offset=8
    [junit] Test: L2, ffffffffdd6f303a
    [junit] tag=7eeb7, index=981, offset=1a
    [junit] Test: DTLB, 148c62f42a4b286c
    [junit] tag=7a15259, index=0, offset=86c
    [junit] Test: L1, 49c6e2b71fd839e9
    [junit] tag=71fd83, index=4f, offset=9
    [junit] Test: L2, ffffffffaee44aad
    [junit] tag=7d772, index=255, offset=d
    [junit] Test: DTLB, 51117e061a9cd829
    [junit] tag=30d4e6, index=0, offset=1829
    [junit] Test: L1, ffffffff84ad8264
    [junit] tag=f84ad8, index=13, offset=4
    [junit] Test: L2, c5dbc6ec5bdae596
    [junit] tag=62ded, index=72c, offset=16
    [junit] Test: DTLB, 63e5f99764c70994
    [junit] tag=4bb2638, index=0, offset=994
    [junit] Test: L1, ffffffffd5cfee52
    [junit] tag=fd5cfe, index=72, offset=12
    [junit] Test: L2, af39229731f95e68
    [junit] tag=398fc, index=af3, offset=8
    [junit] Test: DTLB, ffffffffe9256473
    [junit] tag=7ff492b, index=0, offset=473
    [junit] Test: L1, ffffffffbec13263
    [junit] tag=fbec13, index=13, offset=3
    [junit] Test: L2, a8fbadbb63152ce1
    [junit] tag=5b18a, index=967, offset=1
    [junit] Test: DTLB, 4bdd55553a96ecac
    [junit] tag=2a9d4b7, index=0, offset=cac
    [junit] Test: L1, ffffffff91aa7030
    [junit] tag=f91aa7, index=1, offset=10
    [junit] Test: L2, ffffffff96fc674c
    [junit] tag=7cb7e, index=33a, offset=c
    [junit] Test: DTLB, c9578944a6938a7
    [junit] tag=4a25349, index=0, offset=18a7
    [junit] Test: L1, fffffffff26c50ef
    [junit] tag=ff26c5, index=7, offset=f
    [junit] Test: L2, 3486def85b22ff1e
    [junit] tag=42d91, index=7f8, offset=1e
    [junit] Test: DTLB, e7f3a5e71c251224
    [junit] tag=738e128, index=0, offset=1224
    [junit] Test: L1, ffffffffba1e14f8
    [junit] tag=fba1e1, index=27, offset=18
    [junit] Test: L2, d5bfe78a0bebca97
    [junit] tag=505f5, index=e54, offset=17
    [junit] Test: DTLB, ffffffffa38ef154
    [junit] tag=7fd1c77, index=0, offset=1154
    [junit] Test: L1, ffffffff93b6be47
    [junit] tag=f93b6b, index=72, offset=7
    [junit] Test: L2, e5a6b9a11daceb82
    [junit] tag=8ed6, index=75c, offset=2
    [junit] Test: DTLB, d2042d7b041045b7
    [junit] tag=3d82082, index=0, offset=5b7
    [junit] Test: L1, aabd1ccd08ff968c
    [junit] tag=d08ff9, index=34, offset=c
    [junit] Test: L2, fffffffff444f1b5
    [junit] tag=7fa22, index=78d, offset=15
    [junit] Test: DTLB, ffffffffd3239e4f
    [junit] tag=7fe991c, index=0, offset=1e4f
    [junit] Test: L1, 74db4e7f595b73a6
    [junit] tag=f595b7, index=1d, offset=6
    [junit] Test: L2, 18d25ad16bed1a27
    [junit] tag=b5f6, index=8d1, offset=7
    [junit] Test: DTLB, 54f220806b2c1be2
    [junit] tag=4035960, index=0, offset=1be2
    [junit] Test: L1, ffffffffb94e61e3
    [junit] tag=fb94e6, index=f, offset=3
    [junit] Test: L2, fffffffff037fc77
    [junit] tag=7f81b, index=fe3, offset=17
    [junit] Test: DTLB, ad8187350768e8ce
    [junit] tag=1a83b47, index=0, offset=8ce
    [junit] Test: L1, ffffffffebc2b99a
    [junit] tag=febc2b, index=4c, offset=1a
    [junit] Test: L2, 2fa6a43362d55615
    [junit] tag=1b16a, index=ab0, offset=15
    [junit] Test: DTLB, e334ad0364fec842
    [junit] tag=1b27f6, index=0, offset=842
    [junit] Test: L1, 6eb913079e42f97
    [junit] tag=79e42, index=7c, offset=17
    [junit] Test: L2, ffffffffa40e83e8
    [junit] tag=7d207, index=41f, offset=8
    [junit] Test: DTLB, 814f4c3b38592504
    [junit] tag=1d9c2c9, index=0, offset=504
    [junit] Test: L1, ffffffffc63722d9
    [junit] tag=fc6372, index=16, offset=19
    [junit] Test: L2, ffffffffd1185b1c
    [junit] tag=7e88c, index=2d8, offset=1c
    [junit] Test: DTLB, ffffffff96e71c7e
    [junit] tag=7fcb738, index=0, offset=1c7e
    [junit] Test: L1, fffffffff5366efa
    [junit] tag=ff5366, index=77, offset=1a
    [junit] Test: L2, e290566c24f0de6b
    [junit] tag=61278, index=6f3, offset=b
    [junit] Test: DTLB, ec60d6d72c6742e1
    [junit] tag=6b9633a, index=0, offset=2e1
    [junit] Test: L1, ffffffff8d03fc27
    [junit] tag=f8d03f, index=61, offset=7
    [junit] Test: L2, 8a84d32e734a5eeb
    [junit] tag=739a5, index=2f7, offset=b
    [junit] Test: DTLB, e82896926c37a38d
    [junit] tag=49361bd, index=0, offset=38d
    [junit] Test: L1, ffffffffe742e779
    [junit] tag=fe742e, index=3b, offset=19
    [junit] Test: L2, ef3ba78201a10588
    [junit] tag=100d0, index=82c, offset=8
    [junit] Test: DTLB, ffffffffde535bda
    [junit] tag=7fef29a, index=0, offset=1bda
    [junit] Test: L1, ffffffffa375d5ee
    [junit] tag=fa375d, index=2f, offset=e
    [junit] Test: L2, ffffffffe60b4208
    [junit] tag=7f305, index=a10, offset=8
    [junit] Test: DTLB, ffffffffbc8a9d40
    [junit] tag=7fde454, index=0, offset=1d40
    [junit] Test: L1, fc87a9987b2bbc7d
    [junit] tag=87b2bb, index=63, offset=1d
    [junit] Test: L2, fffffffffba37978
    [junit] tag=7fdd1, index=bcb, offset=18
    [junit] Test: DTLB, 7612241e776beda1
    [junit] tag=f3bb5f, index=0, offset=da1
    [junit] Test: L1, 60e11ca328c8191d
    [junit] tag=328c81, index=48, offset=1d
    [junit] Test: L2, 333531d904979884
    [junit] tag=4824b, index=cc4, offset=4
    [junit] Test: DTLB, 9862120159556046
    [junit] tag=acaab, index=0, offset=46
    [junit] Test: L1, ffffffff87d72cf7
    [junit] tag=f87d72, index=67, offset=17
    [junit] Test: L2, ffffffffd108ae9f
    [junit] tag=7e884, index=574, offset=1f
    [junit] Test: DTLB, d766d1be3dcbad39
    [junit] tag=5f1ee5d, index=0, offset=d39
    [junit] Test: L1, 8a2a0e3362697c2e
    [junit] tag=362697, index=61, offset=e
    [junit] Test: L2, ffffffff80472bb4
    [junit] tag=7c023, index=95d, offset=14
    [junit] Test: DTLB, ffffffffacddd0d7
    [junit] tag=7fd66ee, index=0, offset=10d7
    [junit] Test: L1, 3d297c8b24171eac
    [junit] tag=b24171, index=75, offset=c
    [junit] Test: L2, ffffffffeac55108
    [junit] tag=7f562, index=a88, offset=8
    [junit] Test: DTLB, 633a17fd4743623d
    [junit] tag=7ea3a1b, index=0, offset=23d
    [junit] Test: L1, b781f934102d0b22
    [junit] tag=4102d0, index=59, offset=2
    [junit] Test: L2, be0d82c322077d17
    [junit] tag=19103, index=be8, offset=17
    [junit] Test: DTLB, ffffffffaab65a1d
    [junit] tag=7fd55b2, index=0, offset=1a1d
    [junit] Test: L1, 801fca4272946fb0
    [junit] tag=272946, index=7d, offset=10
    [junit] Test: L2, 8112ffeb7a8c528d
    [junit] tag=5bd46, index=294, offset=d
    [junit] Test: DTLB, 83eca4c915e6c8da
    [junit] tag=648af36, index=0, offset=8da
    [junit] Test: L1, ffffffffc5cc0409
    [junit] tag=fc5cc0, index=20, offset=9
    [junit] Test: L2, 518df308330b43d2
    [junit] tag=41985, index=a1e, offset=12
    [junit] Test: DTLB, fffffffffb5c4f2c
    [junit] tag=7ffdae2, index=0, offset=f2c
    [junit] Test: L1, 1b5ad34d46c63325
    [junit] tag=d46c63, index=19, offset=5
    [junit] Test: L2, ffffffffab1c010b
    [junit] tag=7d58e, index=8, offset=b
    [junit] Test: DTLB, ffffffff9ca5b38a
    [junit] tag=7fce52d, index=0, offset=138a
    [junit] Test: L1, ffffffffcb56a4a6
    [junit] tag=fcb56a, index=25, offset=6
    [junit] Test: L2, ffffffffb8c41f7c
    [junit] tag=7dc62, index=fb, offset=1c
    [junit] Test: DTLB, ffffffffc8c5963e
    [junit] tag=7fe462c, index=0, offset=163e
    [junit] Test: L1, 11239c2751b31076
    [junit] tag=751b31, index=3, offset=16
    [junit] Test: L2, ffffffffb6b8ed4d
    [junit] tag=7db5c, index=76a, offset=d
    [junit] Test: DTLB, 9ed66d447f005adb
    [junit] tag=223f802, index=0, offset=1adb
    [junit] Test: L1, e33acd866ffb1c2a
    [junit] tag=66ffb1, index=61, offset=a
    [junit] Test: L2, ffffffffd7fc75c6
    [junit] tag=7ebfe, index=3ae, offset=6
    [junit] Test: DTLB, 2b9008ef143a6892
    [junit] tag=778a1d3, index=0, offset=892
    [junit] Test: L1, fffffffff528211c
    [junit] tag=ff5282, index=8, offset=1c
    [junit] Test: L2, 66c3e9461e58f6f6
    [junit] tag=30f2c, index=7b7, offset=16
    [junit] Test: DTLB, ffffffffb1b70406
    [junit] tag=7fd8db8, index=0, offset=406
    [junit] Test: L1, 24e2ac20e872b11
    [junit] tag=20e872, index=58, offset=11
    [junit] Test: L2, f36661171fc6f2fa
    [junit] tag=38fe3, index=797, offset=1a
    [junit] Test: DTLB, ffffffffaeebaf3f
    [junit] tag=7fd775d, index=0, offset=f3f
    [junit] Test: L1, ffffffffae352b22
    [junit] tag=fae352, index=59, offset=2
    [junit] Test: L2, fffffffff5c4a088
    [junit] tag=7fae2, index=504, offset=8
    [junit] Test: DTLB, 98d9e86f618cdf22
    [junit] tag=37b0c66, index=0, offset=1f22
    [junit] Test: L1, ffffffff9923aa54
    [junit] tag=f9923a, index=52, offset=14
    [junit] Test: L2, ffffffffd0e16921
    [junit] tag=7e870, index=b49, offset=1
    [junit] Test: DTLB, ffffffff9ed143be
    [junit] tag=7fcf68a, index=0, offset=3be
    [junit] Test: L1, b7b1df681fd893d8
    [junit] tag=81fd89, index=1e, offset=18
    [junit] Test: L2, 6e3f254e6f2cfb91
    [junit] tag=73796, index=7dc, offset=11
    [junit] Test: DTLB, ffffffffdbeea636
    [junit] tag=7fedf75, index=0, offset=636
    [junit] Test: L1, c52a30ae0bdab666
    [junit] tag=e0bdab, index=33, offset=6
    [junit] Test: L2, 9a5cd230396c4e5a
    [junit] tag=1cb6, index=272, offset=1a
    [junit] Test: DTLB, 751569278fb1610
    [junit] tag=493c7d8, index=0, offset=1610
    [junit] Test: L1, ffffffffb03db2aa
    [junit] tag=fb03db, index=15, offset=a
    [junit] Test: L2, ffffffffa7e98203
    [junit] tag=7d3f4, index=c10, offset=3
    [junit] Test: DTLB, ffffffffee452781
    [junit] tag=7ff7229, index=0, offset=781
    [junit] Test: L1, ffffffffb807c233
    [junit] tag=fb807c, index=11, offset=13
    [junit] Test: L2, ffffffffa8aa67f5
    [junit] tag=7d455, index=33f, offset=15
    [junit] Test: DTLB, e6fcaf203dffa9a6
    [junit] tag=101effd, index=0, offset=9a6
    [junit] Test: L1, 69735522855f9c2
    [junit] tag=22855f, index=4e, offset=2
    [junit] Test: L2, 7d3a3ab45227aebb
    [junit] tag=22913, index=d75, offset=1b
    [junit] Test: DTLB, ffffffffef6bb3b4
    [junit] tag=7ff7b5d, index=0, offset=13b4
    [junit] Test: L1, ffffffffb5ed2a83
    [junit] tag=fb5ed2, index=54, offset=3
    [junit] Test: L2, a3c5ff5f3c6718f8
    [junit] tag=79e33, index=8c7, offset=18
    [junit] Test: DTLB, 170a6c1b6a8caec9
    [junit] tag=db5465, index=0, offset=ec9
    [junit] Test: L1, 55f31adb762efd54
    [junit] tag=b762ef, index=6a, offset=14
    [junit] Test: L2, ffffffffb30fa30a
    [junit] tag=7d987, index=d18, offset=a
    [junit] Test: DTLB, ab7f48e1726a9df8
    [junit] tag=70b9354, index=0, offset=1df8
    [junit] Test: L1, 9ce8189c46273023
    [junit] tag=c46273, index=1, offset=3
    [junit] Test: L2, db482b7a1180bafb
    [junit] tag=508c0, index=5d7, offset=1b
    [junit] Test: DTLB, ffffffff82ddc3c9
    [junit] tag=7fc16ee, index=0, offset=3c9
    [junit] Test: L1, a802627470979ab0
    [junit] tag=470979, index=55, offset=10
    [junit] Test: L2, ffffffff9404a495
    [junit] tag=7ca02, index=524, offset=15
    [junit] Test: DTLB, ffffffffbfc9e447
    [junit] tag=7fdfe4f, index=0, offset=447
    [junit] Test: L1, fffffffff957d227
    [junit] tag=ff957d, index=11, offset=7
    [junit] Test: L2, 7a0f23bb22963356
    [junit] tag=5914b, index=19a, offset=16
    [junit] Test: DTLB, ffffffff8e04a3df
    [junit] tag=7fc7025, index=0, offset=3df
    [junit] Test: L1, ffffffffb0fdbc25
    [junit] tag=fb0fdb, index=61, offset=5
    [junit] Test: L2, ffffffffc92e75ca
    [junit] tag=7e497, index=3ae, offset=a
    [junit] Test: DTLB, 8dca9f4b4a9c74e9
    [junit] tag=25a54e3, index=0, offset=14e9
    [junit] Test: L1, ffffffff88ab2e74
    [junit] tag=f88ab2, index=73, offset=14
    [junit] Test: L2, 8524ff377c31b926
    [junit] tag=3be18, index=dc9, offset=6
    [junit] Test: DTLB, ffffffff8f771930
    [junit] tag=7fc7bb8, index=0, offset=1930
    [junit] Test: L1, ffffffffb1793521
    [junit] tag=fb1793, index=29, offset=1
    [junit] Test: L2, abbe02527ed0327c
    [junit] tag=13f68, index=193, offset=1c
    [junit] Test: DTLB, ffffffffa68709a7
    [junit] tag=7fd3438, index=0, offset=9a7
    [junit] Test: L1, 88641d1f273f4375
    [junit] tag=f273f4, index=1b, offset=15
    [junit] Test: L2, 5636991833d4661d
    [junit] tag=419ea, index=330, offset=1d
    [junit] Test: DTLB, ec0439376b91fcde
    [junit] tag=1bb5c8f, index=0, offset=1cde
    [junit] Test: L1, ffffffffb84cf518
    [junit] tag=fb84cf, index=28, offset=18
    [junit] Test: L2, ffffffffe9e679ad
    [junit] tag=7f4f3, index=3cd, offset=d
    [junit] Test: DTLB, ffffffffba6a88cc
    [junit] tag=7fdd354, index=0, offset=8cc
    [junit] Test: L1, ffffffffe4b82853
    [junit] tag=fe4b82, index=42, offset=13
    [junit] Test: L2, 5379f9e37a2342da
    [junit] tag=1bd11, index=a16, offset=1a
    [junit] Test: DTLB, ffffffffdbc822b1
    [junit] tag=7fede41, index=0, offset=2b1
    [junit] Test: L1, e0225c550c911d8c
    [junit] tag=50c911, index=6c, offset=c
    [junit] Test: L2, ffffffffd0b8e6fa
    [junit] tag=7e85c, index=737, offset=1a
    [junit] Test: DTLB, 8949b477bf4fe13
    [junit] tag=23bdfa7, index=0, offset=1e13
    [junit] Test: L1, 8e43a15445c520e1
    [junit] tag=445c52, index=7, offset=1
    [junit] Test: L2, 25d70a862031e7c
    [junit] tag=43101, index=8f3, offset=1c
    [junit] Test: DTLB, ffffffff8543a466
    [junit] tag=7fc2a1d, index=0, offset=466
    [junit] Test: L1, ea86b2dc6ef51195
    [junit] tag=c6ef51, index=c, offset=15
    [junit] Test: L2, a78174b701e75a4f
    [junit] tag=380f3, index=ad2, offset=f
    [junit] Test: DTLB, 6159bd2043956990
    [junit] tag=1021cab, index=0, offset=990
    [junit] Test: L1, d11331fb3ea3b8c8
    [junit] tag=b3ea3b, index=46, offset=8
    [junit] Test: L2, e4443e0800dc8174
    [junit] tag=4006e, index=40b, offset=14
    [junit] Test: DTLB, 19d004b64d826838
    [junit] tag=5b26c13, index=0, offset=838
    [junit] Test: L1, ffffffff90121478
    [junit] tag=f90121, index=23, offset=18
    [junit] Test: L2, fffffffff4ed96b5
    [junit] tag=7fa76, index=cb5, offset=15
    [junit] Test: DTLB, 8c9d52ad669ceabd
    [junit] tag=56b34e7, index=0, offset=abd
    [junit] Test: L1, ffffffffe88660b6
    [junit] tag=fe8866, index=5, offset=16
    [junit] Test: L2, 909e0349364d2b92
    [junit] tag=49b26, index=95c, offset=12
    [junit] Test: DTLB, ffffffffe554a397
    [junit] tag=7ff2aa5, index=0, offset=397
    [junit] Test: L1, ffffffffe29b0bf8
    [junit] tag=fe29b0, index=5f, offset=18
    [junit] Test: L2, 48d9fb38543dc34f
    [junit] tag=42a1e, index=e1a, offset=f
    [junit] Test: DTLB, ffffffffbc8f8287
    [junit] tag=7fde47c, index=0, offset=287
    [junit] Test: L1, dca5bf0574ba694c
    [junit] tag=574ba6, index=4a, offset=c
    [junit] Test: L2, ffffffff85dcfaa4
    [junit] tag=7c2ee, index=7d5, offset=4
    [junit] Test: DTLB, fffffffff874eadb
    [junit] tag=7ffc3a7, index=0, offset=adb
    [junit] Test: L1, e04319ca4b0041a4
    [junit] tag=a4b004, index=d, offset=4
    [junit] Test: L2, 2d7cc8330963d837
    [junit] tag=184b1, index=ec1, offset=17
    [junit] Test: DTLB, 32e4f7ef4016962e
    [junit] tag=77a00b4, index=0, offset=162e
    [junit] Test: L1, ffffffffd864345e
    [junit] tag=fd8643, index=22, offset=1e
    [junit] Test: L2, ffffffff8378e7c2
    [junit] tag=7c1bc, index=73e, offset=2
    [junit] Test: DTLB, be208b4d266837be
    [junit] tag=2693341, index=0, offset=17be
    [junit] Test: L1, b0166c1168cfbe0c
    [junit] tag=168cfb, index=70, offset=c
    [junit] Test: L2, ffffffffb7935557
    [junit] tag=7dbc9, index=aaa, offset=17
    [junit] Test: DTLB, ffffffff9480daf3
    [junit] tag=7fca406, index=0, offset=1af3
    [junit] Test: L1, 561de32f43108aa8
    [junit] tag=f43108, index=55, offset=8
    [junit] Test: L2, 268f1985213c69d3
    [junit] tag=2909e, index=34e, offset=13
    [junit] Test: DTLB, ffffffff9ba4b187
    [junit] tag=7fcdd25, index=0, offset=1187
    [junit] Test: L1, ffffffff882d3046
    [junit] tag=f882d3, index=2, offset=6
    [junit] Test: L2, 112ef03f2ee799e7
    [junit] tag=79773, index=ccf, offset=7
    [junit] Test: DTLB, 939bb14b3e3eba90
    [junit] tag=259f1f5, index=0, offset=1a90
    [junit] Test: L1, ffffffffe2d12c98
    [junit] tag=fe2d12, index=64, offset=18
    [junit] Test: L2, e447391c5ac4c302
    [junit] tag=62d62, index=618, offset=2
    [junit] Test: DTLB, 369c6b1266af8373
    [junit] tag=93357c, index=0, offset=373
    [junit] Test: L1, eb2118a2feb2ed0
    [junit] tag=a2feb2, index=76, offset=10
    [junit] Test: L2, ffffffffcefdda80
    [junit] tag=7e77e, index=ed4, offset=0
    [junit] Test: DTLB, ffffffff80eb388a
    [junit] tag=7fc0759, index=0, offset=188a
    [junit] Test: L1, ffffffff813a3dea
    [junit] tag=f813a3, index=6f, offset=a
    [junit] Test: L2, ffffffffaf1e71ab
    [junit] tag=7d78f, index=38d, offset=b
    [junit] Test: DTLB, 43dbbf9565b115d4
    [junit] tag=4ab2d88, index=0, offset=15d4
    [junit] Test: L1, 4cd2c5714d48fecf
    [junit] tag=14d48f, index=76, offset=f
    [junit] Test: L2, 648366ef57088172
    [junit] tag=7ab84, index=40b, offset=12
    [junit] Test: DTLB, ffffffffcc2f44ae
    [junit] tag=7fe617a, index=0, offset=4ae
    [junit] Test: L1, 7040a9b443746ed1
    [junit] tag=443746, index=76, offset=11
    [junit] Test: L2, fffffffff3b98b3d
    [junit] tag=7f9dc, index=c59, offset=1d
    [junit] Test: DTLB, ffffffffadd0b372
    [junit] tag=7fd6e85, index=0, offset=1372
    [junit] Test: L1, ffffffffaaec4aa5
    [junit] tag=faaec4, index=55, offset=5
    [junit] Test: L2, 77e641104a4432c4
    [junit] tag=2522, index=196, offset=4
    [junit] Test: DTLB, ffffffffc95ab6db
    [junit] tag=7fe4ad5, index=0, offset=16db
    [junit] Test: L1, fffffffff31049bf
    [junit] tag=ff3104, index=4d, offset=1f
    [junit] Test: L2, ffffffffd4261f23
    [junit] tag=7ea13, index=f9, offset=3
    [junit] Test: DTLB, ffffffffab0185bd
    [junit] tag=7fd580c, index=0, offset=5bd
    [junit] Test: L1, c9520f6706a4f27d
    [junit] tag=706a4f, index=13, offset=1d
    [junit] Test: L2, e26c53ba29bcfaf3
    [junit] tag=514de, index=7d7, offset=13
    [junit] Test: DTLB, ffffffffcc427f54
    [junit] tag=7fe6213, index=0, offset=1f54
    [junit] Test: L1, 19ad1b523e5ba8bb
    [junit] tag=23e5ba, index=45, offset=1b
    [junit] Test: L2, ffffffffc6f4feff
    [junit] tag=7e37a, index=7f7, offset=1f
    [junit] Test: DTLB, 23877ceb09b8ede8
    [junit] tag=7584dc7, index=0, offset=de8
    [junit] Test: L1, 88c3410737f00466
    [junit] tag=737f00, index=23, offset=6
    [junit] Test: L2, ffffffffe6994450
    [junit] tag=7f34c, index=a22, offset=10
    [junit] Test: DTLB, fffffffff83f3cc9
    [junit] tag=7ffc1f9, index=0, offset=1cc9
    [junit] Test: L1, ffffffff826ecbc1
    [junit] tag=f826ec, index=5e, offset=1
    [junit] Test: L2, ffffffffe858a814
    [junit] tag=7f42c, index=540, offset=14
    [junit] Test: DTLB, ffffffffd5e11cd3
    [junit] tag=7feaf08, index=0, offset=1cd3
    [junit] Test: L1, ffffffffb275d1e2
    [junit] tag=fb275d, index=f, offset=2
    [junit] Test: L2, ffffffffe88ea687
    [junit] tag=7f447, index=534, offset=7
    [junit] Test: DTLB, ffffffff9939a0e0
    [junit] tag=7fcc9cd, index=0, offset=e0
    [junit] Test: L1, ffffffffa3b82ab7
    [junit] tag=fa3b82, index=55, offset=17
    [junit] Test: L2, 69927e786f4807ee
    [junit] tag=437a4, index=3f, offset=e
    [junit] Test: DTLB, 6881df75133c2587
    [junit] tag=3a899e1, index=0, offset=587
    [junit] Test: L1, ffffffffc170ad1e
    [junit] tag=fc170a, index=68, offset=1e
    [junit] Test: L2, d1019d584a5a2458
    [junit] tag=4252d, index=122, offset=18
    [junit] Test: DTLB, ffffffffe5af9781
    [junit] tag=7ff2d7c, index=0, offset=1781
    [junit] Test: L1, fffffffff4220ead
    [junit] tag=ff4220, index=75, offset=d
    [junit] Test: L2, 70368b52549f69e4
    [junit] tag=12a4f, index=b4f, offset=4
    [junit] Test: DTLB, f937d19f1307d87f
    [junit] tag=4f8983e, index=0, offset=187f
    [junit] Test: L1, 12c3d4cc0512e1e9
    [junit] tag=c0512e, index=f, offset=9
    [junit] Test: L2, ffffffffc1cbd7e0
    [junit] tag=7e0e5, index=ebf, offset=0
    [junit] Test: DTLB, ffffffffb0224ae4
    [junit] tag=7fd8112, index=0, offset=ae4
    [junit] Test: L1, fffffffffc5adc0e
    [junit] tag=ffc5ad, index=60, offset=e
    [junit] Test: L2, 60567bfd79fcf3a0
    [junit] tag=6bcfe, index=79d, offset=0
    [junit] Test: DTLB, ffffffffc375ebec
    [junit] tag=7fe1baf, index=0, offset=bec
    [junit] Test: L1, 83d64865588b8cc0
    [junit] tag=5588b8, index=66, offset=0
    [junit] Test: L2, ffffffffa321cd01
    [junit] tag=7d190, index=e68, offset=1
    [junit] Test: DTLB, ffffffff823664e8
    [junit] tag=7fc11b3, index=0, offset=4e8
    [junit] Test: L1, 4efc2a9f456732a8
    [junit] tag=f45673, index=15, offset=8
    [junit] Test: L2, ffffffffe5621fa3
    [junit] tag=7f2b1, index=fd, offset=3
    [junit] Test: DTLB, ffffffff8b1d6b45
    [junit] tag=7fc58eb, index=0, offset=b45
    [junit] Test: L1, ffffffffd683bc26
    [junit] tag=fd683b, index=61, offset=6
    [junit] Test: L2, d62963a008541710
    [junit] tag=42a, index=b8, offset=10
    [junit] Test: DTLB, fffffffff1b5462f
    [junit] tag=7ff8daa, index=0, offset=62f
    [junit] Test: L1, 14f45d6157dd0a07
    [junit] tag=157dd0, index=50, offset=7
    [junit] Test: L2, 1203adc7352bb07c
    [junit] tag=39a95, index=d83, offset=1c
    [junit] Test: DTLB, ffffffffbb8e3b3c
    [junit] tag=7fddc71, index=0, offset=1b3c
    [junit] Test: L1, 88c168450d5469c5
    [junit] tag=50d546, index=4e, offset=5
    [junit] Test: L2, 51463e864d564f19
    [junit] tag=326ab, index=278, offset=19
    [junit] Test: DTLB, e478a91b36e9779d
    [junit] tag=d9b74b, index=0, offset=179d
    [junit] Test: L1, 4220cd2517f4ff49
    [junit] tag=517f4f, index=7a, offset=9
    [junit] Test: L2, ffffffffdc23ba47
    [junit] tag=7ee11, index=dd2, offset=7
    [junit] Test: DTLB, ffffffffc9fa1183
    [junit] tag=7fe4fd0, index=0, offset=1183
    [junit] Test: L1, c96be012312a9be4
    [junit] tag=2312a9, index=5f, offset=4
    [junit] Test: L2, ffffffffb84db3e2
    [junit] tag=7dc26, index=d9f, offset=2
    [junit] Test: DTLB, fffffffff84c73ae
    [junit] tag=7ffc263, index=0, offset=13ae
    [junit] Test: L1, ecff7de87a3539d3
    [junit] tag=87a353, index=4e, offset=13
    [junit] Test: L2, 78eec7f401f0cee7
    [junit] tag=200f8, index=677, offset=7
    [junit] Test: DTLB, ffffffffddced3b7
    [junit] tag=7feee76, index=0, offset=13b7
    [junit] Test: L1, ffffffffc96051f3
    [junit] tag=fc9605, index=f, offset=13
    [junit] Test: L2, ffffffffef282b1e
    [junit] tag=7f794, index=158, offset=1e
    [junit] Test: DTLB, f57f34a6055c10a5
    [junit] tag=5302ae0, index=0, offset=10a5
    [junit] Test: L1, ffffffff8b8a3325
    [junit] tag=f8b8a3, index=19, offset=5
    [junit] Test: L2, 2ec99d9d6739ad95
    [junit] tag=6b39c, index=d6c, offset=15
    [junit] Test: DTLB, 5223abb0541aa7bc
    [junit] tag=582a0d5, index=0, offset=7bc
    [junit] Test: L1, 773304365a97c6c7
    [junit] tag=65a97c, index=36, offset=7
    [junit] Test: L2, 612a4c5419012735
    [junit] tag=20c80, index=939, offset=15
    [junit] Test: DTLB, ffffffffc1b325ed
    [junit] tag=7fe0d99, index=0, offset=5ed
    [junit] Test: L1, ffffffffa0956a3c
    [junit] tag=fa0956, index=51, offset=1c
    [junit] Test: L2, ffffffffd0576483
    [junit] tag=7e82b, index=b24, offset=3
    [junit] Test: DTLB, ffffffffef46d7c5
    [junit] tag=7ff7a36, index=0, offset=17c5
    [junit] Test: L1, ffffffffd51c0270
    [junit] tag=fd51c0, index=13, offset=10
    [junit] Test: L2, 47b7219b1d747d21
    [junit] tag=58eba, index=3e9, offset=1
    [junit] Test: DTLB, ffffffffcd7a866b
    [junit] tag=7fe6bd4, index=0, offset=66b
    [junit] Test: L1, ffffffff9ed9872e
    [junit] tag=f9ed98, index=39, offset=e
    [junit] Test: L2, e00d2fda1877ea0f
    [junit] tag=50c3b, index=f50, offset=f
    [junit] Test: DTLB, 1293f299685dc096
    [junit] tag=4cb42ee, index=0, offset=96
    [junit] Test: L1, cfc8fad70f931a3c
    [junit] tag=70f931, index=51, offset=1c
    [junit] Test: L2, ffffffff8b531756
    [junit] tag=7c5a9, index=8ba, offset=16
    [junit] Test: DTLB, ffffffffd0b08b6f
    [junit] tag=7fe8584, index=0, offset=b6f
    [junit] Test: L1, 11d623672a9e7e19
    [junit] tag=72a9e7, index=70, offset=19
    [junit] Test: L2, ffffffffb2fdf693
    [junit] tag=7d97e, index=fb4, offset=13
    [junit] Test: DTLB, ffffffff9b5cac4b
    [junit] tag=7fcdae5, index=0, offset=c4b
    [junit] Test: L1, ffffffff961fb558
    [junit] tag=f961fb, index=2a, offset=18
    [junit] Test: L2, ffffffff9c43853d
    [junit] tag=7ce21, index=c29, offset=1d
    [junit] Test: DTLB, ffffffffd6833b91
    [junit] tag=7feb419, index=0, offset=1b91
    [junit] Test: L1, ffffffff8a6ab84e
    [junit] tag=f8a6ab, index=42, offset=e
    [junit] Test: L2, ffffffffd5528db6
    [junit] tag=7eaa9, index=46d, offset=16
    [junit] Test: DTLB, dba5c6ff44d03458
    [junit] tag=7fa2681, index=0, offset=1458
    [junit] Test: L1, ffffffffffebba75
    [junit] tag=fffebb, index=53, offset=15
    [junit] Test: L2, ffffffff9a19b1c7
    [junit] tag=7cd0c, index=d8e, offset=7
    [junit] Test: DTLB, ffffffff81703f0f
    [junit] tag=7fc0b81, index=0, offset=1f0f
    [junit] Test: L1, 4ffcfa175bd9861f
    [junit] tag=75bd98, index=30, offset=1f
    [junit] Test: L2, 6dd675d0370246c3
    [junit] tag=1b81, index=236, offset=3
    [junit] Test: DTLB, ffffffffc2341a94
    [junit] tag=7fe11a0, index=0, offset=1a94
    [junit] Test: L1, ffffffffee208145
    [junit] tag=fee208, index=a, offset=5
    [junit] Test: L2, ffffffffe8ee4efe
    [junit] tag=7f477, index=277, offset=1e
    [junit] Test: DTLB, 69c27ebf239c178f
    [junit] tag=5f91ce0, index=0, offset=178f
    [junit] Test: L1, 65c14edd00399898
    [junit] tag=d00399, index=44, offset=18
    [junit] Test: L2, ffffffffeeab932d
    [junit] tag=7f755, index=c99, offset=d
    [junit] Test: DTLB, ffffffffa449994e
    [junit] tag=7fd224c, index=0, offset=194e
    [junit] Test: L1, 64e52c7e73c24a46
    [junit] tag=e73c24, index=52, offset=6
    [junit] Test: L2, 36b6111f7e147900
    [junit] tag=7bf0a, index=3c8, offset=0
    [junit] Test: DTLB, 705fc257106e3c8b
    [junit] tag=2b88371, index=0, offset=1c8b
    [junit] Test: L1, ffffffffab86fc71
    [junit] tag=fab86f, index=63, offset=11
    [junit] Test: L2, ffffffffe61d55d0
    [junit] tag=7f30e, index=aae, offset=10
    [junit] Test: DTLB, 72ee9e5b135e1967
    [junit] tag=2d89af0, index=0, offset=1967
    [junit] Test: L1, 923b267c09d6e620
    [junit] tag=c09d6e, index=31, offset=0
    [junit] Test: L2, 9c9592a639bccf47
    [junit] tag=31cde, index=67a, offset=7
    [junit] Test: DTLB, ace687d229aab6ff
    [junit] tag=6914d55, index=0, offset=16ff
    [junit] Test: L1, ffffffff864dfa5c
    [junit] tag=f864df, index=52, offset=1c
    [junit] Test: L2, ffffffffe8391452
    [junit] tag=7f41c, index=8a2, offset=12
    [junit] Test: DTLB, ffffffff8e50da8a
    [junit] tag=7fc7286, index=0, offset=1a8a
    [junit] Test: L1, 912608af457dc2d9
    [junit] tag=f457dc, index=16, offset=19
    [junit] Test: L2, 40b9494d7521fbd9
    [junit] tag=6ba90, index=fde, offset=19
    [junit] Test: DTLB, e4a8ca414544192a
    [junit] tag=20a2a20, index=0, offset=192a
    [junit] Test: L1, fffffffffd2d2278
    [junit] tag=ffd2d2, index=13, offset=18
    [junit] Test: L2, ffffffff8f42a639
    [junit] tag=7c7a1, index=531, offset=19
    [junit] Test: DTLB, fffffffffba07fcf
    [junit] tag=7ffdd03, index=0, offset=1fcf
    [junit] Test: L1, ffffffffc581fc36
    [junit] tag=fc581f, index=61, offset=16
    [junit] Test: L2, ffffffffab46610a
    [junit] tag=7d5a3, index=308, offset=a
    [junit] Test: DTLB, 65a4defd04f87dc7
    [junit] tag=7e827c3, index=0, offset=1dc7
    [junit] Test: L1, ffffffffc4654e4d
    [junit] tag=fc4654, index=72, offset=d
    [junit] Test: L2, ffffffffff36706f
    [junit] tag=7ff9b, index=383, offset=f
    [junit] Test: DTLB, 512ecd62387351c8
    [junit] tag=311c39a, index=0, offset=11c8
    [junit] Test: L1, ffffffffee0633fa
    [junit] tag=fee063, index=1f, offset=1a
    [junit] Test: L2, ffffffffd2e6adc1
    [junit] tag=7e973, index=56e, offset=1
    [junit] Test: DTLB, 4bfef76d339dec59
    [junit] tag=3699cef, index=0, offset=c59
    [junit] Test: L1, 44a04e9207b60ffa
    [junit] tag=207b60, index=7f, offset=1a
    [junit] Test: L2, ffffffffc531915c
    [junit] tag=7e298, index=c8a, offset=1c
    [junit] Test: DTLB, c7b953114a664491
    [junit] tag=8a5332, index=0, offset=491
    [junit] Test: L1, ffffffffeb36f5ab
    [junit] tag=feb36f, index=2d, offset=b
    [junit] Test: L2, 64a820be09851f1d
    [junit] tag=704c2, index=8f8, offset=1d
    [junit] Test: DTLB, ffffffffebea419a
    [junit] tag=7ff5f52, index=0, offset=19a
    [junit] Test: L1, ffffffffaab824e8
    [junit] tag=faab82, index=27, offset=8
    [junit] Test: L2, 72c00bd51bcf8305
    [junit] tag=28de7, index=c18, offset=5
    [junit] Test: DTLB, 9ae219b86d49d5be
    [junit] tag=5c36a4e, index=0, offset=15be
    [junit] Test: L1, d7e4b97d220bc315
    [junit] tag=d220bc, index=18, offset=15
    [junit] Test: L2, 42559721627e9e92
    [junit] tag=b13f, index=4f4, offset=12
    [junit] Test: DTLB, ffffffff9c9d92dd
    [junit] tag=7fce4ec, index=0, offset=12dd
    [junit] Test: L1, ffffffff90503e05
    [junit] tag=f90503, index=70, offset=5
    [junit] Test: L2, ffffffff86783ba9
    [junit] tag=7c33c, index=1dd, offset=9
    [junit] Test: DTLB, 58ea1fca77028736
    [junit] tag=653b814, index=0, offset=736
    [junit] Test: L1, ffffffffd461d4cf
    [junit] tag=fd461d, index=26, offset=f
    [junit] Test: L2, 419501324624fca5
    [junit] tag=12312, index=7e5, offset=5
    [junit] Test: DTLB, cdf088d53756777
    [junit] tag=46a9bab, index=0, offset=777
    [junit] Test: L1, 4163fd181a453a26
    [junit] tag=81a453, index=51, offset=6
    [junit] Test: L2, ffffffffc0ff909a
    [junit] tag=7e07f, index=c84, offset=1a
    [junit] Test: DTLB, ffffffff902ae2be
    [junit] tag=7fc8157, index=0, offset=2be
    [junit] Test: L1, ffffffffa006e788
    [junit] tag=fa006e, index=3c, offset=8
    [junit] Test: L2, ba9027bd0b943963
    [junit] tag=685ca, index=1cb, offset=3
    [junit] Test: DTLB, 5cc3e75275ef741f
    [junit] tag=293af7b, index=0, offset=141f
    [junit] Test: L1, fa41ebc047aa0537
    [junit] tag=47aa0, index=29, offset=17
    [junit] Test: L2, ffffffffc24689dd
    [junit] tag=7e123, index=44e, offset=1d
    [junit] Test: DTLB, 8dd5adfb2305ce17
    [junit] tag=7d9182e, index=0, offset=e17
    [junit] Test: L1, 5005536c30027679
    [junit] tag=c30027, index=33, offset=19
    [junit] Test: L2, cd63392459b77496
    [junit] tag=22cdb, index=ba4, offset=16
    [junit] Test: DTLB, c996ff613b242858
    [junit] tag=309d921, index=0, offset=858
    [junit] Test: L1, bc840a913035413
    [junit] tag=913035, index=20, offset=13
    [junit] Test: L2, 61f766fd64277043
    [junit] tag=6b213, index=b82, offset=3
    [junit] Test: DTLB, d878b2632660750e
    [junit] tag=3193303, index=0, offset=150e
    [junit] Test: L1, f0aec6d554c5652e
    [junit] tag=554c56, index=29, offset=e
    [junit] Test: L2, e7080e050e5c327b
    [junit] tag=2872e, index=193, offset=1b
    [junit] Test: DTLB, 7c0a223708fd57c3
    [junit] tag=1b847ea, index=0, offset=17c3
    [junit] Test: L1, f0bc9b91fbdca34
    [junit] tag=91fbdc, index=51, offset=14
    [junit] Test: L2, ffffffff809ce04a
    [junit] tag=7c04e, index=702, offset=a
    [junit] Test: DTLB, ffffffff95273f42
    [junit] tag=7fca939, index=0, offset=1f42
    [junit] Test: L1, ffffffffee73d771
    [junit] tag=fee73d, index=3b, offset=11
    [junit] Test: L2, 533174f929cda590
    [junit] tag=494e6, index=d2c, offset=10
    [junit] Test: DTLB, 5f52b31e503e2301
    [junit] tag=f281f1, index=0, offset=301
    [junit] Test: L1, fffffffff58ae77a
    [junit] tag=ff58ae, index=3b, offset=1a
    [junit] Test: L2, ffffffffdffc7311
    [junit] tag=7effe, index=398, offset=11
    [junit] Test: DTLB, fffffffff666b69f
    [junit] tag=7ffb335, index=0, offset=169f
    [junit] Test: L1, fffffffff4616826
    [junit] tag=ff4616, index=41, offset=6
    [junit] Test: L2, ffffffffab725fb6
    [junit] tag=7d5b9, index=2fd, offset=16
    [junit] Test: DTLB, ffffffffdb293a5d
    [junit] tag=7fed949, index=0, offset=1a5d
    [junit] Test: L1, ffffffffdf5a4d8b
    [junit] tag=fdf5a4, index=6c, offset=b
    [junit] Test: L2, dfda13c5090501ab
    [junit] tag=28482, index=80d, offset=b
    [junit] Test: DTLB, ffffffffc8a2a430
    [junit] tag=7fe4515, index=0, offset=430
    [junit] Test: L1, ffffffffec11ec90
    [junit] tag=fec11e, index=64, offset=10
    [junit] Test: L2, 32cb11b0423b96bf
    [junit] tag=211d, index=cb5, offset=1f
    [junit] Test: DTLB, 8b9418232a51408c
    [junit] tag=119528a, index=0, offset=8c
    [junit] Test: L1, ffffffffacbe9205
    [junit] tag=facbe9, index=10, offset=5
    [junit] Test: L2, 8fd205652052b9cc
    [junit] tag=29029, index=5ce, offset=c
    [junit] Test: DTLB, b2cc3351334d2910
    [junit] tag=2899a69, index=0, offset=910
    [junit] Test: L1, fffffffff228ab77
    [junit] tag=ff228a, index=5b, offset=17
    [junit] Test: L2, ffffffffdc78c537
    [junit] tag=7ee3c, index=629, offset=17
    [junit] Test: DTLB, ffffffff8791f804
    [junit] tag=7fc3c8f, index=0, offset=1804
    [junit] Test: L1, ffffffff828db070
    [junit] tag=f828db, index=3, offset=10
    [junit] Test: L2, 82a7f1e6640f1898
    [junit] tag=33207, index=8c4, offset=18
    [junit] Test: DTLB, ffffffff83af4263
    [junit] tag=7fc1d7a, index=0, offset=263
    [junit] Test: L1, fffffffff91dd549
    [junit] tag=ff91dd, index=2a, offset=9
    [junit] Test: L2, 28c9d8cb35f0cb0c
    [junit] tag=59af8, index=658, offset=c
    [junit] Test: DTLB, ffffffffcee8ed98
    [junit] tag=7fe7747, index=0, offset=d98
    [junit] Test: L1, 9cd70efb7f6b5272
    [junit] tag=b7f6b5, index=13, offset=12
    [junit] Test: L2, 5c00ce165ca2bca5
    [junit] tag=32e51, index=5e5, offset=5
    [junit] Test: DTLB, 6c987dc11bb8f80e
    [junit] tag=608ddc7, index=0, offset=180e
    [junit] Test: L1, c822168c6152725d
    [junit] tag=c61527, index=12, offset=1d
    [junit] Test: L2, e34e070452fd5697
    [junit] tag=2297e, index=ab4, offset=17
    [junit] Test: DTLB, 3c2f5341a2bbe4f
    [junit] tag=1a0d15d, index=0, offset=1e4f
    [junit] Test: L1, d2eb46e801385784
    [junit] tag=801385, index=3c, offset=4
    [junit] Test: L2, ffffffffb75fe8b3
    [junit] tag=7dbaf, index=f45, offset=13
    [junit] Test: DTLB, ffffffff80209027
    [junit] tag=7fc0104, index=0, offset=1027
    [junit] Test: L1, ffffffffda5b5ad0
    [junit] tag=fda5b5, index=56, offset=10
    [junit] Test: L2, e8908e5615d747d8
    [junit] tag=30aeb, index=a3e, offset=18
    [junit] Test: DTLB, 33e1a03735736f6
    [junit] tag=1b9ab9, index=0, offset=16f6
    [junit] Test: L1, ffffffffa707e249
    [junit] tag=fa707e, index=12, offset=9
    [junit] Test: L2, 8872db864fded2ec
    [junit] tag=327ef, index=697, offset=c
    [junit] Test: DTLB, ffffffff8464d068
    [junit] tag=7fc2326, index=0, offset=1068
    [junit] Test: L1, e613ab10109233f2
    [junit] tag=10923, index=1f, offset=12
    [junit] Test: L2, ffffffffe8cd5e1c
    [junit] tag=7f466, index=af0, offset=1c
    [junit] Test: DTLB, 25350ac057b1c928
    [junit] tag=602bd8e, index=0, offset=928
    [junit] Test: L1, 9e72aff879280b17
    [junit] tag=879280, index=58, offset=17
    [junit] Test: L2, a1b681165fb80c3d
    [junit] tag=32fdc, index=61, offset=1d
    [junit] Test: DTLB, 9415a19e61dfb26b
    [junit] tag=4f30efd, index=0, offset=126b
    [junit] Test: L1, fffffffffb19ded9
    [junit] tag=ffb19d, index=76, offset=19
    [junit] Test: L2, 761c168a14be59b2
    [junit] tag=50a5f, index=2cd, offset=12
    [junit] Test: DTLB, 614f21b666392cf8
    [junit] tag=5b331c9, index=0, offset=cf8
    [junit] Test: L1, f07dfd2d229cca3e
    [junit] tag=d229cc, index=51, offset=1e
    [junit] Test: L2, a0dcf5c752928e13
    [junit] tag=3a949, index=470, offset=13
    [junit] Test: DTLB, ffffffff92459994
    [junit] tag=7fc922c, index=0, offset=1994
    [junit] Test: L1, a80eb0bb7d6b00cd
    [junit] tag=b7d6b0, index=6, offset=d
    [junit] Test: L2, ffffffff83d360f9
    [junit] tag=7c1e9, index=b07, offset=19
    [junit] Test: DTLB, ffffffffcb186ef9
    [junit] tag=7fe58c3, index=0, offset=ef9
    [junit] Test: L1, f8ba0982430a22a7
    [junit] tag=2430a2, index=15, offset=7
    [junit] Test: L2, c319b177426e3b20
    [junit] tag=3a137, index=1d9, offset=0
    [junit] Test: DTLB, a286b5047df12d27
    [junit] tag=23ef89, index=0, offset=d27
    [junit] Test: L1, ffffffffd6c117f1
    [junit] tag=fd6c11, index=3f, offset=11
    [junit] Test: L2, ffffffff862cef76
    [junit] tag=7c316, index=77b, offset=16
    [junit] Test: DTLB, 3d8f0ac91253c65b
    [junit] tag=648929e, index=0, offset=65b
    [junit] Test: L1, ffffffffe56f4468
    [junit] tag=fe56f4, index=23, offset=8
    [junit] Test: L2, 4bb5583745e6184d
    [junit] tag=3a2f3, index=c2, offset=d
    [junit] Test: DTLB, ffffffffbf968697
    [junit] tag=7fdfcb4, index=0, offset=697
    [junit] Test: L1, ffffffffe6999057
    [junit] tag=fe6999, index=2, offset=17
    [junit] Test: L2, ffffffffbb4d6a9f
    [junit] tag=7dda6, index=b54, offset=1f
    [junit] Test: DTLB, 4983e6c9214557e0
    [junit] tag=6490a2a, index=0, offset=17e0
    [junit] Test: L1, ffffffffa306fc52
    [junit] tag=fa306f, index=62, offset=12
    [junit] Test: L2, b7f9e1050bde8821
    [junit] tag=285ef, index=441, offset=1
    [junit] Test: DTLB, b9555918470ee027
    [junit] tag=c23877, index=0, offset=27
    [junit] Test: L1, d489d96d7470c7f9
    [junit] tag=d7470c, index=3f, offset=19
    [junit] Test: L2, 17cfc8f02a87ac58
    [junit] tag=1543, index=d62, offset=18
    [junit] Test: DTLB, ffffffff827924f8
    [junit] tag=7fc13c9, index=0, offset=4f8
    [junit] Test: L1, 50dad3622d0fd69e
    [junit] tag=22d0fd, index=34, offset=1e
    [junit] Test: L2, ffffffffdcf66b3b
    [junit] tag=7ee7b, index=359, offset=1b
    [junit] Test: DTLB, 6d43011930a7a4e1
    [junit] tag=c9853d, index=0, offset=4e1
    [junit] Test: L1, ffffffffd2a72387
    [junit] tag=fd2a72, index=1c, offset=7
    [junit] Test: L2, ffffffffe40f7845
    [junit] tag=7f207, index=bc2, offset=5
    [junit] Test: DTLB, e516f4f8713c5233
    [junit] tag=7c389e2, index=0, offset=1233
    [junit] Test: L1, ffffffffc9043c49
    [junit] tag=fc9043, index=62, offset=9
    [junit] Test: L2, 256ca0462bd42b33
    [junit] tag=315ea, index=159, offset=13
    [junit] Test: DTLB, d420e92169a39743
    [junit] tag=10b4d1c, index=0, offset=1743
    [junit] Test: L1, fffffffff43ac82f
    [junit] tag=ff43ac, index=41, offset=f
    [junit] Test: L2, cb32fdbf27e5ff83
    [junit] tag=793f2, index=ffc, offset=3
    [junit] Test: DTLB, ffffffffe440e9f4
    [junit] tag=7ff2207, index=0, offset=9f4
    [junit] Test: L1, 1cdff5d95b1bcd1a
    [junit] tag=95b1bc, index=68, offset=1a
    [junit] Test: L2, fffffffff10e6cd5
    [junit] tag=7f887, index=366, offset=15
    [junit] Test: DTLB, e72b11c36b5863e9
    [junit] tag=61b5ac3, index=0, offset=3e9
    [junit] Test: L1, d96ab41b0390a98b
    [junit] tag=b0390a, index=4c, offset=b
    [junit] Test: L2, 8ce6545d7faa905c
    [junit] tag=6bfd5, index=482, offset=1c
    [junit] Test: DTLB, ffffffffc8e7f456
    [junit] tag=7fe473f, index=0, offset=1456
    [junit] Test: L1, 3cab4e40622bbd16
    [junit] tag=622bb, index=68, offset=16
    [junit] Test: L2, ca14f0ec2bbf28fd
    [junit] tag=615df, index=947, offset=1d
    [junit] Test: DTLB, 597b436b60261d08
    [junit] tag=35b0130, index=0, offset=1d08
    [junit] Test: L1, 1773276d4863ef34
    [junit] tag=d4863e, index=79, offset=14
    [junit] Test: L2, 77d9f9e55fe7e49c
    [junit] tag=2aff3, index=f24, offset=1c
    [junit] Test: DTLB, ffffffff94fea08c
    [junit] tag=7fca7f5, index=0, offset=8c
    [junit] Test: L1, ffffffffeea18ca3
    [junit] tag=feea18, index=65, offset=3
    [junit] Test: L2, ffffffff855f95cd
    [junit] tag=7c2af, index=cae, offset=d
    [junit] Test: DTLB, ffffffffcccc8db6
    [junit] tag=7fe6664, index=0, offset=db6
    [junit] Test: L1, 69f0e89756ca28b5
    [junit] tag=756ca2, index=45, offset=15
    [junit] Test: L2, fffffffff7f36ab7
    [junit] tag=7fbf9, index=b55, offset=17
    [junit] Test: DTLB, 89a5512875283fbb
    [junit] tag=143a941, index=0, offset=1fbb
    [junit] Test: L1, 740a262115920ac3
    [junit] tag=115920, index=56, offset=3
    [junit] Test: L2, ffffffffb9b627e2
    [junit] tag=7dcdb, index=13f, offset=2
    [junit] Test: DTLB, 6dea8aec4d30db43
    [junit] tag=7626986, index=0, offset=1b43
    [junit] Test: L1, ffffffffd1ed660a
    [junit] tag=fd1ed6, index=30, offset=a
    [junit] Test: L2, 8dd73f961a553fc5
    [junit] tag=30d2a, index=9fe, offset=5
    [junit] Test: DTLB, 99f2dd5448d3b95c
    [junit] tag=2a2469d, index=0, offset=195c
    [junit] Test: L1, 4eed3b6e390ebf3c
    [junit] tag=e390eb, index=79, offset=1c
    [junit] Test: L2, ffffffffc9a35013
    [junit] tag=7e4d1, index=a80, offset=13
    [junit] Test: DTLB, f305a81d1448acb7
    [junit] tag=e8a245, index=0, offset=cb7
    [junit] Test: L1, 53116eb472da355
    [junit] tag=b472da, index=1a, offset=15
    [junit] Test: L2, 3adbdfdc58c172c4
    [junit] tag=62c60, index=b96, offset=4
    [junit] Test: DTLB, 97b4b5ac7c7f0596
    [junit] tag=563e3f8, index=0, offset=596
    [junit] Test: L1, ffffffffc2e55efe
    [junit] tag=fc2e55, index=77, offset=1e
    [junit] Test: L2, 92bfaaa02b0fcaa
    [junit] tag=50158, index=7e5, offset=a
    [junit] Test: DTLB, ffffffff90ed85f4
    [junit] tag=7fc876c, index=0, offset=5f4
    [junit] Test: L1, ffffffffaf1de7f6
    [junit] tag=faf1de, index=3f, offset=16
    [junit] Test: L2, ffffffffe1ffb4e1
    [junit] tag=7f0ff, index=da7, offset=1
    [junit] Test: DTLB, 94008659001748d3
    [junit] tag=2c800ba, index=0, offset=8d3
    [junit] Test: L1, ffffffffdcc1e789
    [junit] tag=fdcc1e, index=3c, offset=9
    [junit] Test: L2, ffffffff8df959bc
    [junit] tag=7c6fc, index=acd, offset=1c
    [junit] Test: DTLB, 623c1db874197a89
    [junit] tag=5c3a0cb, index=0, offset=1a89
    [junit] Test: L1, 99a297a72efb1720
    [junit] tag=72efb1, index=39, offset=0
    [junit] Test: L2, d035ce4b324e4e85
    [junit] tag=59927, index=274, offset=5
    [junit] Test: DTLB, cc24fa11cacbaec
    [junit] tag=508e565, index=0, offset=1aec
    [junit] Test: L1, ffffffffeaf7a9d1
    [junit] tag=feaf7a, index=4e, offset=11
    [junit] Test: L2, ffffffffd5f42228
    [junit] tag=7eafa, index=111, offset=8
    [junit] Test: DTLB, ffffffff96c85ca3
    [junit] tag=7fcb642, index=0, offset=1ca3
    [junit] Test: L1, ffffffffb90c1fba
    [junit] tag=fb90c1, index=7d, offset=1a
    [junit] Test: L2, ffffffffdb3c99fc
    [junit] tag=7ed9e, index=4cf, offset=1c
    [junit] Test: DTLB, ffffffffa48953df
    [junit] tag=7fd244a, index=0, offset=13df
    [junit] Test: L1, ffffffffe268dad9
    [junit] tag=fe268d, index=56, offset=19
    [junit] Test: L2, 21fe50de1bca1961
    [junit] tag=70de5, index=cb, offset=1
    [junit] Test: DTLB, 7c17513d1b9a5ad5
    [junit] tag=1e8dcd2, index=0, offset=1ad5
    [junit] Test: L1, ffffffffbfee0cd2
    [junit] tag=fbfee0, index=66, offset=12
    [junit] Test: L2, 76211e637f1b4a1
    [junit] tag=31bf8, index=da5, offset=1
    [junit] Test: DTLB, c72113b01fd0d220
    [junit] tag=580fe86, index=0, offset=1220
    [junit] Test: L1, 404386af694dd698
    [junit] tag=f694dd, index=34, offset=18
    [junit] Test: L2, 760f6abb0a01534c
    [junit] tag=58500, index=a9a, offset=c
    [junit] Test: DTLB, ffffffffbe279947
    [junit] tag=7fdf13c, index=0, offset=1947
    [junit] Test: L1, ffffffffafde8b7c
    [junit] tag=fafde8, index=5b, offset=1c
    [junit] Test: L2, dfa469607012252e
    [junit] tag=3809, index=129, offset=e
    [junit] Test: DTLB, 8ebb9ec1568a6d73
    [junit] tag=60ab453, index=0, offset=d73
    [junit] Test: L1, 62017234583fc29f
    [junit] tag=4583fc, index=14, offset=1f
    [junit] Test: L2, ffffffffc3189881
    [junit] tag=7e18c, index=4c4, offset=1
    [junit] Test: DTLB, 6bc7e4a6698ee4ba
    [junit] tag=5334c77, index=0, offset=4ba
    [junit] Test: L1, ffffffffe9a5ec8c
    [junit] tag=fe9a5e, index=64, offset=c
    [junit] Test: L2, ffffffffe7c1ce39
    [junit] tag=7f3e0, index=e71, offset=19
    [junit] Test: DTLB, ffffffffba8d66e8
    [junit] tag=7fdd46b, index=0, offset=6e8
    [junit] Test: L1, cbd9d163036d2cfa
    [junit] tag=3036d2, index=67, offset=1a
    [junit] Test: L2, b573ec673e6a7913
    [junit] tag=39f35, index=3c8, offset=13
    [junit] Test: DTLB, ffffffffa3a24958
    [junit] tag=7fd1d12, index=0, offset=958
    [junit] Test: L1, bbafeee62af47977
    [junit] tag=62af47, index=4b, offset=17
    [junit] Test: L2, 333980700d267754
    [junit] tag=693, index=3ba, offset=14
    [junit] Test: DTLB, ffffffffe2b6abb9
    [junit] tag=7ff15b5, index=0, offset=bb9
    [junit] Test: L1, d849df8b2140c65c
    [junit] tag=b2140c, index=32, offset=1c
    [junit] Test: L2, 748355d26272563
    [junit] tag=69313, index=92b, offset=3
    [junit] Test: DTLB, ffffffffa90d4240
    [junit] tag=7fd486a, index=0, offset=240
    [junit] Test: L1, 59835894d386a9c
    [junit] tag=94d386, index=54, offset=1c
    [junit] Test: L2, 15d7d86705e812e7
    [junit] tag=382f4, index=97, offset=7
    [junit] Test: DTLB, ffffffffbee4d4ad
    [junit] tag=7fdf726, index=0, offset=14ad
    [junit] Test: L1, ffffffffe54b3a69
    [junit] tag=fe54b3, index=53, offset=9
    [junit] Test: L2, ffffffffd0c80f95
    [junit] tag=7e864, index=7c, offset=15
    [junit] Test: DTLB, 3f407cdc60c1aa17
    [junit] tag=6e3060d, index=0, offset=a17
    [junit] Test: L1, ffffffffa9731356
    [junit] tag=fa9731, index=1a, offset=16
    [junit] Test: L2, fffffffff515ed9b
    [junit] tag=7fa8a, index=f6c, offset=1b
    [junit] Test: DTLB, ffffffffb1a84aab
    [junit] tag=7fd8d42, index=0, offset=aab
    [junit] Test: L1, 5a3df0c261b5c96a
    [junit] tag=261b5c, index=4b, offset=a
    [junit] Test: L2, ffffffffd77d1486
    [junit] tag=7ebbe, index=8a4, offset=6
    [junit] Test: DTLB, ffffffffd2b4d481
    [junit] tag=7fe95a6, index=0, offset=1481
    [junit] Test: L1, ffffffffb51a8da8
    [junit] tag=fb51a8, index=6d, offset=8
    [junit] Test: L2, ffffffffd094c3fe
    [junit] tag=7e84a, index=61f, offset=1e
    [junit] Test: DTLB, 676df9c522def073
    [junit] tag=62916f7, index=0, offset=1073
    [junit] Test: L1, ffffffffbbdad8fe
    [junit] tag=fbbdad, index=47, offset=1e
    [junit] Test: L2, ffffffff8b6e75f3
    [junit] tag=7c5b7, index=3af, offset=13
    [junit] Test: DTLB, fffffffff3891ec6
    [junit] tag=7ff9c48, index=0, offset=1ec6
    [junit] Test: L1, fffffffff548a239
    [junit] tag=ff548a, index=11, offset=19
    [junit] Test: L2, ffffffff8269f162
    [junit] tag=7c134, index=f8b, offset=2
    [junit] Test: DTLB, ffffffffad188ebe
    [junit] tag=7fd68c4, index=0, offset=ebe
    [junit] Test: L1, e9c41a9e29699d94
    [junit] tag=e29699, index=6c, offset=14
    [junit] Test: L2, ffffffffea238c4e
    [junit] tag=7f511, index=c62, offset=e
    [junit] Test: DTLB, ce722493296a09d9
    [junit] tag=4994b50, index=0, offset=9d9
    [junit] Test: L1, 519bc8700ac2cd37
    [junit] tag=ac2c, index=69, offset=17
    [junit] Test: L2, c59047795a54929f
    [junit] tag=4ad2a, index=494, offset=1f
    [junit] Test: DTLB, fffffffffd778dc5
    [junit] tag=7ffebbc, index=0, offset=dc5
    [junit] Test: L1, f643a75d75f29547
    [junit] tag=d75f29, index=2a, offset=7
    [junit] Test: L2, ffffffff88a4540a
    [junit] tag=7c452, index=2a0, offset=a
    [junit] Test: DTLB, bd1be7301507f582
    [junit] tag=180a83f, index=0, offset=1582
    [junit] Test: L1, 5fc9852f0a74ec28
    [junit] tag=f0a74e, index=61, offset=8
    [junit] Test: L2, ffffffff9fea7933
    [junit] tag=7cff5, index=3c9, offset=13
    [junit] Test: DTLB, e2ee98e04c5831de
    [junit] tag=70262c1, index=0, offset=11de
    [junit] Test: L1, 488fb78548f8a3ee
    [junit] tag=548f8a, index=1f, offset=e
    [junit] Test: L2, ffffffffb047d6e6
    [junit] tag=7d823, index=eb7, offset=6
    [junit] Test: DTLB, fb49b7663a868d3a
    [junit] tag=331d434, index=0, offset=d3a
    [junit] Test: L1, c214071b4ca895bd
    [junit] tag=b4ca89, index=2d, offset=1d
    [junit] Test: L2, ac0e8af71dc1733f
    [junit] tag=38ee0, index=b99, offset=1f
    [junit] Test: DTLB, 77a8d8191841bf85
    [junit] tag=c8c20d, index=0, offset=1f85
    [junit] Test: L1, c59c18ce069dbc9e
    [junit] tag=e069db, index=64, offset=1e
    [junit] Test: L2, ffffffffb45fe508
    [junit] tag=7da2f, index=f28, offset=8
    [junit] Test: DTLB, ffffffffbdb5f3df
    [junit] tag=7fdedaf, index=0, offset=13df
    [junit] Test: L1, 2c3117b213291e65
    [junit] tag=213291, index=73, offset=5
    [junit] Test: L2, fffffffffc1ac5fb
    [junit] tag=7fe0d, index=62f, offset=1b
    [junit] Test: DTLB, ffffffffdaaa2637
    [junit] tag=7fed551, index=0, offset=637
    [junit] Test: L1, ffffffffa38d5e40
    [junit] tag=fa38d5, index=72, offset=0
    [junit] Test: L2, ffffffffbcc00d7b
    [junit] tag=7de60, index=6b, offset=1b
    [junit] Test: DTLB, fffffffff8a53ce1
    [junit] tag=7ffc529, index=0, offset=1ce1
    [junit] Test: L1, f57d84993c536b1f
    [junit] tag=93c536, index=58, offset=1f
    [junit] Test: L2, 9ce76c2f7bfa2a5b
    [junit] tag=7bdfd, index=152, offset=1b
    [junit] Test: DTLB, 7bccd4af2e919068
    [junit] tag=579748c, index=0, offset=1068
    [junit] Test: L1, dc0601134e618f26
    [junit] tag=34e618, index=79, offset=6
    [junit] Test: L2, fffffffff1caadf1
    [junit] tag=7f8e5, index=56f, offset=11
    [junit] Test: DTLB, ffffffffdc1a36aa
    [junit] tag=7fee0d1, index=0, offset=16aa
    [junit] Test: L1, a92491f70299d732
    [junit] tag=70299d, index=39, offset=12
    [junit] Test: L2, c31a862b421c3b04
    [junit] tag=5a10e, index=1d8, offset=4
    [junit] Test: DTLB, ffffffff928c0147
    [junit] tag=7fc9460, index=0, offset=147
    [junit] Test: L1, ffffffffeb42c59f
    [junit] tag=feb42c, index=2c, offset=1f
    [junit] Test: L2, a6cdcdfe370ef77d
    [junit] tag=71b87, index=7bb, offset=1d
    [junit] Test: DTLB, ffffffffdf0467c0
    [junit] tag=7fef823, index=0, offset=7c0
    [junit] Test: L1, 671fd6ff4d503a97
    [junit] tag=f4d503, index=54, offset=17
    [junit] Test: L2, fffffffff78c3460
    [junit] tag=7fbc6, index=1a3, offset=0
    [junit] Test: DTLB, a86a915024802d1
    [junit] tag=a81240, index=0, offset=2d1
    [junit] Test: L1, d69d94047c1c94f1
    [junit] tag=47c1c9, index=27, offset=11
    [junit] Test: L2, ffffffffbdc01ac0
    [junit] tag=7dee0, index=d6, offset=0
    [junit] Test: DTLB, ffffffff906e51f3
    [junit] tag=7fc8372, index=0, offset=11f3
    [junit] Test: L1, ffffffffca3ca388
    [junit] tag=fca3ca, index=1c, offset=8
    [junit] Test: L2, 4b7cd2702dfb7dd8
    [junit] tag=16fd, index=bee, offset=18
    [junit] Test: DTLB, 55f5cf9c43066258
    [junit] tag=4e21833, index=0, offset=258
    [junit] Test: L1, f57e06973755b149
    [junit] tag=73755b, index=a, offset=9
    [junit] Test: L2, 11fc42076d959479
    [junit] tag=3b6ca, index=ca3, offset=19
    [junit] Test: DTLB, ffffffffa600c633
    [junit] tag=7fd3006, index=0, offset=633
    [junit] Test: L1, ffffffffebda93ea
    [junit] tag=febda9, index=1f, offset=a
    [junit] Test: L2, 59ce102d10f555e1
    [junit] tag=6887a, index=aaf, offset=1
    [junit] Test: DTLB, ffffffffd16f25b4
    [junit] tag=7fe8b79, index=0, offset=5b4
    [junit] Test: L1, 1bfbe9e561130f9a
    [junit] tag=561130, index=7c, offset=1a
    [junit] Test: L2, ffffffffd0a331bb
    [junit] tag=7e851, index=98d, offset=1b
    [junit] Test: DTLB, ffffffffdd7d7b32
    [junit] tag=7feebeb, index=0, offset=1b32
    [junit] Test: L1, ffffffff8e0ba2b6
    [junit] tag=f8e0ba, index=15, offset=16
    [junit] Test: L2, ffffffff92b7c1e4
    [junit] tag=7c95b, index=e0f, offset=4
    [junit] Test: DTLB, 87bee1ed7e4d530b
    [junit] tag=76bf26a, index=0, offset=130b
    [junit] Test: L1, 1394302172706254
    [junit] tag=172706, index=12, offset=14
    [junit] Test: L2, ffffffff98ec3f80
    [junit] tag=7cc76, index=1fc, offset=0
    [junit] Test: DTLB, ffffffff81a0a2e7
    [junit] tag=7fc0d05, index=0, offset=2e7
    [junit] Test: L1, ffffffffa2a6f6da
    [junit] tag=fa2a6f, index=36, offset=1a
    [junit] Test: L2, ffffffff9f276797
    [junit] tag=7cf93, index=b3c, offset=17
    [junit] Test: DTLB, ffffffffceb8719a
    [junit] tag=7fe75c3, index=0, offset=119a
    [junit] Test: L1, fffffffffe3ae621
    [junit] tag=ffe3ae, index=31, offset=1
    [junit] Test: L2, 396b07e60ca2ed78
    [junit] tag=30651, index=76b, offset=18
    [junit] Test: DTLB, ffffffffad08ae22
    [junit] tag=7fd6845, index=0, offset=e22
    [junit] Test: L1, 3a8a4c3847e9d39e
    [junit] tag=847e9d, index=1c, offset=1e
    [junit] Test: L2, ffffffffcb397fa4
    [junit] tag=7e59c, index=bfd, offset=4
    [junit] Test: DTLB, 35fd9cfc58f317fa
    [junit] tag=7e2c798, index=0, offset=17fa
    [junit] Test: L1, ffffffffd5ac41a4
    [junit] tag=fd5ac4, index=d, offset=4
    [junit] Test: L2, fffffffff1615c30
    [junit] tag=7f8b0, index=ae1, offset=10
    [junit] Test: DTLB, 33774d9c3b1e9af3
    [junit] tag=4e1d8f4, index=0, offset=1af3
    [junit] Test: L1, ffffffffda245031
    [junit] tag=fda245, index=1, offset=11
    [junit] Test: L2, 7d2c83d17d8bd9b1
    [junit] tag=bec5, index=ecd, offset=11
    [junit] Test: DTLB, fffffffffd5482f6
    [junit] tag=7ffeaa4, index=0, offset=2f6
    [junit] Test: L1, fbeb08bf53a096cf
    [junit] tag=f53a09, index=36, offset=f
    [junit] Test: L2, ffffffffaa6c24d5
    [junit] tag=7d536, index=126, offset=15
    [junit] Test: DTLB, 75bada6e3bc2f252
    [junit] tag=371de17, index=0, offset=1252
    [junit] Test: L1, 9ffda8fc53c13943
    [junit] tag=c53c13, index=4a, offset=3
    [junit] Test: L2, 76b718a47f0e1c37
    [junit] tag=23f87, index=e1, offset=17
    [junit] Test: DTLB, ffffffffb5433fef
    [junit] tag=7fdaa19, index=0, offset=1fef
    [junit] Test: L1, eaf559615c86147b
    [junit] tag=15c861, index=23, offset=1b
    [junit] Test: L2, 4ac4f30a504ee719
    [junit] tag=52827, index=738, offset=19
    [junit] Test: DTLB, ffffffffbbd05d08
    [junit] tag=7fdde82, index=0, offset=1d08
    [junit] Test: L1, ffffffffc6f04012
    [junit] tag=fc6f04, index=0, offset=12
    [junit] Test: L2, 7f83af8574a5997a
    [junit] tag=2ba52, index=ccb, offset=1a
    [junit] Test: DTLB, bef5dc25772d5a66
    [junit] tag=12bb96a, index=0, offset=1a66
    [junit] Test: L1, fffffffffb79460f
    [junit] tag=ffb794, index=30, offset=f
    [junit] Test: L2, ffffffff8ffccacd
    [junit] tag=7c7fe, index=656, offset=d
    [junit] Test: DTLB, ffffffffd979b3f6
    [junit] tag=7fecbcd, index=0, offset=13f6
    [junit] Test: L1, ffffffffdf2ee467
    [junit] tag=fdf2ee, index=23, offset=7
    [junit] Test: L2, 706aa5843da4eb11
    [junit] tag=21ed2, index=758, offset=11
    [junit] Test: DTLB, ffffffffd73cec37
    [junit] tag=7feb9e7, index=0, offset=c37
    [junit] Test: L1, ffffffff9b005823
    [junit] tag=f9b005, index=41, offset=3
    [junit] Test: L2, 14d526b06d951a7f
    [junit] tag=36ca, index=8d3, offset=1f
    [junit] Test: DTLB, ffffffffeddd39e4
    [junit] tag=7ff6ee9, index=0, offset=19e4
    [junit] Test: L1, ffffffffaf7a6fed
    [junit] tag=faf7a6, index=7f, offset=d
    [junit] Test: L2, 4559222904396b5e
    [junit] tag=4821c, index=b5a, offset=1e
    [junit] Test: DTLB, 8e1b31f5223a09ea
    [junit] tag=7a911d0, index=0, offset=9ea
    [junit] Test: L1, ffffffffcf34b787
    [junit] tag=fcf34b, index=3c, offset=7
    [junit] Test: L2, ffffffffed8fcf0e
    [junit] tag=7f6c7, index=e78, offset=e
    [junit] Test: DTLB, fffffffff4785cec
    [junit] tag=7ffa3c2, index=0, offset=1cec
    [junit] Test: L1, ffffffffda357cc6
    [junit] tag=fda357, index=66, offset=6
    [junit] Test: L2, ffffffffef1a8e09
    [junit] tag=7f78d, index=470, offset=9
    [junit] Test: DTLB, 7f1f5db09862a35
    [junit] tag=6d84c31, index=0, offset=a35
    [junit] Test: L1, 6aed794c332a4087
    [junit] tag=c332a4, index=4, offset=7
    [junit] Test: L2, fffffffff65cfdb7
    [junit] tag=7fb2e, index=7ed, offset=17
    [junit] Test: DTLB, ffffffffc0d8e12a
    [junit] tag=7fe06c7, index=0, offset=12a
    [junit] Test: L1, ffffffffb378888d
    [junit] tag=fb3788, index=44, offset=d
    [junit] Test: L2, abdd2a2f731266c0
    [junit] tag=7b989, index=336, offset=0
    [junit] Test: DTLB, ffffffff83e59db6
    [junit] tag=7fc1f2c, index=0, offset=1db6
    [junit] Test: L1, 15a12dc15a65280a
    [junit] tag=15a652, index=40, offset=a
    [junit] Test: L2, ffffffff8d1bff73
    [junit] tag=7c68d, index=ffb, offset=13
    [junit] Test: DTLB, ffffffffb7723811
    [junit] tag=7fdbb91, index=0, offset=1811
    [junit] Test: L1, ffffffffad90d690
    [junit] tag=fad90d, index=34, offset=10
    [junit] Test: L2, 9c22d14a3ac5c3da
    [junit] tag=51d62, index=e1e, offset=1a
    [junit] Test: DTLB, ffffffffd3e23839
    [junit] tag=7fe9f11, index=0, offset=1839
    [junit] Test: L1, ffffffffecf32dc0
    [junit] tag=fecf32, index=6e, offset=0
    [junit] Test: L2, 96be27b279e7a7cb
    [junit] tag=13cf3, index=d3e, offset=b
    [junit] Test: DTLB, 456b8cc2625d1e0
    [junit] tag=661312e, index=0, offset=11e0
    [junit] Test: L1, 7ed203d673436278
    [junit] tag=673436, index=13, offset=18
    [junit] Test: L2, ffffffffa6fd3dd0
    [junit] tag=7d37e, index=9ee, offset=10
    [junit] Test: DTLB, ee55fd195843e551
    [junit] tag=cac21f, index=0, offset=551
    [junit] Test: L1, 27ec0e24250d7097
    [junit] tag=4250d7, index=4, offset=17
    [junit] Test: L2, ffffffffc626c1cf
    [junit] tag=7e313, index=60e, offset=f
    [junit] Test: DTLB, ffffffffe99d785d
    [junit] tag=7ff4ceb, index=0, offset=185d
    [junit] Test: L1, 458afa902001e5c9
    [junit] tag=2001e, index=2e, offset=9
    [junit] Test: L2, ffffffff81394abd
    [junit] tag=7c09c, index=a55, offset=1d
    [junit] Test: DTLB, 6516ca1d07cf4576
    [junit] tag=e83e7a, index=0, offset=576
    [junit] Test: L1, cff798421fcc0d10
    [junit] tag=21fcc0, index=68, offset=10
    [junit] Test: L2, 788738fc1f5e5609
    [junit] tag=60faf, index=2b0, offset=9
    [junit] Test: DTLB, 673826443f9fe79b
    [junit] tag=221fcff, index=0, offset=79b
    [junit] Test: L1, 6ed4396b692085c4
    [junit] tag=b69208, index=2e, offset=4
    [junit] Test: L2, fffffffffd891c26
    [junit] tag=7fec4, index=8e1, offset=6
    [junit] Test: DTLB, f986e35f4b7fa664
    [junit] tag=2fa5bfd, index=0, offset=664
    [junit] Test: L1, ffffffffb317fcb6
    [junit] tag=fb317f, index=65, offset=16
    [junit] Test: L2, 9334cdf67b467e9e
    [junit] tag=33da3, index=3f4, offset=1e
    [junit] Test: DTLB, 76ac1cc86a45dac3
    [junit] tag=643522e, index=0, offset=1ac3
    [junit] Test: L1, c228d71d1ce25a0a
    [junit] tag=d1ce25, index=50, offset=a
    [junit] Test: L2, 4b54eabb058494b1
    [junit] tag=582c2, index=4a5, offset=11
    [junit] Test: DTLB, ffffffff987e2704
    [junit] tag=7fcc3f1, index=0, offset=704
    [junit] Test: L1, ffffffffa0e01699
    [junit] tag=fa0e01, index=34, offset=19
    [junit] Test: L2, ca172fec3dd80933
    [junit] tag=61eec, index=49, offset=13
    [junit] Test: DTLB, b51de17a371130b2
    [junit] tag=3d1b889, index=0, offset=10b2
    [junit] Test: L1, 7cd273333fb3cbee
    [junit] tag=33fb3c, index=5f, offset=e
    [junit] Test: L2, ffffffffa2335090
    [junit] tag=7d119, index=a84, offset=10
    [junit] Test: DTLB, 67ae9a2a7cc67a6b
    [junit] tag=153e633, index=0, offset=1a6b
    [junit] Test: L1, 3488e7ae3bfa7d0c
    [junit] tag=e3bfa7, index=68, offset=c
    [junit] Test: L2, ffffffffb3ac6c44
    [junit] tag=7d9d6, index=362, offset=4
    [junit] Test: DTLB, ffffffffd89e14cb
    [junit] tag=7fec4f0, index=0, offset=14cb
    [junit] Test: L1, 6a6cddf212f24856
    [junit] tag=212f24, index=42, offset=16
    [junit] Test: L2, 56c07bd12f284399
    [junit] tag=9794, index=21c, offset=19
    [junit] Test: DTLB, ac2a295275806e0c
    [junit] tag=293ac03, index=0, offset=e0c
    [junit] Test: L1, ffffffffad2a2de9
    [junit] tag=fad2a2, index=6f, offset=9
    [junit] Test: L2, ffffffff809e0cff
    [junit] tag=7c04f, index=67, offset=1f
    [junit] Test: DTLB, ffffffffbe3d8f6a
    [junit] tag=7fdf1ec, index=0, offset=f6a
    [junit] Test: L1, ba85163d0c43c363
    [junit] tag=d0c43c, index=1b, offset=3
    [junit] Test: L2, ffffffff96b829cb
    [junit] tag=7cb5c, index=14e, offset=b
    [junit] Test: DTLB, ffffffffe5922ba3
    [junit] tag=7ff2c91, index=0, offset=ba3
    [junit] Test: L1, ffffffffaae6b4da
    [junit] tag=faae6b, index=26, offset=1a
    [junit] Test: L2, ffffffff97d13380
    [junit] tag=7cbe8, index=99c, offset=0
    [junit] Test: DTLB, ffffffffdf17126a
    [junit] tag=7fef8b8, index=0, offset=126a
    [junit] Test: L1, 5ecc967207239d8c
    [junit] tag=207239, index=6c, offset=c
    [junit] Test: L2, c1d466836c4c8dc7
    [junit] tag=1b626, index=46e, offset=7
    [junit] Test: DTLB, ffffffffe0fd935c
    [junit] tag=7ff07ec, index=0, offset=135c
    [junit] Test: L1, ffffffffab52d56a
    [junit] tag=fab52d, index=2b, offset=a
    [junit] Test: L2, 815185563f7bffba
    [junit] tag=31fbd, index=ffd, offset=1a
    [junit] Test: DTLB, 6a4646774830a3f5
    [junit] tag=3ba4185, index=0, offset=3f5
    [junit] Test: L1, 5f97590956a80ef1
    [junit] tag=956a80, index=77, offset=11
    [junit] Test: L2, cb0264ad5c93d9ff
    [junit] tag=6ae49, index=ecf, offset=1f
    [junit] Test: DTLB, 95255d4153b1b549
    [junit] tag=20a9d8d, index=0, offset=1549
    [junit] Test: L1, a30b8b46253b86d9
    [junit] tag=6253b8, index=36, offset=19
    [junit] Test: L2, ffffffffee0a979c
    [junit] tag=7f705, index=4bc, offset=1c
    [junit] Test: DTLB, 2d751cd55481b5b4
    [junit] tag=6aaa40d, index=0, offset=15b4
    [junit] Test: L1, 9d9a81e94ae775e2
    [junit] tag=94ae77, index=2f, offset=2
    [junit] Test: L2, ffffffffeb4e7b64
    [junit] tag=7f5a7, index=3db, offset=4
    [junit] Test: DTLB, ffffffff94acf073
    [junit] tag=7fca567, index=0, offset=1073
    [junit] Test: L1, 89d2258911d5e774
    [junit] tag=911d5e, index=3b, offset=14
    [junit] Test: L2, ffffffff8907632f
    [junit] tag=7c483, index=b19, offset=f
    [junit] Test: DTLB, b5ae02541cda8d87
    [junit] tag=2a0e6d4, index=0, offset=d87
    [junit] Test: L1, ffffffffc87de6e4
    [junit] tag=fc87de, index=37, offset=4
    [junit] Test: L2, ffffffffdea07bfb
    [junit] tag=7ef50, index=3df, offset=1b
    [junit] Test: DTLB, ffffffff8fca7c64
    [junit] tag=7fc7e53, index=0, offset=1c64
    [junit] Test: L1, ffffffffef519dd6
    [junit] tag=fef519, index=6e, offset=16
    [junit] Test: L2, ffffffffc8f865ab
    [junit] tag=7e47c, index=32d, offset=b
    [junit] Test: DTLB, f5ad4c102f13b04a
    [junit] tag=81789d, index=0, offset=104a
    [junit] Test: L1, ffffffff997a156e
    [junit] tag=f997a1, index=2b, offset=e
    [junit] Test: L2, ffffffff80d0e534
    [junit] tag=7c068, index=729, offset=14
    [junit] Test: DTLB, a283eaa7566f3f68
    [junit] tag=53ab379, index=0, offset=1f68
    [junit] Test: L1, 4ac31f3f43066fed
    [junit] tag=f43066, index=7f, offset=d
    [junit] Test: L2, 74c17d334e6d01a9
    [junit] tag=1a736, index=80d, offset=9
    [junit] Test: DTLB, ffffffffefc73467
    [junit] tag=7ff7e39, index=0, offset=1467
    [junit] Test: L1, 41169a98776f179e
    [junit] tag=8776f1, index=3c, offset=1e
    [junit] Test: L2, ffffffffc4f20919
    [junit] tag=7e279, index=48, offset=19
    [junit] Test: DTLB, ffffffffd97babd3
    [junit] tag=7fecbdd, index=0, offset=bd3
    [junit] Test: L1, ffffffff88e43c5e
    [junit] tag=f88e43, index=62, offset=1e
    [junit] Test: L2, 53f907ba1c7acad4
    [junit] tag=50e3d, index=656, offset=14
    [junit] Test: DTLB, ffffffffa2ed130b
    [junit] tag=7fd1768, index=0, offset=130b
    [junit] Test: L1, 3fa81ffd1c409614
    [junit] tag=d1c409, index=30, offset=14
    [junit] Test: L2, ffffffff89b12dee
    [junit] tag=7c4d8, index=96f, offset=e
    [junit] Test: DTLB, 3952a2750e5d994
    [junit] tag=13a872e, index=0, offset=1994
    [junit] Test: L1, ffffffffde9ba506
    [junit] tag=fde9ba, index=28, offset=6
    [junit] Test: L2, ffffffff8d0acf77
    [junit] tag=7c685, index=67b, offset=17
    [junit] Test: DTLB, ffffffffc1bce18f
    [junit] tag=7fe0de7, index=0, offset=18f
    [junit] Test: L1, ffffffff9e3d1d16
    [junit] tag=f9e3d1, index=68, offset=16
    [junit] Test: L2, 2ef43a3a57954ca5
    [junit] tag=52bca, index=a65, offset=5
    [junit] Test: DTLB, ffffffff9352687b
    [junit] tag=7fc9a93, index=0, offset=87b
    [junit] Test: L1, 8aa821042b2eab5b
    [junit] tag=42b2ea, index=5a, offset=1b
    [junit] Test: L2, 74743cce548ac9e9
    [junit] tag=72a45, index=64f, offset=9
    [junit] Test: DTLB, ffffffffb8c5c9eb
    [junit] tag=7fdc62e, index=0, offset=9eb
    [junit] Test: L1, ffffffffd2a1acac
    [junit] tag=fd2a1a, index=65, offset=c
    [junit] Test: L2, ffffffff92d0023b
    [junit] tag=7c968, index=11, offset=1b
    [junit] Test: DTLB, ffffffffa330ae8c
    [junit] tag=7fd1985, index=0, offset=e8c
    [junit] Test: L1, ffffffff8a830809
    [junit] tag=f8a830, index=40, offset=9
    [junit] Test: L2, ffffffff9fba1623
    [junit] tag=7cfdd, index=b1, offset=3
    [junit] Test: DTLB, b74c9bfe232b1e26
    [junit] tag=7f11958, index=0, offset=1e26
    [junit] Test: L1, ffffffffcc0a3de5
    [junit] tag=fcc0a3, index=6f, offset=5
    [junit] Test: L2, ffffffff9c4a095c
    [junit] tag=7ce25, index=4a, offset=1c
    [junit] Test: DTLB, 737a1015718bdcb5
    [junit] tag=ab8c5e, index=0, offset=1cb5
    [junit] Test: L1, 5376d6a33635e177
    [junit] tag=33635e, index=b, offset=17
    [junit] Test: L2, 7fc744d0063f1bcb
    [junit] tag=31f, index=8de, offset=b
    [junit] Test: DTLB, ffffffffe85e7605
    [junit] tag=7ff42f3, index=0, offset=1605
    [junit] Test: L1, ffffffffc6d27071
    [junit] tag=fc6d27, index=3, offset=11
    [junit] Test: L2, ffffffffeea70365
    [junit] tag=7f753, index=81b, offset=5
    [junit] Test: DTLB, ad5fc351633e5dc2
    [junit] tag=28b19f2, index=0, offset=1dc2
    [junit] Test: L1, e74023730afb006e
    [junit] tag=30afb0, index=3, offset=e
    [junit] Test: L2, ffffffffd468ecf8
    [junit] tag=7ea34, index=767, offset=18
    [junit] Test: DTLB, ffffffff9ee0205c
    [junit] tag=7fcf701, index=0, offset=5c
    [junit] Test: L1, ffffffffae789b6b
    [junit] tag=fae789, index=5b, offset=b
    [junit] Test: L2, d4c2f47949ac0de4
    [junit] tag=4a4d6, index=6f, offset=4
    [junit] Test: DTLB, ffffffff8323454f
    [junit] tag=7fc191a, index=0, offset=54f
    [junit] Test: L1, 9687f67a22104e25
    [junit] tag=a22104, index=71, offset=5
    [junit] Test: L2, 918438a220c71df1
    [junit] tag=11063, index=8ef, offset=11
    [junit] Test: DTLB, ffffffffb1819bc9
    [junit] tag=7fd8c0c, index=0, offset=1bc9
    [junit] Test: L1, 9c6bdfd9486a110d
    [junit] tag=9486a1, index=8, offset=d
    [junit] Test: L2, f43fd31b77ad633b
    [junit] tag=5bbd6, index=b19, offset=1b
    [junit] Test: DTLB, 8bd21a6e256cced7
    [junit] tag=3712b66, index=0, offset=ed7
    [junit] Test: L1, ffffffff9a872cc2
    [junit] tag=f9a872, index=66, offset=2
    [junit] Test: L2, ffffffff91f85d5b
    [junit] tag=7c8fc, index=2ea, offset=1b
    [junit] Test: DTLB, ffffffffaffee3da
    [junit] tag=7fd7ff7, index=0, offset=3da
    [junit] Test: L1, a92e333a5beabb4b
    [junit] tag=a5beab, index=5a, offset=b
    [junit] Test: L2, ffffffff82446143
    [junit] tag=7c122, index=30a, offset=3
    [junit] Test: DTLB, 88cdf7037b91646d
    [junit] tag=1bdc8b, index=0, offset=46d
    [junit] Test: L1, f36ad40b05625043
    [junit] tag=b05625, index=2, offset=3
    [junit] Test: L2, 6e97f49a0e91275c
    [junit] tag=50748, index=93a, offset=1c
    [junit] Test: DTLB, ffffffffcd08bac2
    [junit] tag=7fe6845, index=0, offset=1ac2
    [junit] Test: L1, ffffffff8fc4c258
    [junit] tag=f8fc4c, index=12, offset=18
    [junit] Test: L2, fffffffff7b5a1af
    [junit] tag=7fbda, index=d0d, offset=f
    [junit] Test: DTLB, fffffffff7906ead
    [junit] tag=7ffbc83, index=0, offset=ead
    [junit] Test: L1, ffffffffe8e4dc84
    [junit] tag=fe8e4d, index=64, offset=4
    [junit] Test: L2, 88d39f2c156b8313
    [junit] tag=60ab5, index=c18, offset=13
    [junit] Test: DTLB, ffffffffd85ce07b
    [junit] tag=7fec2e7, index=0, offset=7b
    [junit] Test: L1, ffffffffb2a7ffce
    [junit] tag=fb2a7f, index=7e, offset=e
    [junit] Test: L2, 7f5b4453196c3095
    [junit] tag=18cb6, index=184, offset=15
    [junit] Test: DTLB, 5564e17761bba071
    [junit] tag=3bb0ddd, index=0, offset=71
    [junit] Test: L1, d0774cf346884015
    [junit] tag=346884, index=0, offset=15
    [junit] Test: L2, 5cd2a4d153ee32c5
    [junit] tag=a9f7, index=196, offset=5
    [junit] Test: DTLB, ffffffffdde6e9e2
    [junit] tag=7feef37, index=0, offset=9e2
    [junit] Test: L1, 1b44780124dafcc2
    [junit] tag=124daf, index=66, offset=2
    [junit] Test: L2, ffffffffa55f7b44
    [junit] tag=7d2af, index=bda, offset=4
    [junit] Test: DTLB, ef341f260f113b63
    [junit] tag=1307889, index=0, offset=1b63
    [junit] Test: L1, ffffffffad8cfad5
    [junit] tag=fad8cf, index=56, offset=15
    [junit] Test: L2, c00ffc1920ab702e
    [junit] tag=49055, index=b81, offset=e
    [junit] Test: DTLB, d609a17f40026a8c
    [junit] tag=3fa0013, index=0, offset=a8c
    [junit] Test: L1, ffffffff9b5d325c
    [junit] tag=f9b5d3, index=12, offset=1c
    [junit] Test: L2, 1bd069bd62a424b8
    [junit] tag=6b152, index=125, offset=18
    [junit] Test: DTLB, ffffffff9ca822b8
    [junit] tag=7fce541, index=0, offset=2b8
    [junit] Test: L1, ffffffffd4a6b31f
    [junit] tag=fd4a6b, index=18, offset=1f
    [junit] Test: L2, 7b2fedbb6d6eb1c6
    [junit] tag=5b6b7, index=58e, offset=6
    [junit] Test: DTLB, 7a30cbdd64e4f165
    [junit] tag=6eb2727, index=0, offset=1165
    [junit] Test: L1, ffffffffd567e059
    [junit] tag=fd567e, index=2, offset=19
    [junit] Test: L2, 2fcbf81617a744ce
    [junit] tag=30bd3, index=a26, offset=e
    [junit] Test: DTLB, 1e6d27a63508ecf5
    [junit] tag=531a847, index=0, offset=cf5
    [junit] Test: L1, afa646fd102325bb
    [junit] tag=d10232, index=2d, offset=1b
    [junit] Test: L2, 58cafaa117a4426c
    [junit] tag=8bd2, index=213, offset=c
    [junit] Test: DTLB, d8661f2e5a77a9d9
    [junit] tag=172d3bd, index=0, offset=9d9
    [junit] Test: L1, fffffffff146fa1a
    [junit] tag=ff146f, index=50, offset=1a
    [junit] Test: L2, ffffffffe6117b77
    [junit] tag=7f308, index=bdb, offset=17
    [junit] Test: DTLB, 51e8f3254c4ce47c
    [junit] tag=12a6267, index=0, offset=47c
    [junit] Test: L1, 12d5517311369d06
    [junit] tag=311369, index=68, offset=6
    [junit] Test: L2, bfc7edf10daa769d
    [junit] tag=86d5, index=3b4, offset=1d
    [junit] Test: DTLB, ffffffff914b97d0
    [junit] tag=7fc8a5c, index=0, offset=17d0
    [junit] Test: L1, fffffffffcef7498
    [junit] tag=ffcef7, index=24, offset=18
    [junit] Test: L2, ffffffffb453a9b3
    [junit] tag=7da29, index=d4d, offset=13
    [junit] Test: DTLB, ffffffffc57b076f
    [junit] tag=7fe2bd8, index=0, offset=76f
    [junit] Test: L1, ffffffffb6ff3d8c
    [junit] tag=fb6ff3, index=6c, offset=c
    [junit] Test: L2, ac0df9a669858dae
    [junit] tag=334c2, index=c6d, offset=e
    [junit] Test: DTLB, ffffffffb3a3626e
    [junit] tag=7fd9d1b, index=0, offset=26e
    [junit] Test: L1, aa540be552a0d5c9
    [junit] tag=552a0d, index=2e, offset=9
    [junit] Test: L2, 5f538aa22a6d7ddc
    [junit] tag=11536, index=bee, offset=1c
    [junit] Test: DTLB, ffffffff82d244fb
    [junit] tag=7fc1692, index=0, offset=4fb
    [junit] Test: L1, 554ee4777062ff27
    [junit] tag=77062f, index=79, offset=7
    [junit] Test: L2, a3a42c6409dee61e
    [junit] tag=204ef, index=730, offset=1e
    [junit] Test: DTLB, ca692fb951ecbf81
    [junit] tag=5ca8f65, index=0, offset=1f81
    [junit] Test: L1, fffffffff365fa50
    [junit] tag=ff365f, index=52, offset=10
    [junit] Test: L2, ffffffffb5635fee
    [junit] tag=7dab1, index=aff, offset=e
    [junit] Test: DTLB, ed0b85b406be5410
    [junit] tag=5a035f2, index=0, offset=1410
    [junit] Test: L1, ffffffff941c4bb2
    [junit] tag=f941c4, index=5d, offset=12
    [junit] Test: L2, 7399d92b5e55e280
    [junit] tag=5af2a, index=f14, offset=0
    [junit] Test: DTLB, ffffffffab0482c0
    [junit] tag=7fd5824, index=0, offset=2c0
    [junit] Test: L1, fffffffff3060aca
    [junit] tag=ff3060, index=56, offset=a
    [junit] Test: L2, a94e64e96f5c7314
    [junit] tag=4b7ae, index=398, offset=14
    [junit] Test: DTLB, 4d39fd765a2c4415
    [junit] tag=3b2d162, index=0, offset=415
    [junit] Test: L1, ffffffffc50bcc39
    [junit] tag=fc50bc, index=61, offset=19
    [junit] Test: L2, ffffffffd4ee36da
    [junit] tag=7ea77, index=1b6, offset=1a
    [junit] Test: DTLB, 206e4ba403c52ce6
    [junit] tag=5201e29, index=0, offset=ce6
    [junit] Test: L1, 35a6fbd341736ee3
    [junit] tag=341736, index=77, offset=3
    [junit] Test: L2, 965cbaeb716a69fa
    [junit] tag=5b8b5, index=34f, offset=1a
    [junit] Test: DTLB, 1f973161617741d1
    [junit] tag=30b0bba, index=0, offset=1d1
    [junit] Test: L1, ffffffff92767589
    [junit] tag=f92767, index=2c, offset=9
    [junit] Test: L2, 73059d8675b67e82
    [junit] tag=33adb, index=3f4, offset=2
    [junit] Test: DTLB, ffffffffd0878866
    [junit] tag=7fe843c, index=0, offset=866
    [junit] Test: L1, 6fe9564d42cae804
    [junit] tag=d42cae, index=40, offset=4
    [junit] Test: L2, ffffffffbee80452
    [junit] tag=7df74, index=22, offset=12
    [junit] Test: DTLB, ffffffffcbe32e2e
    [junit] tag=7fe5f19, index=0, offset=e2e
    [junit] Test: L1, a9e428f272e9db5e
    [junit] tag=272e9d, index=5a, offset=1e
    [junit] Test: L2, ffffffffb2635068
    [junit] tag=7d931, index=a83, offset=8
    [junit] Test: DTLB, ce0095e872c8adec
    [junit] tag=7439645, index=0, offset=dec
    [junit] Test: L1, aa8d74862c0c536a
    [junit] tag=62c0c5, index=1b, offset=a
    [junit] Test: L2, 1ef3bb4a168abc12
    [junit] tag=50b45, index=5e0, offset=12
    [junit] Test: DTLB, ffffffffa6e5921a
    [junit] tag=7fd372c, index=0, offset=121a
    [junit] Test: L1, 32ce1c833df81318
    [junit] tag=33df81, index=18, offset=18
    [junit] Test: L2, 7e7f936e441f1d9f
    [junit] tag=7220f, index=8ec, offset=1f
    [junit] Test: DTLB, 73643f54349c07de
    [junit] tag=2a1a4e0, index=0, offset=7de
    [junit] Test: L1, ffffffffb3988ad6
    [junit] tag=fb3988, index=56, offset=16
    [junit] Test: L2, ffffffff8d305fb9
    [junit] tag=7c698, index=2fd, offset=19
    [junit] Test: DTLB, 7399a18448103b3e
    [junit] tag=4224081, index=0, offset=1b3e
    [junit] Test: L1, c5afebdd75741a78
    [junit] tag=d75741, index=53, offset=18
    [junit] Test: L2, ffffffff8b13db80
    [junit] tag=7c589, index=edc, offset=0
    [junit] Test: DTLB, df5d993c0d90ab5a
    [junit] tag=1e06c85, index=0, offset=b5a
    [junit] Test: L1, fa1f08f2d02d9f6
    [junit] tag=f2d02d, index=4f, offset=16
    [junit] Test: L2, a75792ef2094c6ec
    [junit] tag=7904a, index=637, offset=c
    [junit] Test: DTLB, d4a7ff55597229d2
    [junit] tag=2aacb91, index=0, offset=9d2
    [junit] Test: L1, fffffffffb1767cb
    [junit] tag=ffb176, index=3e, offset=b
    [junit] Test: L2, e2f8e81132395b4a
    [junit] tag=991c, index=ada, offset=a
    [junit] Test: DTLB, fdfb8d4e2538d4b7
    [junit] tag=27129c6, index=0, offset=14b7
    [junit] Test: L1, c20a45ba14d73658
    [junit] tag=a14d73, index=32, offset=18
    [junit] Test: L2, ffffffffd036ba2b
    [junit] tag=7e81b, index=5d1, offset=b
    [junit] Test: DTLB, ffffffffd0551564
    [junit] tag=7fe82a8, index=0, offset=1564
    [junit] Test: L1, ffffffffe9774ccd
    [junit] tag=fe9774, index=66, offset=d
    [junit] Test: L2, ffffffffab2b1e35
    [junit] tag=7d595, index=8f1, offset=15
    [junit] Test: DTLB, 19479d2620e36976
    [junit] tag=131071b, index=0, offset=976
    [junit] Test: L1, dc0c3f5d73e222eb
    [junit] tag=d73e22, index=17, offset=b
    [junit] Test: L2, ffffffff8f361557
    [junit] tag=7c79b, index=aa, offset=17
    [junit] Test: DTLB, ffffffff81757fea
    [junit] tag=7fc0bab, index=0, offset=1fea
    [junit] Test: L1, ffffffffae8498c9
    [junit] tag=fae849, index=46, offset=9
    [junit] Test: L2, ffffffff983997ff
    [junit] tag=7cc1c, index=cbf, offset=1f
    [junit] Test: DTLB, ffffffff9aec838d
    [junit] tag=7fcd764, index=0, offset=38d
    [junit] Test: L1, 59555f602bf1014b
    [junit] tag=2bf10, index=a, offset=b
    [junit] Test: L2, ffffffff96a0d945
    [junit] tag=7cb50, index=6ca, offset=5
    [junit] Test: DTLB, 635b3e96d1905fb
    [junit] tag=74b68c8, index=0, offset=5fb
    [junit] Test: L1, 596250444f94ce82
    [junit] tag=44f94c, index=74, offset=2
    [junit] Test: L2, 8036704e555f914b
    [junit] tag=72aaf, index=c8a, offset=b
    [junit] Test: DTLB, e977e9e329988ee
    [junit] tag=4f194cc, index=0, offset=8ee
    [junit] Test: L1, 84f4745e714584a4
    [junit] tag=e71458, index=25, offset=4
    [junit] Test: L2, ab3ed2b130efbed0
    [junit] tag=9877, index=df6, offset=10
    [junit] Test: DTLB, 2fee8db4541bdab1
    [junit] tag=5a2a0de, index=0, offset=1ab1
    [junit] Test: L1, b04f091f7e6c8ffc
    [junit] tag=f7e6c8, index=7f, offset=1c
    [junit] Test: L2, dc3257cd45583b0e
    [junit] tag=6a2ac, index=1d8, offset=e
    [junit] Test: DTLB, aabf07104e400442
    [junit] tag=827200, index=0, offset=442
    [junit] Test: L1, ffffffffccbac87c
    [junit] tag=fccbac, index=43, offset=1c
    [junit] Test: L2, d9ddb0475bcbc3da
    [junit] tag=3ade5, index=e1e, offset=1a
    [junit] Test: DTLB, d5f28c5e6f258745
    [junit] tag=2f3792c, index=0, offset=745
    [junit] Test: L1, ffffffff8d86020f
    [junit] tag=f8d860, index=10, offset=f
    [junit] Test: L2, 7d9dbeae31d2365f
    [junit] tag=718e9, index=1b2, offset=1f
    [junit] Test: DTLB, ffffffffa8e6225b
    [junit] tag=7fd4731, index=0, offset=25b
    [junit] Test: L1, ffffffffe699f0eb
    [junit] tag=fe699f, index=7, offset=b
    [junit] Test: L2, c0b8979e21a2c9d0
    [junit] tag=710d1, index=64e, offset=10
    [junit] Test: DTLB, 58c38cc947ac3b9f
    [junit] tag=64a3d61, index=0, offset=1b9f
    [junit] Test: L1, ffffffffd3f9a818
    [junit] tag=fd3f9a, index=40, offset=18
    [junit] Test: L2, ffffffff8f1e2dbe
    [junit] tag=7c78f, index=16d, offset=1e
    [junit] Test: DTLB, 7b771c432c0e6e8a
    [junit] tag=2196073, index=0, offset=e8a
    [junit] Test: L1, ffffffffce5a2a70
    [junit] tag=fce5a2, index=53, offset=10
    [junit] Test: L2, a8c6cb846cdb6a01
    [junit] tag=2366d, index=b50, offset=1
    [junit] Test: DTLB, ffffffffe37ec060
    [junit] tag=7ff1bf6, index=0, offset=60
    [junit] Test: L1, 148628ec23ebf9fb
    [junit] tag=c23ebf, index=4f, offset=1b
    [junit] Test: L2, 89979bb92f927aee
    [junit] tag=497c9, index=3d7, offset=e
    [junit] Test: DTLB, 59419fd159aef544
    [junit] tag=68acd77, index=0, offset=1544
    [junit] Test: L1, f6ce0ca1690a207b
    [junit] tag=1690a2, index=3, offset=1b
    [junit] Test: L2, ffffffffa2f0be6a
    [junit] tag=7d178, index=5f3, offset=a
    [junit] Test: DTLB, 7463131c46c0bb3d
    [junit] tag=e23605, index=0, offset=1b3d
    [junit] Test: L1, ffffffffb2fdb5fe
    [junit] tag=fb2fdb, index=2f, offset=1e
    [junit] Test: L2, 81ed5d03a4072eb
    [junit] tag=1d20, index=397, offset=b
    [junit] Test: DTLB, b877df927d21dd56
    [junit] tag=493e90e, index=0, offset=1d56
    [junit] Test: L1, c45153ec618d1cd3
    [junit] tag=c618d1, index=66, offset=13
    [junit] Test: L2, b25f3c34327fc35
    [junit] tag=1a193, index=fe1, offset=15
    [junit] Test: DTLB, ffffffffdd3d4110
    [junit] tag=7fee9ea, index=0, offset=110
    [junit] Test: L1, ffffffffbffbba3c
    [junit] tag=fbffbb, index=51, offset=1c
    [junit] Test: L2, d4e0a13569b43565
    [junit] tag=2b4da, index=1ab, offset=5
    [junit] Test: DTLB, ffffffffb3a3c1f2
    [junit] tag=7fd9d1e, index=0, offset=1f2
    [junit] Test: L1, ffffffff92cb4c51
    [junit] tag=f92cb4, index=62, offset=11
    [junit] Test: L2, 34ba4b7a36177c54
    [junit] tag=51b0b, index=be2, offset=14
    [junit] Test: DTLB, cb30c2fe61a3fa91
    [junit] tag=7f30d1f, index=0, offset=1a91
    [junit] Test: L1, 1a9ee88d0a2c9f30
    [junit] tag=d0a2c9, index=79, offset=10
    [junit] Test: L2, fffffffffe9804e8
    [junit] tag=7ff4c, index=27, offset=8
    [junit] Test: DTLB, eeb8902616e62112
    [junit] tag=130b731, index=0, offset=112
    [junit] Test: L1, ffffffffd2f95abb
    [junit] tag=fd2f95, index=55, offset=1b
    [junit] Test: L2, cf1bca4b067ee501
    [junit] tag=5833f, index=728, offset=1
    [junit] Test: DTLB, 99be24891da65d5e
    [junit] tag=448ed32, index=0, offset=1d5e
    [junit] Test: L1, a9dcfb9f0271087f
    [junit] tag=f02710, index=43, offset=1f
    [junit] Test: L2, a3be8acd328e36a0
    [junit] tag=69947, index=1b5, offset=0
    [junit] Test: DTLB, ffffffffef94e05f
    [junit] tag=7ff7ca7, index=0, offset=5f
    [junit] Test: L1, ffffffff87cb3d85
    [junit] tag=f87cb3, index=6c, offset=5
    [junit] Test: L2, ee95626575ae938d
    [junit] tag=2bad7, index=49c, offset=d
    [junit] Test: DTLB, 7a431fc02a659ace
    [junit] tag=601532c, index=0, offset=1ace
    [junit] Test: L1, ffffffffb9616070
    [junit] tag=fb9616, index=3, offset=10
    [junit] Test: L2, ffffffffed7dcdff
    [junit] tag=7f6be, index=e6f, offset=1f
    [junit] Test: DTLB, ffffffff9901140e
    [junit] tag=7fcc808, index=0, offset=140e
    [junit] Test: L1, c763130b3452b059
    [junit] tag=b3452b, index=2, offset=19
    [junit] Test: L2, 6b19d595069fff30
    [junit] tag=2834f, index=ff9, offset=10
    [junit] Test: DTLB, ffffffff95b97c24
    [junit] tag=7fcadcb, index=0, offset=1c24
    [junit] Test: L1, ffffffffc2202f4b
    [junit] tag=fc2202, index=7a, offset=b
    [junit] Test: L2, fffffffffc73c0e3
    [junit] tag=7fe39, index=e07, offset=3
    [junit] Test: DTLB, ad7effdc61c0590d
    [junit] tag=6e30e02, index=0, offset=190d
    [junit] Test: L1, ffffffffda0130fa
    [junit] tag=fda013, index=7, offset=1a
    [junit] Test: L2, af5ca8a168cbf289
    [junit] tag=b465, index=f94, offset=9
    [junit] Test: DTLB, ffffffff82a2cce9
    [junit] tag=7fc1516, index=0, offset=ce9
    [junit] Test: L1, ffffffffc68554b5
    [junit] tag=fc6855, index=25, offset=15
    [junit] Test: L2, ffffffffc9b6707d
    [junit] tag=7e4db, index=383, offset=1d
    [junit] Test: DTLB, ffffffffb252372c
    [junit] tag=7fd9291, index=0, offset=172c
    [junit] Test: L1, 264e17e8563038ea
    [junit] tag=856303, index=47, offset=a
    [junit] Test: L2, fffffffffc18f53e
    [junit] tag=7fe0c, index=7a9, offset=1e
    [junit] Test: DTLB, 1db6767b44f3ccce
    [junit] tag=3da279e, index=0, offset=cce
    [junit] Test: L1, fcd94b8242428f36
    [junit] tag=242428, index=79, offset=16
    [junit] Test: L2, d2d5f62a2fd7f976
    [junit] tag=517eb, index=fcb, offset=16
    [junit] Test: DTLB, ffffffffeb31cbb6
    [junit] tag=7ff598e, index=0, offset=bb6
    [junit] Test: L1, fffffffff1533b54
    [junit] tag=ff1533, index=5a, offset=14
    [junit] Test: L2, ad16a0b81a73757a
    [junit] tag=40d39, index=bab, offset=1a
    [junit] Test: DTLB, ffffffffa8a328b0
    [junit] tag=7fd4519, index=0, offset=8b0
    [junit] Test: L1, ce58597153ce8a0e
    [junit] tag=153ce8, index=50, offset=e
    [junit] Test: L2, ffffffffe6decee6
    [junit] tag=7f36f, index=677, offset=6
    [junit] Test: DTLB, f2b94d2f35f75714
    [junit] tag=179afba, index=0, offset=1714
    [junit] Test: L1, ffffffffe1455edf
    [junit] tag=fe1455, index=76, offset=1f
    [junit] Test: L2, 19843b5500d34737
    [junit] tag=28069, index=a39, offset=17
    [junit] Test: DTLB, c0b670820aae174d
    [junit] tag=4105570, index=0, offset=174d
    [junit] Test: L1, 9fcfe9f419e58cdd
    [junit] tag=419e58, index=66, offset=1d
    [junit] Test: L2, ffffffff8041e38f
    [junit] tag=7c020, index=f1c, offset=f
    [junit] Test: DTLB, ffffffffec1c3dc9
    [junit] tag=7ff60e1, index=0, offset=1dc9
    [junit] Test: L1, 22a200830598dae8
    [junit] tag=30598d, index=57, offset=8
    [junit] Test: L2, ffffffff8e1feb75
    [junit] tag=7c70f, index=f5b, offset=15
    [junit] Test: DTLB, fffffffffd029014
    [junit] tag=7ffe814, index=0, offset=1014
    [junit] Test: L1, ffffffffeb15784b
    [junit] tag=feb157, index=42, offset=b
    [junit] Test: L2, ffffffff8601df0a
    [junit] tag=7c300, index=ef8, offset=a
    [junit] Test: DTLB, fbe14ae04f03a888
    [junit] tag=702781d, index=0, offset=888
    [junit] Test: L1, ffffffff870b0a39
    [junit] tag=f870b0, index=51, offset=19
    [junit] Test: L2, ffffffffdeb6c7b8
    [junit] tag=7ef5b, index=63d, offset=18
    [junit] Test: DTLB, 96ce0c360b37d2f
    [junit] tag=61b059b, index=0, offset=1d2f
    [junit] Test: L1, ffffffffb315bb35
    [junit] tag=fb315b, index=59, offset=15
    [junit] Test: L2, ffffffffb2e148c0
    [junit] tag=7d970, index=a46, offset=0
    [junit] Test: DTLB, 56e2ecc32f56b20c
    [junit] tag=6197ab5, index=0, offset=120c
    [junit] Test: L1, e22df558377fb136
    [junit] tag=8377fb, index=9, offset=16
    [junit] Test: L2, ffffffffa845fb1b
    [junit] tag=7d422, index=fd8, offset=1b
    [junit] Test: DTLB, fffffffff74aed48
    [junit] tag=7ffba57, index=0, offset=d48
    [junit] Test: L1, 73d6f65f1f0d9415
    [junit] tag=f1f0d9, index=20, offset=15
    [junit] Test: L2, fffffffff1093cf2
    [junit] tag=7f884, index=9e7, offset=12
    [junit] Test: DTLB, ffffffffacac308d
    [junit] tag=7fd6561, index=0, offset=108d
    [junit] Test: L1, b9a970a64547c349
    [junit] tag=64547c, index=1a, offset=9
    [junit] Test: L2, 674544fc5547977e
    [junit] tag=62aa3, index=cbb, offset=1e
    [junit] Test: DTLB, ef81f5e97df5ee7e
    [junit] tag=74befaf, index=0, offset=e7e
    [junit] Test: L1, 37aaf3af3dee77d7
    [junit] tag=f3dee7, index=3e, offset=17
    [junit] Test: L2, b753c6645aecf3b4
    [junit] tag=22d76, index=79d, offset=14
    [junit] Test: DTLB, ffffffff9a2fa28a
    [junit] tag=7fcd17d, index=0, offset=28a
    [junit] Test: L1, e47de195660f98ce
    [junit] tag=5660f9, index=46, offset=e
    [junit] Test: L2, e00340c5736eab36
    [junit] tag=2b9b7, index=559, offset=16
    [junit] Test: DTLB, ffffffffe510f435
    [junit] tag=7ff2887, index=0, offset=1435
    [junit] Test: L1, ffffffffcba38d98
    [junit] tag=fcba38, index=6c, offset=18
    [junit] Test: L2, ffffffffa7fc40a4
    [junit] tag=7d3fe, index=205, offset=4
    [junit] Test: DTLB, ffffffffe02bb620
    [junit] tag=7ff015d, index=0, offset=1620
    [junit] Test: L1, ffffffffed5ea79b
    [junit] tag=fed5ea, index=3c, offset=1b
    [junit] Test: L2, c3eba44e4a614fb6
    [junit] tag=72530, index=a7d, offset=16
    [junit] Test: DTLB, 178fd5537dfb5866
    [junit] tag=29befda, index=0, offset=1866
    [junit] Test: L1, ffffffff8aa5d5e9
    [junit] tag=f8aa5d, index=2f, offset=9
    [junit] Test: L2, ffffffff8c32b2a6
    [junit] tag=7c619, index=595, offset=6
    [junit] Test: DTLB, ffffffffe1380dc5
    [junit] tag=7ff09c0, index=0, offset=dc5
    [junit] Test: L1, 9dbd5fc4298035f1
    [junit] tag=429803, index=2f, offset=11
    [junit] Test: L2, 4d794f110d530a23
    [junit] tag=86a9, index=851, offset=3
    [junit] Test: DTLB, 84694f4c51af99bf
    [junit] tag=2628d7c, index=0, offset=19bf
    [junit] Test: L1, 3b5cf87f195537a0
    [junit] tag=f19553, index=3d, offset=0
    [junit] Test: L2, 47a0d15e4324175c
    [junit] tag=72192, index=ba, offset=1c
    [junit] Test: DTLB, ffffffffb2725b6e
    [junit] tag=7fd9392, index=0, offset=1b6e
    [junit] Test: L1, 80af8d2e4927dcba
    [junit] tag=e4927d, index=65, offset=1a
    [junit] Test: L2, fffffffff2c830b1
    [junit] tag=7f964, index=185, offset=11
    [junit] Test: DTLB, ffffffff99600f84
    [junit] tag=7fccb00, index=0, offset=f84
    [junit] Test: L1, 253e6bd3014e048f
    [junit] tag=3014e0, index=24, offset=f
    [junit] Test: L2, ffffffffe7776fb9
    [junit] tag=7f3bb, index=b7d, offset=19
    [junit] Test: DTLB, caeaf7eb1a4ab79d
    [junit] tag=758d255, index=0, offset=179d
    [junit] Test: L1, ffffffffe13ea417
    [junit] tag=fe13ea, index=20, offset=17
    [junit] Test: L2, 8b41874878ff41ca
    [junit] tag=43c7f, index=a0e, offset=a
    [junit] Test: DTLB, 3e9e7a2801f9cdf0
    [junit] tag=1400fce, index=0, offset=df0
    [junit] Test: L1, d6a8072d35e7c914
    [junit] tag=d35e7c, index=48, offset=14
    [junit] Test: L2, 7faa2a6f6323cc79
    [junit] tag=7b191, index=e63, offset=19
    [junit] Test: DTLB, 1d9c2c921d8e7dda
    [junit] tag=490ec73, index=0, offset=1dda
    [junit] Test: L1, ffffffffd7ed1755
    [junit] tag=fd7ed1, index=3a, offset=15
    [junit] Test: L2, ffffffffbde9536d
    [junit] tag=7def4, index=a9b, offset=d
    [junit] Test: DTLB, 5579eab80dbd31e6
    [junit] tag=5c06de9, index=0, offset=11e6
    [junit] Test: L1, ffffffffb5d1db69
    [junit] tag=fb5d1d, index=5b, offset=9
    [junit] Test: L2, ffffffffe27356e7
    [junit] tag=7f139, index=ab7, offset=7
    [junit] Test: DTLB, 9f4d47a570531d30
    [junit] tag=52b8298, index=0, offset=1d30
    [junit] Test: L1, 992fa91868c86ec2
    [junit] tag=868c86, index=76, offset=2
    [junit] Test: L2, 1fa7d9711346f1a2
    [junit] tag=89a3, index=78d, offset=2
    [junit] Test: DTLB, ffffffff8a6a7171
    [junit] tag=7fc5353, index=0, offset=1171
    [junit] Test: L1, 147005a9174475b0
    [junit] tag=917447, index=2d, offset=10
    [junit] Test: L2, d536e4746dd63cde
    [junit] tag=236eb, index=1e6, offset=1e
    [junit] Test: DTLB, ffffffffb83fee2e
    [junit] tag=7fdc1ff, index=0, offset=e2e
    [junit] Test: L1, ffffffffe368cbe4
    [junit] tag=fe368c, index=5f, offset=4
    [junit] Test: L2, bfda96c619b9228e
    [junit] tag=30cdc, index=914, offset=e
    [junit] Test: DTLB, ffffffffca0fbf42
    [junit] tag=7fe507d, index=0, offset=1f42
    [junit] Test: L1, ffffffff8ad1e032
    [junit] tag=f8ad1e, index=1, offset=12
    [junit] Test: L2, ffffffff994981fe
    [junit] tag=7cca4, index=c0f, offset=1e
    [junit] Test: DTLB, ffffffff8cc8be54
    [junit] tag=7fc6645, index=0, offset=1e54
    [junit] Test: L1, ffffffffcbc2031d
    [junit] tag=fcbc20, index=18, offset=1d
    [junit] Test: L2, 14a6224c205125c7
    [junit] tag=61028, index=92e, offset=7
    [junit] Test: DTLB, 462c3f1f41147958
    [junit] tag=fa08a3, index=0, offset=1958
    [junit] Test: L1, ffffffffe774c599
    [junit] tag=fe774c, index=2c, offset=19
    [junit] Test: L2, 54f7802b7d17b221
    [junit] tag=5be8b, index=d91, offset=1
    [junit] Test: DTLB, 2bbe53af7b9f8c7e
    [junit] tag=57bdcfc, index=0, offset=c7e
    [junit] Test: L1, ffffffffcc474bb9
    [junit] tag=fcc474, index=5d, offset=19
    [junit] Test: L2, e18a3f4e41cf1c19
    [junit] tag=720e7, index=8e0, offset=19
    [junit] Test: DTLB, ffffffffcaed9050
    [junit] tag=7fe576c, index=0, offset=1050
    [junit] Test: L1, ffffffffa89d37a8
    [junit] tag=fa89d3, index=3d, offset=8
    [junit] Test: L2, 1789b7f63ac246e9
    [junit] tag=31d61, index=237, offset=9
    [junit] Test: DTLB, ffffffffc74e112c
    [junit] tag=7fe3a70, index=0, offset=112c
    [junit] Test: L1, 907883893575ee44
    [junit] tag=93575e, index=72, offset=4
    [junit] Test: L2, ffffffffe6257977
    [junit] tag=7f312, index=bcb, offset=17
    [junit] Test: DTLB, ffffffffc6a129dd
    [junit] tag=7fe3509, index=0, offset=9dd
    [junit] Test: L1, 765abf3e58b66c81
    [junit] tag=e58b66, index=64, offset=1
    [junit] Test: L2, ffffffff995c4bd2
    [junit] tag=7ccae, index=25e, offset=12
    [junit] Test: DTLB, ffffffffcb3311d8
    [junit] tag=7fe5998, index=0, offset=11d8
    [junit] Test: L1, ffffffffd890c452
    [junit] tag=fd890c, index=22, offset=12
    [junit] Test: L2, ffffffff8ca523cd
    [junit] tag=7c652, index=91e, offset=d
    [junit] Test: DTLB, ec16aa76242ca6bd
    [junit] tag=3b12165, index=0, offset=6bd
    [junit] Test: L1, ffffffff8c889b29
    [junit] tag=f8c889, index=59, offset=9
    [junit] Test: L2, fffffffffd294f27
    [junit] tag=7fe94, index=a79, offset=7
    [junit] Test: DTLB, 80c2e200785bfb58
    [junit] tag=3c2df, index=0, offset=1b58
    [junit] Test: L1, 3ac90acb5e6b9d5c
    [junit] tag=b5e6b9, index=6a, offset=1c
    [junit] Test: L2, 39ab5d4217ee65d4
    [junit] tag=10bf7, index=32e, offset=14
    [junit] Test: DTLB, ffffffffd812256e
    [junit] tag=7fec091, index=0, offset=56e
    [junit] Test: L1, ffffffffdf79143c
    [junit] tag=fdf791, index=21, offset=1c
    [junit] Test: L2, ffffffffa306e97d
    [junit] tag=7d183, index=74b, offset=1d
    [junit] Test: DTLB, ffffffff8d6f0146
    [junit] tag=7fc6b78, index=0, offset=146
    [junit] Test: L1, c76ee2aa61171648
    [junit] tag=a61171, index=32, offset=8
    [junit] Test: L2, ffffffffc99eefdf
    [junit] tag=7e4cf, index=77e, offset=1f
    [junit] Test: DTLB, 893e6433176f14e3
    [junit] tag=198bb78, index=0, offset=14e3
    [junit] Test: L1, 21b28e6b003dbd7a
    [junit] tag=b003db, index=6b, offset=1a
    [junit] Test: L2, 95e607d77491ee29
    [junit] tag=3ba48, index=f71, offset=9
    [junit] Test: DTLB, c692e229709cc8e4
    [junit] tag=14b84e6, index=0, offset=8e4
    [junit] Test: L1, ffffffffee5c2b63
    [junit] tag=fee5c2, index=5b, offset=3
    [junit] Test: L2, ffffffffefe2b1a2
    [junit] tag=7f7f1, index=58d, offset=2
    [junit] Test: DTLB, 61be28642ebc276c
    [junit] tag=32175e1, index=0, offset=76c
    [junit] Test: L1, 397c0ddd45f39294
    [junit] tag=d45f39, index=14, offset=14
    [junit] Test: L2, fffffffffc9f5461
    [junit] tag=7fe4f, index=aa3, offset=1
    [junit] Test: DTLB, 7c9ba57262cce7e8
    [junit] tag=3931667, index=0, offset=7e8
    [junit] Test: L1, 1d39bab70f71a4ad
    [junit] tag=70f71a, index=25, offset=d
    [junit] Test: L2, ffffffffcd865adf
    [junit] tag=7e6c3, index=2d6, offset=1f
    [junit] Test: DTLB, 2edfbb412ea8ceb8
    [junit] tag=2097546, index=0, offset=eb8
    [junit] Test: L1, ffffffff81faa334
    [junit] tag=f81faa, index=19, offset=14
    [junit] Test: L2, ffffffffa6c95a42
    [junit] tag=7d364, index=ad2, offset=2
    [junit] Test: DTLB, ffffffff84aa256e
    [junit] tag=7fc2551, index=0, offset=56e
    [junit] Test: L1, ffffffffb6616773
    [junit] tag=fb6616, index=3b, offset=13
    [junit] Test: L2, fbb179535b001594
    [junit] tag=1ad80, index=ac, offset=14
    [junit] Test: DTLB, 6b491b9f5d553ba4
    [junit] tag=4faeaa9, index=0, offset=1ba4
    [junit] Test: L1, ffffffffb4088fd3
    [junit] tag=fb4088, index=7e, offset=13
    [junit] Test: L2, ffffffffa50236e3
    [junit] tag=7d281, index=1b7, offset=3
    [junit] Test: DTLB, ffffffffc923da63
    [junit] tag=7fe491e, index=0, offset=1a63
    [junit] Test: L1, c705eba90043d77a
    [junit] tag=90043d, index=3b, offset=1a
    [junit] Test: L2, fffffffff9597530
    [junit] tag=7fcac, index=ba9, offset=10
    [junit] Test: DTLB, ffffffffb772ccbf
    [junit] tag=7fdbb96, index=0, offset=cbf
    [junit] Test: L1, 936589f04673418a
    [junit] tag=46734, index=c, offset=a
    [junit] Test: L2, fffffffff13b78ed
    [junit] tag=7f89d, index=bc7, offset=d
    [junit] Test: DTLB, 8f98a6b912480eb9
    [junit] tag=5c89240, index=0, offset=eb9
    [junit] Test: L1, c15e14f67cd176ce
    [junit] tag=67cd17, index=36, offset=e
    [junit] Test: L2, a83b405369ffe42
    [junit] tag=29b4f, index=ff2, offset=2
    [junit] Test: DTLB, ffffffff9661ad7d
    [junit] tag=7fcb30d, index=0, offset=d7d
    [junit] Test: L1, 229b078676e6ad9
    [junit] tag=8676e6, index=56, offset=19
    [junit] Test: L2, 7e6f37831b45c08d
    [junit] tag=18da2, index=e04, offset=d
    [junit] Test: DTLB, 55798ab3b43d7cb
    [junit] tag=559da1e, index=0, offset=17cb
    [junit] Test: L1, 9769835d7926f51b
    [junit] tag=d7926f, index=28, offset=1b
    [junit] Test: L2, ffffffffabc8062c
    [junit] tag=7d5e4, index=31, offset=c
    [junit] Test: DTLB, 9be65c3735992b3d
    [junit] tag=1b9acc9, index=0, offset=b3d
    [junit] Test: L1, f761698847850b35
    [junit] tag=847850, index=59, offset=15
    [junit] Test: L2, 2027e395683733a8
    [junit] tag=2b41b, index=99d, offset=8
    [junit] Test: DTLB, ffffffffa08aaa26
    [junit] tag=7fd0455, index=0, offset=a26
    [junit] Test: L1, ffffffffafdb2770
    [junit] tag=fafdb2, index=3b, offset=10
    [junit] Test: L2, ffffffff857c9e2e
    [junit] tag=7c2be, index=4f1, offset=e
    [junit] Test: DTLB, ffffffffdd75e51b
    [junit] tag=7feebaf, index=0, offset=51b
    [junit] Test: L1, ffffffffae814220
    [junit] tag=fae814, index=11, offset=0
    [junit] Test: L2, 47c02f6e1f345e50
    [junit] tag=70f9a, index=2f2, offset=10
    [junit] Test: DTLB, ffffffffaf8afa4a
    [junit] tag=7fd7c57, index=0, offset=1a4a
    [junit] Test: L1, 21bc4ee125ae26d7
    [junit] tag=125ae2, index=36, offset=17
    [junit] Test: L2, cfce9cd13cc7ddfc
    [junit] tag=9e63, index=eef, offset=1c
    [junit] Test: DTLB, ffffffff8303ee17
    [junit] tag=7fc181f, index=0, offset=e17
    [junit] Test: L1, ffffffff8f8a9f8d
    [junit] tag=f8f8a9, index=7c, offset=d
    [junit] Test: L2, ffffffffef487ffa
    [junit] tag=7f7a4, index=3ff, offset=1a
    [junit] Test: DTLB, ffffffffbe4309e7
    [junit] tag=7fdf218, index=0, offset=9e7
    [junit] Test: L1, 98c9a8490a68a160
    [junit] tag=90a68a, index=b, offset=0
    [junit] Test: L2, d7c3c84f7aa2a436
    [junit] tag=7bd51, index=521, offset=16
    [junit] Test: DTLB, bda705b64c2c43d7
    [junit] tag=5b26162, index=0, offset=3d7
    [junit] Test: L1, 6d9d70db7ac3513e
    [junit] tag=b7ac35, index=9, offset=1e
    [junit] Test: L2, ffffffff83bf1635
    [junit] tag=7c1df, index=8b1, offset=15
    [junit] Test: DTLB, ffffffff9adbb0fd
    [junit] tag=7fcd6dd, index=0, offset=10fd
    [junit] Test: L1, ffffffffefc77253
    [junit] tag=fefc77, index=12, offset=13
    [junit] Test: L2, 3761ebf63d278596
    [junit] tag=31e93, index=c2c, offset=16
    [junit] Test: DTLB, ffffffff807b26ba
    [junit] tag=7fc03d9, index=0, offset=6ba
    [junit] Test: L1, ffffffff962410c2
    [junit] tag=f96241, index=6, offset=2
    [junit] Test: L2, 6902c52d6732aef9
    [junit] tag=6b399, index=577, offset=19
    [junit] Test: DTLB, ffffffffd97b722e
    [junit] tag=7fecbdb, index=0, offset=122e
    [junit] Test: L1, ffffffffdbf7db67
    [junit] tag=fdbf7d, index=5b, offset=7
    [junit] Test: L2, 9fda31344a589e6e
    [junit] tag=2252c, index=4f3, offset=e
    [junit] Test: DTLB, ffffffffb0e7194f
    [junit] tag=7fd8738, index=0, offset=194f
    [junit] Test: L1, ffffffffdb6f57e4
    [junit] tag=fdb6f5, index=3f, offset=4
    [junit] Test: L2, 982a688734270116
    [junit] tag=39a13, index=808, offset=16
    [junit] Test: DTLB, ffffffffa0d737c2
    [junit] tag=7fd06b9, index=0, offset=17c2
    [junit] Test: L1, ffffffffe4896c71
    [junit] tag=fe4896, index=63, offset=11
    [junit] Test: L2, fffffffff522f2a4
    [junit] tag=7fa91, index=795, offset=4
    [junit] Test: DTLB, ffffffffc27d8210
    [junit] tag=7fe13ec, index=0, offset=210
    [junit] Test: L1, ffffffff9290b9ee
    [junit] tag=f9290b, index=4f, offset=e
    [junit] Test: L2, ffffffff977c31d6
    [junit] tag=7cbbe, index=18e, offset=16
    [junit] Test: DTLB, b3cbd2d2381ccc2b
    [junit] tag=691c0e6, index=0, offset=c2b
    [junit] Test: L1, 15d0eda4625949b6
    [junit] tag=462594, index=4d, offset=16
    [junit] Test: L2, ffffffff9a553a49
    [junit] tag=7cd2a, index=9d2, offset=9
    [junit] Test: DTLB, ffffffffed135776
    [junit] tag=7ff689a, index=0, offset=1776
    [junit] Test: L1, 822814cc73653e94
    [junit] tag=c73653, index=74, offset=14
    [junit] Test: L2, ffffffffd9a24ad5
    [junit] tag=7ecd1, index=256, offset=15
    [junit] Test: DTLB, b566403842ae3d93
    [junit] tag=1c21571, index=0, offset=1d93
    [junit] Test: L1, 3f03308f782c15ac
    [junit] tag=f782c1, index=2d, offset=c
    [junit] Test: L2, ffffffffc0f231bb
    [junit] tag=7e079, index=18d, offset=1b
    [junit] Test: DTLB, caf03fac5cc048a5
    [junit] tag=562e602, index=0, offset=8a5
    [junit] Test: L1, ffffffffe5aeff40
    [junit] tag=fe5aef, index=7a, offset=0
    [junit] Test: L2, ffffffffa88495ec
    [junit] tag=7d442, index=4af, offset=c
    [junit] Test: DTLB, 7993eabc72d73af6
    [junit] tag=5e396b9, index=0, offset=1af6
    [junit] Test: L1, 7d6c376e1d88d603
    [junit] tag=e1d88d, index=30, offset=3
    [junit] Test: L2, ffffffffd2dbd112
    [junit] tag=7e96d, index=e88, offset=12
    [junit] Test: DTLB, ffffffff8236552c
    [junit] tag=7fc11b2, index=0, offset=152c
    [junit] Test: L1, ffffffffeebabc1e
    [junit] tag=feebab, index=60, offset=1e
    [junit] Test: L2, 961603497924a8a1
    [junit] tag=4bc92, index=545, offset=1
    [junit] Test: DTLB, ffffffff822e04bc
    [junit] tag=7fc1170, index=0, offset=4bc
    [junit] Test: L1, fffffffff45f2b40
    [junit] tag=ff45f2, index=5a, offset=0
    [junit] Test: L2, ec06e870474f8e09
    [junit] tag=23a7, index=c70, offset=9
    [junit] Test: DTLB, ffffffff92c1f50b
    [junit] tag=7fc960f, index=0, offset=150b
    [junit] Test: L1, c0b846a158fe5118
    [junit] tag=158fe5, index=8, offset=18
    [junit] Test: L2, 9c7792d73725e6a2
    [junit] tag=39b92, index=f35, offset=2
    [junit] Test: DTLB, 4450f7e013621cdc
    [junit] tag=7009b10, index=0, offset=1cdc
    [junit] Test: L1, b2f3abd64c5ec282
    [junit] tag=64c5ec, index=14, offset=2
    [junit] Test: L2, ffffffffb3dcb259
    [junit] tag=7d9ee, index=592, offset=19
    [junit] Test: DTLB, dfe5277134c3bb02
    [junit] tag=389a61d, index=0, offset=1b02
    [junit] Test: L1, 4f512bc804cb51e2
    [junit] tag=804cb5, index=f, offset=2
    [junit] Test: L2, ffffffff89fd36f1
    [junit] tag=7c4fe, index=9b7, offset=11
    [junit] Test: DTLB, 489cad3750da8a87
    [junit] tag=1ba86d4, index=0, offset=a87
    [junit] Test: L1, 9efea5375ff3781c
    [junit] tag=75ff37, index=40, offset=1c
    [junit] Test: L2, c3be35c42b0ec1df
    [junit] tag=21587, index=60e, offset=1f
    [junit] Test: DTLB, 295d506b60262d47
    [junit] tag=35b0131, index=0, offset=d47
    [junit] Test: L1, 8dea32d456fae18f
    [junit] tag=456fae, index=c, offset=f
    [junit] Test: L2, ffffffff93837056
    [junit] tag=7c9c1, index=b82, offset=16
    [junit] Test: DTLB, 87454a2a685e5e60
    [junit] tag=15342f2, index=0, offset=1e60
    [junit] Test: L1, 31054ce267c8c62
    [junit] tag=e267c8, index=63, offset=2
    [junit] Test: L2, ffffffffd346e2f3
    [junit] tag=7e9a3, index=717, offset=13
    [junit] Test: DTLB, 6f2eee4d34b785c2
    [junit] tag=269a5bc, index=0, offset=5c2
    [junit] Test: L1, ffffffffb058e403
    [junit] tag=fb058e, index=20, offset=3
    [junit] Test: L2, ce243762361a0d87
    [junit] tag=11b0d, index=6c, offset=7
    [junit] Test: DTLB, 9945742c0daa9a43
    [junit] tag=1606d54, index=0, offset=1a43
    [junit] Test: L1, ffffffffe9bdb6bd
    [junit] tag=fe9bdb, index=35, offset=1d
    [junit] Test: L2, db7c714545184564
    [junit] tag=2a28c, index=22b, offset=4
    [junit] Test: DTLB, 93d0a83b734ca829
    [junit] tag=1db9a65, index=0, offset=829
    [junit] Test: L1, ffffffffebef8d48
    [junit] tag=febef8, index=6a, offset=8
    [junit] Test: L2, ffffffffa38269a1
    [junit] tag=7d1c1, index=34d, offset=1
    [junit] Test: DTLB, ffffffffb71bd101
    [junit] tag=7fdb8de, index=0, offset=1101
    [junit] Test: L1, ffffffffe2bcd587
    [junit] tag=fe2bcd, index=2c, offset=7
    [junit] Test: L2, fffffffff7bef1e2
    [junit] tag=7fbdf, index=78f, offset=2
    [junit] Test: DTLB, ffffffffb00049fe
    [junit] tag=7fd8002, index=0, offset=9fe
    [junit] Test: L1, 66dc07e262089951
    [junit] tag=262089, index=4a, offset=11
    [junit] Test: L2, fffffffffd10e2ab
    [junit] tag=7fe88, index=715, offset=b
    [junit] Test: DTLB, ffffffffca30c3f4
    [junit] tag=7fe5186, index=0, offset=3f4
    [junit] Test: L1, ef5babcd7d8fd28d
    [junit] tag=d7d8fd, index=14, offset=d
    [junit] Test: L2, ffffffff9b9484c7
    [junit] tag=7cdca, index=426, offset=7
    [junit] Test: DTLB, fffffffff5e1f368
    [junit] tag=7ffaf0f, index=0, offset=1368
    [junit] Test: L1, d6e2e8ef52cf2247
    [junit] tag=f52cf2, index=12, offset=7
    [junit] Test: L2, ffffffffbc681f25
    [junit] tag=7de34, index=f9, offset=5
    [junit] Test: DTLB, 6b2685b65c3a0158
    [junit] tag=5b2e1d0, index=0, offset=158
    [junit] Test: L1, ffffffffa2351c5f
    [junit] tag=fa2351, index=62, offset=1f
    [junit] Test: L2, ffffffffd28738f4
    [junit] tag=7e943, index=9c7, offset=14
    [junit] Test: DTLB, b3d35f341ac50014
    [junit] tag=1a0d628, index=0, offset=14
    [junit] Test: L1, 87b267815f18fe07
    [junit] tag=15f18f, index=70, offset=7
    [junit] Test: L2, 584a40c92bd19437
    [junit] tag=495e8, index=ca1, offset=17
    [junit] Test: DTLB, cdaa487878fbd588
    [junit] tag=3c3c7de, index=0, offset=1588
    [junit] Test: L1, 513e98b4f88350e
    [junit] tag=b4f883, index=28, offset=e
    [junit] Test: L2, ffffffffd4d89b2c
    [junit] tag=7ea6c, index=4d9, offset=c
    [junit] Test: DTLB, 26f3c45b539c61bc
    [junit] tag=2da9ce3, index=0, offset=1bc
    [junit] Test: L1, ffffffffb8d62c8e
    [junit] tag=fb8d62, index=64, offset=e
    [junit] Test: L2, 464f41625bec6a3e
    [junit] tag=12df6, index=351, offset=1e
    [junit] Test: DTLB, fe3fbbde6d9dab1f
    [junit] tag=6f36ced, index=0, offset=b1f
    [junit] Test: L1, ffffffffe35b5ab7
    [junit] tag=fe35b5, index=55, offset=17
    [junit] Test: L2, ac7ba4b63a69aa7a
    [junit] tag=31d34, index=d53, offset=1a
    [junit] Test: DTLB, fff6c94d55f2443f
    [junit] tag=26aaf92, index=0, offset=43f
    [junit] Test: L1, de9cb18611f866a8
    [junit] tag=611f86, index=35, offset=8
    [junit] Test: L2, 8e56baf87252c45e
    [junit] tag=43929, index=622, offset=1e
    [junit] Test: DTLB, 508a86a5b9a8fea
    [junit] tag=352dcd4, index=0, offset=fea
    [junit] Test: L1, 8d3c67e966e45034
    [junit] tag=966e45, index=1, offset=14
    [junit] Test: L2, 7822015252a1e888
    [junit] tag=12950, index=f44, offset=8
    [junit] Test: DTLB, c32221ae74354639
    [junit] tag=573a1aa, index=0, offset=639
    [junit] Test: L1, ffffffff887a7c7f
    [junit] tag=f887a7, index=63, offset=1f
    [junit] Test: L2, 9bdf13632b5db80c
    [junit] tag=195ae, index=dc0, offset=c
    [junit] Test: DTLB, 99e6dcf573ea5fdb
    [junit] tag=7ab9f52, index=0, offset=1fdb
    [junit] Test: L1, ffffffff8b467196
    [junit] tag=f8b467, index=c, offset=16
    [junit] Test: L2, ffffffffb07ed51f
    [junit] tag=7d83f, index=6a8, offset=1f
    [junit] Test: DTLB, ffffffffb990c975
    [junit] tag=7fdcc86, index=0, offset=975
    [junit] Test: L1, ffffffffa18d781c
    [junit] tag=fa18d7, index=40, offset=1c
    [junit] Test: L2, 280a859a0394ff07
    [junit] tag=501ca, index=7f8, offset=7
    [junit] Test: DTLB, 3e98ef6948352f2e
    [junit] tag=34a41a9, index=0, offset=f2e
    [junit] Test: L1, a038e3e46e93f595
    [junit] tag=46e93f, index=2c, offset=15
    [junit] Test: L2, 197a5f310eee69d1
    [junit] tag=8777, index=34e, offset=11
    [junit] Test: DTLB, ffffffffbb87f1a1
    [junit] tag=7fddc3f, index=0, offset=11a1
    [junit] Test: L1, ffffffff9d164362
    [junit] tag=f9d164, index=1b, offset=2
    [junit] Test: L2, ffffffffa0963e52
    [junit] tag=7d04b, index=1f2, offset=12
    [junit] Test: DTLB, 7b29b1293a09763e
    [junit] tag=149d04b, index=0, offset=163e
    [junit] Test: L1, 9eaf604fb263eb
    [junit] tag=4fb26, index=1f, offset=b
    [junit] Test: L2, 7b4d9f231e2997f9
    [junit] tag=18f14, index=cbf, offset=19
    [junit] Test: DTLB, d20ebe47275a964b
    [junit] tag=2393ad4, index=0, offset=164b
    [junit] Test: L1, ffffffffc1182db9
    [junit] tag=fc1182, index=6d, offset=19
    [junit] Test: L2, fffffffffe423779
    [junit] tag=7ff21, index=1bb, offset=19
    [junit] Test: DTLB, f3a63be36fa22622
    [junit] tag=71b7d11, index=0, offset=622
    [junit] Test: L1, ffffffff8ffabc7b
    [junit] tag=f8ffab, index=63, offset=1b
    [junit] Test: L2, 6e42f5787d5132e8
    [junit] tag=43ea8, index=997, offset=8
    [junit] Test: DTLB, 83673186658a9b8e
    [junit] tag=4332c54, index=0, offset=1b8e
    [junit] Test: L1, ffffffff8265e38b
    [junit] tag=f8265e, index=1c, offset=b
    [junit] Test: L2, ffffffffb9b01300
    [junit] tag=7dcd8, index=98, offset=0
    [junit] Test: DTLB, fffffffff729378c
    [junit] tag=7ffb949, index=0, offset=178c
    [junit] Test: L1, fffffffffaa67004
    [junit] tag=ffaa67, index=0, offset=4
    [junit] Test: L2, ced3ddca7842bb64
    [junit] tag=53c21, index=5db, offset=4
    [junit] Test: DTLB, ffffffff924baa5b
    [junit] tag=7fc925d, index=0, offset=a5b
    [junit] Test: L1, dac5e3cf111f9f85
    [junit] tag=f111f9, index=7c, offset=5
    [junit] Test: L2, b08e81fa35cfb47d
    [junit] tag=51ae7, index=da3, offset=1d
    [junit] Test: DTLB, bfc541822e80827b
    [junit] tag=4117404, index=0, offset=27b
    [junit] Test: L1, b419164b0892fcb0
    [junit] tag=b0892f, index=65, offset=10
    [junit] Test: L2, ffffffffad4a970e
    [junit] tag=7d6a5, index=4b8, offset=e
    [junit] Test: DTLB, 875e3a9d51354b27
    [junit] tag=4ea89aa, index=0, offset=b27
    [junit] Test: L1, 13f574d12226fc67
    [junit] tag=12226f, index=63, offset=7
    [junit] Test: L2, e1f479dd50a5f230
    [junit] tag=6a852, index=f91, offset=10
    [junit] Test: DTLB, 3e90419160b6a150
    [junit] tag=48b05b5, index=0, offset=150
    [junit] Test: L1, bd5b776929d732cd
    [junit] tag=929d73, index=16, offset=d
    [junit] Test: L2, ffffffff861dd110
    [junit] tag=7c30e, index=e88, offset=10
    [junit] Test: DTLB, ffffffffc6d1e7d0
    [junit] tag=7fe368f, index=0, offset=7d0
    [junit] Test: L1, dfdc496017610ee5
    [junit] tag=17610, index=77, offset=5
    [junit] Test: L2, ffffffffb19104d4
    [junit] tag=7d8c8, index=826, offset=14
    [junit] Test: DTLB, ffffffff8c8740c2
    [junit] tag=7fc643a, index=0, offset=c2
    [junit] Test: L1, ffffffffdb6f7468
    [junit] tag=fdb6f7, index=23, offset=8
    [junit] Test: L2, cfeba79c739cdeff
    [junit] tag=639ce, index=6f7, offset=1f
    [junit] Test: DTLB, ffffffffa0cf4f82
    [junit] tag=7fd067a, index=0, offset=f82
    [junit] Test: L1, ffffffff97e723bd
    [junit] tag=f97e72, index=1d, offset=1d
    [junit] Test: L2, 65fab45f6d250d08
    [junit] tag=7b692, index=868, offset=8
    [junit] Test: DTLB, ffffffffe4398f72
    [junit] tag=7ff21cc, index=0, offset=f72
    [junit] Test: L1, ffffffffb5f2dbf8
    [junit] tag=fb5f2d, index=5f, offset=18
    [junit] Test: L2, 6782a0e2036f4518
    [junit] tag=101b7, index=a28, offset=18
    [junit] Test: DTLB, 37a41c8476994b10
    [junit] tag=423b4ca, index=0, offset=b10
    [junit] Test: L1, ffffffffe41af566
    [junit] tag=fe41af, index=2b, offset=6
    [junit] Test: L2, 43969f9101654201
    [junit] tag=80b2, index=a10, offset=1
    [junit] Test: DTLB, 872cc63255299734
    [junit] tag=192a94c, index=0, offset=1734
    [junit] Test: L1, 396dd175212809bb
    [junit] tag=521280, index=4d, offset=1b
    [junit] Test: L2, ffffffff812e5af9
    [junit] tag=7c097, index=2d7, offset=19
    [junit] Test: DTLB, ffffffffe01a017f
    [junit] tag=7ff00d0, index=0, offset=17f
    [junit] Test: L1, ffffffffdee41a70
    [junit] tag=fdee41, index=53, offset=10
    [junit] Test: L2, ffffffff9faa402c
    [junit] tag=7cfd5, index=201, offset=c
    [junit] Test: DTLB, 1408f6176d9aab57
    [junit] tag=bb6cd5, index=0, offset=b57
    [junit] Test: L1, ffffffff89c71a99
    [junit] tag=f89c71, index=54, offset=19
    [junit] Test: L2, ffffffff9e111335
    [junit] tag=7cf08, index=899, offset=15
    [junit] Test: DTLB, ffffffffb7288e60
    [junit] tag=7fdb944, index=0, offset=e60
    [junit] Test: L1, 409b14cc473f61fb
    [junit] tag=c473f6, index=f, offset=1b
    [junit] Test: L2, ffffffffe94fc5e9
    [junit] tag=7f4a7, index=e2f, offset=9
    [junit] Test: DTLB, 1f088d0213aba098
    [junit] tag=109d5d, index=0, offset=98
    [junit] Test: L1, d6179a041d2cd78b
    [junit] tag=41d2cd, index=3c, offset=b
    [junit] Test: L2, 25ea4432747206fe
    [junit] tag=13a39, index=37, offset=1e
    [junit] Test: DTLB, ffffffffff684ada
    [junit] tag=7fffb42, index=0, offset=ada
    [junit] Test: L1, cd08b32b4c3f8656
    [junit] tag=b4c3f8, index=32, offset=16
    [junit] Test: L2, 2d693d1b2f406fa8
    [junit] tag=597a0, index=37d, offset=8
    [junit] Test: DTLB, dfa5d01939d7290d
    [junit] tag=c9ceb9, index=0, offset=90d
    [junit] Test: L1, fffffffffe4e90eb
    [junit] tag=ffe4e9, index=7, offset=b
    [junit] Test: L2, ffffffffc05d9b58
    [junit] tag=7e02e, index=cda, offset=18
    [junit] Test: DTLB, fffffffff4597be9
    [junit] tag=7ffa2cb, index=0, offset=1be9
    [junit] Test: L1, 2540a68a42e681be
    [junit] tag=a42e68, index=d, offset=1e
    [junit] Test: L2, e28dbf22764b22cb
    [junit] tag=13b25, index=916, offset=b
    [junit] Test: DTLB, 8a9a33e62006cdfc
    [junit] tag=7310036, index=0, offset=dfc
    [junit] Test: L1, fffffffff4dedd6a
    [junit] tag=ff4ded, index=6b, offset=a
    [junit] Test: L2, ffffffffd3e49563
    [junit] tag=7e9f2, index=4ab, offset=3
    [junit] Test: DTLB, ffffffffd6350c58
    [junit] tag=7feb1a8, index=0, offset=c58
    [junit] Test: L1, 961edbcb4f21d5e2
    [junit] tag=b4f21d, index=2f, offset=2
    [junit] Test: L2, ffffffffcd0d97e1
    [junit] tag=7e686, index=cbf, offset=1
    [junit] Test: DTLB, fa747a1203794d03
    [junit] tag=901bca, index=0, offset=d03
    [junit] Test: L1, b2f7e2c37b4fe469
    [junit] tag=37b4fe, index=23, offset=9
    [junit] Test: L2, ffffffff9a776e2b
    [junit] tag=7cd3b, index=b71, offset=b
    [junit] Test: DTLB, 91fdb7db58d07d83
    [junit] tag=6dac683, index=0, offset=1d83
    [junit] Test: L1, ffffffff93ea64ac
    [junit] tag=f93ea6, index=25, offset=c
    [junit] Test: L2, a55462b7745f0387
    [junit] tag=3ba2f, index=81c, offset=7
    [junit] Test: DTLB, 2bbbdf3361038c53
    [junit] tag=19b081c, index=0, offset=c53
    [junit] Test: L1, ffffffffb7a1eb12
    [junit] tag=fb7a1e, index=58, offset=12
    [junit] Test: L2, ffffffffdd40b2f5
    [junit] tag=7eea0, index=597, offset=15
    [junit] Test: DTLB, 6c904570372d80ce
    [junit] tag=381b96c, index=0, offset=ce
    [junit] Test: L1, ffffffff9775fb22
    [junit] tag=f9775f, index=59, offset=2
    [junit] Test: L2, ffffffffeb94313f
    [junit] tag=7f5ca, index=189, offset=1f
    [junit] Test: DTLB, ffffffff82719c6d
    [junit] tag=7fc138c, index=0, offset=1c6d
    [junit] Test: L1, ffffffff8875293c
    [junit] tag=f88752, index=49, offset=1c
    [junit] Test: L2, d6f7407f46de2b06
    [junit] tag=7a36f, index=158, offset=6
    [junit] Test: DTLB, 51bb27133e5d649c
    [junit] tag=99f2eb, index=0, offset=49c
    [junit] Test: L1, f10739717a2a0abf
    [junit] tag=17a2a0, index=55, offset=1f
    [junit] Test: L2, ffffffffa10bce31
    [junit] tag=7d085, index=e71, offset=11
    [junit] Test: DTLB, e821bb9a5738bf93
    [junit] tag=4d2b9c5, index=0, offset=1f93
    [junit] Test: L1, ce22e3fc7ee002af
    [junit] tag=c7ee00, index=15, offset=f
    [junit] Test: L2, ffffffff9ef2cb13
    [junit] tag=7cf79, index=658, offset=13
    [junit] Test: DTLB, 974961565d8fbee4
    [junit] tag=2b2ec7d, index=0, offset=1ee4
    [junit] Test: L1, 2789e2df27438ada
    [junit] tag=f27438, index=56, offset=1a
    [junit] Test: L2, ffffffffdbd5b8ea
    [junit] tag=7edea, index=dc7, offset=a
    [junit] Test: DTLB, 86f5937e08191ed4
    [junit] tag=3f040c8, index=0, offset=1ed4
    [junit] Test: L1, 92b3884c39d752c7
    [junit] tag=c39d75, index=16, offset=7
    [junit] Test: L2, fffffffff19d7fb7
    [junit] tag=7f8ce, index=bfd, offset=17
    [junit] Test: DTLB, ffffffffb401eaae
    [junit] tag=7fda00f, index=0, offset=aae
    [junit] Test: L1, dc84d2b028a47852
    [junit] tag=28a47, index=42, offset=12
    [junit] Test: L2, 97c833be10e0bcae
    [junit] tag=70870, index=5e5, offset=e
    [junit] Test: DTLB, ffffffffeea5672e
    [junit] tag=7ff752b, index=0, offset=72e
    [junit] Test: L1, ffffffffc3460d10
    [junit] tag=fc3460, index=68, offset=10
    [junit] Test: L2, 29a62f17385e6d49
    [junit] tag=39c2f, index=36a, offset=9
    [junit] Test: DTLB, 8de9fc7d4c0bd1d2
    [junit] tag=3ea605e, index=0, offset=11d2
    [junit] Test: L1, ffffffff8dc9fced
    [junit] tag=f8dc9f, index=67, offset=d
    [junit] Test: L2, 55daa1307b0100e4
    [junit] tag=3d80, index=807, offset=4
    [junit] Test: DTLB, ffffffffdffec4a4
    [junit] tag=7fefff6, index=0, offset=4a4
    [junit] Test: L1, ffffffffba5c110a
    [junit] tag=fba5c1, index=8, offset=a
    [junit] Test: L2, ffffffffdf49e4e3
    [junit] tag=7efa4, index=f27, offset=3
    [junit] Test: DTLB, ffffffffca0b953d
    [junit] tag=7fe505c, index=0, offset=153d
    [junit] Test: L1, d3536e2d4845fdba
    [junit] tag=d4845f, index=6d, offset=1a
    [junit] Test: L2, ffffffffc5f23521
    [junit] tag=7e2f9, index=1a9, offset=1
    [junit] Test: DTLB, ffffffff94e23fd8
    [junit] tag=7fca711, index=0, offset=1fd8
    [junit] Test: L1, ac39eee30dc10bc1
    [junit] tag=30dc10, index=5e, offset=1
    [junit] Test: L2, 2380358655752337
    [junit] tag=32aba, index=919, offset=17
    [junit] Test: DTLB, 27e1f2021de59df8
    [junit] tag=10ef2c, index=0, offset=1df8
    [junit] Test: L1, 4b9715a458fefee9
    [junit] tag=458fef, index=77, offset=9
    [junit] Test: L2, ffffffff9af6c97c
    [junit] tag=7cd7b, index=64b, offset=1c
    [junit] Test: DTLB, fffffffff76fa6fa
    [junit] tag=7ffbb7d, index=0, offset=6fa
    [junit] Test: L1, e3f5a5b97acad04c
    [junit] tag=97acad, index=2, offset=c
    [junit] Test: L2, 64eeaf652a529621
    [junit] tag=29529, index=4b1, offset=1
    [junit] Test: DTLB, 6e0905c84c113aba
    [junit] tag=6426089, index=0, offset=1aba
    [junit] Test: L1, fffffffff6318d01
    [junit] tag=ff6318, index=68, offset=1
    [junit] Test: L2, ffffffffb923498e
    [junit] tag=7dc91, index=a4c, offset=e
    [junit] Test: DTLB, 1315175d0aee5f7f
    [junit] tag=2e85772, index=0, offset=1f7f
    [junit] Test: L1, ffffffffeadad4b1
    [junit] tag=feadad, index=25, offset=11
    [junit] Test: L2, ffffffffed05ff65
    [junit] tag=7f682, index=ffb, offset=5
    [junit] Test: DTLB, ffffffffae14c4a9
    [junit] tag=7fd70a6, index=0, offset=4a9
    [junit] Test: L1, ffffffffcee744e0
    [junit] tag=fcee74, index=27, offset=0
    [junit] Test: L2, ffffffff900f1663
    [junit] tag=7c807, index=8b3, offset=3
    [junit] Test: DTLB, fe1dae5276790a77
    [junit] tag=293b3c8, index=0, offset=a77
    [junit] Test: L1, ffffffffac325736
    [junit] tag=fac325, index=39, offset=16
    [junit] Test: L2, e6a6cc727b751111
    [junit] tag=13dba, index=888, offset=11
    [junit] Test: DTLB, cb181f14179bf80c
    [junit] tag=a0bcdf, index=0, offset=180c
    [junit] Test: L1, ffffffff8f408206
    [junit] tag=f8f408, index=10, offset=6
    [junit] Test: L2, ffffffffe387fb59
    [junit] tag=7f1c3, index=fda, offset=19
    [junit] Test: DTLB, 2c6b8d243e778c45
    [junit] tag=121f3bc, index=0, offset=c45
    [junit] Test: L1, c5e7fc4d373866ca
    [junit] tag=d37386, index=36, offset=a
    [junit] Test: L2, ffffffffef97e542
    [junit] tag=7f7cb, index=f2a, offset=2
    [junit] Test: DTLB, ffffffffd74a3e37
    [junit] tag=7feba51, index=0, offset=1e37
    [junit] Test: L1, fffffffffdc171c3
    [junit] tag=ffdc17, index=e, offset=3
    [junit] Test: L2, fffffffff58d2ae5
    [junit] tag=7fac6, index=957, offset=5
    [junit] Test: DTLB, ffffffffb1973990
    [junit] tag=7fd8cb9, index=0, offset=1990
    [junit] Test: L1, b3ba39673d497a8e
    [junit] tag=73d497, index=54, offset=e
    [junit] Test: L2, a9b4325b5989aff3
    [junit] tag=5acc4, index=d7f, offset=13
    [junit] Test: DTLB, ffffffffdd96a061
    [junit] tag=7feecb5, index=0, offset=61
    [junit] Test: L1, fffffffff314dbb7
    [junit] tag=ff314d, index=5d, offset=17
    [junit] Test: L2, 64165f240b68c1e
    [junit] tag=1205b, index=460, offset=1e
    [junit] Test: DTLB, ffffffff8c047004
    [junit] tag=7fc6023, index=0, offset=1004
    [junit] Test: L1, 963c3b4f007e087b
    [junit] tag=f007e0, index=43, offset=1b
    [junit] Test: L2, f9ce86b60bcd0f26
    [junit] tag=305e6, index=879, offset=6
    [junit] Test: DTLB, ffffffffc45f14d4
    [junit] tag=7fe22f8, index=0, offset=14d4
    [junit] Test: L1, ffffffffe6a98fac
    [junit] tag=fe6a98, index=7d, offset=c
    [junit] Test: L2, ffffffffc2e90b5c
    [junit] tag=7e174, index=85a, offset=1c
    [junit] Test: DTLB, 7c5ce16521180f2c
    [junit] tag=32908c0, index=0, offset=f2c
    [junit] Test: L1, fc82dc1b54e3eb07
    [junit] tag=b54e3e, index=58, offset=7
    [junit] Test: L2, fffffffff9c7ef2d
    [junit] tag=7fce3, index=f79, offset=d
    [junit] Test: DTLB, 53445d261db6ca0e
    [junit] tag=130edb6, index=0, offset=a0e
    [junit] Test: L1, 7bafef650962ff29
    [junit] tag=50962f, index=79, offset=9
    [junit] Test: L2, a6ed89bb620c584b
    [junit] tag=5b106, index=2c2, offset=b
    [junit] Test: DTLB, ffffffffc3079710
    [junit] tag=7fe183c, index=0, offset=1710
    [junit] Test: L1, ffffffff8d3d7813
    [junit] tag=f8d3d7, index=40, offset=13
    [junit] Test: L2, ffffffffb1d79c34
    [junit] tag=7d8eb, index=ce1, offset=14
    [junit] Test: DTLB, ffffffffe0286878
    [junit] tag=7ff0143, index=0, offset=878
    [junit] Test: L1, ffffffffb88d8c91
    [junit] tag=fb88d8, index=64, offset=11
    [junit] Test: L2, 4f26c26951063c41
    [junit] tag=4a883, index=1e2, offset=1
    [junit] Test: DTLB, e1c104e3098a8df8
    [junit] tag=7184c54, index=0, offset=df8
    [junit] Test: L1, 5bd8da1a081454bd
    [junit] tag=a08145, index=25, offset=1d
    [junit] Test: L2, ffffffff8b573a18
    [junit] tag=7c5ab, index=9d0, offset=18
    [junit] Test: DTLB, ffffffff8c052ada
    [junit] tag=7fc6029, index=0, offset=ada
    [junit] Test: L1, c47a9b57c348654
    [junit] tag=57c348, index=32, offset=14
    [junit] Test: L2, 93b42cd5540098e
    [junit] tag=6aaa0, index=4c, offset=e
    [junit] Test: DTLB, ffffffffa04e9c6f
    [junit] tag=7fd0274, index=0, offset=1c6f
    [junit] Test: L1, 5fc8f1dc4e6295ad
    [junit] tag=c4e629, index=2d, offset=d
    [junit] Test: L2, ffffffffb8892189
    [junit] tag=7dc44, index=90c, offset=9
    [junit] Test: DTLB, 17347f317151d0c5
    [junit] tag=18b8a8e, index=0, offset=10c5
    [junit] Test: L1, 54e213fd168ff3a8
    [junit] tag=d168ff, index=1d, offset=8
    [junit] Test: L2, 53c0daef46c4935f
    [junit] tag=7a362, index=49a, offset=1f
    [junit] Test: DTLB, ffffffffab6052f7
    [junit] tag=7fd5b02, index=0, offset=12f7
    [junit] Test: L1, fffffffffe280151
    [junit] tag=ffe280, index=a, offset=11
    [junit] Test: L2, ffffffff93f19eab
    [junit] tag=7c9f8, index=cf5, offset=b
    [junit] Test: DTLB, e33e3c1e01b6b463
    [junit] tag=f00db5, index=0, offset=1463
    [junit] Test: L1, fffffffff856522f
    [junit] tag=ff8565, index=11, offset=f
    [junit] Test: L2, ffffffffffa731f4
    [junit] tag=7ffd3, index=98f, offset=14
    [junit] Test: DTLB, ffffffffff827884
    [junit] tag=7fffc13, index=0, offset=1884
    [junit] Test: L1, ffffffffea44d436
    [junit] tag=fea44d, index=21, offset=16
    [junit] Test: L2, ffffffff9e67e874
    [junit] tag=7cf33, index=f43, offset=14
    [junit] Test: DTLB, b32bdf681dfdbb52
    [junit] tag=340efed, index=0, offset=1b52
    [junit] Test: L1, ffffffff94e9233b
    [junit] tag=f94e92, index=19, offset=1b
    [junit] Test: L2, ffffffffcecff913
    [junit] tag=7e767, index=fc8, offset=13
    [junit] Test: DTLB, 986a98e4514d3f2e
    [junit] tag=7228a69, index=0, offset=1f2e
    [junit] Test: L1, ffffffffd6dee342
    [junit] tag=fd6dee, index=1a, offset=2
    [junit] Test: L2, ffffffffc232509f
    [junit] tag=7e119, index=284, offset=1f
    [junit] Test: DTLB, ffffffffe7fbb341
    [junit] tag=7ff3fdd, index=0, offset=1341
    [junit] Test: L1, d521c29810863c50
    [junit] tag=810863, index=62, offset=10
    [junit] Test: L2, ffffffff9cd1733a
    [junit] tag=7ce68, index=b99, offset=1a
    [junit] Test: DTLB, 8f84186d5e7128c2
    [junit] tag=36af389, index=0, offset=8c2
    [junit] Test: L1, 4ee730082583076e
    [junit] tag=825830, index=3b, offset=e
    [junit] Test: L2, 23f84f07313b7aa1
    [junit] tag=3989d, index=bd5, offset=1
    [junit] Test: DTLB, 9a84a365f8231bf
    [junit] tag=1b2fc11, index=0, offset=11bf
    [junit] Test: L1, fffffffff6e0b1c2
    [junit] tag=ff6e0b, index=e, offset=2
    [junit] Test: L2, fd5fb057299fb51e
    [junit] tag=394cf, index=da8, offset=1e
    [junit] Test: DTLB, 9120f8254a08bc7b
    [junit] tag=12a5045, index=0, offset=1c7b
    [junit] Test: L1, d2025f7103f8f64f
    [junit] tag=103f8f, index=32, offset=f
    [junit] Test: L2, aea7775917f30d6e
    [junit] tag=48bf9, index=86b, offset=e
    [junit] Test: DTLB, ffffffffc98e7d9a
    [junit] tag=7fe4c73, index=0, offset=1d9a
    [junit] Test: L1, f6009187538bbd1d
    [junit] tag=7538bb, index=68, offset=1d
    [junit] Test: L2, ffffffffc82356af
    [junit] tag=7e411, index=ab5, offset=f
    [junit] Test: DTLB, ffffffffb94ef4f4
    [junit] tag=7fdca77, index=0, offset=14f4
    [junit] Test: L1, c63c64ea31d95652
    [junit] tag=a31d95, index=32, offset=12
    [junit] Test: L2, d892eaf6441cf6bc
    [junit] tag=3220e, index=7b5, offset=1c
    [junit] Test: DTLB, 55d32eaa23b12ca8
    [junit] tag=5511d89, index=0, offset=ca8
    [junit] Test: L1, 649e10b334cadd90
    [junit] tag=334cad, index=6c, offset=10
    [junit] Test: L2, ffffffff82e54a51
    [junit] tag=7c172, index=a52, offset=11
    [junit] Test: DTLB, ffffffffef6018f3
    [junit] tag=7ff7b00, index=0, offset=18f3
    [junit] Test: L1, c5949827749e5314
    [junit] tag=7749e5, index=18, offset=14
    [junit] Test: L2, 67b4b25c358e4de4
    [junit] tag=61ac7, index=26f, offset=4
    [junit] Test: DTLB, ffffffffe1242422
    [junit] tag=7ff0921, index=0, offset=422
    [junit] Test: L1, fffffffff5b3b1a2
    [junit] tag=ff5b3b, index=d, offset=2
    [junit] Test: L2, ffffffff8404ed3c
    [junit] tag=7c202, index=769, offset=1c
    [junit] Test: DTLB, c78a689b3dc5756f
    [junit] tag=4d9ee2b, index=0, offset=156f
    [junit] Test: L1, ffffffffc74a0baa
    [junit] tag=fc74a0, index=5d, offset=a
    [junit] Test: L2, f82c316a1318b69c
    [junit] tag=5098c, index=5b4, offset=1c
    [junit] Test: DTLB, 4022189773f71535
    [junit] tag=4bb9fb8, index=0, offset=1535
    [junit] Test: L1, fffffffff7d8db9b
    [junit] tag=ff7d8d, index=5c, offset=1b
    [junit] Test: L2, c62e03e366db9dd0
    [junit] tag=1b36d, index=cee, offset=10
    [junit] Test: DTLB, 7a101ab2268863b9
    [junit] tag=5913443, index=0, offset=3b9
    [junit] Test: L1, 91329996486a7ce3
    [junit] tag=6486a7, index=67, offset=3
    [junit] Test: L2, ff15eebe2848176f
    [junit] tag=71424, index=bb, offset=f
    [junit] Test: DTLB, ce62591f12445c7b
    [junit] tag=f89222, index=0, offset=1c7b
    [junit] Test: L1, ffffffff89d6e11f
    [junit] tag=f89d6e, index=8, offset=1f
    [junit] Test: L2, 6fa6fc9233aa49d5
    [junit] tag=119d5, index=24e, offset=15
    [junit] Test: DTLB, ffffffffcd335821
    [junit] tag=7fe699a, index=0, offset=1821
    [junit] Test: L1, e2d3577d2ec689e9
    [junit] tag=d2ec68, index=4f, offset=9
    [junit] Test: L2, 9aa564a70c2dde05
    [junit] tag=38616, index=ef0, offset=5
    [junit] Test: DTLB, ffffffff97bf9c75
    [junit] tag=7fcbdfc, index=0, offset=1c75
    [junit] Test: L1, bc7af71919552281
    [junit] tag=919552, index=14, offset=1
    [junit] Test: L2, ffffffff9976920e
    [junit] tag=7ccbb, index=490, offset=e
    [junit] Test: DTLB, ffffffff92d9446e
    [junit] tag=7fc96ca, index=0, offset=46e
    [junit] Test: L1, 324c95122fc3dc56
    [junit] tag=22fc3d, index=62, offset=16
    [junit] Test: L2, ffffffffdba8fafc
    [junit] tag=7edd4, index=7d7, offset=1c
    [junit] Test: DTLB, ffffffff98fb7454
    [junit] tag=7fcc7db, index=0, offset=1454
    [junit] Test: L1, 83ee7cb333ef8976
    [junit] tag=333ef8, index=4b, offset=16
    [junit] Test: L2, ffffffffbbf7a8a9
    [junit] tag=7ddfb, index=d45, offset=9
    [junit] Test: DTLB, ffffffffedbf0a26
    [junit] tag=7ff6df8, index=0, offset=a26
    [junit] Test: L1, ffffffffd017f7c1
    [junit] tag=fd017f, index=3e, offset=1
    [junit] Test: L2, 40f1ce0c24d91860
    [junit] tag=6126c, index=8c3, offset=0
    [junit] Test: DTLB, ffffffffae32acaf
    [junit] tag=7fd7195, index=0, offset=caf
    [junit] Test: L1, 7f4b7e34229671a4
    [junit] tag=422967, index=d, offset=4
    [junit] Test: L2, adbef07f6136a75b
    [junit] tag=7b09b, index=53a, offset=1b
    [junit] Test: DTLB, efea9e9e559744a5
    [junit] tag=4f2acba, index=0, offset=4a5
    [junit] Test: L1, ffffffffab110cbb
    [junit] tag=fab110, index=65, offset=1b
    [junit] Test: L2, ffffffff9b7918fa
    [junit] tag=7cdbc, index=8c7, offset=1a
    [junit] Test: DTLB, ba22eda85169e25d
    [junit] tag=5428b4f, index=0, offset=25d
    [junit] Test: L1, 20a68ae7451b0f8f
    [junit] tag=7451b0, index=7c, offset=f
    [junit] Test: L2, ffffffffba21dd66
    [junit] tag=7dd10, index=eeb, offset=6
    [junit] Test: DTLB, 6a71f0410acf151
    [junit] tag=208567, index=0, offset=1151
    [junit] Test: L1, 1078cfad2b3d45a1
    [junit] tag=d2b3d4, index=2d, offset=1
    [junit] Test: L2, d8002913331edd72
    [junit] tag=1998f, index=6eb, offset=12
    [junit] Test: DTLB, 3f7e9e4f0d24ca3c
    [junit] tag=2786926, index=0, offset=a3c
    [junit] Test: L1, 4c7897d50579d9b1
    [junit] tag=50579d, index=4d, offset=11
    [junit] Test: L2, 5ae1d98b3bedb87a
    [junit] tag=59df6, index=dc3, offset=1a
    [junit] Test: DTLB, ffffffffdaf694eb
    [junit] tag=7fed7b4, index=0, offset=14eb
    [junit] Test: L1, ffffffffed28ebd4
    [junit] tag=fed28e, index=5e, offset=14
    [junit] Test: L2, ffffffffd8adb1a7
    [junit] tag=7ec56, index=d8d, offset=7
    [junit] Test: DTLB, ffffffffb8fc225f
    [junit] tag=7fdc7e1, index=0, offset=25f
    [junit] Test: L1, 9fbe46155b4bb579
    [junit] tag=55b4bb, index=2b, offset=19
    [junit] Test: L2, fffffffff42e2d1b
    [junit] tag=7fa17, index=168, offset=1b
    [junit] Test: DTLB, ffffffffdb33e608
    [junit] tag=7fed99f, index=0, offset=608
    [junit] Test: L1, ffffffffaeade16f
    [junit] tag=faeade, index=b, offset=f
    [junit] Test: L2, 2c26700435f633f0
    [junit] tag=21afb, index=19f, offset=10
    [junit] Test: DTLB, ffffffffe30a6a0c
    [junit] tag=7ff1853, index=0, offset=a0c
    [junit] Test: L1, 1326b3df19144be7
    [junit] tag=f19144, index=5f, offset=7
    [junit] Test: L2, 2ab989bc4acf83ce
    [junit] tag=62567, index=c1e, offset=e
    [junit] Test: DTLB, ffffffffc6b55164
    [junit] tag=7fe35aa, index=0, offset=1164
    [junit] Test: L1, 1465986a4ca274d8
    [junit] tag=a4ca27, index=26, offset=18
    [junit] Test: L2, ffffffffee0ea109
    [junit] tag=7f707, index=508, offset=9
    [junit] Test: DTLB, 749c6d0854e7f47c
    [junit] tag=42a73f, index=0, offset=147c
    [junit] Test: L1, 45d73eb214fb6dab
    [junit] tag=214fb6, index=6d, offset=b
    [junit] Test: L2, d2e50a042394d0e3
    [junit] tag=211ca, index=687, offset=3
    [junit] Test: DTLB, ffffffffdf16f050
    [junit] tag=7fef8b7, index=0, offset=1050
    [junit] Test: L1, ebc71bb57200e776
    [junit] tag=57200e, index=3b, offset=16
    [junit] Test: L2, ffffffffa581f674
    [junit] tag=7d2c0, index=fb3, offset=14
    [junit] Test: DTLB, ffffffffe0e983f0
    [junit] tag=7ff074c, index=0, offset=3f0
    [junit] Test: L1, 6073cd80792483d7
    [junit] tag=79248, index=1e, offset=17
    [junit] Test: L2, 7dff4c656fb4b5b0
    [junit] tag=2b7da, index=5ad, offset=10
    [junit] Test: DTLB, 52b3f149000acbab
    [junit] tag=2480056, index=0, offset=bab
    [junit] Test: L1, f3496e0a014d5ae5
    [junit] tag=a014d5, index=57, offset=5
    [junit] Test: L2, ffffffff8b669894
    [junit] tag=7c5b3, index=4c4, offset=14
    [junit] Test: DTLB, bb4e95760a1ca72b
    [junit] tag=3b050e5, index=0, offset=72b
    [junit] Test: L1, 90aea7b96ed27356
    [junit] tag=96ed27, index=1a, offset=16
    [junit] Test: L2, ffffffffd2255344
    [junit] tag=7e912, index=a9a, offset=4
    [junit] Test: DTLB, 765172983a70b1d5
    [junit] tag=4c1d385, index=0, offset=11d5
    [junit] Test: L1, ffffffffc1c9afeb
    [junit] tag=fc1c9a, index=7f, offset=b
    [junit] Test: L2, ffffffff90eefd55
    [junit] tag=7c877, index=7ea, offset=15
    [junit] Test: DTLB, b9e7931855958f5b
    [junit] tag=c2acac, index=0, offset=f5b
    [junit] Test: L1, 2887a0b8078ddcaf
    [junit] tag=8078dd, index=65, offset=f
    [junit] Test: L2, 8209b5145e7125dc
    [junit] tag=22f38, index=92e, offset=1c
    [junit] Test: DTLB, a0bb054815b3a45a
    [junit] tag=240ad9d, index=0, offset=45a
    [junit] Test: L1, 1047fc1611e056d4
    [junit] tag=611e05, index=36, offset=14
    [junit] Test: L2, e82aa085cb0e0d0
    [junit] tag=42e58, index=706, offset=10
    [junit] Test: DTLB, ae7ce9b70f8b9ea1
    [junit] tag=5b87c5c, index=0, offset=1ea1
    [junit] Test: L1, 5314f5b5515229d0
    [junit] tag=551522, index=4e, offset=10
    [junit] Test: L2, b2e39e63296ccc71
    [junit] tag=194b6, index=663, offset=11
    [junit] Test: DTLB, ffffffffab0c5fdd
    [junit] tag=7fd5862, index=0, offset=1fdd
    [junit] Test: L1, cddc2fa40739eea5
    [junit] tag=40739e, index=75, offset=5
    [junit] Test: L2, ffffffffa3d5f6f9
    [junit] tag=7d1ea, index=fb7, offset=19
    [junit] Test: DTLB, fffffffffc298928
    [junit] tag=7ffe14c, index=0, offset=928
    [junit] Test: L1, ffffffffeb453cc4
    [junit] tag=feb453, index=66, offset=4
    [junit] Test: L2, d0780c220b06b463
    [junit] tag=10583, index=5a3, offset=3
    [junit] Test: DTLB, ffffffffaf5b7e47
    [junit] tag=7fd7adb, index=0, offset=1e47
    [junit] Test: L1, f129c8dd515330db
    [junit] tag=d51533, index=6, offset=1b
    [junit] Test: L2, ffffffffdaba9455
    [junit] tag=7ed5d, index=4a2, offset=15
    [junit] Test: DTLB, 303183e350175716
    [junit] tag=71a80ba, index=0, offset=1716
    [junit] Test: L1, 711bce1f40e5357a
    [junit] tag=f40e53, index=2b, offset=1a
    [junit] Test: L2, 7619384c62cde1b7
    [junit] tag=63166, index=f0d, offset=17
    [junit] Test: DTLB, fb1dd9e56e432506
    [junit] tag=72b7219, index=0, offset=506
    [junit] Test: L1, ffffffff988eb74a
    [junit] tag=f988eb, index=3a, offset=a
    [junit] Test: L2, fb9f9d7d6e5390b1
    [junit] tag=6b729, index=c85, offset=11
    [junit] Test: DTLB, 5820315b73e8cef7
    [junit] tag=2db9f46, index=0, offset=ef7
    [junit] Test: L1, ffffffffb895fab4
    [junit] tag=fb895f, index=55, offset=14
    [junit] Test: L2, f1477d556cf64e7f
    [junit] tag=2b67b, index=273, offset=1f
    [junit] Test: DTLB, 77c828690d13dcb7
    [junit] tag=348689e, index=0, offset=1cb7
    [junit] Test: L1, fa7b0a46852f3c7
    [junit] tag=46852f, index=1e, offset=7
    [junit] Test: L2, 8f269282454768a8
    [junit] tag=122a3, index=b45, offset=8
    [junit] Test: DTLB, ffffffffd0dc7c62
    [junit] tag=7fe86e3, index=0, offset=1c62
    [junit] Test: L1, dba876e550623b4b
    [junit] tag=550623, index=5a, offset=b
    [junit] Test: L2, 6249ab87254c3de3
    [junit] tag=392a6, index=1ef, offset=3
    [junit] Test: DTLB, ffffffffd83a1e91
    [junit] tag=7fec1d0, index=0, offset=1e91
    [junit] Test: L1, d74df4d366964c36
    [junit] tag=366964, index=61, offset=16
    [junit] Test: L2, 25bb662d08743f30
    [junit] tag=6843a, index=1f9, offset=10
    [junit] Test: DTLB, ffffffffc3c5cd40
    [junit] tag=7fe1e2e, index=0, offset=d40
    [junit] Test: L1, ffffffffc47614df
    [junit] tag=fc4761, index=26, offset=1f
    [junit] Test: L2, ffffffffe4719555
    [junit] tag=7f238, index=caa, offset=15
    [junit] Test: DTLB, ffffffff8fd45dfa
    [junit] tag=7fc7ea2, index=0, offset=1dfa
    [junit] Test: L1, ffffffffdcca2e16
    [junit] tag=fdcca2, index=70, offset=16
    [junit] Test: L2, ffffffff95cb3f86
    [junit] tag=7cae5, index=9fc, offset=6
    [junit] Test: DTLB, 530db6363fbe4845
    [junit] tag=1b1fdf2, index=0, offset=845
    [junit] Test: L1, ffffffff86cb202c
    [junit] tag=f86cb2, index=1, offset=c
    [junit] Test: L2, ffffffffec1bf5d6
    [junit] tag=7f60d, index=fae, offset=16
    [junit] Test: DTLB, ffffffff987e8290
    [junit] tag=7fcc3f4, index=0, offset=290
    [junit] Test: L1, ffffffffcb6d1e05
    [junit] tag=fcb6d1, index=70, offset=5
    [junit] Test: L2, ffffffffbaa5fa9b
    [junit] tag=7dd52, index=fd4, offset=1b
    [junit] Test: DTLB, ffffffff9458335c
    [junit] tag=7fca2c1, index=0, offset=135c
    [junit] Test: L1, 84c74e2e39738245
    [junit] tag=e39738, index=12, offset=5
    [junit] Test: L2, ffffffffc8ed27e6
    [junit] tag=7e476, index=93f, offset=6
    [junit] Test: DTLB, 446726a6254ca361
    [junit] tag=5312a65, index=0, offset=361
    [junit] Test: L1, ffffffffdef22c9d
    [junit] tag=fdef22, index=64, offset=1d
    [junit] Test: L2, ffffffffe47c39ce
    [junit] tag=7f23e, index=1ce, offset=e
    [junit] Test: DTLB, ffffffffb78ed0e2
    [junit] tag=7fdbc76, index=0, offset=10e2
    [junit] Test: L1, ffffffff80fb5048
    [junit] tag=f80fb5, index=2, offset=8
    [junit] Test: L2, ffffffffb3146edc
    [junit] tag=7d98a, index=376, offset=1c
    [junit] Test: DTLB, fffffffff1942ca3
    [junit] tag=7ff8ca1, index=0, offset=ca3
    [junit] Test: L1, 54f9ab5e173547ae
    [junit] tag=e17354, index=3d, offset=e
    [junit] Test: L2, ffffffffd5bb8c32
    [junit] tag=7eadd, index=c61, offset=12
    [junit] Test: DTLB, ffffffffc4055d59
    [junit] tag=7fe202a, index=0, offset=1d59
    [junit] Test: L1, 45332f4b14d59a1c
    [junit] tag=b14d59, index=50, offset=1c
    [junit] Test: L2, 9a5bf019222c4056
    [junit] tag=49116, index=202, offset=16
    [junit] Test: DTLB, fffffffff6e9f689
    [junit] tag=7ffb74f, index=0, offset=1689
    [junit] Test: L1, ffffffffd6367765
    [junit] tag=fd6367, index=3b, offset=5
    [junit] Test: L2, ffffffffcb5a2cb0
    [junit] tag=7e5ad, index=165, offset=10
    [junit] Test: DTLB, ffffffffe33b1973
    [junit] tag=7ff19d8, index=0, offset=1973
    [junit] Test: L1, 7600a54f026e084f
    [junit] tag=f026e0, index=42, offset=f
    [junit] Test: L2, ffffffffe6b204fe
    [junit] tag=7f359, index=27, offset=1e
    [junit] Test: DTLB, ffffffffe59b8679
    [junit] tag=7ff2cdc, index=0, offset=679
    [junit] Test: L1, 80b967036b75291d
    [junit] tag=36b752, index=48, offset=1d
    [junit] Test: L2, 4c0920f17dbf4ccc
    [junit] tag=bedf, index=a66, offset=c
    [junit] Test: DTLB, f0e5f2034d08112a
    [junit] tag=1a6840, index=0, offset=112a
    [junit] Test: L1, ffffffffb2ffc905
    [junit] tag=fb2ffc, index=48, offset=5
    [junit] Test: L2, 54edda32444e6f2c
    [junit] tag=12227, index=379, offset=c
    [junit] Test: DTLB, 853419451d26296f
    [junit] tag=228e931, index=0, offset=96f
    [junit] Test: L1, c1f050363e8ee5d7
    [junit] tag=63e8ee, index=2e, offset=17
    [junit] Test: L2, 21536cce279fc8cf
    [junit] tag=713cf, index=e46, offset=f
    [junit] Test: DTLB, ffffffffbf847651
    [junit] tag=7fdfc23, index=0, offset=1651
    [junit] Test: L1, bcb51af475cefb3d
    [junit] tag=475cef, index=59, offset=1d
    [junit] Test: L2, ffffffffbb4db557
    [junit] tag=7dda6, index=daa, offset=17
    [junit] Test: DTLB, 742f26f907d58e4e
    [junit] tag=7c83eac, index=0, offset=e4e
    [junit] Test: L1, ffffffffca19d90e
    [junit] tag=fca19d, index=48, offset=e
    [junit] Test: L2, ffffffffed266c29
    [junit] tag=7f693, index=361, offset=9
    [junit] Test: DTLB, 475050ce09503b33
    [junit] tag=6704a81, index=0, offset=1b33
    [junit] Test: L1, 1cca8a4e1ff9f1c3
    [junit] tag=e1ff9f, index=e, offset=3
    [junit] Test: L2, ffffffff890d6949
    [junit] tag=7c486, index=b4a, offset=9
    [junit] Test: DTLB, ffffffff8f20ddd4
    [junit] tag=7fc7906, index=0, offset=1dd4
    [junit] Test: L1, 56cff1e309b328a
    [junit] tag=e309b3, index=14, offset=a
    [junit] Test: L2, ffffffffbd338828
    [junit] tag=7de99, index=c41, offset=8
    [junit] Test: DTLB, bfe6832d55d36ee7
    [junit] tag=16aae9b, index=0, offset=ee7
    [junit] Test: L1, 87a36b8c6b318886
    [junit] tag=c6b318, index=44, offset=6
    [junit] Test: L2, ffffffffb69d2d68
    [junit] tag=7db4e, index=96b, offset=8
    [junit] Test: DTLB, e1f503a80ba2657f
    [junit] tag=5405d13, index=0, offset=57f
    [junit] Test: L1, f7ce6ab454181ac1
    [junit] tag=454181, index=56, offset=1
    [junit] Test: L2, fffffffff1fb9697
    [junit] tag=7f8fd, index=cb4, offset=17
    [junit] Test: DTLB, ffffffffd8a3223d
    [junit] tag=7fec519, index=0, offset=23d
    [junit] Test: L1, ffffffffba2251c6
    [junit] tag=fba225, index=e, offset=6
    [junit] Test: L2, ffffffffdd045e5a
    [junit] tag=7ee82, index=2f2, offset=1a
    [junit] Test: DTLB, 2ca9588f6944c3cf
    [junit] tag=47b4a26, index=0, offset=3cf
    [junit] Test: L1, ffffffffd5d68c5d
    [junit] tag=fd5d68, index=62, offset=1d
    [junit] Test: L2, ffffffffc9a9c27e
    [junit] tag=7e4d4, index=e13, offset=1e
    [junit] Test: DTLB, ffffffffce892f63
    [junit] tag=7fe7449, index=0, offset=f63
    [junit] Test: L1, ffffffffb4bfc9cc
    [junit] tag=fb4bfc, index=4e, offset=c
    [junit] Test: L2, fffffffff7febf79
    [junit] tag=7fbff, index=5fb, offset=19
    [junit] Test: DTLB, 546b6b7476d2256
    [junit] tag=5ba3b69, index=0, offset=256
    [junit] Test: L1, ffffffffc1d5302d
    [junit] tag=fc1d53, index=1, offset=d
    [junit] Test: L2, 7f4eb5f85ea254b2
    [junit] tag=42f51, index=2a5, offset=12
    [junit] Test: DTLB, cc202e5b44820002
    [junit] tag=2da2410, index=0, offset=2
    [junit] Test: L1, ffffffffacd5fea6
    [junit] tag=facd5f, index=75, offset=6
    [junit] Test: L2, ffffffffa19629ef
    [junit] tag=7d0cb, index=14f, offset=f
    [junit] Test: DTLB, 3ec52db71d8c709d
    [junit] tag=5b8ec63, index=0, offset=109d
    [junit] Test: L1, ffffffffc8a00383
    [junit] tag=fc8a00, index=1c, offset=3
    [junit] Test: L2, ffffffff855dd07d
    [junit] tag=7c2ae, index=e83, offset=1d
    [junit] Test: DTLB, 398775f21de360f6
    [junit] tag=790ef1b, index=0, offset=f6
    [junit] Test: L1, d8a3d03f2bceedea
    [junit] tag=f2bcee, index=6f, offset=a
    [junit] Test: L2, ffffffffe031d5b7
    [junit] tag=7f018, index=ead, offset=17
    [junit] Test: DTLB, 8010c6f62744ff0b
    [junit] tag=7b13a27, index=0, offset=1f0b
    [junit] Test: L1, ffffffffc1f5d461
    [junit] tag=fc1f5d, index=23, offset=1
    [junit] Test: L2, f25374221cd34af6
    [junit] tag=10e69, index=a57, offset=16
    [junit] Test: DTLB, ffffffffa569067a
    [junit] tag=7fd2b48, index=0, offset=67a
    [junit] Test: L1, 1fa3e048149175fe
    [junit] tag=814917, index=2f, offset=1e
    [junit] Test: L2, ffffffff93f7f6d6
    [junit] tag=7c9fb, index=fb6, offset=16
    [junit] Test: DTLB, 6ea86ce71726c90
    [junit] tag=6738b93, index=0, offset=c90
    [junit] Test: L1, a4cde93b21d17d0a
    [junit] tag=b21d17, index=68, offset=a
    [junit] Test: L2, ffffffff9a7e1819
    [junit] tag=7cd3f, index=c0, offset=19
    [junit] Test: DTLB, ffffffffe909df80
    [junit] tag=7ff484e, index=0, offset=1f80
    [junit] Test: L1, 2cff2e33ccf799
    [junit] tag=e33ccf, index=3c, offset=19
    [junit] Test: L2, 8fa9bd32036c23e9
    [junit] tag=101b6, index=11f, offset=9
    [junit] Test: DTLB, 4a8883747ecf93cc
    [junit] tag=3a3f67c, index=0, offset=13cc
    [junit] Test: L1, ffffffffa76a5654
    [junit] tag=fa76a5, index=32, offset=14
    [junit] Test: L2, 3b947c911d8b86e1
    [junit] tag=8ec5, index=c37, offset=1
    [junit] Test: DTLB, ffffffffea9d4f3c
    [junit] tag=7ff54ea, index=0, offset=f3c
    [junit] Test: L1, 580581ba51b56b42
    [junit] tag=a51b56, index=5a, offset=2
    [junit] Test: L2, ffffffffd3513a9d
    [junit] tag=7e9a8, index=9d4, offset=1d
    [junit] Test: DTLB, 65bd71537f3e516f
    [junit] tag=29bf9f2, index=0, offset=116f
    [junit] Test: L1, e9703b750d53edf7
    [junit] tag=50d53e, index=6f, offset=17
    [junit] Test: L2, ffffffff8c710987
    [junit] tag=7c638, index=84c, offset=7
    [junit] Test: DTLB, ffffffffa1b48dcf
    [junit] tag=7fd0da4, index=0, offset=dcf
    [junit] Test: L1, 15f866ce4838429b
    [junit] tag=e48384, index=14, offset=1b
    [junit] Test: L2, 7c589cb104a2ba39
    [junit] tag=8251, index=5d1, offset=19
    [junit] Test: DTLB, 4bced3f1314761ba
    [junit] tag=7898a3b, index=0, offset=1ba
    [junit] Test: L1, ffffffff9ebf8207
    [junit] tag=f9ebf8, index=10, offset=7
    [junit] Test: L2, efa5882b67a4821e
    [junit] tag=5b3d2, index=410, offset=1e
    [junit] Test: DTLB, ffffffff95fa15ba
    [junit] tag=7fcafd0, index=0, offset=15ba
    [junit] Test: L1, ffffffffa399df81
    [junit] tag=fa399d, index=7c, offset=1
    [junit] Test: L2, ffffffffad8231a7
    [junit] tag=7d6c1, index=18d, offset=7
    [junit] Test: DTLB, ffffffffb84b7c7d
    [junit] tag=7fdc25b, index=0, offset=1c7d
    [junit] Test: L1, b7eeebfa2e57f39e
    [junit] tag=a2e57f, index=1c, offset=1e
    [junit] Test: L2, 1c87226217140166
    [junit] tag=10b8a, index=b, offset=6
    [junit] Test: DTLB, 9df2b6c6a3b08fd
    [junit] tag=36351d8, index=0, offset=8fd
    [junit] Test: L1, ffffffffbc0da9c6
    [junit] tag=fbc0da, index=4e, offset=6
    [junit] Test: L2, a42b92ff10df056f
    [junit] tag=7886f, index=82b, offset=f
    [junit] Test: DTLB, 258f648a14c780de
    [junit] tag=450a63c, index=0, offset=de
    [junit] Test: L1, ffffffff9b7375e8
    [junit] tag=f9b737, index=2f, offset=8
    [junit] Test: L2, 93b676cc271c3cd8
    [junit] tag=6138e, index=1e6, offset=18
    [junit] Test: DTLB, b108569a7732f1a6
    [junit] tag=4d3b997, index=0, offset=11a6
    [junit] Test: L1, ffffffffc40b6363
    [junit] tag=fc40b6, index=1b, offset=3
    [junit] Test: L2, 3adc05e469ef8a1c
    [junit] tag=234f7, index=c50, offset=1c
    [junit] Test: DTLB, fffffffff81698cc
    [junit] tag=7ffc0b4, index=0, offset=18cc
    [junit] Test: L1, b8cc24b6362d9118
    [junit] tag=6362d9, index=8, offset=18
    [junit] Test: L2, b430bea06764eb36
    [junit] tag=33b2, index=759, offset=16
    [junit] Test: DTLB, fffffffffa41cb60
    [junit] tag=7ffd20e, index=0, offset=b60
    [junit] Test: L1, d7a76e414fb7902b
    [junit] tag=14fb79, index=1, offset=b
    [junit] Test: L2, ffffffff87ed0d93
    [junit] tag=7c3f6, index=86c, offset=13
    [junit] Test: DTLB, a102bc1d1eae1941
    [junit] tag=e8f570, index=0, offset=1941
    [junit] Test: L1, 7eab4e0b6446fc26
    [junit] tag=b6446f, index=61, offset=6
    [junit] Test: L2, ffffffffaab79be9
    [junit] tag=7d55b, index=cdf, offset=9
    [junit] Test: DTLB, ffffffff8ac31d2e
    [junit] tag=7fc5618, index=0, offset=1d2e
    [junit] Test: L1, f2d7fe070a03907f
    [junit] tag=70a039, index=3, offset=1f
    [junit] Test: L2, ffffffffc5993666
    [junit] tag=7e2cc, index=9b3, offset=6
    [junit] Test: DTLB, 3fb78e8328028f89
    [junit] tag=4194014, index=0, offset=f89
    [junit] Test: L1, ffffffff977d9788
    [junit] tag=f977d9, index=3c, offset=8
    [junit] Test: L2, ffffffff85e2e066
    [junit] tag=7c2f1, index=703, offset=6
    [junit] Test: DTLB, 340ea39c3a6bdc9c
    [junit] tag=4e1d35e, index=0, offset=1c9c
    [junit] Test: L1, dc93edad1784f8b1
    [junit] tag=d1784f, index=45, offset=11
    [junit] Test: L2, c33e6a5874683f55
    [junit] tag=43a34, index=1fa, offset=15
    [junit] Test: DTLB, f01ded270e8d6cdd
    [junit] tag=138746b, index=0, offset=cdd
    [junit] Test: L1, e194d38322eed30c
    [junit] tag=322eed, index=18, offset=c
    [junit] Test: L2, ffffffffcb9be68c
    [junit] tag=7e5cd, index=f34, offset=c
    [junit] Test: DTLB, e47b350a7e524778
    [junit] tag=53f292, index=0, offset=778
    [junit] Test: L1, ffffffffd71e3716
    [junit] tag=fd71e3, index=38, offset=16
    [junit] Test: L2, ea6b11da7513ac66
    [junit] tag=53a89, index=d63, offset=6
    [junit] Test: DTLB, ffffffff8b06e733
    [junit] tag=7fc5837, index=0, offset=733
    [junit] Test: L1, ffffffffd122ccd5
    [junit] tag=fd122c, index=66, offset=15
    [junit] Test: L2, 7f473c0034c25c01
    [junit] tag=1a61, index=2e0, offset=1
    [junit] Test: DTLB, 3430f8bb4c146b09
    [junit] tag=5da60a3, index=0, offset=b09
    [junit] Test: L1, ffffffffcd3b9c7b
    [junit] tag=fcd3b9, index=63, offset=1b
    [junit] Test: L2, d340897f20987fb4
    [junit] tag=7904c, index=3fd, offset=14
    [junit] Test: DTLB, ffffffff9c0b7386
    [junit] tag=7fce05b, index=0, offset=1386
    [junit] Test: L1, eddc87a332966145
    [junit] tag=332966, index=a, offset=5
    [junit] Test: L2, ffffffffedf247e9
    [junit] tag=7f6f9, index=23f, offset=9
    [junit] Test: DTLB, ec10078547df955c
    [junit] tag=42a3efc, index=0, offset=155c
    [junit] Test: L1, ffffffff94619115
    [junit] tag=f94619, index=8, offset=15
    [junit] Test: L2, 92e05ae836edfc70
    [junit] tag=41b76, index=fe3, offset=10
    [junit] Test: DTLB, 525f07a34ebbb34e
    [junit] tag=51a75dd, index=0, offset=134e
    [junit] Test: L1, ffffffffe7920eff
    [junit] tag=fe7920, index=77, offset=1f
    [junit] Test: L2, ffffffff9cf0baa3
    [junit] tag=7ce78, index=5d5, offset=3
    [junit] Test: DTLB, ffffffffa8617d88
    [junit] tag=7fd430b, index=0, offset=1d88
    [junit] Test: L1, fffffffff78a9deb
    [junit] tag=ff78a9, index=6f, offset=b
    [junit] Test: L2, ffffffffb7511ead
    [junit] tag=7dba8, index=8f5, offset=d
    [junit] Test: DTLB, dc9fdb865835b701
    [junit] tag=432c1ad, index=0, offset=1701
    [junit] Test: L1, ffffffffe7ec4a26
    [junit] tag=fe7ec4, index=51, offset=6
    [junit] Test: L2, 486ba6811a4ec51
    [junit] tag=408d2, index=762, offset=11
    [junit] Test: DTLB, 71c7e65235fd1b83
    [junit] tag=291afe8, index=0, offset=1b83
    [junit] Test: L1, fffffffff7eec4f0
    [junit] tag=ff7eec, index=27, offset=10
    [junit] Test: L2, b7f10fdc46c5d581
    [junit] tag=62362, index=eac, offset=1
    [junit] Test: DTLB, 99c37e3262bf845c
    [junit] tag=19315fc, index=0, offset=45c
    [junit] Test: L1, d49b21771b80af34
    [junit] tag=71b80a, index=79, offset=14
    [junit] Test: L2, ffffffff928a9ced
    [junit] tag=7c945, index=4e7, offset=d
    [junit] Test: DTLB, 2ba9ee9f60558df2
    [junit] tag=4fb02ac, index=0, offset=df2
    [junit] Test: L1, ffffffffc3d6acc4
    [junit] tag=fc3d6a, index=66, offset=4
    [junit] Test: L2, dd157dac06125dfc
    [junit] tag=60309, index=2ef, offset=1c
    [junit] Test: DTLB, ffffffff9c06bd88
    [junit] tag=7fce035, index=0, offset=1d88
    [junit] Test: L1, bf5755f077403dc6
    [junit] tag=77403, index=6e, offset=6
    [junit] Test: L2, c9f256c27dac2490
    [junit] tag=13ed6, index=124, offset=10
    [junit] Test: DTLB, b0f1875e0442b3ab
    [junit] tag=2f02215, index=0, offset=13ab
    [junit] Test: L1, fffffffff9cdc0d2
    [junit] tag=ff9cdc, index=6, offset=12
    [junit] Test: L2, 6c27367167585f78
    [junit] tag=b3ac, index=2fb, offset=18
    [junit] Test: DTLB, ffffffff9fa1b959
    [junit] tag=7fcfd0d, index=0, offset=1959
    [junit] Test: L1, 68ba9c1b1edbafe1
    [junit] tag=b1edba, index=7f, offset=1
    [junit] Test: L2, ffffffffff16f71d
    [junit] tag=7ff8b, index=7b8, offset=1d
    [junit] Test: DTLB, ffffffffd6f885dc
    [junit] tag=7feb7c4, index=0, offset=5dc
    [junit] Test: L1, 93d2323f735d01b0
    [junit] tag=f735d0, index=d, offset=10
    [junit] Test: L2, d56160ab013f024a
    [junit] tag=5809f, index=812, offset=a
    [junit] Test: DTLB, ffffffffbc90fe15
    [junit] tag=7fde487, index=0, offset=1e15
    [junit] Test: L1, ffffffffa1a1492c
    [junit] tag=fa1a14, index=49, offset=c
    [junit] Test: L2, ffffffffe9df15df
    [junit] tag=7f4ef, index=8ae, offset=1f
    [junit] Test: DTLB, ffffffffe92a972c
    [junit] tag=7ff4954, index=0, offset=172c
    [junit] Test: L1, ffffffffd5bef159
    [junit] tag=fd5bef, index=a, offset=19
    [junit] Test: L2, ffffffffbe5259e3
    [junit] tag=7df29, index=2cf, offset=3
    [junit] Test: DTLB, adf5d3c40e79a4bf
    [junit] tag=62073cd, index=0, offset=4bf
    [junit] Test: L1, b5307e96489efa96
    [junit] tag=6489ef, index=54, offset=16
    [junit] Test: L2, ffffffff87862741
    [junit] tag=7c3c3, index=13a, offset=1
    [junit] Test: DTLB, ed49c50b4abaa402
    [junit] tag=5a55d5, index=0, offset=402
    [junit] Test: L1, ffffffffdbc1e007
    [junit] tag=fdbc1e, index=0, offset=7
    [junit] Test: L2, fffffffffaa3a53e
    [junit] tag=7fd51, index=d29, offset=1e
    [junit] Test: DTLB, 863419874e38cc84
    [junit] tag=43a71c6, index=0, offset=c84
    [junit] Test: L1, ffffffff9708243c
    [junit] tag=f97082, index=21, offset=1c
    [junit] Test: L2, ffffffffc2244bee
    [junit] tag=7e112, index=25f, offset=e
    [junit] Test: DTLB, ffffffffaef1c9b3
    [junit] tag=7fd778e, index=0, offset=9b3
    [junit] Test: L1, be3d50e054144c58
    [junit] tag=54144, index=62, offset=18
    [junit] Test: L2, f33d94d465a4b0ed
    [junit] tag=232d2, index=587, offset=d
    [junit] Test: DTLB, fffffffffa772c58
    [junit] tag=7ffd3b9, index=0, offset=c58
    [junit] Test: L1, 69d2bb1c2becd991
    [junit] tag=c2becd, index=4c, offset=11
    [junit] Test: L2, 7dbf4bf622bf1d36
    [junit] tag=3115f, index=8e9, offset=16
    [junit] Test: DTLB, 89f7760f1d783c69
    [junit] tag=78ebc1, index=0, offset=1c69
    [junit] Test: L1, 788ceaf46338bcea
    [junit] tag=46338b, index=67, offset=a
    [junit] Test: L2, 48e8e89f7b4dffa3
    [junit] tag=7bda6, index=ffd, offset=3
    [junit] Test: DTLB, ffffffff92f2e11a
    [junit] tag=7fc9797, index=0, offset=11a
    [junit] Test: L1, c782eff102aa127f
    [junit] tag=102aa1, index=13, offset=1f
    [junit] Test: L2, 8c5457581287b8c5
    [junit] tag=40943, index=dc6, offset=5
    [junit] Test: DTLB, 73036bd44d8e57a8
    [junit] tag=6a26c72, index=0, offset=17a8
    [junit] Test: L1, fffffffff4d81f23
    [junit] tag=ff4d81, index=79, offset=3
    [junit] Test: L2, ffffffffeb9001c2
    [junit] tag=7f5c8, index=e, offset=2
    [junit] Test: DTLB, ffffffffef97b6ae
    [junit] tag=7ff7cbd, index=0, offset=16ae
    [junit] Test: L1, ffffffffc52964e9
    [junit] tag=fc5296, index=27, offset=9
    [junit] Test: L2, ffffffffa5c87444
    [junit] tag=7d2e4, index=3a2, offset=4
    [junit] Test: DTLB, ffffffff8e75a07d
    [junit] tag=7fc73ad, index=0, offset=7d
    [junit] Test: L1, 2e2441b63878be53
    [junit] tag=63878b, index=72, offset=13
    [junit] Test: L2, fffffffffb1ebec7
    [junit] tag=7fd8f, index=5f6, offset=7
    [junit] Test: DTLB, 9ec7c1e95e08e431
    [junit] tag=74af047, index=0, offset=431
    [junit] Test: L1, ffffffffb244859d
    [junit] tag=fb2448, index=2c, offset=1d
    [junit] Test: L2, 4115b3db209a61d3
    [junit] tag=5904d, index=30e, offset=13
    [junit] Test: DTLB, ffffffffc9d5e1f7
    [junit] tag=7fe4eaf, index=0, offset=1f7
    [junit] Test: L1, cf8473110772b5a4
    [junit] tag=10772b, index=2d, offset=4
    [junit] Test: L2, 60bf66643d8b53ee
    [junit] tag=21ec5, index=a9f, offset=e
    [junit] Test: DTLB, d8434d1c68ca3eb8
    [junit] tag=e34651, index=0, offset=1eb8
    [junit] Test: L1, 33f514eb77e495c9
    [junit] tag=b77e49, index=2e, offset=9
    [junit] Test: L2, cc158eb33943e918
    [junit] tag=19ca1, index=f48, offset=18
    [junit] Test: DTLB, ffffffffb3a33870
    [junit] tag=7fd9d19, index=0, offset=1870
    [junit] Test: L1, ffffffffb19b756f
    [junit] tag=fb19b7, index=2b, offset=f
    [junit] Test: L2, 2b2acc9a765e88ed
    [junit] tag=53b2f, index=447, offset=d
    [junit] Test: DTLB, ffffffffa6774a20
    [junit] tag=7fd33ba, index=0, offset=a20
    [junit] Test: L1, 88a475e82ec3a2d9
    [junit] tag=82ec3a, index=16, offset=19
    [junit] Test: L2, e21300ec6f8248c1
    [junit] tag=637c1, index=246, offset=1
    [junit] Test: DTLB, fffffffffc354a3e
    [junit] tag=7ffe1aa, index=0, offset=a3e
    [junit] Test: L1, ffffffffc8ddb62c
    [junit] tag=fc8ddb, index=31, offset=c
    [junit] Test: L2, a7c8901672efe3a2
    [junit] tag=33977, index=f1d, offset=2
    [junit] Test: DTLB, ffffffff9fff204c
    [junit] tag=7fcfff9, index=0, offset=4c
    [junit] Test: L1, fffffffff5303c5a
    [junit] tag=ff5303, index=62, offset=1a
    [junit] Test: L2, f0b688f6553ba177
    [junit] tag=32a9d, index=d0b, offset=17
    [junit] Test: DTLB, 22f4644c4dda6331
    [junit] tag=2626ed3, index=0, offset=331
    [junit] Test: L1, ffffffffc49bb3b7
    [junit] tag=fc49bb, index=1d, offset=17
    [junit] Test: L2, ffffffffae50b157
    [junit] tag=7d728, index=58a, offset=17
    [junit] Test: DTLB, f99c554203a9875d
    [junit] tag=2101d4c, index=0, offset=75d
    [junit] Test: L1, 16b21d8c7864e48b
    [junit] tag=c7864e, index=24, offset=b
    [junit] Test: L2, 3a0dbe8378003cba
    [junit] tag=1bc00, index=1e5, offset=1a
    [junit] Test: DTLB, ffffffff9fde842f
    [junit] tag=7fcfef4, index=0, offset=42f
    [junit] Test: L1, 1ca1520c55634e43
    [junit] tag=c55634, index=72, offset=3
    [junit] Test: L2, 110bf4e777b1d76d
    [junit] tag=3bbd8, index=ebb, offset=d
    [junit] Test: DTLB, 94f74a072fbed11e
    [junit] tag=397df6, index=0, offset=111e
    [junit] Test: L1, 77edb68578dcaf77
    [junit] tag=578dca, index=7b, offset=17
    [junit] Test: L2, fdc30ad1747341cb
    [junit] tag=ba39, index=a0e, offset=b
    [junit] Test: DTLB, ffffffffaa38ea25
    [junit] tag=7fd51c7, index=0, offset=a25
    [junit] Test: L1, ffffffffe9618532
    [junit] tag=fe9618, index=29, offset=12
    [junit] Test: L2, ffffffffba275be2
    [junit] tag=7dd13, index=adf, offset=2
    [junit] Test: DTLB, 23ae67b50a6ca478
    [junit] tag=5a85365, index=0, offset=478
    [junit] Test: L1, ffffffff9500f8ed
    [junit] tag=f9500f, index=47, offset=d
    [junit] Test: L2, ffffffffa125af1f
    [junit] tag=7d092, index=d78, offset=1f
    [junit] Test: DTLB, ffffffffd236c5a5
    [junit] tag=7fe91b6, index=0, offset=5a5
    [junit] Test: L1, f556183b7c4ed17a
    [junit] tag=b7c4ed, index=b, offset=1a
    [junit] Test: L2, 8b77b39c4d9d5a71
    [junit] tag=626ce, index=ad3, offset=11
    [junit] Test: DTLB, d45982c4022bef7b
    [junit] tag=620115f, index=0, offset=f7b
    [junit] Test: L1, 443abcc3336bbf11
    [junit] tag=3336bb, index=78, offset=11
    [junit] Test: L2, 2c9dc0ad1b6cf0d9
    [junit] tag=68db6, index=786, offset=19
    [junit] Test: DTLB, de7dc9d871c353b5
    [junit] tag=6c38e1a, index=0, offset=13b5
    [junit] Test: L1, c041800448b171e0
    [junit] tag=448b17, index=f, offset=0
    [junit] Test: L2, ffffffffbaeef313
    [junit] tag=7dd77, index=798, offset=13
    [junit] Test: DTLB, ffffffffd571c824
    [junit] tag=7feab8e, index=0, offset=824
    [junit] Test: L1, ffffffffd2f0a1a5
    [junit] tag=fd2f0a, index=d, offset=5
    [junit] Test: L2, d10d74c11532d646
    [junit] tag=8a99, index=6b2, offset=6
    [junit] Test: DTLB, d9c5b1a30e5a8bfe
    [junit] tag=51872d4, index=0, offset=bfe
    [junit] Test: L1, f5959698425347ea
    [junit] tag=842534, index=3f, offset=a
    [junit] Test: L2, 6cf012e2579218dc
    [junit] tag=12bc9, index=c6, offset=1c
    [junit] Test: DTLB, ffffffffa93671b2
    [junit] tag=7fd49b3, index=0, offset=11b2
    [junit] Test: L1, ffffffff9d08a91d
    [junit] tag=f9d08a, index=48, offset=1d
    [junit] Test: L2, fffffffffc20ed94
    [junit] tag=7fe10, index=76c, offset=14
    [junit] Test: DTLB, 97a7b24d5c2bee7f
    [junit] tag=26ae15f, index=0, offset=e7f
    [junit] Test: L1, 27eaf77620cc0a25
    [junit] tag=620cc0, index=51, offset=5
    [junit] Test: L2, ffffffffbc92ff20
    [junit] tag=7de49, index=7f9, offset=0
    [junit] Test: DTLB, ffffffffa2cbe4be
    [junit] tag=7fd165f, index=0, offset=4be
    [junit] Test: L1, 57a4c679682743ed
    [junit] tag=968274, index=1f, offset=d
    [junit] Test: L2, ca623bb34fa680e1
    [junit] tag=1a7d3, index=407, offset=1
    [junit] Test: DTLB, 41e9d64c2a099b33
    [junit] tag=261504c, index=0, offset=1b33
    [junit] Test: L1, 2e98cad004039186
    [junit] tag=4039, index=c, offset=6
    [junit] Test: L2, ffffffffc8000422
    [junit] tag=7e400, index=21, offset=2
    [junit] Test: DTLB, ffffffffdabb7ee5
    [junit] tag=7fed5db, index=0, offset=1ee5
    [junit] Test: L1, ffffffffc621c158
    [junit] tag=fc621c, index=a, offset=18
    [junit] Test: L2, ffffffff892a9df7
    [junit] tag=7c495, index=4ef, offset=17
    [junit] Test: DTLB, ffffffffb031e5b3
    [junit] tag=7fd818f, index=0, offset=5b3
    [junit] Test: L1, ffffffffa40e8f24
    [junit] tag=fa40e8, index=79, offset=4
    [junit] Test: L2, 831d626968642b85
    [junit] tag=4b432, index=15c, offset=5
    [junit] Test: DTLB, ffffffffa141f352
    [junit] tag=7fd0a0f, index=0, offset=1352
    [junit] Test: L1, ffffffffe869c029
    [junit] tag=fe869c, index=1, offset=9
    [junit] Test: L2, ffffffffbee3a3e3
    [junit] tag=7df71, index=d1f, offset=3
    [junit] Test: DTLB, ffffffffa0a26cff
    [junit] tag=7fd0513, index=0, offset=cff
    [junit] Test: L1, ffffffff986dc706
    [junit] tag=f986dc, index=38, offset=6
    [junit] Test: L2, f120eda3270290a3
    [junit] tag=19381, index=485, offset=3
    [junit] Test: DTLB, ffffffffa28d2680
    [junit] tag=7fd1469, index=0, offset=680
    [junit] Test: L1, ffffffff99d46dc0
    [junit] tag=f99d46, index=6e, offset=0
    [junit] Test: L2, 82a6eba8152fa2f9
    [junit] tag=40a97, index=d17, offset=19
    [junit] Test: DTLB, 11ed3529044887d0
    [junit] tag=1482244, index=0, offset=7d0
    [junit] Test: L1, bc7459862e6480fa
    [junit] tag=62e648, index=7, offset=1a
    [junit] Test: L2, 9e07b90a685a3995
    [junit] tag=5342d, index=1cc, offset=15
    [junit] Test: DTLB, bcef71fb722540e6
    [junit] tag=7db912a, index=0, offset=e6
    [junit] Test: L1, 81886bbd0d10913f
    [junit] tag=d0d109, index=9, offset=1f
    [junit] Test: L2, ffffffffa14afc0f
    [junit] tag=7d0a5, index=7e0, offset=f
    [junit] Test: DTLB, ffffffff8958f3a6
    [junit] tag=7fc4ac7, index=0, offset=13a6
    [junit] Test: L1, fffffffffb369c9f
    [junit] tag=ffb369, index=64, offset=1f
    [junit] Test: L2, ffffffffbd2d58f1
    [junit] tag=7de96, index=ac7, offset=11
    [junit] Test: DTLB, 872ed25f2c5e4c44
    [junit] tag=2f962f2, index=0, offset=c44
    [junit] Test: L1, ffffffff8f779013
    [junit] tag=f8f779, index=0, offset=13
    [junit] Test: L2, fffffffff47a7898
    [junit] tag=7fa3d, index=3c4, offset=18
    [junit] Test: DTLB, fffffffff98a8170
    [junit] tag=7ffcc54, index=0, offset=170
    [junit] Test: L1, 413cd8af0b1f4e84
    [junit] tag=f0b1f4, index=74, offset=4
    [junit] Test: L2, f1e408cd5d4b2932
    [junit] tag=6aea5, index=949, offset=12
    [junit] Test: DTLB, 343c43f27b7fa437
    [junit] tag=793dbfd, index=0, offset=437
    [junit] Test: L1, 5e7845eb6013f52b
    [junit] tag=b6013f, index=29, offset=b
    [junit] Test: L2, ffffffffe5d452fc
    [junit] tag=7f2ea, index=297, offset=1c
    [junit] Test: DTLB, 702f12d80bce6fb1
    [junit] tag=6c05e73, index=0, offset=fb1
    [junit] Test: L1, 884f170625b3929d
    [junit] tag=625b39, index=14, offset=1d
    [junit] Test: L2, ffffffffd668b0a0
    [junit] tag=7eb34, index=585, offset=0
    [junit] Test: DTLB, 174aaf49205c5eef
    [junit] tag=24902e2, index=0, offset=1eef
    [junit] Test: L1, c78c6cce009cf286
    [junit] tag=e009cf, index=14, offset=6
    [junit] Test: L2, 1d46222b0796575f
    [junit] tag=583cb, index=2ba, offset=1f
    [junit] Test: DTLB, 71d9609d66095135
    [junit] tag=4eb304a, index=0, offset=1135
    [junit] Test: L1, ffffffff830d8fe4
    [junit] tag=f830d8, index=7f, offset=4
    [junit] Test: L2, ffffffffd313868e
    [junit] tag=7e989, index=c34, offset=e
    [junit] Test: DTLB, ffffffff896d8f64
    [junit] tag=7fc4b6c, index=0, offset=f64
    [junit] Test: L1, ffffffffbc415c69
    [junit] tag=fbc415, index=63, offset=9
    [junit] Test: L2, ffffffff904aa929
    [junit] tag=7c825, index=549, offset=9
    [junit] Test: DTLB, ffffffff94fcf437
    [junit] tag=7fca7e7, index=0, offset=1437
    [junit] Test: L1, ffffffffabfa4511
    [junit] tag=fabfa4, index=28, offset=11
    [junit] Test: L2, 6c025f3f48425317
    [junit] tag=7a421, index=298, offset=17
    [junit] Test: DTLB, ffffffffa83aad4a
    [junit] tag=7fd41d5, index=0, offset=d4a
    [junit] Test: L1, 48f40564191e7f57
    [junit] tag=4191e7, index=7a, offset=17
    [junit] Test: L2, ffffffffd6911566
    [junit] tag=7eb48, index=8ab, offset=6
    [junit] Test: DTLB, fffffffffd3e62c4
    [junit] tag=7ffe9f3, index=0, offset=2c4
    [junit] Test: L1, da6629e25f686383
    [junit] tag=25f686, index=1c, offset=3
    [junit] Test: L2, ffffffffdebea6a3
    [junit] tag=7ef5f, index=535, offset=3
    [junit] Test: DTLB, d7e85d8253b141de
    [junit] tag=4129d8a, index=0, offset=1de
    [junit] Test: L1, ffffffff952234d8
    [junit] tag=f95223, index=26, offset=18
    [junit] Test: L2, 77e83ba14062e136
    [junit] tag=a031, index=709, offset=16
    [junit] Test: DTLB, ffffffffa8a3118d
    [junit] tag=7fd4518, index=0, offset=118d
    [junit] Test: L1, f396ead3087600c8
    [junit] tag=308760, index=6, offset=8
    [junit] Test: L2, fffffffff711f4bf
    [junit] tag=7fb88, index=fa5, offset=1f
    [junit] Test: DTLB, a7d19cdb28658e02
    [junit] tag=6d9432c, index=0, offset=e02
    [junit] Test: L1, 70f225b40fd1e6cd
    [junit] tag=40fd1e, index=36, offset=d
    [junit] Test: L2, ffffffffb05fd9d6
    [junit] tag=7d82f, index=ece, offset=16
    [junit] Test: DTLB, 8813867d06531285
    [junit] tag=3e83298, index=0, offset=1285
    [junit] Test: L1, ffffffffa0e3984d
    [junit] tag=fa0e39, index=42, offset=d
    [junit] Test: L2, 7c9080a2303783ce
    [junit] tag=1181b, index=c1e, offset=e
    [junit] Test: DTLB, 2f2ea665051fe2fa
    [junit] tag=32828ff, index=0, offset=2fa
    [junit] Test: L1, cca790eb147ac36b
    [junit] tag=b147ac, index=1b, offset=b
    [junit] Test: L2, 3ca38a04794d04c7
    [junit] tag=23ca6, index=826, offset=7
    [junit] Test: DTLB, ffffffffe9870c8f
    [junit] tag=7ff4c38, index=0, offset=c8f
    [junit] Test: L1, ffffffffb55ec0ef
    [junit] tag=fb55ec, index=7, offset=f
    [junit] Test: L2, ffffffffabdc36c8
    [junit] tag=7d5ee, index=1b6, offset=8
    [junit] Test: DTLB, ffffffffe076ab3a
    [junit] tag=7ff03b5, index=0, offset=b3a
    [junit] Test: L1, e5fb2fff37d6f551
    [junit] tag=f37d6f, index=2a, offset=11
    [junit] Test: L2, 9c1efc6c0dbc3295
    [junit] tag=606de, index=194, offset=15
    [junit] Test: DTLB, 71b675e0705bd458
    [junit] tag=70382de, index=0, offset=1458
    [junit] Test: L1, 96c4850e5bf9baa8
    [junit] tag=e5bf9b, index=55, offset=8
    [junit] Test: L2, ffffffff92475ffc
    [junit] tag=7c923, index=aff, offset=1c
    [junit] Test: DTLB, ffffffffa08cdca8
    [junit] tag=7fd0466, index=0, offset=1ca8
    [junit] Test: L1, ffffffffc7e0e949
    [junit] tag=fc7e0e, index=4a, offset=9
    [junit] Test: L2, 5d37bf8744ef28fe
    [junit] tag=3a277, index=947, offset=1e
    [junit] Test: DTLB, 4d29ec4b162dc009
    [junit] tag=258b16e, index=0, offset=9
    [junit] Test: L1, 14bd237005d50e15
    [junit] tag=5d50, index=70, offset=15
    [junit] Test: L2, fcf1fe4b13edf368
    [junit] tag=589f6, index=f9b, offset=8
    [junit] Test: DTLB, 770e415a1cc7bd59
    [junit] tag=2d0e63d, index=0, offset=1d59
    [junit] Test: L1, 9cb8154c3b3ff760
    [junit] tag=c3b3ff, index=3b, offset=0
    [junit] Test: L2, ffffffffd9bc1882
    [junit] tag=7ecde, index=c4, offset=2
    [junit] Test: DTLB, 694161171865c933
    [junit] tag=b8c32e, index=0, offset=933
    [junit] Test: L1, 6b2e09041afee04c
    [junit] tag=41afee, index=2, offset=c
    [junit] Test: L2, ae2e524908c8a0b2
    [junit] tag=48464, index=505, offset=12
    [junit] Test: DTLB, 7ae2a6d178a8e70d
    [junit] tag=68bc547, index=0, offset=70d
    [junit] Test: L1, ffffffffe0fa5f01
    [junit] tag=fe0fa5, index=78, offset=1
    [junit] Test: L2, d5b216c303e19804
    [junit] tag=181f0, index=cc0, offset=4
    [junit] Test: DTLB, 6ee5ec343978b9ba
    [junit] tag=1a1cbc5, index=0, offset=19ba
    [junit] Test: L1, ffffffffc63d9d70
    [junit] tag=fc63d9, index=6b, offset=10
    [junit] Test: L2, 207cd9e15f01afe4
    [junit] tag=af80, index=d7f, offset=4
    [junit] Test: DTLB, ffffffffb41b06f1
    [junit] tag=7fda0d8, index=0, offset=6f1
    [junit] Test: L1, ffffffff9434f212
    [junit] tag=f9434f, index=10, offset=12
    [junit] Test: L2, ffffffffb0dd1511
    [junit] tag=7d86e, index=8a8, offset=11
    [junit] Test: DTLB, 282b7be70c53a8f
    [junit] tag=5f38629, index=0, offset=1a8f
    [junit] Test: L1, fffffffffae08a0f
    [junit] tag=ffae08, index=50, offset=f
    [junit] Test: L2, ffffffff84c1d43e
    [junit] tag=7c260, index=ea1, offset=1e
    [junit] Test: DTLB, 2f0d6d7d787a7e95
    [junit] tag=3ebc3d3, index=0, offset=1e95
    [junit] Test: L1, dde118e32d22501f
    [junit] tag=32d225, index=0, offset=1f
    [junit] Test: L2, ffffffffa5006818
    [junit] tag=7d280, index=340, offset=18
    [junit] Test: DTLB, 2b2072b00d0d1a24
    [junit] tag=5806868, index=0, offset=1a24
    [junit] Test: L1, 9108955235a6bfaa
    [junit] tag=235a6b, index=7d, offset=a
    [junit] Test: L2, fffffffffdc9c03f
    [junit] tag=7fee4, index=e01, offset=1f
    [junit] Test: DTLB, ffffffffd731120f
    [junit] tag=7feb988, index=0, offset=120f
    [junit] Test: L1, 655a8d461f89f26
    [junit] tag=461f89, index=79, offset=6
    [junit] Test: L2, ffffffff85d41adb
    [junit] tag=7c2ea, index=d6, offset=1b
    [junit] Test: DTLB, ffffffffebcb6dcd
    [junit] tag=7ff5e5b, index=0, offset=dcd
    [junit] Test: L1, 80ff71a65db8853f
    [junit] tag=65db88, index=29, offset=1f
    [junit] Test: L2, 3d460e4909f9b89d
    [junit] tag=484fc, index=dc4, offset=1d
    [junit] Test: DTLB, ffffffffd3d5ffbf
    [junit] tag=7fe9eaf, index=0, offset=1fbf
    [junit] Test: L1, ffffffff9ecbdb07
    [junit] tag=f9ecbd, index=58, offset=7
    [junit] Test: L2, ffffffffc5129e60
    [junit] tag=7e289, index=4f3, offset=0
    [junit] Test: DTLB, ffffffff8ca55575
    [junit] tag=7fc652a, index=0, offset=1575
    [junit] Test: L1, ffffffff9bd00501
    [junit] tag=f9bd00, index=28, offset=1
    [junit] Test: L2, ffffffffdb49d6aa
    [junit] tag=7eda4, index=eb5, offset=a
    [junit] Test: DTLB, ffffffffc6b6a613
    [junit] tag=7fe35b5, index=0, offset=613
    [junit] Test: L1, cda20e517e1556d4
    [junit] tag=17e155, index=36, offset=14
    [junit] Test: L2, 96d340866417201c
    [junit] tag=3320b, index=900, offset=1c
    [junit] Test: DTLB, 3c2cf2625a2ca852
    [junit] tag=312d165, index=0, offset=852
    [junit] Test: L1, ffffffffaeb4ad19
    [junit] tag=faeb4a, index=68, offset=19
    [junit] Test: L2, ffffffffb83103e3
    [junit] tag=7dc18, index=81f, offset=3
    [junit] Test: DTLB, 646c774c2ea8b7f1
    [junit] tag=2617545, index=0, offset=17f1
    [junit] Test: L1, ffffffffeaf0dbf0
    [junit] tag=feaf0d, index=5f, offset=10
    [junit] Test: L2, 59b79a620c963109
    [junit] tag=1064b, index=188, offset=9
    [junit] Test: DTLB, 22a9c6075166e206
    [junit] tag=3a8b37, index=0, offset=206
    [junit] Test: L1, fffffffff5b11d64
    [junit] tag=ff5b11, index=6b, offset=4
    [junit] Test: L2, ffffffff901c6351
    [junit] tag=7c80e, index=31a, offset=11
    [junit] Test: DTLB, 780e665e126914c7
    [junit] tag=2f09348, index=0, offset=14c7
    [junit] Test: L1, ffffffffa37cc92e
    [junit] tag=fa37cc, index=49, offset=e
    [junit] Test: L2, ffffffff96e5804a
    [junit] tag=7cb72, index=c02, offset=a
    [junit] Test: DTLB, ffffffffbdc10d54
    [junit] tag=7fdee08, index=0, offset=d54
    [junit] Test: L1, 621746de51191cc5
    [junit] tag=e51191, index=66, offset=5
    [junit] Test: L2, ffffffffa44ed32e
    [junit] tag=7d227, index=699, offset=e
    [junit] Test: DTLB, ffffffffa8ce502f
    [junit] tag=7fd4672, index=0, offset=102f
    [junit] Test: L1, 5e0834ae6bf80992
    [junit] tag=e6bf80, index=4c, offset=12
    [junit] Test: L2, ffffffffaaa863d6
    [junit] tag=7d554, index=31e, offset=16
    [junit] Test: DTLB, 7a1312a4620498bd
    [junit] tag=5231024, index=0, offset=18bd
    [junit] Test: L1, a0baac0e36338db6
    [junit] tag=e36338, index=6d, offset=16
    [junit] Test: L2, ffffffffe30bfb78
    [junit] tag=7f185, index=fdb, offset=18
    [junit] Test: DTLB, 730b11ae149166c0
    [junit] tag=570a48b, index=0, offset=6c0
    [junit] Test: L1, 431a533a3d9cf924
    [junit] tag=a3d9cf, index=49, offset=4
    [junit] Test: L2, fadf021550482d60
    [junit] tag=2a824, index=16b, offset=0
    [junit] Test: DTLB, fffffffff046f716
    [junit] tag=7ff8237, index=0, offset=1716
    [junit] Test: L1, 659e2f2d3bf90d36
    [junit] tag=d3bf90, index=69, offset=16
    [junit] Test: L2, d0f43195f9977a4
    [junit] tag=4afcc, index=bbd, offset=4
    [junit] Test: DTLB, ffffffffc5130e89
    [junit] tag=7fe2898, index=0, offset=e89
    [junit] Test: L1, ffffffff87da7e4d
    [junit] tag=f87da7, index=72, offset=d
    [junit] Test: L2, fffffffffe0ec78c
    [junit] tag=7ff07, index=63c, offset=c
    [junit] Test: DTLB, fffffffffe580190
    [junit] tag=7fff2c0, index=0, offset=190
    [junit] Test: L1, 7d65e52b73bd050b
    [junit] tag=b73bd0, index=28, offset=b
    [junit] Test: L2, b272e96c19cb50ea
    [junit] tag=60ce5, index=a87, offset=a
    [junit] Test: DTLB, ffffffffffc76cc7
    [junit] tag=7fffe3b, index=0, offset=cc7
    [junit] Test: L1, ffffffff8421aac2
    [junit] tag=f8421a, index=56, offset=2
    [junit] Test: L2, 74d823d16bd4bab2
    [junit] tag=b5ea, index=5d5, offset=12
    [junit] Test: DTLB, 6b29bcbb79f75160
    [junit] tag=5dbcfba, index=0, offset=1160
    [junit] Test: L1, ffffffffff2a1cf7
    [junit] tag=fff2a1, index=67, offset=17
    [junit] Test: L2, 2a0b0e0e3f9e7388
    [junit] tag=71fcf, index=39c, offset=8
    [junit] Test: DTLB, 13761220257974da
    [junit] tag=1012bcb, index=0, offset=14da
    [junit] Test: L1, 3f6ae8a822759502
    [junit] tag=822759, index=28, offset=2
    [junit] Test: L2, ffffffffab243b59
    [junit] tag=7d592, index=1da, offset=19
    [junit] Test: DTLB, ffffffffda9872b3
    [junit] tag=7fed4c3, index=0, offset=12b3
    [junit] Test: L1, ffffffff987311bd
    [junit] tag=f98731, index=d, offset=1d
    [junit] Test: L2, 277a620e05451b16
    [junit] tag=702a2, index=8d8, offset=16
    [junit] Test: DTLB, e723cc447b32731b
    [junit] tag=223d993, index=0, offset=131b
    [junit] Test: L1, bd988a806cfc06c8
    [junit] tag=6cfc0, index=36, offset=8
    [junit] Test: L2, ffffffff929b1942
    [junit] tag=7c94d, index=8ca, offset=2
    [junit] Test: DTLB, fffffffffcc2c049
    [junit] tag=7ffe616, index=0, offset=49
    [junit] Test: L1, ffffffffb3d06834
    [junit] tag=fb3d06, index=41, offset=14
    [junit] Test: L2, ffffffffbabf10bd
    [junit] tag=7dd5f, index=885, offset=1d
    [junit] Test: DTLB, ffffffffd5af3db0
    [junit] tag=7fead79, index=0, offset=1db0
    [junit] Test: L1, ffffffff8a196a7b
    [junit] tag=f8a196, index=53, offset=1b
    [junit] Test: L2, b20d9014123a87f1
    [junit] tag=2091d, index=43f, offset=11
    [junit] Test: DTLB, 6da2fb345f604c59
    [junit] tag=1a2fb02, index=0, offset=c59
    [junit] Test: L1, d56fb6a358d88f81
    [junit] tag=358d88, index=7c, offset=1
    [junit] Test: L2, ffffffffff63e5c4
    [junit] tag=7ffb1, index=f2e, offset=4
    [junit] Test: DTLB, d71af6d02cd0c292
    [junit] tag=6816686, index=0, offset=292
    [junit] Test: L1, ffffffffef71ad66
    [junit] tag=fef71a, index=6b, offset=6
    [junit] Test: L2, c21a496250773ee
    [junit] tag=31283, index=b9f, offset=e
    [junit] Test: DTLB, ffffffff96575f4c
    [junit] tag=7fcb2ba, index=0, offset=1f4c
    [junit] Test: L1, ffffffff859df997
    [junit] tag=f859df, index=4c, offset=17
    [junit] Test: L2, ffffffff8fa334de
    [junit] tag=7c7d1, index=9a6, offset=1e
    [junit] Test: DTLB, beecdf664757aee
    [junit] tag=7b323ab, index=0, offset=1aee
    [junit] Test: L1, ffffffffd828dfee
    [junit] tag=fd828d, index=7f, offset=e
    [junit] Test: L2, ffffffffac2e742b
    [junit] tag=7d617, index=3a1, offset=b
    [junit] Test: DTLB, ffffffffbaebca69
    [junit] tag=7fdd75e, index=0, offset=a69
    [junit] Test: L1, ffffffff9f471c38
    [junit] tag=f9f471, index=61, offset=18
    [junit] Test: L2, fa96dec97fe760e6
    [junit] tag=4bff3, index=b07, offset=6
    [junit] Test: DTLB, ffffffff9efd9907
    [junit] tag=7fcf7ec, index=0, offset=1907
    [junit] Test: L1, ffffffffb0a90808
    [junit] tag=fb0a90, index=40, offset=8
    [junit] Test: L2, ffffffffc250ee1c
    [junit] tag=7e128, index=770, offset=1c
    [junit] Test: DTLB, 9faff09e71382e80
    [junit] tag=4f389c1, index=0, offset=e80
    [junit] Test: L1, ffffffffbb7d5517
    [junit] tag=fbb7d5, index=28, offset=17
    [junit] Test: L2, ffffffffd333accd
    [junit] tag=7e999, index=d66, offset=d
    [junit] Test: DTLB, ffffffffeab73f54
    [junit] tag=7ff55b9, index=0, offset=1f54
    [junit] Test: L1, ffffffffd6d9ad49
    [junit] tag=fd6d9a, index=6a, offset=9
    [junit] Test: L2, ffffffffbe70d701
    [junit] tag=7df38, index=6b8, offset=1
    [junit] Test: DTLB, ffffffffc8fc3c39
    [junit] tag=7fe47e1, index=0, offset=1c39
    [junit] Test: L1, ffffffff9299e94a
    [junit] tag=f9299e, index=4a, offset=a
    [junit] Test: L2, ffffffffbb11906d
    [junit] tag=7dd88, index=c83, offset=d
    [junit] Test: DTLB, 6e3ac20a2cbe65cb
    [junit] tag=5165f3, index=0, offset=5cb
    [junit] Test: L1, ffffffff8eb58e76
    [junit] tag=f8eb58, index=73, offset=16
    [junit] Test: L2, f49a30ec3ccfea5e
    [junit] tag=61e67, index=f52, offset=1e
    [junit] Test: DTLB, ffffffff861f1050
    [junit] tag=7fc30f8, index=0, offset=1050
    [junit] Test: L1, ffffffffe37bf406
    [junit] tag=fe37bf, index=20, offset=6
    [junit] Test: L2, fffffffff15141a7
    [junit] tag=7f8a8, index=a0d, offset=7
    [junit] Test: DTLB, ffffffff89315e6c
    [junit] tag=7fc498a, index=0, offset=1e6c
    [junit] Test: L1, 5a7b431e45c2edc3
    [junit] tag=e45c2e, index=6e, offset=3
    [junit] Test: L2, 8a026a8154e45cf8
    [junit] tag=aa72, index=2e7, offset=18
    [junit] Test: DTLB, 903e958a30eaa83b
    [junit] tag=4518755, index=0, offset=83b
    [junit] Test: L1, 5e4f1e18238553
    [junit] tag=e18238, index=2a, offset=13
    [junit] Test: L2, ffffffff847c14bb
    [junit] tag=7c23e, index=a5, offset=1b
    [junit] Test: DTLB, fffffffff482c91e
    [junit] tag=7ffa416, index=0, offset=91e
    [junit] Test: L1, ffffffff8eceb83e
    [junit] tag=f8eceb, index=41, offset=1e
    [junit] Test: L2, d269d44436268b8f
    [junit] tag=21b13, index=45c, offset=f
    [junit] Test: DTLB, fffffffffa2654c8
    [junit] tag=7ffd132, index=0, offset=14c8
    [junit] Test: L1, 47ec8bfe1912d344
    [junit] tag=e1912d, index=1a, offset=4
    [junit] Test: L2, 421e96795ddcccbe
    [junit] tag=4aeee, index=665, offset=1e
    [junit] Test: DTLB, 5997d7f00a50956d
    [junit] tag=7805284, index=0, offset=156d
    [junit] Test: L1, ffffffffbdfae6e0
    [junit] tag=fbdfae, index=37, offset=0
    [junit] Test: L2, a10ae7b8436df087
    [junit] tag=421b6, index=f84, offset=7
    [junit] Test: DTLB, ffffffffc9be45d6
    [junit] tag=7fe4df2, index=0, offset=5d6
    [junit] Test: L1, ffffffffd91fa3a9
    [junit] tag=fd91fa, index=1d, offset=9
    [junit] Test: L2, 60bfa7cd148feebd
    [junit] tag=68a47, index=f75, offset=1d
    [junit] Test: DTLB, ffffffffcdb5c16a
    [junit] tag=7fe6dae, index=0, offset=16a
    [junit] Test: L1, ffffffffe8b0c82e
    [junit] tag=fe8b0c, index=41, offset=e
    [junit] Test: L2, 4793d78946762176
    [junit] tag=4a33b, index=10b, offset=16
    [junit] Test: DTLB, ffffffff8beb72b6
    [junit] tag=7fc5f5b, index=0, offset=12b6
    [junit] Test: L1, a04e6990163e4d4b
    [junit] tag=163e4, index=6a, offset=b
    [junit] Test: L2, ffffffff80f23b31
    [junit] tag=7c079, index=1d9, offset=11
    [junit] Test: DTLB, 564781666b105fb6
    [junit] tag=3335882, index=0, offset=1fb6
    [junit] Test: L1, ffffffffb6c66e9f
    [junit] tag=fb6c66, index=74, offset=1f
    [junit] Test: L2, ffffffffd197ea08
    [junit] tag=7e8cb, index=f50, offset=8
    [junit] Test: DTLB, ffffffff9c7bce7a
    [junit] tag=7fce3de, index=0, offset=e7a
    [junit] Test: L1, ffffffffbd5b7e4a
    [junit] tag=fbd5b7, index=72, offset=a
    [junit] Test: L2, e4a8b91c1abc7826
    [junit] tag=60d5e, index=3c1, offset=6
    [junit] Test: DTLB, 56f96b96dfaf6a4
    [junit] tag=5cb6fd7, index=0, offset=16a4
    [junit] Test: L1, 57ac1b028ea116f
    [junit] tag=28ea1, index=b, offset=f
    [junit] Test: L2, 54f7aea470d318ee
    [junit] tag=23869, index=8c7, offset=e
    [junit] Test: DTLB, 43b5101776f22476
    [junit] tag=bbb791, index=0, offset=476
    [junit] Test: L1, ffffffff888fe18f
    [junit] tag=f888fe, index=c, offset=f
    [junit] Test: L2, 4b47c935526f1915
    [junit] tag=2a937, index=8c8, offset=15
    [junit] Test: DTLB, ffffffff8bbdc5a9
    [junit] tag=7fc5dee, index=0, offset=5a9
    [junit] Test: L1, ffffffffcee65adc
    [junit] tag=fcee65, index=56, offset=1c
    [junit] Test: L2, 18abe8fe7278ab81
    [junit] tag=7393c, index=55c, offset=1
    [junit] Test: DTLB, 266b44de421bf54a
    [junit] tag=6f210df, index=0, offset=154a
    [junit] Test: L1, e6c96b0e5dd200b7
    [junit] tag=e5dd20, index=5, offset=17
    [junit] Test: L2, ffffffffd7b66386
    [junit] tag=7ebdb, index=31c, offset=6
    [junit] Test: DTLB, fffffffff6f709e2
    [junit] tag=7ffb7b8, index=0, offset=9e2
    [junit] Test: L1, ffffffff820d031d
    [junit] tag=f820d0, index=18, offset=1d
    [junit] Test: L2, fffffffff7d8bebf
    [junit] tag=7fbec, index=5f5, offset=1f
    [junit] Test: DTLB, ffffffffc348fdbf
    [junit] tag=7fe1a47, index=0, offset=1dbf
    [junit] Test: L1, ffffffffed59c9cc
    [junit] tag=fed59c, index=4e, offset=c
    [junit] Test: L2, 515293661aba658e
    [junit] tag=30d5d, index=32c, offset=e
    [junit] Test: DTLB, ffffffffc7c4c164
    [junit] tag=7fe3e26, index=0, offset=164
    [junit] Test: L1, ffffffffd258e0ac
    [junit] tag=fd258e, index=5, offset=c
    [junit] Test: L2, ffffffffb61fa553
    [junit] tag=7db0f, index=d2a, offset=13
    [junit] Test: DTLB, 3f4f62ef13d3b6e0
    [junit] tag=7789e9d, index=0, offset=16e0
    [junit] Test: L1, ffffffff80107f3c
    [junit] tag=f80107, index=79, offset=1c
    [junit] Test: L2, 1f95a97655262f1f
    [junit] tag=32a93, index=178, offset=1f
    [junit] Test: DTLB, ffffffff8187818a
    [junit] tag=7fc0c3c, index=0, offset=18a
    [junit] Test: L1, ffffffffe3f55912
    [junit] tag=fe3f55, index=48, offset=12
    [junit] Test: L2, ffffffffdd607b5b
    [junit] tag=7eeb0, index=3da, offset=1b
    [junit] Test: DTLB, 665626424a1ca6e4
    [junit] tag=21250e5, index=0, offset=6e4
    [junit] Test: L1, ffffffffd6a08a4c
    [junit] tag=fd6a08, index=52, offset=c
    [junit] Test: L2, b94ce0f53f2acb29
    [junit] tag=29f95, index=659, offset=9
    [junit] Test: DTLB, ffffffffba094f2b
    [junit] tag=7fdd04a, index=0, offset=f2b
    [junit] Test: L1, ffffffffa2285026
    [junit] tag=fa2285, index=1, offset=6
    [junit] Test: L2, 78c353583af71264
    [junit] tag=41d7b, index=893, offset=4
    [junit] Test: DTLB, ffffffff9cac9775
    [junit] tag=7fce564, index=0, offset=1775
    [junit] Test: L1, ffffffffa514ea74
    [junit] tag=fa514e, index=53, offset=14
    [junit] Test: L2, 506d30564cc9011d
    [junit] tag=32664, index=808, offset=1d
    [junit] Test: DTLB, ffffffffa9ea4c64
    [junit] tag=7fd4f52, index=0, offset=c64
    [junit] Test: L1, ffffffffc2f6e62c
    [junit] tag=fc2f6e, index=31, offset=c
    [junit] Test: L2, 1fb6f80944bd5afa
    [junit] tag=4a25e, index=ad7, offset=1a
    [junit] Test: DTLB, afec3cc315a4587c
    [junit] tag=618ad22, index=0, offset=187c
    [junit] Test: L1, 36e66b2d0088b679
    [junit] tag=d0088b, index=33, offset=19
    [junit] Test: L2, ffffffffbf72d725
    [junit] tag=7dfb9, index=6b9, offset=5
    [junit] Test: DTLB, ffffffffc6dfcdfa
    [junit] tag=7fe36fe, index=0, offset=dfa
    [junit] Test: L1, ffffffffdee7c18a
    [junit] tag=fdee7c, index=c, offset=a
    [junit] Test: L2, ffffffffa465811e
    [junit] tag=7d232, index=c08, offset=1e
    [junit] Test: DTLB, ffffffffbab5e61b
    [junit] tag=7fdd5af, index=0, offset=61b
    [junit] Test: L1, ffffffffca6394d6
    [junit] tag=fca639, index=26, offset=16
    [junit] Test: L2, 3d8690aa52fef469
    [junit] tag=5297f, index=7a3, offset=9
    [junit] Test: DTLB, 888cbfa871633e77
    [junit] tag=5438b19, index=0, offset=1e77
    [junit] Test: L1, ffffffff8691d3f8
    [junit] tag=f8691d, index=1f, offset=18
    [junit] Test: L2, bbed7cd542d7b06b
    [junit] tag=2a16b, index=d83, offset=b
    [junit] Test: DTLB, f93a6dfa6e691d84
    [junit] tag=7d37348, index=0, offset=1d84
    [junit] Test: L1, 8b5f19a773ca3018
    [junit] tag=773ca3, index=0, offset=18
    [junit] Test: L2, ffffffffe2bf796b
    [junit] tag=7f15f, index=bcb, offset=b
    [junit] Test: DTLB, ffffffffe006a478
    [junit] tag=7ff0035, index=0, offset=478
    [junit] Test: L1, ffffffff9cd7a132
    [junit] tag=f9cd7a, index=9, offset=12
    [junit] Test: L2, ffffffffc5262f13
    [junit] tag=7e293, index=178, offset=13
    [junit] Test: DTLB, ffffffffeed04d4f
    [junit] tag=7ff7682, index=0, offset=d4f
    [junit] Test: L1, ffffffffc81df3ca
    [junit] tag=fc81df, index=1e, offset=a
    [junit] Test: L2, ffffffffdfbb04c1
    [junit] tag=7efdd, index=826, offset=1
    [junit] Test: DTLB, 8d459ac318830b5f
    [junit] tag=618c418, index=0, offset=b5f
    [junit] Test: L1, 40f2296640f504ec
    [junit] tag=640f50, index=27, offset=c
    [junit] Test: L2, ffffffff966460c1
    [junit] tag=7cb32, index=306, offset=1
    [junit] Test: DTLB, 848fefdf3c7e422d
    [junit] tag=6f9e3f2, index=0, offset=22d
    [junit] Test: L1, f5436d5f6f1702a1
    [junit] tag=f6f170, index=15, offset=1
    [junit] Test: L2, ffffffff9af661a4
    [junit] tag=7cd7b, index=30d, offset=4
    [junit] Test: DTLB, 4e8adb2b3ea5989f
    [junit] tag=159f52c, index=0, offset=189f
    [junit] Test: L1, ffffffff998e081f
    [junit] tag=f998e0, index=40, offset=1f
    [junit] Test: L2, ffffffffd4f543cc
    [junit] tag=7ea7a, index=a1e, offset=c
    [junit] Test: DTLB, ecfdac875355997a
    [junit] tag=43a9aac, index=0, offset=197a
    [junit] Test: L1, 5a6f9a111794dd49
    [junit] tag=11794d, index=6a, offset=9
    [junit] Test: L2, ffffffff8fc5bce4
    [junit] tag=7c7e2, index=de7, offset=4
    [junit] Test: DTLB, 233816c1091f1804
    [junit] tag=60848f8, index=0, offset=1804
    [junit] Test: L1, ffffffffdee89f4d
    [junit] tag=fdee89, index=7a, offset=d
    [junit] Test: L2, 38a53aab1b5bf196
    [junit] tag=58dad, index=f8c, offset=16
    [junit] Test: DTLB, d10ef3b04f0e4284
    [junit] tag=5827872, index=0, offset=284
    [junit] Test: L1, ffffffffbf5fa32a
    [junit] tag=fbf5fa, index=19, offset=a
    [junit] Test: L2, 5e030ea14f4f679
    [junit] tag=50a7a, index=7b3, offset=19
    [junit] Test: DTLB, ffffffffbaf84a51
    [junit] tag=7fdd7c2, index=0, offset=a51
    [junit] Test: L1, f4dab88b022f1396
    [junit] tag=b022f1, index=1c, offset=16
    [junit] Test: L2, fffffffff0d82257
    [junit] tag=7f86c, index=112, offset=17
    [junit] Test: DTLB, c3beb72a52751b93
    [junit] tag=15293a8, index=0, offset=1b93
    [junit] Test: L1, ffffffffacc56594
    [junit] tag=facc56, index=2c, offset=14
    [junit] Test: L2, ffffffff94dec73b
    [junit] tag=7ca6f, index=639, offset=1b
    [junit] Test: DTLB, ffffffffba6dc2fa
    [junit] tag=7fdd36e, index=0, offset=2fa
    [junit] Test: L1, f0c853eb7a5ee640
    [junit] tag=b7a5ee, index=32, offset=0
    [junit] Test: L2, 30a63cf16eefb22e
    [junit] tag=b777, index=d91, offset=e
    [junit] Test: DTLB, ffffffffd8c9af4f
    [junit] tag=7fec64d, index=0, offset=f4f
    [junit] Test: L1, ffffffffc042cddb
    [junit] tag=fc042c, index=6e, offset=1b
    [junit] Test: L2, cccef5fa0efc10a1
    [junit] tag=5077e, index=85, offset=1
    [junit] Test: DTLB, 89ada847030b5d7b
    [junit] tag=238185a, index=0, offset=1d7b
    [junit] Test: L1, ffffffffb51aa135
    [junit] tag=fb51aa, index=9, offset=15
    [junit] Test: L2, c16389c0092abc4a
    [junit] tag=495, index=5e2, offset=a
    [junit] Test: DTLB, 74a5b9ca0bcd77ae
    [junit] tag=6505e6b, index=0, offset=17ae
    [junit] Test: L1, 94cc8ee3346ce2bb
    [junit] tag=3346ce, index=15, offset=1b
    [junit] Test: L2, acec5ace2600e1e3
    [junit] tag=71300, index=70f, offset=3
    [junit] Test: DTLB, ffffffff8b6fee6d
    [junit] tag=7fc5b7f, index=0, offset=e6d
    [junit] Test: L1, 466bc98410cc94b1
    [junit] tag=410cc9, index=25, offset=11
    [junit] Test: L2, ffffffffa42b770b
    [junit] tag=7d215, index=bb8, offset=b
    [junit] Test: DTLB, b587cfd428d1b718
    [junit] tag=6a1468d, index=0, offset=1718
    [junit] Test: L1, a063a26c184ff79f
    [junit] tag=c184ff, index=3c, offset=1f
    [junit] Test: L2, 8fff914f4f0919f8
    [junit] tag=7a784, index=8cf, offset=18
    [junit] Test: DTLB, ffffffffd20048ab
    [junit] tag=7fe9002, index=0, offset=8ab
    [junit] Test: L1, 42caa91c3919760b
    [junit] tag=c39197, index=30, offset=b
    [junit] Test: L2, fffffffffc0775a4
    [junit] tag=7fe03, index=bad, offset=4
    [junit] Test: DTLB, 41b033af078abb74
    [junit] tag=5783c55, index=0, offset=1b74
    [junit] Test: L1, 9e4db90288e4a26
    [junit] tag=288e4, index=51, offset=6
    [junit] Test: L2, ffffffff8a2d589e
    [junit] tag=7c516, index=ac4, offset=1e
    [junit] Test: DTLB, 46a5e84a46a9173b
    [junit] tag=2523548, index=0, offset=173b
    [junit] Test: L1, ffffffffb6c5d769
    [junit] tag=fb6c5d, index=3b, offset=9
    [junit] Test: L2, ffffffffbe0f56d2
    [junit] tag=7df07, index=ab6, offset=12
    [junit] Test: DTLB, d8a6b48b4c7dec47
    [junit] tag=45a63ef, index=0, offset=c47
    [junit] Test: L1, d609dc0a188163ca
    [junit] tag=a18816, index=1e, offset=a
    [junit] Test: L2, c85e73f2596dd4f8
    [junit] tag=12cb6, index=ea7, offset=18
    [junit] Test: DTLB, 399c7e0f40d3c7
    [junit] tag=3f07a06, index=0, offset=13c7
    [junit] Test: L1, ffffffffa0a644bb
    [junit] tag=fa0a64, index=25, offset=1b
    [junit] Test: L2, ffffffffc0b18f26
    [junit] tag=7e058, index=c79, offset=6
    [junit] Test: DTLB, 4e3c5d1c313c6d93
    [junit] tag=e189e3, index=0, offset=d93
    [junit] Test: L1, ffffffff93b3dbf2
    [junit] tag=f93b3d, index=5f, offset=12
    [junit] Test: L2, ffffffffcb5176c1
    [junit] tag=7e5a8, index=bb6, offset=1
    [junit] Test: DTLB, 48f4cc341dcad96d
    [junit] tag=1a0ee56, index=0, offset=196d
    [junit] Test: L1, 181bc5d929885778
    [junit] tag=929885, index=3b, offset=18
    [junit] Test: L2, ffffffffcf938be8
    [junit] tag=7e7c9, index=c5f, offset=8
    [junit] Test: DTLB, ffffffffecc8aa7a
    [junit] tag=7ff6645, index=0, offset=a7a
    [junit] Test: L1, ffffffffb96d3942
    [junit] tag=fb96d3, index=4a, offset=2
    [junit] Test: L2, ffffffff8d303c12
    [junit] tag=7c698, index=1e0, offset=12
    [junit] Test: DTLB, 6470c491594503ff
    [junit] tag=48aca28, index=0, offset=3ff
    [junit] Test: L1, 72461eca01c5aed3
    [junit] tag=a01c5a, index=76, offset=13
    [junit] Test: L2, ffffffffbec5f9b4
    [junit] tag=7df62, index=fcd, offset=14
    [junit] Test: DTLB, ffffffffae0b59fb
    [junit] tag=7fd705a, index=0, offset=19fb
    [junit] Test: L1, 3eacdad530152299
    [junit] tag=530152, index=14, offset=19
    [junit] Test: L2, c27e242209049216
    [junit] tag=10482, index=490, offset=16
    [junit] Test: DTLB, fffffffffbab959f
    [junit] tag=7ffdd5c, index=0, offset=159f
    [junit] Test: L1, ffffffffde1c3be8
    [junit] tag=fde1c3, index=5f, offset=8
    [junit] Test: L2, ffffffffe5d5740f
    [junit] tag=7f2ea, index=ba0, offset=f
    [junit] Test: DTLB, ffffffffa3acd390
    [junit] tag=7fd1d66, index=0, offset=1390
    [junit] Test: L1, 90caf5d5537fab71
    [junit] tag=5537fa, index=5b, offset=11
    [junit] Test: L2, ffffffffcccdf813
    [junit] tag=7e666, index=fc0, offset=13
    [junit] Test: DTLB, 361a7be3337d72aa
    [junit] tag=7199beb, index=0, offset=12aa
    [junit] Test: L1, 1ab48f7d4f43c359
    [junit] tag=d4f43c, index=1a, offset=19
    [junit] Test: L2, ffffffff8a188e42
    [junit] tag=7c50c, index=472, offset=2
    [junit] Test: DTLB, ffffffffee31c575
    [junit] tag=7ff718e, index=0, offset=575
    [junit] Test: L1, c973bc3c7ea3d0f4
    [junit] tag=c7ea3d, index=7, offset=14
    [junit] Test: L2, ffffffff9b79fd5a
    [junit] tag=7cdbc, index=fea, offset=1a
    [junit] ------------- ---------------- ---------------
    [junit] 
    [junit] Testcase: runTest took 0,264 sec
    [junit] Running ru.ispras.microtesk.translator.mmu.spec.basis.IntegerEquationSolverTestCase
    [junit] Testsuite: ru.ispras.microtesk.translator.mmu.spec.basis.IntegerEquationSolverTestCase
    [junit] Tests run: 12, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,009 sec
    [junit] Tests run: 12, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,009 sec
    [junit] 
    [junit] Testcase: runTestA took 0,002 sec
    [junit] Testcase: runTestB took 0 sec
    [junit] Testcase: runTestC took 0 sec
    [junit] Testcase: runTestD took 0 sec
    [junit] Testcase: runTestE took 0 sec
    [junit] Testcase: runTestF took 0,001 sec
    [junit] Testcase: runTestG took 0 sec
    [junit] Testcase: runTestH took 0,001 sec
    [junit] Testcase: runTestI took 0,001 sec
    [junit] Testcase: runTestJ took 0 sec
    [junit] Testcase: runTestK took 0,001 sec
    [junit] Testcase: runTestL took 0 sec
    [junit] Running ru.ispras.microtesk.translator.mmu.spec.basis.IntegerFormulaSolverTestCase
    [junit] Testsuite: ru.ispras.microtesk.translator.mmu.spec.basis.IntegerFormulaSolverTestCase
    [junit] Tests run: 12, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,008 sec
    [junit] Tests run: 12, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,008 sec
    [junit] 
    [junit] Testcase: runTestA took 0,002 sec
    [junit] Testcase: runTestB took 0 sec
    [junit] Testcase: runTestC took 0 sec
    [junit] Testcase: runTestD took 0 sec
    [junit] Testcase: runTestE took 0 sec
    [junit] Testcase: runTestF took 0 sec
    [junit] Testcase: runTestG took 0 sec
    [junit] Testcase: runTestH took 0 sec
    [junit] Testcase: runTestI took 0 sec
    [junit] Testcase: runTestJ took 0 sec
    [junit] Testcase: runTestK took 0 sec
    [junit] Testcase: runTestN took 0 sec
    [junit] Running ru.ispras.microtesk.translator.mmu.spec.basis.IntegerRangeTestCase
    [junit] Testsuite: ru.ispras.microtesk.translator.mmu.spec.basis.IntegerRangeTestCase
    [junit]  ===== Range list 0 ===== 
    [junit] [0, 0]
    [junit] [1, 1]
    [junit] [2, 2]
    [junit] [3, 11]
    [junit] [12, 12]
    [junit] [13, 14]
    [junit] [15, 15]
    [junit] [16, 17]
    [junit] [18, 23]
    [junit] [24, 25]
    [junit] [26, 53]
    [junit] [54, 63]
    [junit] 
    [junit]  ===== Range list 1 ===== 
    [junit] [0, 2]
    [junit] [3, 5]
    [junit] [6, 11]
    [junit] [12, 14]
    [junit] [15, 26]
    [junit] [27, 30]
    [junit] [31, 55]
    [junit] [56, 63]
    [junit] [64, 90]
    [junit] [91, 99]
    [junit] [100, 100]
    [junit] [101, 101]
    [junit] [102, 111]
    [junit] [112, 127]
    [junit] 
    [junit]  ===== Range list 2 ===== 
    [junit] [0, 43]
    [junit] [44, 55]
    [junit] [56, 99]
    [junit] [100, 127]
    [junit] 
    [junit]  ===== Range list 3 ===== 
    [junit] [0, 43]
    [junit] [44, 54]
    [junit] [55, 55]
    [junit] [56, 99]
    [junit] [100, 111]
    [junit] [112, 127]
    [junit] 
    [junit]  ===== Range list 4 ===== 
    [junit] [0, 55]
    [junit] [56, 57]
    [junit] [58, 99]
    [junit] [100, 127]
    [junit] 
    [junit]  ===== Range list 5 ===== 
    [junit] [22, 22]
    [junit] [23, 43]
    [junit] [44, 54]
    [junit] [55, 55]
    [junit] [56, 99]
    [junit] [100, 111]
    [junit] [112, 127]
    [junit] 
    [junit] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,007 sec
    [junit] Tests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,007 sec
    [junit] ------------- Standard Output ---------------
    [junit]  ===== Range list 0 ===== 
    [junit] [0, 0]
    [junit] [1, 1]
    [junit] [2, 2]
    [junit] [3, 11]
    [junit] [12, 12]
    [junit] [13, 14]
    [junit] [15, 15]
    [junit] [16, 17]
    [junit] [18, 23]
    [junit] [24, 25]
    [junit] [26, 53]
    [junit] [54, 63]
    [junit] 
    [junit]  ===== Range list 1 ===== 
    [junit] [0, 2]
    [junit] [3, 5]
    [junit] [6, 11]
    [junit] [12, 14]
    [junit] [15, 26]
    [junit] [27, 30]
    [junit] [31, 55]
    [junit] [56, 63]
    [junit] [64, 90]
    [junit] [91, 99]
    [junit] [100, 100]
    [junit] [101, 101]
    [junit] [102, 111]
    [junit] [112, 127]
    [junit] 
    [junit]  ===== Range list 2 ===== 
    [junit] [0, 43]
    [junit] [44, 55]
    [junit] [56, 99]
    [junit] [100, 127]
    [junit] 
    [junit]  ===== Range list 3 ===== 
    [junit] [0, 43]
    [junit] [44, 54]
    [junit] [55, 55]
    [junit] [56, 99]
    [junit] [100, 111]
    [junit] [112, 127]
    [junit] 
    [junit]  ===== Range list 4 ===== 
    [junit] [0, 55]
    [junit] [56, 57]
    [junit] [58, 99]
    [junit] [100, 127]
    [junit] 
    [junit]  ===== Range list 5 ===== 
    [junit] [22, 22]
    [junit] [23, 43]
    [junit] [44, 54]
    [junit] [55, 55]
    [junit] [56, 99]
    [junit] [100, 111]
    [junit] [112, 127]
    [junit] 
    [junit] ------------- ---------------- ---------------
    [junit] 
    [junit] Testcase: runTest0 took 0,002 sec
    [junit] Testcase: runTest1 took 0,001 sec
    [junit] Testcase: runTest2 took 0 sec
    [junit] Testcase: runTest3 took 0,001 sec
    [junit] Testcase: runTest4 took 0 sec
    [junit] Testcase: runTest5 took 0 sec
    [junit] Running ru.ispras.microtesk.translator.mmu.spec.builder.IntegerFieldTrackerTestCase
    [junit] Testsuite: ru.ispras.microtesk.translator.mmu.spec.builder.IntegerFieldTrackerTestCase
    [junit] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,003 sec
    [junit] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0,003 sec
    [junit] 
    [junit] Testcase: test took 0,001 sec
    [junit] Testcase: test2 took 0 sec
    [junit] Testcase: test3 took 0 sec
     [echo] templates for vliw from F:\SVN\MicroTESK\microtesk\microtesk\dist/arch/demo/vliw
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: vliw
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\demo\vliw\templates\combination.rb
    [apply] Loaded template VliwBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/vliw_base.rb
    [apply] Loaded template CombinationTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/combination.rb
    [apply] Processing template CombinationTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/combination.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: R
    [apply] Output (runtime: false): "// Initializer for R"
    [apply] Operation: LUI
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: R
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: F
    [apply] Output (runtime: false): "// Initializer for F"
    [apply] Addressing mode: R
    [apply] Operation: LUI
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Operation: MTF
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: F
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1_1
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADD
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADD
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SUB
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SUB
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1_1
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1_2
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Operation: ADD_S
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Operation: ADD_S
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Operation: SUB_S
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Operation: SUB_S
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1_2
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ----------------------- Generating Data for Test Case 0 ------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation fp.add(case=underflow, exp=8, frac=23) for op ADD_S(fd: F, fs: F, ft: F):[context=null, type=ADD_S, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=ADD_S, testcase=fp.add, ADD_S=ADD_S, ADD_S.fd=F, ADD_S.fd.i=#IMM, ADD_S.fs=F, ADD_S.fs.i=#IMM, ADD_S.ft=F, ADD_S.ft.i=#IMM}, bindings={ADD_S.fd.i=00101, ADD_S.fd=ADD_S.fd, ADD_S.fs.i=00101, ADD_S.fs=ADD_S.fs, ADD_S.ft.i=00110, ADD_S.ft=ADD_S.ft}, parameters={case=underflow, exp=8, frac=23}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {ADD_S.fd=Argument [name=fd, kind=MODE, value=mode F(i: #IMM), mode=OUT, type=Type.FLOAT(23, 8)], ADD_S.ft=Argument [name=ft, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)], ADD_S.fs=Argument [name=fs, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation fp.add(case=inexact, exp=8, frac=23) for op ADD_S(fd: F, fs: F, ft: F):[context=null, type=ADD_S, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=ADD_S, testcase=fp.add, ADD_S=ADD_S, ADD_S.fd=F, ADD_S.fd.i=#IMM, ADD_S.fs=F, ADD_S.fs.i=#IMM, ADD_S.ft=F, ADD_S.ft.i=#IMM}, bindings={ADD_S.fd.i=00111, ADD_S.fd=ADD_S.fd, ADD_S.fs.i=00111, ADD_S.fs=ADD_S.fs, ADD_S.ft.i=01000, ADD_S.ft=ADD_S.ft}, parameters={case=inexact, exp=8, frac=23}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {ADD_S.fd=Argument [name=fd, kind=MODE, value=mode F(i: #IMM), mode=OUT, type=Type.FLOAT(23, 8)], ADD_S.ft=Argument [name=ft, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)], ADD_S.fs=Argument [name=fs, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: ADD_S, c2: ADD_S):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={vliw.c2.fs=01010011010101011111101000111010, vliw.c2.ft=10101001110010010111000000100101, vliw.c1.ft=01011010111000000000011111010010, vliw.c1.fs=11100110111101100111100011011110}]
    [apply] Creating code to assign 01010011010101011111101000111010 to mode F(i: #IMM = 7)...
    [apply] Creating code to assign 10101001110010010111000000100101 to mode F(i: #IMM = 8)...
    [apply] Creating code to assign 01011010111000000000011111010010 to mode F(i: #IMM = 6)...
    [apply] Creating code to assign 11100110111101100111100011011110 to mode F(i: #IMM = 5)...
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation add(case=normal, size=32) for op ADD(rd: R, rs: R, rt: R):[context=null, type=ADD, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=ADD, testcase=add, ADD=ADD, ADD.rd=R, ADD.rd.i=#IMM, ADD.rs=R, ADD.rs.i=#IMM, ADD.rt=R, ADD.rt.i=#IMM}, bindings={ADD.rd.i=00001, ADD.rd=ADD.rd, ADD.rs.i=00011, ADD.rs=ADD.rs, ADD.rt.i=00101, ADD.rt=ADD.rt}, parameters={case=normal, size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {ADD.rs=Argument [name=rs, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], ADD.rt=Argument [name=rt, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], ADD.rd=Argument [name=rd, kind=MODE, value=mode R(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation add(case=overflow, size=32) for op ADD(rd: R, rs: R, rt: R):[context=null, type=ADD, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=ADD, testcase=add, ADD=ADD, ADD.rd=R, ADD.rd.i=#IMM, ADD.rs=R, ADD.rs.i=#IMM, ADD.rt=R, ADD.rt.i=#IMM}, bindings={ADD.rd.i=00010, ADD.rd=ADD.rd, ADD.rs.i=00100, ADD.rs=ADD.rs, ADD.rt.i=00110, ADD.rt=ADD.rt}, parameters={case=overflow, size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {ADD.rs=Argument [name=rs, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], ADD.rt=Argument [name=rt, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], ADD.rd=Argument [name=rd, kind=MODE, value=mode R(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: ADD, c2: ADD):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={vliw.c2.rs=11111100001101110000000001011101, vliw.c2.rt=11000110000100110000011111111010, vliw.c1.rs=00111010000010001010100010100111, vliw.c1.rt=10110000110010001001101111000011}]
    [apply] Creating code to assign 11111100001101110000000001011101 to mode R(i: #IMM = 4)...
    [apply] Creating code to assign 11000110000100110000011111111010 to mode R(i: #IMM = 6)...
    [apply] Creating code to assign 00111010000010001010100010100111 to mode R(i: #IMM = 3)...
    [apply] Creating code to assign 10110000110010001001101111000011 to mode R(i: #IMM = 5)...
    [apply] 
    [apply] ---------------------------- Executing Test Case 0 -----------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] LUI 25, 21333; ADDI 25, 25, 64058;
    [apply] MTF 25, 7; NOP;
    [apply] LUI 25, 43465; ADDI 25, 25, 28709;
    [apply] MTF 25, 8; NOP;
    [apply] LUI 25, 23264; ADDI 25, 25, 2002;
    [apply] MTF 25, 6; NOP;
    [apply] LUI 25, 59126; ADDI 25, 25, 30942;
    [apply] MTF 25, 5; NOP;
    [apply] LUI 4, 64567; ADDI 4, 4, 93;
    [apply] LUI 6, 50707; ADDI 6, 6, 2042;
    [apply] LUI 3, 14856; ADDI 3, 3, 43175;
    [apply] LUI 5, 45256; ADDI 5, 5, 39875;
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] ADD_S 5, 5, 6; ADD_S 7, 7, 8;
    [apply] ADD 1, 3, 5; ADD 2, 4, 6;
    [apply] 
    [apply] ----------------------------- Printing Test Case 0 -----------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] // Initializer for F
    [apply] LUI 25, 21333; ADDI 25, 25, 64058;
    [apply] MTF 25, 7; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 43465; ADDI 25, 25, 28709;
    [apply] MTF 25, 8; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 23264; ADDI 25, 25, 2002;
    [apply] MTF 25, 6; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 59126; ADDI 25, 25, 30942;
    [apply] MTF 25, 5; NOP;
    [apply] // Initializer for R
    [apply] LUI 4, 64567; ADDI 4, 4, 93;
    [apply] // Initializer for R
    [apply] LUI 6, 50707; ADDI 6, 6, 2042;
    [apply] // Initializer for R
    [apply] LUI 3, 14856; ADDI 3, 3, 43175;
    [apply] // Initializer for R
    [apply] LUI 5, 45256; ADDI 5, 5, 39875;
    [apply] 
    [apply] Stimulus
    [apply] ADD_S 5, 5, 6; ADD_S 7, 7, 8;
    [apply] ADD 1, 3, 5; ADD 2, 4, 6;
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Generating Data for Test Case 1 ------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation add(case=normal, size=32) for op ADD(rd: R, rs: R, rt: R):[context=null, type=ADD, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=ADD, testcase=add, ADD=ADD, ADD.rd=R, ADD.rd.i=#IMM, ADD.rs=R, ADD.rs.i=#IMM, ADD.rt=R, ADD.rt.i=#IMM}, bindings={ADD.rd.i=00001, ADD.rd=ADD.rd, ADD.rs.i=00011, ADD.rs=ADD.rs, ADD.rt.i=00101, ADD.rt=ADD.rt}, parameters={case=normal, size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {ADD.rs=Argument [name=rs, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], ADD.rt=Argument [name=rt, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], ADD.rd=Argument [name=rd, kind=MODE, value=mode R(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation add(case=overflow, size=32) for op ADD(rd: R, rs: R, rt: R):[context=null, type=ADD, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=ADD, testcase=add, ADD=ADD, ADD.rd=R, ADD.rd.i=#IMM, ADD.rs=R, ADD.rs.i=#IMM, ADD.rt=R, ADD.rt.i=#IMM}, bindings={ADD.rd.i=00010, ADD.rd=ADD.rd, ADD.rs.i=00100, ADD.rs=ADD.rs, ADD.rt.i=00110, ADD.rt=ADD.rt}, parameters={case=overflow, size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {ADD.rs=Argument [name=rs, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], ADD.rt=Argument [name=rt, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], ADD.rd=Argument [name=rd, kind=MODE, value=mode R(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: ADD, c2: ADD):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={vliw.c2.rs=00001010011100101001001110100101, vliw.c2.rt=11100000000010011010101000011111, vliw.c1.rs=11101110101111010100100101001000, vliw.c1.rt=01010000101011011101011100011110}]
    [apply] Creating code to assign 00001010011100101001001110100101 to mode R(i: #IMM = 4)...
    [apply] Creating code to assign 11100000000010011010101000011111 to mode R(i: #IMM = 6)...
    [apply] Creating code to assign 11101110101111010100100101001000 to mode R(i: #IMM = 3)...
    [apply] Creating code to assign 01010000101011011101011100011110 to mode R(i: #IMM = 5)...
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation fp.sub(case=normal, exp=8, frac=23) for op SUB_S(fd: F, fs: F, ft: F):[context=null, type=SUB_S, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=SUB_S, testcase=fp.sub, SUB_S=SUB_S, SUB_S.fd=F, SUB_S.fd.i=#IMM, SUB_S.fs=F, SUB_S.fs.i=#IMM, SUB_S.ft=F, SUB_S.ft.i=#IMM}, bindings={SUB_S.fd.i=01001, SUB_S.fd=SUB_S.fd, SUB_S.fs.i=01001, SUB_S.fs=SUB_S.fs, SUB_S.ft.i=01010, SUB_S.ft=SUB_S.ft}, parameters={case=normal, exp=8, frac=23}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {SUB_S.fs=Argument [name=fs, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)], SUB_S.fd=Argument [name=fd, kind=MODE, value=mode F(i: #IMM), mode=OUT, type=Type.FLOAT(23, 8)], SUB_S.ft=Argument [name=ft, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation fp.sub(case=overflow, exp=8, frac=23) for op SUB_S(fd: F, fs: F, ft: F):[context=null, type=SUB_S, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=SUB_S, testcase=fp.sub, SUB_S=SUB_S, SUB_S.fd=F, SUB_S.fd.i=#IMM, SUB_S.fs=F, SUB_S.fs.i=#IMM, SUB_S.ft=F, SUB_S.ft.i=#IMM}, bindings={SUB_S.fd.i=01011, SUB_S.fd=SUB_S.fd, SUB_S.fs.i=01011, SUB_S.fs=SUB_S.fs, SUB_S.ft.i=01100, SUB_S.ft=SUB_S.ft}, parameters={case=overflow, exp=8, frac=23}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {SUB_S.fs=Argument [name=fs, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)], SUB_S.fd=Argument [name=fd, kind=MODE, value=mode F(i: #IMM), mode=OUT, type=Type.FLOAT(23, 8)], SUB_S.ft=Argument [name=ft, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: SUB_S, c2: SUB_S):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={vliw.c2.fs=00011000011010000001001001000000, vliw.c2.ft=11101001110110101000011111100111, vliw.c1.ft=10010001101100001110101011001011, vliw.c1.fs=00100101011101110101000001011100}]
    [apply] Creating code to assign 00011000011010000001001001000000 to mode F(i: #IMM = 11)...
    [apply] Creating code to assign 11101001110110101000011111100111 to mode F(i: #IMM = 12)...
    [apply] Creating code to assign 10010001101100001110101011001011 to mode F(i: #IMM = 10)...
    [apply] Creating code to assign 00100101011101110101000001011100 to mode F(i: #IMM = 9)...
    [apply] 
    [apply] ---------------------------- Executing Test Case 1 -----------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] LUI 4, 2674; ADDI 4, 4, 37797;
    [apply] LUI 6, 57353; ADDI 6, 6, 43551;
    [apply] LUI 3, 61117; ADDI 3, 3, 18760;
    [apply] LUI 5, 20653; ADDI 5, 5, 55070;
    [apply] LUI 25, 6248; ADDI 25, 25, 4672;
    [apply] MTF 25, 11; NOP;
    [apply] LUI 25, 59866; ADDI 25, 25, 34791;
    [apply] MTF 25, 12; NOP;
    [apply] LUI 25, 37296; ADDI 25, 25, 60107;
    [apply] MTF 25, 10; NOP;
    [apply] LUI 25, 9591; ADDI 25, 25, 20572;
    [apply] MTF 25, 9; NOP;
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] ADD 1, 3, 5; ADD 2, 4, 6;
    [apply] SUB_S 9, 9, 10; SUB_S 11, 11, 12;
    [apply] 
    [apply] ----------------------------- Printing Test Case 1 -----------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] // Initializer for R
    [apply] LUI 4, 2674; ADDI 4, 4, 37797;
    [apply] // Initializer for R
    [apply] LUI 6, 57353; ADDI 6, 6, 43551;
    [apply] // Initializer for R
    [apply] LUI 3, 61117; ADDI 3, 3, 18760;
    [apply] // Initializer for R
    [apply] LUI 5, 20653; ADDI 5, 5, 55070;
    [apply] // Initializer for F
    [apply] LUI 25, 6248; ADDI 25, 25, 4672;
    [apply] MTF 25, 11; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 59866; ADDI 25, 25, 34791;
    [apply] MTF 25, 12; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 37296; ADDI 25, 25, 60107;
    [apply] MTF 25, 10; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 9591; ADDI 25, 25, 20572;
    [apply] MTF 25, 9; NOP;
    [apply] 
    [apply] Stimulus
    [apply] ADD 1, 3, 5; ADD 2, 4, 6;
    [apply] SUB_S 9, 9, 10; SUB_S 11, 11, 12;
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Generating Data for Test Case 2 ------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation fp.add(case=underflow, exp=8, frac=23) for op ADD_S(fd: F, fs: F, ft: F):[context=null, type=ADD_S, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=ADD_S, testcase=fp.add, ADD_S=ADD_S, ADD_S.fd=F, ADD_S.fd.i=#IMM, ADD_S.fs=F, ADD_S.fs.i=#IMM, ADD_S.ft=F, ADD_S.ft.i=#IMM}, bindings={ADD_S.fd.i=00101, ADD_S.fd=ADD_S.fd, ADD_S.fs.i=00101, ADD_S.fs=ADD_S.fs, ADD_S.ft.i=00110, ADD_S.ft=ADD_S.ft}, parameters={case=underflow, exp=8, frac=23}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {ADD_S.fd=Argument [name=fd, kind=MODE, value=mode F(i: #IMM), mode=OUT, type=Type.FLOAT(23, 8)], ADD_S.ft=Argument [name=ft, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)], ADD_S.fs=Argument [name=fs, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation fp.add(case=inexact, exp=8, frac=23) for op ADD_S(fd: F, fs: F, ft: F):[context=null, type=ADD_S, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=ADD_S, testcase=fp.add, ADD_S=ADD_S, ADD_S.fd=F, ADD_S.fd.i=#IMM, ADD_S.fs=F, ADD_S.fs.i=#IMM, ADD_S.ft=F, ADD_S.ft.i=#IMM}, bindings={ADD_S.fd.i=00111, ADD_S.fd=ADD_S.fd, ADD_S.fs.i=00111, ADD_S.fs=ADD_S.fs, ADD_S.ft.i=01000, ADD_S.ft=ADD_S.ft}, parameters={case=inexact, exp=8, frac=23}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {ADD_S.fd=Argument [name=fd, kind=MODE, value=mode F(i: #IMM), mode=OUT, type=Type.FLOAT(23, 8)], ADD_S.ft=Argument [name=ft, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)], ADD_S.fs=Argument [name=fs, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: ADD_S, c2: ADD_S):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={vliw.c2.fs=11010000110100001100011001111011, vliw.c2.ft=01001010111010110001101111010110, vliw.c1.ft=00110110000011000001010001101101, vliw.c1.fs=11011011001111101001100010101000}]
    [apply] Creating code to assign 11010000110100001100011001111011 to mode F(i: #IMM = 7)...
    [apply] Creating code to assign 01001010111010110001101111010110 to mode F(i: #IMM = 8)...
    [apply] Creating code to assign 00110110000011000001010001101101 to mode F(i: #IMM = 6)...
    [apply] Creating code to assign 11011011001111101001100010101000 to mode F(i: #IMM = 5)...
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation sub(case=normal, size=32) for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=SUB, testcase=sub, SUB=SUB, SUB.rd=R, SUB.rd.i=#IMM, SUB.rs=R, SUB.rs.i=#IMM, SUB.rt=R, SUB.rt.i=#IMM}, bindings={SUB.rd.i=00111, SUB.rd=SUB.rd, SUB.rs.i=01000, SUB.rs=SUB.rs, SUB.rt.i=01001, SUB.rt=SUB.rt}, parameters={case=normal, size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {SUB.rs=Argument [name=rs, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], SUB.rd=Argument [name=rd, kind=MODE, value=mode R(i: #IMM), mode=OUT, type=Type.INT(32)], SUB.rt=Argument [name=rt, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation sub(case=overflow, size=32) for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=SUB, testcase=sub, SUB=SUB, SUB.rd=R, SUB.rd.i=#IMM, SUB.rs=R, SUB.rs.i=#IMM, SUB.rt=R, SUB.rt.i=#IMM}, bindings={SUB.rd.i=01010, SUB.rd=SUB.rd, SUB.rs.i=01011, SUB.rs=SUB.rs, SUB.rt.i=01100, SUB.rt=SUB.rt}, parameters={case=overflow, size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {SUB.rs=Argument [name=rs, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], SUB.rd=Argument [name=rd, kind=MODE, value=mode R(i: #IMM), mode=OUT, type=Type.INT(32)], SUB.rt=Argument [name=rt, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: SUB, c2: SUB):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={vliw.c2.rs=01100011000101010011010011001001, vliw.c2.rt=00000000110000010010000101011001, vliw.c1.rs=10000111000011101110111111011011, vliw.c1.rt=00010100110001110111000110010110}]
    [apply] Creating code to assign 01100011000101010011010011001001 to mode R(i: #IMM = 11)...
    [apply] Creating code to assign 00000000110000010010000101011001 to mode R(i: #IMM = 12)...
    [apply] Creating code to assign 10000111000011101110111111011011 to mode R(i: #IMM = 8)...
    [apply] Creating code to assign 00010100110001110111000110010110 to mode R(i: #IMM = 9)...
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] ---------------------------- Executing Test Case 2 -----------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] LUI 25, 53456; ADDI 25, 25, 50811;
    [apply] MTF 25, 7; NOP;
    [apply] LUI 25, 19179; ADDI 25, 25, 7126;
    [apply] MTF 25, 8; NOP;
    [apply] LUI 25, 13836; ADDI 25, 25, 5229;
    [apply] MTF 25, 6; NOP;
    [apply] LUI 25, 56126; ADDI 25, 25, 39080;
    [apply] MTF 25, 5; NOP;
    [apply] LUI 11, 25365; ADDI 11, 11, 13513;
    [apply] LUI 12, 193; ADDI 12, 12, 8537;
    [apply] LUI 8, 34574; ADDI 8, 8, 61403;
    [apply] LUI 9, 5319; ADDI 9, 9, 29078;
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] ADD_S 5, 5, 6; ADD_S 7, 7, 8;
    [apply] SUB 7, 8, 9; SUB 10, 11, 12;
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] ----------------------------- Printing Test Case 2 -----------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] // Initializer for F
    [apply] LUI 25, 53456; ADDI 25, 25, 50811;
    [apply] MTF 25, 7; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 19179; ADDI 25, 25, 7126;
    [apply] MTF 25, 8; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 13836; ADDI 25, 25, 5229;
    [apply] MTF 25, 6; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 56126; ADDI 25, 25, 39080;
    [apply] MTF 25, 5; NOP;
    [apply] // Initializer for R
    [apply] LUI 11, 25365; ADDI 11, 11, 13513;
    [apply] // Initializer for R
    [apply] LUI 12, 193; ADDI 12, 12, 8537;
    [apply] // Initializer for R
    [apply] LUI 8, 34574; ADDI 8, 8, 61403;
    [apply] // Initializer for R
    [apply] LUI 9, 5319; ADDI 9, 9, 29078;
    [apply] 
    [apply] Stimulus
    [apply] ADD_S 5, 5, 6; ADD_S 7, 7, 8;
    [apply] SUB 7, 8, 9; SUB 10, 11, 12;
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Generating Data for Test Case 3 ------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation sub(case=normal, size=32) for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=SUB, testcase=sub, SUB=SUB, SUB.rd=R, SUB.rd.i=#IMM, SUB.rs=R, SUB.rs.i=#IMM, SUB.rt=R, SUB.rt.i=#IMM}, bindings={SUB.rd.i=00111, SUB.rd=SUB.rd, SUB.rs.i=01000, SUB.rs=SUB.rs, SUB.rt.i=01001, SUB.rt=SUB.rt}, parameters={case=normal, size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {SUB.rs=Argument [name=rs, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], SUB.rd=Argument [name=rd, kind=MODE, value=mode R(i: #IMM), mode=OUT, type=Type.INT(32)], SUB.rt=Argument [name=rt, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation sub(case=overflow, size=32) for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=SUB, testcase=sub, SUB=SUB, SUB.rd=R, SUB.rd.i=#IMM, SUB.rs=R, SUB.rs.i=#IMM, SUB.rt=R, SUB.rt.i=#IMM}, bindings={SUB.rd.i=01010, SUB.rd=SUB.rd, SUB.rs.i=01011, SUB.rs=SUB.rs, SUB.rt.i=01100, SUB.rt=SUB.rt}, parameters={case=overflow, size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {SUB.rs=Argument [name=rs, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], SUB.rd=Argument [name=rd, kind=MODE, value=mode R(i: #IMM), mode=OUT, type=Type.INT(32)], SUB.rt=Argument [name=rt, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: SUB, c2: SUB):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={vliw.c2.rs=01011000001101111011000010000011, vliw.c2.rt=00000011010000001000001100010010, vliw.c1.rs=11100111110001001010111101011010, vliw.c1.rt=00011100111100011000011000101111}]
    [apply] Creating code to assign 01011000001101111011000010000011 to mode R(i: #IMM = 11)...
    [apply] Creating code to assign 00000011010000001000001100010010 to mode R(i: #IMM = 12)...
    [apply] Creating code to assign 11100111110001001010111101011010 to mode R(i: #IMM = 8)...
    [apply] Creating code to assign 00011100111100011000011000101111 to mode R(i: #IMM = 9)...
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation fp.sub(case=normal, exp=8, frac=23) for op SUB_S(fd: F, fs: F, ft: F):[context=null, type=SUB_S, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=SUB_S, testcase=fp.sub, SUB_S=SUB_S, SUB_S.fd=F, SUB_S.fd.i=#IMM, SUB_S.fs=F, SUB_S.fs.i=#IMM, SUB_S.ft=F, SUB_S.ft.i=#IMM}, bindings={SUB_S.fd.i=01001, SUB_S.fd=SUB_S.fd, SUB_S.fs.i=01001, SUB_S.fs=SUB_S.fs, SUB_S.ft.i=01010, SUB_S.ft=SUB_S.ft}, parameters={case=normal, exp=8, frac=23}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {SUB_S.fs=Argument [name=fs, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)], SUB_S.fd=Argument [name=fd, kind=MODE, value=mode F(i: #IMM), mode=OUT, type=Type.FLOAT(23, 8)], SUB_S.ft=Argument [name=ft, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation fp.sub(case=overflow, exp=8, frac=23) for op SUB_S(fd: F, fs: F, ft: F):[context=null, type=SUB_S, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=SUB_S, testcase=fp.sub, SUB_S=SUB_S, SUB_S.fd=F, SUB_S.fd.i=#IMM, SUB_S.fs=F, SUB_S.fs.i=#IMM, SUB_S.ft=F, SUB_S.ft.i=#IMM}, bindings={SUB_S.fd.i=01011, SUB_S.fd=SUB_S.fd, SUB_S.fs.i=01011, SUB_S.fs=SUB_S.fs, SUB_S.ft.i=01100, SUB_S.ft=SUB_S.ft}, parameters={case=overflow, exp=8, frac=23}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {SUB_S.fs=Argument [name=fs, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)], SUB_S.fd=Argument [name=fd, kind=MODE, value=mode F(i: #IMM), mode=OUT, type=Type.FLOAT(23, 8)], SUB_S.ft=Argument [name=ft, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: SUB_S, c2: SUB_S):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={vliw.c2.fs=01011011011000101110100011010110, vliw.c2.ft=01100010000111100101111010010000, vliw.c1.ft=11111101000001111111011001001110, vliw.c1.fs=10111010000010011001111010111001}]
    [apply] Creating code to assign 01011011011000101110100011010110 to mode F(i: #IMM = 11)...
    [apply] Creating code to assign 01100010000111100101111010010000 to mode F(i: #IMM = 12)...
    [apply] Creating code to assign 11111101000001111111011001001110 to mode F(i: #IMM = 10)...
    [apply] Creating code to assign 10111010000010011001111010111001 to mode F(i: #IMM = 9)...
    [apply] 
    [apply] ---------------------------- Executing Test Case 3 -----------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] LUI 11, 22583; ADDI 11, 11, 45187;
    [apply] LUI 12, 832; ADDI 12, 12, 33554;
    [apply] LUI 8, 59332; ADDI 8, 8, 44890;
    [apply] LUI 9, 7409; ADDI 9, 9, 34351;
    [apply] LUI 25, 23394; ADDI 25, 25, 59606;
    [apply] MTF 25, 11; NOP;
    [apply] LUI 25, 25118; ADDI 25, 25, 24208;
    [apply] MTF 25, 12; NOP;
    [apply] LUI 25, 64775; ADDI 25, 25, 63054;
    [apply] MTF 25, 10; NOP;
    [apply] LUI 25, 47625; ADDI 25, 25, 40633;
    [apply] MTF 25, 9; NOP;
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] SUB 7, 8, 9; SUB 10, 11, 12;
    [apply] SUB_S 9, 9, 10; SUB_S 11, 11, 12;
    [apply] 
    [apply] ----------------------------- Printing Test Case 3 -----------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] // Initializer for R
    [apply] LUI 11, 22583; ADDI 11, 11, 45187;
    [apply] // Initializer for R
    [apply] LUI 12, 832; ADDI 12, 12, 33554;
    [apply] // Initializer for R
    [apply] LUI 8, 59332; ADDI 8, 8, 44890;
    [apply] // Initializer for R
    [apply] LUI 9, 7409; ADDI 9, 9, 34351;
    [apply] // Initializer for F
    [apply] LUI 25, 23394; ADDI 25, 25, 59606;
    [apply] MTF 25, 11; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 25118; ADDI 25, 25, 24208;
    [apply] MTF 25, 12; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 64775; ADDI 25, 25, 63054;
    [apply] MTF 25, 10; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 47625; ADDI 25, 25, 40633;
    [apply] MTF 25, 9; NOP;
    [apply] 
    [apply] Stimulus
    [apply] SUB 7, 8, 9; SUB 10, 11, 12;
    [apply] SUB_S 9, 9, 10; SUB_S 11, 11, 12;
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.540 seconds 
    [apply] Generation rate: 162 instructions/second
    [apply] Programs/stimuli/instructions: 1/4/88
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: vliw
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\demo\vliw\templates\euclid.rb
    [apply] Loaded template VliwBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/vliw_base.rb
    [apply] Loaded template EuclidTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/euclid.rb
    [apply] Processing template EuclidTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/euclid.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: R
    [apply] Output (runtime: false): "// Initializer for R"
    [apply] Operation: LUI
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: R
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: F
    [apply] Output (runtime: false): "// Initializer for F"
    [apply] Addressing mode: R
    [apply] Operation: LUI
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Operation: MTF
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: F
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Output (runtime: true): "Euclidean Algorithm: Debug Output"
    [apply] Output (runtime: true): "Input parameter values: %d, %d", 58, 33
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: cycle_1
    [apply] Output (runtime: true): "Current register values: $4 = %d, $5 = %d", GPR[4], GPR[5]
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: BEQ
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: MOVE
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SLT
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: BNE
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: B
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SUB
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: if_less_1
    [apply] Operation: B
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SUB
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: done_1
    [apply] Output (runtime: true): "Result stored in $6: %d", GPR[6]
    [apply] Ended building a call (empty = false, executable = false)
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={ADDI.rs=10010001101001101010101011000011}]
    [apply] Creating code to assign 10010001101001101010101011000011 to mode R(i: #IMM = 0)...
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: ADDI, c2: ADDI):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op BEQ(rs: R, rt: R, offset: #IMM):[context=null, type=BEQ, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op MOVE(rd: R, rs: R):[context=null, type=MOVE, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: BEQ, c2: MOVE):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op SLT(rd: R, rs: R, rt: R):[context=null, type=SLT, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: SLT, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op BNE(rs: R, rt: R, offset: #IMM):[context=null, type=BNE, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: BNE, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op B(offset: #IMM):[context=null, type=B, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: B, c2: SUB):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op B(offset: #IMM):[context=null, type=B, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: B, c2: SUB):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] LUI 0, 37286; ADDI 0, 0, 43715;
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] Euclidean Algorithm: Debug Output
    [apply] 
    [apply] Input parameter values: 58, 33
    [apply] 
    [apply] ADDI 4, 0, 58; ADDI 5, 0, 33;
    [apply] 
    [apply] Current register values: $4 = 58, $5 = 33
    [apply] 
    [apply] BEQ 4, 5, done_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less_1; NOP;
    [apply] B cycle_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $4 = 25, $5 = 33
    [apply] 
    [apply] BEQ 4, 5, done_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SUB 5, 5, 4;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $4 = 25, $5 = 8
    [apply] 
    [apply] BEQ 4, 5, done_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less_1; NOP;
    [apply] B cycle_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $4 = 17, $5 = 8
    [apply] 
    [apply] BEQ 4, 5, done_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less_1; NOP;
    [apply] B cycle_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $4 = 9, $5 = 8
    [apply] 
    [apply] BEQ 4, 5, done_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less_1; NOP;
    [apply] B cycle_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $4 = 1, $5 = 8
    [apply] 
    [apply] BEQ 4, 5, done_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SUB 5, 5, 4;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $4 = 1, $5 = 7
    [apply] 
    [apply] BEQ 4, 5, done_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SUB 5, 5, 4;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $4 = 1, $5 = 6
    [apply] 
    [apply] BEQ 4, 5, done_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SUB 5, 5, 4;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $4 = 1, $5 = 5
    [apply] 
    [apply] BEQ 4, 5, done_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SUB 5, 5, 4;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $4 = 1, $5 = 4
    [apply] 
    [apply] BEQ 4, 5, done_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SUB 5, 5, 4;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $4 = 1, $5 = 3
    [apply] 
    [apply] BEQ 4, 5, done_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SUB 5, 5, 4;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $4 = 1, $5 = 2
    [apply] 
    [apply] BEQ 4, 5, done_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SUB 5, 5, 4;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $4 = 1, $5 = 1
    [apply] 
    [apply] BEQ 4, 5, done_1; MOVE 6, 4;
    [apply] Jump to label: done_1
    [apply] 
    [apply] Result stored in $6: 1
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] // Initializer for R
    [apply] LUI 0, 37286; ADDI 0, 0, 43715;
    [apply] 
    [apply] Stimulus
    [apply] ADDI 4, 0, 58; ADDI 5, 0, 33;
    [apply] cycle_1:
    [apply] BEQ 4, 5, done_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less_1; NOP;
    [apply] B cycle_1; SUB 4, 4, 5;
    [apply] if_less_1:
    [apply] B cycle_1; SUB 5, 5, 4;
    [apply] done_1:
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.126 seconds 
    [apply] Generation rate: 71 instructions/second
    [apply] Programs/stimuli/instructions: 1/1/9
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: vliw
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\demo\vliw\templates\euclid_loop.rb
    [apply] Loaded template VliwBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/vliw_base.rb
    [apply] Loaded template EuclidLoopTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/euclid_loop.rb
    [apply] Processing template EuclidLoopTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/euclid_loop.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: R
    [apply] Output (runtime: false): "// Initializer for R"
    [apply] Operation: LUI
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: R
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: F
    [apply] Output (runtime: false): "// Initializer for F"
    [apply] Addressing mode: R
    [apply] Operation: LUI
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Operation: MTF
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: F
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Output (runtime: true): "Euclidean Algorithm: Debug Output"
    [apply] Output (runtime: true): "--------------------------------------------------------------------------------"
    [apply] Output (runtime: true): "Input parameter values (iteration 1): %d, %d", 58, 33
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: cycle1_1
    [apply] Output (runtime: true): "Current register values (iteration 1): $4 = %d, $5 = %d", GPR[4], GPR[5]
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: BEQ
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: MOVE
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SLT
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: BNE
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: B
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SUB
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: if_less1_1
    [apply] Operation: B
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SUB
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: done1_1
    [apply] Output (runtime: true): "Result stored in $6 (iteration 1): %d", GPR[6]
    [apply] Output (runtime: true): "--------------------------------------------------------------------------------"
    [apply] Output (runtime: true): "Input parameter values (iteration 2): %d, %d", 44, 52
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: cycle2_1
    [apply] Output (runtime: true): "Current register values (iteration 2): $4 = %d, $5 = %d", GPR[4], GPR[5]
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: BEQ
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: MOVE
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SLT
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: BNE
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: B
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SUB
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: if_less2_1
    [apply] Operation: B
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SUB
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: done2_1
    [apply] Output (runtime: true): "Result stored in $6 (iteration 2): %d", GPR[6]
    [apply] Output (runtime: true): "--------------------------------------------------------------------------------"
    [apply] Output (runtime: true): "Input parameter values (iteration 3): %d, %d", 63, 45
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: cycle3_1
    [apply] Output (runtime: true): "Current register values (iteration 3): $4 = %d, $5 = %d", GPR[4], GPR[5]
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: BEQ
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: MOVE
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SLT
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: BNE
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: B
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SUB
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: if_less3_1
    [apply] Operation: B
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SUB
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: done3_1
    [apply] Output (runtime: true): "Result stored in $6 (iteration 3): %d", GPR[6]
    [apply] Output (runtime: true): "--------------------------------------------------------------------------------"
    [apply] Output (runtime: true): "Input parameter values (iteration 4): %d, %d", 48, 48
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: cycle4_1
    [apply] Output (runtime: true): "Current register values (iteration 4): $4 = %d, $5 = %d", GPR[4], GPR[5]
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: BEQ
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: MOVE
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SLT
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: BNE
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: B
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SUB
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: if_less4_1
    [apply] Operation: B
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SUB
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: done4_1
    [apply] Output (runtime: true): "Result stored in $6 (iteration 4): %d", GPR[6]
    [apply] Output (runtime: true): "--------------------------------------------------------------------------------"
    [apply] Output (runtime: true): "Input parameter values (iteration 5): %d, %d", 63, 4
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: cycle5_1
    [apply] Output (runtime: true): "Current register values (iteration 5): $4 = %d, $5 = %d", GPR[4], GPR[5]
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: BEQ
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: MOVE
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SLT
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: BNE
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: B
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SUB
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: if_less5_1
    [apply] Operation: B
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SUB
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: done5_1
    [apply] Output (runtime: true): "Result stored in $6 (iteration 5): %d", GPR[6]
    [apply] Ended building a call (empty = false, executable = false)
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={ADDI.rs=11100101000010001011110111100101}]
    [apply] Creating code to assign 11100101000010001011110111100101 to mode R(i: #IMM = 0)...
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: ADDI, c2: ADDI):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op BEQ(rs: R, rt: R, offset: #IMM):[context=null, type=BEQ, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op MOVE(rd: R, rs: R):[context=null, type=MOVE, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: BEQ, c2: MOVE):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op SLT(rd: R, rs: R, rt: R):[context=null, type=SLT, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: SLT, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op BNE(rs: R, rt: R, offset: #IMM):[context=null, type=BNE, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: BNE, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op B(offset: #IMM):[context=null, type=B, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: B, c2: SUB):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op B(offset: #IMM):[context=null, type=B, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: B, c2: SUB):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: ADDI, c2: ADDI):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op BEQ(rs: R, rt: R, offset: #IMM):[context=null, type=BEQ, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op MOVE(rd: R, rs: R):[context=null, type=MOVE, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: BEQ, c2: MOVE):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op SLT(rd: R, rs: R, rt: R):[context=null, type=SLT, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: SLT, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op BNE(rs: R, rt: R, offset: #IMM):[context=null, type=BNE, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: BNE, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op B(offset: #IMM):[context=null, type=B, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: B, c2: SUB):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op B(offset: #IMM):[context=null, type=B, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: B, c2: SUB):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: ADDI, c2: ADDI):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op BEQ(rs: R, rt: R, offset: #IMM):[context=null, type=BEQ, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op MOVE(rd: R, rs: R):[context=null, type=MOVE, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: BEQ, c2: MOVE):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op SLT(rd: R, rs: R, rt: R):[context=null, type=SLT, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: SLT, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op BNE(rs: R, rt: R, offset: #IMM):[context=null, type=BNE, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: BNE, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op B(offset: #IMM):[context=null, type=B, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: B, c2: SUB):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op B(offset: #IMM):[context=null, type=B, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: B, c2: SUB):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: ADDI, c2: ADDI):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op BEQ(rs: R, rt: R, offset: #IMM):[context=null, type=BEQ, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op MOVE(rd: R, rs: R):[context=null, type=MOVE, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: BEQ, c2: MOVE):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op SLT(rd: R, rs: R, rt: R):[context=null, type=SLT, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: SLT, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op BNE(rs: R, rt: R, offset: #IMM):[context=null, type=BNE, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: BNE, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op B(offset: #IMM):[context=null, type=B, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: B, c2: SUB):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op B(offset: #IMM):[context=null, type=B, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: B, c2: SUB):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: ADDI, c2: ADDI):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op BEQ(rs: R, rt: R, offset: #IMM):[context=null, type=BEQ, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op MOVE(rd: R, rs: R):[context=null, type=MOVE, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: BEQ, c2: MOVE):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op SLT(rd: R, rs: R, rt: R):[context=null, type=SLT, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: SLT, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op BNE(rs: R, rt: R, offset: #IMM):[context=null, type=BNE, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: BNE, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op B(offset: #IMM):[context=null, type=B, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: B, c2: SUB):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op B(offset: #IMM):[context=null, type=B, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: B, c2: SUB):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] LUI 0, 58632; ADDI 0, 0, 48613;
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] Euclidean Algorithm: Debug Output
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Input parameter values (iteration 1): 58, 33
    [apply] 
    [apply] ADDI 4, 0, 58; ADDI 5, 0, 33;
    [apply] 
    [apply] Current register values (iteration 1): $4 = 58, $5 = 33
    [apply] 
    [apply] BEQ 4, 5, done1_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less1_1; NOP;
    [apply] B cycle1_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle1_1
    [apply] 
    [apply] Current register values (iteration 1): $4 = 25, $5 = 33
    [apply] 
    [apply] BEQ 4, 5, done1_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less1_1; NOP;
    [apply] Jump to label: if_less1_1
    [apply] B cycle1_1; SUB 5, 5, 4;
    [apply] Jump to label: cycle1_1
    [apply] 
    [apply] Current register values (iteration 1): $4 = 25, $5 = 8
    [apply] 
    [apply] BEQ 4, 5, done1_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less1_1; NOP;
    [apply] B cycle1_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle1_1
    [apply] 
    [apply] Current register values (iteration 1): $4 = 17, $5 = 8
    [apply] 
    [apply] BEQ 4, 5, done1_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less1_1; NOP;
    [apply] B cycle1_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle1_1
    [apply] 
    [apply] Current register values (iteration 1): $4 = 9, $5 = 8
    [apply] 
    [apply] BEQ 4, 5, done1_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less1_1; NOP;
    [apply] B cycle1_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle1_1
    [apply] 
    [apply] Current register values (iteration 1): $4 = 1, $5 = 8
    [apply] 
    [apply] BEQ 4, 5, done1_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less1_1; NOP;
    [apply] Jump to label: if_less1_1
    [apply] B cycle1_1; SUB 5, 5, 4;
    [apply] Jump to label: cycle1_1
    [apply] 
    [apply] Current register values (iteration 1): $4 = 1, $5 = 7
    [apply] 
    [apply] BEQ 4, 5, done1_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less1_1; NOP;
    [apply] Jump to label: if_less1_1
    [apply] B cycle1_1; SUB 5, 5, 4;
    [apply] Jump to label: cycle1_1
    [apply] 
    [apply] Current register values (iteration 1): $4 = 1, $5 = 6
    [apply] 
    [apply] BEQ 4, 5, done1_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less1_1; NOP;
    [apply] Jump to label: if_less1_1
    [apply] B cycle1_1; SUB 5, 5, 4;
    [apply] Jump to label: cycle1_1
    [apply] 
    [apply] Current register values (iteration 1): $4 = 1, $5 = 5
    [apply] 
    [apply] BEQ 4, 5, done1_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less1_1; NOP;
    [apply] Jump to label: if_less1_1
    [apply] B cycle1_1; SUB 5, 5, 4;
    [apply] Jump to label: cycle1_1
    [apply] 
    [apply] Current register values (iteration 1): $4 = 1, $5 = 4
    [apply] 
    [apply] BEQ 4, 5, done1_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less1_1; NOP;
    [apply] Jump to label: if_less1_1
    [apply] B cycle1_1; SUB 5, 5, 4;
    [apply] Jump to label: cycle1_1
    [apply] 
    [apply] Current register values (iteration 1): $4 = 1, $5 = 3
    [apply] 
    [apply] BEQ 4, 5, done1_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less1_1; NOP;
    [apply] Jump to label: if_less1_1
    [apply] B cycle1_1; SUB 5, 5, 4;
    [apply] Jump to label: cycle1_1
    [apply] 
    [apply] Current register values (iteration 1): $4 = 1, $5 = 2
    [apply] 
    [apply] BEQ 4, 5, done1_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less1_1; NOP;
    [apply] Jump to label: if_less1_1
    [apply] B cycle1_1; SUB 5, 5, 4;
    [apply] Jump to label: cycle1_1
    [apply] 
    [apply] Current register values (iteration 1): $4 = 1, $5 = 1
    [apply] 
    [apply] BEQ 4, 5, done1_1; MOVE 6, 4;
    [apply] Jump to label: done1_1
    [apply] 
    [apply] Result stored in $6 (iteration 1): 1
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Input parameter values (iteration 2): 44, 52
    [apply] 
    [apply] ADDI 4, 0, 44; ADDI 5, 0, 52;
    [apply] 
    [apply] Current register values (iteration 2): $4 = 44, $5 = 52
    [apply] 
    [apply] BEQ 4, 5, done2_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less2_1; NOP;
    [apply] Jump to label: if_less2_1
    [apply] B cycle2_1; SUB 5, 5, 4;
    [apply] Jump to label: cycle2_1
    [apply] 
    [apply] Current register values (iteration 2): $4 = 44, $5 = 8
    [apply] 
    [apply] BEQ 4, 5, done2_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less2_1; NOP;
    [apply] B cycle2_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle2_1
    [apply] 
    [apply] Current register values (iteration 2): $4 = 36, $5 = 8
    [apply] 
    [apply] BEQ 4, 5, done2_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less2_1; NOP;
    [apply] B cycle2_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle2_1
    [apply] 
    [apply] Current register values (iteration 2): $4 = 28, $5 = 8
    [apply] 
    [apply] BEQ 4, 5, done2_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less2_1; NOP;
    [apply] B cycle2_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle2_1
    [apply] 
    [apply] Current register values (iteration 2): $4 = 20, $5 = 8
    [apply] 
    [apply] BEQ 4, 5, done2_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less2_1; NOP;
    [apply] B cycle2_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle2_1
    [apply] 
    [apply] Current register values (iteration 2): $4 = 12, $5 = 8
    [apply] 
    [apply] BEQ 4, 5, done2_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less2_1; NOP;
    [apply] B cycle2_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle2_1
    [apply] 
    [apply] Current register values (iteration 2): $4 = 4, $5 = 8
    [apply] 
    [apply] BEQ 4, 5, done2_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less2_1; NOP;
    [apply] Jump to label: if_less2_1
    [apply] B cycle2_1; SUB 5, 5, 4;
    [apply] Jump to label: cycle2_1
    [apply] 
    [apply] Current register values (iteration 2): $4 = 4, $5 = 4
    [apply] 
    [apply] BEQ 4, 5, done2_1; MOVE 6, 4;
    [apply] Jump to label: done2_1
    [apply] 
    [apply] Result stored in $6 (iteration 2): 4
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Input parameter values (iteration 3): 63, 45
    [apply] 
    [apply] ADDI 4, 0, 63; ADDI 5, 0, 45;
    [apply] 
    [apply] Current register values (iteration 3): $4 = 63, $5 = 45
    [apply] 
    [apply] BEQ 4, 5, done3_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less3_1; NOP;
    [apply] B cycle3_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle3_1
    [apply] 
    [apply] Current register values (iteration 3): $4 = 18, $5 = 45
    [apply] 
    [apply] BEQ 4, 5, done3_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less3_1; NOP;
    [apply] Jump to label: if_less3_1
    [apply] B cycle3_1; SUB 5, 5, 4;
    [apply] Jump to label: cycle3_1
    [apply] 
    [apply] Current register values (iteration 3): $4 = 18, $5 = 27
    [apply] 
    [apply] BEQ 4, 5, done3_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less3_1; NOP;
    [apply] Jump to label: if_less3_1
    [apply] B cycle3_1; SUB 5, 5, 4;
    [apply] Jump to label: cycle3_1
    [apply] 
    [apply] Current register values (iteration 3): $4 = 18, $5 = 9
    [apply] 
    [apply] BEQ 4, 5, done3_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less3_1; NOP;
    [apply] B cycle3_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle3_1
    [apply] 
    [apply] Current register values (iteration 3): $4 = 9, $5 = 9
    [apply] 
    [apply] BEQ 4, 5, done3_1; MOVE 6, 4;
    [apply] Jump to label: done3_1
    [apply] 
    [apply] Result stored in $6 (iteration 3): 9
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Input parameter values (iteration 4): 48, 48
    [apply] 
    [apply] ADDI 4, 0, 48; ADDI 5, 0, 48;
    [apply] 
    [apply] Current register values (iteration 4): $4 = 48, $5 = 48
    [apply] 
    [apply] BEQ 4, 5, done4_1; MOVE 6, 4;
    [apply] Jump to label: done4_1
    [apply] 
    [apply] Result stored in $6 (iteration 4): 48
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Input parameter values (iteration 5): 63, 4
    [apply] 
    [apply] ADDI 4, 0, 63; ADDI 5, 0, 4;
    [apply] 
    [apply] Current register values (iteration 5): $4 = 63, $5 = 4
    [apply] 
    [apply] BEQ 4, 5, done5_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less5_1; NOP;
    [apply] B cycle5_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle5_1
    [apply] 
    [apply] Current register values (iteration 5): $4 = 59, $5 = 4
    [apply] 
    [apply] BEQ 4, 5, done5_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less5_1; NOP;
    [apply] B cycle5_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle5_1
    [apply] 
    [apply] Current register values (iteration 5): $4 = 55, $5 = 4
    [apply] 
    [apply] BEQ 4, 5, done5_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less5_1; NOP;
    [apply] B cycle5_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle5_1
    [apply] 
    [apply] Current register values (iteration 5): $4 = 51, $5 = 4
    [apply] 
    [apply] BEQ 4, 5, done5_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less5_1; NOP;
    [apply] B cycle5_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle5_1
    [apply] 
    [apply] Current register values (iteration 5): $4 = 47, $5 = 4
    [apply] 
    [apply] BEQ 4, 5, done5_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less5_1; NOP;
    [apply] B cycle5_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle5_1
    [apply] 
    [apply] Current register values (iteration 5): $4 = 43, $5 = 4
    [apply] 
    [apply] BEQ 4, 5, done5_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less5_1; NOP;
    [apply] B cycle5_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle5_1
    [apply] 
    [apply] Current register values (iteration 5): $4 = 39, $5 = 4
    [apply] 
    [apply] BEQ 4, 5, done5_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less5_1; NOP;
    [apply] B cycle5_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle5_1
    [apply] 
    [apply] Current register values (iteration 5): $4 = 35, $5 = 4
    [apply] 
    [apply] BEQ 4, 5, done5_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less5_1; NOP;
    [apply] B cycle5_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle5_1
    [apply] 
    [apply] Current register values (iteration 5): $4 = 31, $5 = 4
    [apply] 
    [apply] BEQ 4, 5, done5_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less5_1; NOP;
    [apply] B cycle5_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle5_1
    [apply] 
    [apply] Current register values (iteration 5): $4 = 27, $5 = 4
    [apply] 
    [apply] BEQ 4, 5, done5_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less5_1; NOP;
    [apply] B cycle5_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle5_1
    [apply] 
    [apply] Current register values (iteration 5): $4 = 23, $5 = 4
    [apply] 
    [apply] BEQ 4, 5, done5_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less5_1; NOP;
    [apply] B cycle5_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle5_1
    [apply] 
    [apply] Current register values (iteration 5): $4 = 19, $5 = 4
    [apply] 
    [apply] BEQ 4, 5, done5_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less5_1; NOP;
    [apply] B cycle5_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle5_1
    [apply] 
    [apply] Current register values (iteration 5): $4 = 15, $5 = 4
    [apply] 
    [apply] BEQ 4, 5, done5_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less5_1; NOP;
    [apply] B cycle5_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle5_1
    [apply] 
    [apply] Current register values (iteration 5): $4 = 11, $5 = 4
    [apply] 
    [apply] BEQ 4, 5, done5_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less5_1; NOP;
    [apply] B cycle5_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle5_1
    [apply] 
    [apply] Current register values (iteration 5): $4 = 7, $5 = 4
    [apply] 
    [apply] BEQ 4, 5, done5_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less5_1; NOP;
    [apply] B cycle5_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle5_1
    [apply] 
    [apply] Current register values (iteration 5): $4 = 3, $5 = 4
    [apply] 
    [apply] BEQ 4, 5, done5_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less5_1; NOP;
    [apply] Jump to label: if_less5_1
    [apply] B cycle5_1; SUB 5, 5, 4;
    [apply] Jump to label: cycle5_1
    [apply] 
    [apply] Current register values (iteration 5): $4 = 3, $5 = 1
    [apply] 
    [apply] BEQ 4, 5, done5_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less5_1; NOP;
    [apply] B cycle5_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle5_1
    [apply] 
    [apply] Current register values (iteration 5): $4 = 2, $5 = 1
    [apply] 
    [apply] BEQ 4, 5, done5_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less5_1; NOP;
    [apply] B cycle5_1; SUB 4, 4, 5;
    [apply] Jump to label: cycle5_1
    [apply] 
    [apply] Current register values (iteration 5): $4 = 1, $5 = 1
    [apply] 
    [apply] BEQ 4, 5, done5_1; MOVE 6, 4;
    [apply] Jump to label: done5_1
    [apply] 
    [apply] Result stored in $6 (iteration 5): 1
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] // Initializer for R
    [apply] LUI 0, 58632; ADDI 0, 0, 48613;
    [apply] 
    [apply] Stimulus
    [apply] ADDI 4, 0, 58; ADDI 5, 0, 33;
    [apply] cycle1_1:
    [apply] BEQ 4, 5, done1_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less1_1; NOP;
    [apply] B cycle1_1; SUB 4, 4, 5;
    [apply] if_less1_1:
    [apply] B cycle1_1; SUB 5, 5, 4;
    [apply] done1_1:
    [apply] ADDI 4, 0, 44; ADDI 5, 0, 52;
    [apply] cycle2_1:
    [apply] BEQ 4, 5, done2_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less2_1; NOP;
    [apply] B cycle2_1; SUB 4, 4, 5;
    [apply] if_less2_1:
    [apply] B cycle2_1; SUB 5, 5, 4;
    [apply] done2_1:
    [apply] ADDI 4, 0, 63; ADDI 5, 0, 45;
    [apply] cycle3_1:
    [apply] BEQ 4, 5, done3_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less3_1; NOP;
    [apply] B cycle3_1; SUB 4, 4, 5;
    [apply] if_less3_1:
    [apply] B cycle3_1; SUB 5, 5, 4;
    [apply] done3_1:
    [apply] ADDI 4, 0, 48; ADDI 5, 0, 48;
    [apply] cycle4_1:
    [apply] BEQ 4, 5, done4_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less4_1; NOP;
    [apply] B cycle4_1; SUB 4, 4, 5;
    [apply] if_less4_1:
    [apply] B cycle4_1; SUB 5, 5, 4;
    [apply] done4_1:
    [apply] ADDI 4, 0, 63; ADDI 5, 0, 4;
    [apply] cycle5_1:
    [apply] BEQ 4, 5, done5_1; MOVE 6, 4;
    [apply] SLT 2, 4, 5; NOP;
    [apply] BNE 2, 0, if_less5_1; NOP;
    [apply] B cycle5_1; SUB 4, 4, 5;
    [apply] if_less5_1:
    [apply] B cycle5_1; SUB 5, 5, 4;
    [apply] done5_1:
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.824 seconds 
    [apply] Generation rate: 40 instructions/second
    [apply] Programs/stimuli/instructions: 1/1/33
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: vliw
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\demo\vliw\templates\fp_example.rb
    [apply] Loaded template VliwBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/vliw_base.rb
    [apply] Loaded template FpExampleTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/fp_example.rb
    [apply] Processing template FpExampleTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/fp_example.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: R
    [apply] Output (runtime: false): "// Initializer for R"
    [apply] Operation: LUI
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: R
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: F
    [apply] Output (runtime: false): "// Initializer for F"
    [apply] Addressing mode: R
    [apply] Operation: LUI
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Operation: MTF
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: F
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Operation: ADD_S
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Operation: SUB_S
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: false): "// zero (:size => 32)"
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Operation: ADD_S
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Operation: ADD_S
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Operation: ADD_S
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Operation: ADD_S
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op ADD_S(fd: F, fs: F, ft: F):[context=null, type=ADD_S, root=false]...
    [apply] TestData [bindings={ADD_S.ft=01010011010101011111101000111010, ADD_S.fs=01011010111000000000011111010010}]
    [apply] Creating code to assign 01010011010101011111101000111010 to mode F(i: #IMM = 6)...
    [apply] Creating code to assign 01011010111000000000011111010010 to mode F(i: #IMM = 5)...
    [apply] Processing situation null for op SUB_S(fd: F, fs: F, ft: F):[context=null, type=SUB_S, root=false]...
    [apply] TestData [bindings={SUB_S.fs=10101001110010010111000000100101, SUB_S.ft=11100110111101100111100011011110}]
    [apply] Creating code to assign 10101001110010010111000000100101 to mode F(i: #IMM = 4)...
    [apply] Creating code to assign 11100110111101100111100011011110 to mode F(i: #IMM = 8)...
    [apply] Processing situation null for op vliw(c1: ADD_S, c2: SUB_S):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op ADD_S(fd: F, fs: F, ft: F):[context=null, type=ADD_S, root=false]...
    [apply] TestData [bindings={ADD_S.fs=10000100001010100100010111011101}]
    [apply] Creating code to assign 10000100001010100100010111011101 to mode F(i: #IMM = 3)...
    [apply] Processing situation null for op ADD_S(fd: F, fs: F, ft: F):[context=null, type=ADD_S, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation zero(size=32) for op vliw(c1: ADD_S, c2: ADD_S):[context=null, type=vliw, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=vliw, testcase=zero, vliw=vliw, vliw.c1=ADD_S, vliw.c1.fd=F, vliw.c1.fd.i=#IMM, vliw.c1.fs=F, vliw.c1.fs.i=#IMM, vliw.c1.ft=F, vliw.c1.ft.i=#IMM, vliw.c2=ADD_S, vliw.c2.fd=F, vliw.c2.fd.i=#IMM, vliw.c2.fs=F, vliw.c2.fs.i=#IMM, vliw.c2.ft=F, vliw.c2.ft.i=#IMM}, bindings={vliw.c1.fd.i=00001, vliw.c1.fd=vliw.c1.fd, vliw.c1.fs.i=00011, vliw.c1.fs=10000100001010100100010111011101, vliw.c1.ft.i=00101, vliw.c1.ft=01011010111000000000011111010010, vliw.c2.fd.i=00010, vliw.c2.fd=01100110111101100111100011011110, vliw.c2.fs.i=00100, vliw.c2.fs=10101001110010010111000000100101, vliw.c2.ft.i=00110, vliw.c2.ft=01010011010101011111101000111010}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {vliw.c2.fd=Argument [name=fd, kind=MODE, value=mode F(i: #IMM), mode=OUT, type=Type.FLOAT(23, 8)], vliw.c2.fs=Argument [name=fs, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)], vliw.c2.ft=Argument [name=ft, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)], vliw.c1.ft=Argument [name=ft, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)], vliw.c1.fs=Argument [name=fs, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)], vliw.c1.fd=Argument [name=fd, kind=MODE, value=mode F(i: #IMM), mode=OUT, type=Type.FLOAT(23, 8)]}
    [apply] TestData [bindings={vliw.c1.fd=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode F(i: #IMM = 1)...
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op ADD_S(fd: F, fs: F, ft: F):[context=null, type=ADD_S, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op ADD_S(fd: F, fs: F, ft: F):[context=null, type=ADD_S, root=false]...
    [apply] TestData [bindings={ADD_S.fs=00101100100101001010111001001110}]
    [apply] Creating code to assign 00101100100101001010111001001110 to mode F(i: #IMM = 7)...
    [apply] Processing situation null for op vliw(c1: ADD_S, c2: ADD_S):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] LUI 25, 21333; ADDI 25, 25, 64058;
    [apply] MTF 25, 6; NOP;
    [apply] LUI 25, 23264; ADDI 25, 25, 2002;
    [apply] MTF 25, 5; NOP;
    [apply] LUI 25, 43465; ADDI 25, 25, 28709;
    [apply] MTF 25, 4; NOP;
    [apply] LUI 25, 59126; ADDI 25, 25, 30942;
    [apply] MTF 25, 8; NOP;
    [apply] LUI 25, 33834; ADDI 25, 25, 17885;
    [apply] MTF 25, 3; NOP;
    [apply] LUI 25, 0; ADDI 25, 25, 0;
    [apply] MTF 25, 1; NOP;
    [apply] LUI 25, 11412; ADDI 25, 25, 44622;
    [apply] MTF 25, 7; NOP;
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] ADD_S 10, 5, 6; SUB_S 2, 4, 8;
    [apply] ADD_S 1, 3, 5; ADD_S 2, 4, 6;
    [apply] ADD_S 1, 8, 1; ADD_S 18, 7, 3;
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] // Initializer for F
    [apply] LUI 25, 21333; ADDI 25, 25, 64058;
    [apply] MTF 25, 6; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 23264; ADDI 25, 25, 2002;
    [apply] MTF 25, 5; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 43465; ADDI 25, 25, 28709;
    [apply] MTF 25, 4; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 59126; ADDI 25, 25, 30942;
    [apply] MTF 25, 8; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 33834; ADDI 25, 25, 17885;
    [apply] MTF 25, 3; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 0; ADDI 25, 25, 0;
    [apply] MTF 25, 1; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 11412; ADDI 25, 25, 44622;
    [apply] MTF 25, 7; NOP;
    [apply] 
    [apply] Stimulus
    [apply] ADD_S 10, 5, 6; SUB_S 2, 4, 8;
    [apply] // zero (:size => 32)
    [apply] ADD_S 1, 3, 5; ADD_S 2, 4, 6;
    [apply] ADD_S 1, 8, 1; ADD_S 18, 7, 3;
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.146 seconds 
    [apply] Generation rate: 164 instructions/second
    [apply] Programs/stimuli/instructions: 1/1/24
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: vliw
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\demo\vliw\templates\fp_exception.rb
    [apply] Loaded template VliwBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/vliw_base.rb
    [apply] Loaded template FpExceptionTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/fp_exception.rb
    [apply] Processing template FpExceptionTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/fp_exception.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: R
    [apply] Output (runtime: false): "// Initializer for R"
    [apply] Operation: LUI
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: R
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: F
    [apply] Output (runtime: false): "// Initializer for F"
    [apply] Addressing mode: R
    [apply] Operation: LUI
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Operation: MTF
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: F
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Output (runtime: true): ""
    [apply] Output (runtime: true): "FPR[%d] = %s", 0, FPR[0]
    [apply] Output (runtime: true): "FPR[%d] = %s", 1, FPR[1]
    [apply] Output (runtime: true): "FPR[%d] = %s", 2, FPR[2]
    [apply] Output (runtime: true): "FPR[%d] = %s", 3, FPR[3]
    [apply] Output (runtime: true): "FPR[%d] = %s", 4, FPR[4]
    [apply] Output (runtime: true): "FPR[%d] = %s", 5, FPR[5]
    [apply] Output (runtime: true): "FPR[%d] = %s", 6, FPR[6]
    [apply] Output (runtime: true): "FPR[%d] = %s", 7, FPR[7]
    [apply] Output (runtime: true): "FPR[%d] = %s", 8, FPR[8]
    [apply] Output (runtime: true): "FPR[%d] = %s", 9, FPR[9]
    [apply] Output (runtime: true): "FPR[%d] = %s", 10, FPR[10]
    [apply] Output (runtime: true): "FPR[%d] = %s", 11, FPR[11]
    [apply] Output (runtime: true): "FPR[%d] = %s", 12, FPR[12]
    [apply] Output (runtime: true): "FPR[%d] = %s", 13, FPR[13]
    [apply] Output (runtime: true): "FPR[%d] = %s", 14, FPR[14]
    [apply] Output (runtime: true): "FPR[%d] = %s", 15, FPR[15]
    [apply] Output (runtime: true): ""
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Operation: ADD_S
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Operation: ADD_S
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Operation: ADD_S
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Operation: ADD_S
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Operation: SUB_S
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Operation: SUB_S
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Operation: SUB_S
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Addressing mode: F
    [apply] Operation: SUB_S
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: true): ""
    [apply] Output (runtime: true): "FPR[%d] = %s", 0, FPR[0]
    [apply] Output (runtime: true): "FPR[%d] = %s", 1, FPR[1]
    [apply] Output (runtime: true): "FPR[%d] = %s", 2, FPR[2]
    [apply] Output (runtime: true): "FPR[%d] = %s", 3, FPR[3]
    [apply] Output (runtime: true): "FPR[%d] = %s", 4, FPR[4]
    [apply] Output (runtime: true): "FPR[%d] = %s", 5, FPR[5]
    [apply] Output (runtime: true): "FPR[%d] = %s", 6, FPR[6]
    [apply] Output (runtime: true): "FPR[%d] = %s", 7, FPR[7]
    [apply] Output (runtime: true): "FPR[%d] = %s", 8, FPR[8]
    [apply] Output (runtime: true): "FPR[%d] = %s", 9, FPR[9]
    [apply] Output (runtime: true): "FPR[%d] = %s", 10, FPR[10]
    [apply] Output (runtime: true): "FPR[%d] = %s", 11, FPR[11]
    [apply] Output (runtime: true): "FPR[%d] = %s", 12, FPR[12]
    [apply] Output (runtime: true): "FPR[%d] = %s", 13, FPR[13]
    [apply] Output (runtime: true): "FPR[%d] = %s", 14, FPR[14]
    [apply] Output (runtime: true): "FPR[%d] = %s", 15, FPR[15]
    [apply] Output (runtime: true): ""
    [apply] Ended building a call (empty = false, executable = false)
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation fp.add(case=normal, exp=8, frac=23) for op ADD_S(fd: F, fs: F, ft: F):[context=null, type=ADD_S, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=ADD_S, testcase=fp.add, ADD_S=ADD_S, ADD_S.fd=F, ADD_S.fd.i=#IMM, ADD_S.fs=F, ADD_S.fs.i=#IMM, ADD_S.ft=F, ADD_S.ft.i=#IMM}, bindings={ADD_S.fd.i=00001, ADD_S.fd=ADD_S.fd, ADD_S.fs.i=00001, ADD_S.fs=ADD_S.fs, ADD_S.ft.i=00010, ADD_S.ft=ADD_S.ft}, parameters={case=normal, exp=8, frac=23}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {ADD_S.fd=Argument [name=fd, kind=MODE, value=mode F(i: #IMM), mode=OUT, type=Type.FLOAT(23, 8)], ADD_S.ft=Argument [name=ft, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)], ADD_S.fs=Argument [name=fs, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation fp.add(case=overflow, exp=8, frac=23) for op ADD_S(fd: F, fs: F, ft: F):[context=null, type=ADD_S, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=ADD_S, testcase=fp.add, ADD_S=ADD_S, ADD_S.fd=F, ADD_S.fd.i=#IMM, ADD_S.fs=F, ADD_S.fs.i=#IMM, ADD_S.ft=F, ADD_S.ft.i=#IMM}, bindings={ADD_S.fd.i=00011, ADD_S.fd=ADD_S.fd, ADD_S.fs.i=00011, ADD_S.fs=ADD_S.fs, ADD_S.ft.i=00100, ADD_S.ft=ADD_S.ft}, parameters={case=overflow, exp=8, frac=23}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {ADD_S.fd=Argument [name=fd, kind=MODE, value=mode F(i: #IMM), mode=OUT, type=Type.FLOAT(23, 8)], ADD_S.ft=Argument [name=ft, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)], ADD_S.fs=Argument [name=fs, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: ADD_S, c2: ADD_S):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={vliw.c2.fs=11100101000010001011110111100101, vliw.c2.ft=01011010111000000000011111010010, vliw.c1.ft=01010011010101011111101000111010, vliw.c1.fs=10101001110010010111000000100101}]
    [apply] Creating code to assign 11100101000010001011110111100101 to mode F(i: #IMM = 3)...
    [apply] Creating code to assign 01011010111000000000011111010010 to mode F(i: #IMM = 4)...
    [apply] Creating code to assign 01010011010101011111101000111010 to mode F(i: #IMM = 2)...
    [apply] Creating code to assign 10101001110010010111000000100101 to mode F(i: #IMM = 1)...
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation fp.add(case=underflow, exp=8, frac=23) for op ADD_S(fd: F, fs: F, ft: F):[context=null, type=ADD_S, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=ADD_S, testcase=fp.add, ADD_S=ADD_S, ADD_S.fd=F, ADD_S.fd.i=#IMM, ADD_S.fs=F, ADD_S.fs.i=#IMM, ADD_S.ft=F, ADD_S.ft.i=#IMM}, bindings={ADD_S.fd.i=00101, ADD_S.fd=ADD_S.fd, ADD_S.fs.i=00101, ADD_S.fs=ADD_S.fs, ADD_S.ft.i=00110, ADD_S.ft=ADD_S.ft}, parameters={case=underflow, exp=8, frac=23}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {ADD_S.fd=Argument [name=fd, kind=MODE, value=mode F(i: #IMM), mode=OUT, type=Type.FLOAT(23, 8)], ADD_S.ft=Argument [name=ft, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)], ADD_S.fs=Argument [name=fs, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation fp.add(case=inexact, exp=8, frac=23) for op ADD_S(fd: F, fs: F, ft: F):[context=null, type=ADD_S, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=ADD_S, testcase=fp.add, ADD_S=ADD_S, ADD_S.fd=F, ADD_S.fd.i=#IMM, ADD_S.fs=F, ADD_S.fs.i=#IMM, ADD_S.ft=F, ADD_S.ft.i=#IMM}, bindings={ADD_S.fd.i=00111, ADD_S.fd=ADD_S.fd, ADD_S.fs.i=00111, ADD_S.fs=ADD_S.fs, ADD_S.ft.i=01000, ADD_S.ft=ADD_S.ft}, parameters={case=inexact, exp=8, frac=23}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {ADD_S.fd=Argument [name=fd, kind=MODE, value=mode F(i: #IMM), mode=OUT, type=Type.FLOAT(23, 8)], ADD_S.ft=Argument [name=ft, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)], ADD_S.fs=Argument [name=fs, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: ADD_S, c2: ADD_S):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={vliw.c2.fs=10101000101001111100011000010011, vliw.c2.ft=11001000000011001011000011001000, vliw.c1.ft=10011011110000110011101000001000, vliw.c1.fs=00001011000101110001110101010010}]
    [apply] Creating code to assign 10101000101001111100011000010011 to mode F(i: #IMM = 7)...
    [apply] Creating code to assign 11001000000011001011000011001000 to mode F(i: #IMM = 8)...
    [apply] Creating code to assign 10011011110000110011101000001000 to mode F(i: #IMM = 6)...
    [apply] Creating code to assign 00001011000101110001110101010010 to mode F(i: #IMM = 5)...
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation fp.sub(case=normal, exp=8, frac=23) for op SUB_S(fd: F, fs: F, ft: F):[context=null, type=SUB_S, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=SUB_S, testcase=fp.sub, SUB_S=SUB_S, SUB_S.fd=F, SUB_S.fd.i=#IMM, SUB_S.fs=F, SUB_S.fs.i=#IMM, SUB_S.ft=F, SUB_S.ft.i=#IMM}, bindings={SUB_S.fd.i=01001, SUB_S.fd=SUB_S.fd, SUB_S.fs.i=01001, SUB_S.fs=SUB_S.fs, SUB_S.ft.i=01010, SUB_S.ft=SUB_S.ft}, parameters={case=normal, exp=8, frac=23}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {SUB_S.fs=Argument [name=fs, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)], SUB_S.fd=Argument [name=fd, kind=MODE, value=mode F(i: #IMM), mode=OUT, type=Type.FLOAT(23, 8)], SUB_S.ft=Argument [name=ft, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation fp.sub(case=overflow, exp=8, frac=23) for op SUB_S(fd: F, fs: F, ft: F):[context=null, type=SUB_S, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=SUB_S, testcase=fp.sub, SUB_S=SUB_S, SUB_S.fd=F, SUB_S.fd.i=#IMM, SUB_S.fs=F, SUB_S.fs.i=#IMM, SUB_S.ft=F, SUB_S.ft.i=#IMM}, bindings={SUB_S.fd.i=01011, SUB_S.fd=SUB_S.fd, SUB_S.fs.i=01011, SUB_S.fs=SUB_S.fs, SUB_S.ft.i=01100, SUB_S.ft=SUB_S.ft}, parameters={case=overflow, exp=8, frac=23}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {SUB_S.fs=Argument [name=fs, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)], SUB_S.fd=Argument [name=fd, kind=MODE, value=mode F(i: #IMM), mode=OUT, type=Type.FLOAT(23, 8)], SUB_S.ft=Argument [name=ft, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: SUB_S, c2: SUB_S):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={vliw.c2.fs=01010000101011011101011100011110, vliw.c2.ft=11011011101011111111000010100110, vliw.c1.ft=10100011101110000111111011101011, vliw.c1.fs=00101101111100100010010000001100}]
    [apply] Creating code to assign 01010000101011011101011100011110 to mode F(i: #IMM = 11)...
    [apply] Creating code to assign 11011011101011111111000010100110 to mode F(i: #IMM = 12)...
    [apply] Creating code to assign 10100011101110000111111011101011 to mode F(i: #IMM = 10)...
    [apply] Creating code to assign 00101101111100100010010000001100 to mode F(i: #IMM = 9)...
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation fp.sub(case=underflow, exp=8, frac=23) for op SUB_S(fd: F, fs: F, ft: F):[context=null, type=SUB_S, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=SUB_S, testcase=fp.sub, SUB_S=SUB_S, SUB_S.fd=F, SUB_S.fd.i=#IMM, SUB_S.fs=F, SUB_S.fs.i=#IMM, SUB_S.ft=F, SUB_S.ft.i=#IMM}, bindings={SUB_S.fd.i=01101, SUB_S.fd=SUB_S.fd, SUB_S.fs.i=01101, SUB_S.fs=SUB_S.fs, SUB_S.ft.i=01110, SUB_S.ft=SUB_S.ft}, parameters={case=underflow, exp=8, frac=23}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {SUB_S.fs=Argument [name=fs, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)], SUB_S.fd=Argument [name=fd, kind=MODE, value=mode F(i: #IMM), mode=OUT, type=Type.FLOAT(23, 8)], SUB_S.ft=Argument [name=ft, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation fp.sub(case=inexact, exp=8, frac=23) for op SUB_S(fd: F, fs: F, ft: F):[context=null, type=SUB_S, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=SUB_S, testcase=fp.sub, SUB_S=SUB_S, SUB_S.fd=F, SUB_S.fd.i=#IMM, SUB_S.fs=F, SUB_S.fs.i=#IMM, SUB_S.ft=F, SUB_S.ft.i=#IMM}, bindings={SUB_S.fd.i=01111, SUB_S.fd=SUB_S.fd, SUB_S.fs.i=01111, SUB_S.fs=SUB_S.fs, SUB_S.ft.i=00000, SUB_S.ft=SUB_S.ft}, parameters={case=inexact, exp=8, frac=23}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {SUB_S.fs=Argument [name=fs, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)], SUB_S.fd=Argument [name=fd, kind=MODE, value=mode F(i: #IMM), mode=OUT, type=Type.FLOAT(23, 8)], SUB_S.ft=Argument [name=ft, kind=MODE, value=mode F(i: #IMM), mode=IN, type=Type.FLOAT(23, 8)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: SUB_S, c2: SUB_S):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={vliw.c2.fs=00100101011101110101000001011100, vliw.c2.ft=11011000011110111101101010111001, vliw.c1.ft=10110100111110010001011101111011, vliw.c1.fs=11110000010110000000111101011010}]
    [apply] Creating code to assign 00100101011101110101000001011100 to mode F(i: #IMM = 15)...
    [apply] Creating code to assign 11011000011110111101101010111001 to mode F(i: #IMM = 0)...
    [apply] Creating code to assign 10110100111110010001011101111011 to mode F(i: #IMM = 14)...
    [apply] Creating code to assign 11110000010110000000111101011010 to mode F(i: #IMM = 13)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] LUI 25, 58632; ADDI 25, 25, 48613;
    [apply] MTF 25, 3; NOP;
    [apply] LUI 25, 23264; ADDI 25, 25, 2002;
    [apply] MTF 25, 4; NOP;
    [apply] LUI 25, 21333; ADDI 25, 25, 64058;
    [apply] MTF 25, 2; NOP;
    [apply] LUI 25, 43465; ADDI 25, 25, 28709;
    [apply] MTF 25, 1; NOP;
    [apply] LUI 25, 43175; ADDI 25, 25, 50707;
    [apply] MTF 25, 7; NOP;
    [apply] LUI 25, 51212; ADDI 25, 25, 45256;
    [apply] MTF 25, 8; NOP;
    [apply] LUI 25, 39875; ADDI 25, 25, 14856;
    [apply] MTF 25, 6; NOP;
    [apply] LUI 25, 2839; ADDI 25, 25, 7506;
    [apply] MTF 25, 5; NOP;
    [apply] LUI 25, 20653; ADDI 25, 25, 55070;
    [apply] MTF 25, 11; NOP;
    [apply] LUI 25, 56239; ADDI 25, 25, 61606;
    [apply] MTF 25, 12; NOP;
    [apply] LUI 25, 41912; ADDI 25, 25, 32491;
    [apply] MTF 25, 10; NOP;
    [apply] LUI 25, 11762; ADDI 25, 25, 9228;
    [apply] MTF 25, 9; NOP;
    [apply] LUI 25, 9591; ADDI 25, 25, 20572;
    [apply] MTF 25, 15; NOP;
    [apply] LUI 25, 55419; ADDI 25, 25, 55993;
    [apply] MTF 25, 0; NOP;
    [apply] LUI 25, 46329; ADDI 25, 25, 6011;
    [apply] MTF 25, 14; NOP;
    [apply] LUI 25, 61528; ADDI 25, 25, 3930;
    [apply] MTF 25, 13; NOP;
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] 
    [apply] FPR[0] = 11011000011110111101101010111001
    [apply] FPR[1] = 10101001110010010111000000100101
    [apply] FPR[2] = 01010011010101011111101000111010
    [apply] FPR[3] = 11100101000010001011110111100101
    [apply] FPR[4] = 01011010111000000000011111010010
    [apply] FPR[5] = 00001011000101110001110101010010
    [apply] FPR[6] = 10011011110000110011101000001000
    [apply] FPR[7] = 10101000101001111100011000010011
    [apply] FPR[8] = 11001000000011001011000011001000
    [apply] FPR[9] = 00101101111100100010010000001100
    [apply] FPR[10] = 10100011101110000111111011101011
    [apply] FPR[11] = 01010000101011011101011100011110
    [apply] FPR[12] = 11011011101011111111000010100110
    [apply] FPR[13] = 11110000010110000000111101011010
    [apply] FPR[14] = 10110100111110010001011101111011
    [apply] FPR[15] = 00100101011101110101000001011100
    [apply] 
    [apply] ADD_S 1, 1, 2; ADD_S 3, 3, 4;
    [apply] ADD_S 5, 5, 6; ADD_S 7, 7, 8;
    [apply] SUB_S 9, 9, 10; SUB_S 11, 11, 12;
    [apply] SUB_S 13, 13, 14; SUB_S 15, 15, 0;
    [apply] 
    [apply] FPR[0] = 11011000011110111101101010111001
    [apply] FPR[1] = 01010011010101011111101000111010
    [apply] FPR[2] = 01010011010101011111101000111010
    [apply] FPR[3] = 11100101000010001011110111011110
    [apply] FPR[4] = 01011010111000000000011111010010
    [apply] FPR[5] = 10011011110000110011101000001000
    [apply] FPR[6] = 10011011110000110011101000001000
    [apply] FPR[7] = 11001000000011001011000011001000
    [apply] FPR[8] = 11001000000011001011000011001000
    [apply] FPR[9] = 00101101111100100010010000011000
    [apply] FPR[10] = 10100011101110000111111011101011
    [apply] FPR[11] = 01011011101011111111000010101001
    [apply] FPR[12] = 11011011101011111111000010100110
    [apply] FPR[13] = 11110000010110000000111101011010
    [apply] FPR[14] = 10110100111110010001011101111011
    [apply] FPR[15] = 01011000011110111101101010111001
    [apply] 
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] // Initializer for F
    [apply] LUI 25, 58632; ADDI 25, 25, 48613;
    [apply] MTF 25, 3; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 23264; ADDI 25, 25, 2002;
    [apply] MTF 25, 4; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 21333; ADDI 25, 25, 64058;
    [apply] MTF 25, 2; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 43465; ADDI 25, 25, 28709;
    [apply] MTF 25, 1; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 43175; ADDI 25, 25, 50707;
    [apply] MTF 25, 7; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 51212; ADDI 25, 25, 45256;
    [apply] MTF 25, 8; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 39875; ADDI 25, 25, 14856;
    [apply] MTF 25, 6; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 2839; ADDI 25, 25, 7506;
    [apply] MTF 25, 5; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 20653; ADDI 25, 25, 55070;
    [apply] MTF 25, 11; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 56239; ADDI 25, 25, 61606;
    [apply] MTF 25, 12; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 41912; ADDI 25, 25, 32491;
    [apply] MTF 25, 10; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 11762; ADDI 25, 25, 9228;
    [apply] MTF 25, 9; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 9591; ADDI 25, 25, 20572;
    [apply] MTF 25, 15; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 55419; ADDI 25, 25, 55993;
    [apply] MTF 25, 0; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 46329; ADDI 25, 25, 6011;
    [apply] MTF 25, 14; NOP;
    [apply] // Initializer for F
    [apply] LUI 25, 61528; ADDI 25, 25, 3930;
    [apply] MTF 25, 13; NOP;
    [apply] 
    [apply] Stimulus
    [apply] ADD_S 1, 1, 2; ADD_S 3, 3, 4;
    [apply] ADD_S 5, 5, 6; ADD_S 7, 7, 8;
    [apply] SUB_S 9, 9, 10; SUB_S 11, 11, 12;
    [apply] SUB_S 13, 13, 14; SUB_S 15, 15, 0;
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.350 seconds 
    [apply] Generation rate: 151 instructions/second
    [apply] Programs/stimuli/instructions: 1/1/53
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: vliw
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\demo\vliw\templates\int_divide.rb
    [apply] Loaded template VliwBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/vliw_base.rb
    [apply] Loaded template IntDivideTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/int_divide.rb
    [apply] Processing template IntDivideTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/int_divide.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: R
    [apply] Output (runtime: false): "// Initializer for R"
    [apply] Operation: LUI
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: R
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: F
    [apply] Output (runtime: false): "// Initializer for F"
    [apply] Addressing mode: R
    [apply] Operation: LUI
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Operation: MTF
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: F
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Output (runtime: true): "Division: Debug Output"
    [apply] Output (runtime: true): "Input parameter values: dividend = %d, divisor = %d", 46, 33
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: MOVE
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: MOVE
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: cycle_1
    [apply] Output (runtime: true): "Current register values: $1 = %d, $2 = %d, $3 = %d, $4 = %d, $5 = %d", GPR[1], GPR[2], GPR[3], GPR[4], GPR[5]
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SUB
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SLT
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: BNE
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: MOVE
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: B
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: done_1
    [apply] Output (runtime: true): "Result: quotient = %d, remainder = %d", GPR[1], GPR[2]
    [apply] Ended building a call (empty = false, executable = false)
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={ADDI.rs=10010001101001101010101011000011}]
    [apply] Creating code to assign 10010001101001101010101011000011 to mode R(i: #IMM = 0)...
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: ADDI, c2: ADDI):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op MOVE(rd: R, rs: R):[context=null, type=MOVE, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op MOVE(rd: R, rs: R):[context=null, type=MOVE, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: MOVE, c2: MOVE):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: SUB, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op SLT(rd: R, rs: R, rt: R):[context=null, type=SLT, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: SLT, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op BNE(rs: R, rt: R, offset: #IMM):[context=null, type=BNE, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: BNE, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op MOVE(rd: R, rs: R):[context=null, type=MOVE, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: MOVE, c2: ADDI):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op B(offset: #IMM):[context=null, type=B, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: B, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] LUI 0, 37286; ADDI 0, 0, 43715;
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] Division: Debug Output
    [apply] 
    [apply] Input parameter values: dividend = 46, divisor = 33
    [apply] 
    [apply] ADDI 4, 0, 46; ADDI 5, 0, 33;
    [apply] MOVE 1, 0; MOVE 2, 4;
    [apply] 
    [apply] Current register values: $1 = 0, $2 = 46, $3 = 0, $4 = 46, $5 = 33
    [apply] 
    [apply] SUB 3, 2, 5; NOP;
    [apply] SLT 6, 3, 0; NOP;
    [apply] BNE 6, 0, done_1; NOP;
    [apply] MOVE 2, 3; ADDI 1, 1, 1;
    [apply] B cycle_1; NOP;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 1, $2 = 13, $3 = 13, $4 = 46, $5 = 33
    [apply] 
    [apply] SUB 3, 2, 5; NOP;
    [apply] SLT 6, 3, 0; NOP;
    [apply] BNE 6, 0, done_1; NOP;
    [apply] Jump to label: done_1
    [apply] 
    [apply] Result: quotient = 1, remainder = 13
    [apply] 
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] // Initializer for R
    [apply] LUI 0, 37286; ADDI 0, 0, 43715;
    [apply] 
    [apply] Stimulus
    [apply] ADDI 4, 0, 46; ADDI 5, 0, 33;
    [apply] MOVE 1, 0; MOVE 2, 4;
    [apply] cycle_1:
    [apply] SUB 3, 2, 5; NOP;
    [apply] SLT 6, 3, 0; NOP;
    [apply] BNE 6, 0, done_1; NOP;
    [apply] MOVE 2, 3; ADDI 1, 1, 1;
    [apply] B cycle_1; NOP;
    [apply] done_1:
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.093 seconds 
    [apply] Generation rate: 107 instructions/second
    [apply] Programs/stimuli/instructions: 1/1/10
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: vliw
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\demo\vliw\templates\int_example.rb
    [apply] Loaded template VliwBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/vliw_base.rb
    [apply] Loaded template IntExampleTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/int_example.rb
    [apply] Processing template IntExampleTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/int_example.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: R
    [apply] Output (runtime: false): "// Initializer for R"
    [apply] Operation: LUI
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: R
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: F
    [apply] Output (runtime: false): "// Initializer for F"
    [apply] Addressing mode: R
    [apply] Operation: LUI
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Operation: MTF
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: F
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADD
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADD
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADD
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADD
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={ADDI.rs=00000111110100100101001101010101}]
    [apply] Creating code to assign 00000111110100100101001101010101 to mode R(i: #IMM = 0)...
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: ADDI, c2: ADDI):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op ADD(rd: R, rs: R, rt: R):[context=null, type=ADD, root=false]...
    [apply] TestData [bindings={ADD.rs=10101001110010010111000000100101, ADD.rt=11100110111101100111100011011110}]
    [apply] Creating code to assign 10101001110010010111000000100101 to mode R(i: #IMM = 3)...
    [apply] Creating code to assign 11100110111101100111100011011110 to mode R(i: #IMM = 5)...
    [apply] Processing situation null for op ADD(rd: R, rs: R, rt: R):[context=null, type=ADD, root=false]...
    [apply] TestData [bindings={ADD.rs=10000100001010100100010111011101, ADD.rt=00101100100101001010111001001110}]
    [apply] Creating code to assign 10000100001010100100010111011101 to mode R(i: #IMM = 4)...
    [apply] Creating code to assign 00101100100101001010111001001110 to mode R(i: #IMM = 6)...
    [apply] Processing situation zero for op vliw(c1: ADD, c2: ADD):[context=null, type=vliw, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=vliw, testcase=zero, vliw=vliw, vliw.c1=ADD, vliw.c1.rd=R, vliw.c1.rd.i=#IMM, vliw.c1.rs=R, vliw.c1.rs.i=#IMM, vliw.c1.rt=R, vliw.c1.rt.i=#IMM, vliw.c2=ADD, vliw.c2.rd=R, vliw.c2.rd.i=#IMM, vliw.c2.rs=R, vliw.c2.rs.i=#IMM, vliw.c2.rt=R, vliw.c2.rt.i=#IMM}, bindings={vliw.c1.rd.i=00001, vliw.c1.rd=vliw.c1.rd, vliw.c1.rs.i=00011, vliw.c1.rs=10101001110010010111000000100101, vliw.c1.rt.i=00101, vliw.c1.rt=11100110111101100111100011011110, vliw.c2.rd.i=00010, vliw.c2.rd=vliw.c2.rd, vliw.c2.rs.i=00100, vliw.c2.rs=10000100001010100100010111011101, vliw.c2.rt.i=00110, vliw.c2.rt=00101100100101001010111001001110}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {vliw.c2.rs=Argument [name=rs, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], vliw.c2.rd=Argument [name=rd, kind=MODE, value=mode R(i: #IMM), mode=OUT, type=Type.INT(32)], vliw.c2.rt=Argument [name=rt, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], vliw.c1.rs=Argument [name=rs, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], vliw.c1.rt=Argument [name=rt, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], vliw.c1.rd=Argument [name=rd, kind=MODE, value=mode R(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={vliw.c1.rd=00000000000000000000000000000000, vliw.c2.rd=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode R(i: #IMM = 1)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode R(i: #IMM = 2)...
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op ADD(rd: R, rs: R, rt: R):[context=null, type=ADD, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op ADD(rd: R, rs: R, rt: R):[context=null, type=ADD, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation random for op vliw(c1: ADD, c2: ADD):[context=null, type=vliw, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=vliw, testcase=random, vliw=vliw, vliw.c1=ADD, vliw.c1.rd=R, vliw.c1.rd.i=#IMM, vliw.c1.rs=R, vliw.c1.rs.i=#IMM, vliw.c1.rt=R, vliw.c1.rt.i=#IMM, vliw.c2=ADD, vliw.c2.rd=R, vliw.c2.rd.i=#IMM, vliw.c2.rs=R, vliw.c2.rs.i=#IMM, vliw.c2.rt=R, vliw.c2.rt.i=#IMM}, bindings={vliw.c1.rd.i=00001, vliw.c1.rd=10010000101111111110100100000011, vliw.c1.rs.i=10010, vliw.c1.rs=00000000000000000000000000011010, vliw.c1.rt.i=00110, vliw.c1.rt=00101100100101001010111001001110, vliw.c2.rd.i=10111, vliw.c2.rd=vliw.c2.rd, vliw.c2.rs.i=10010, vliw.c2.rs=00000000000000000000000000011010, vliw.c2.rt.i=10010, vliw.c2.rt=00000000000000000000000000011010}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {vliw.c2.rs=Argument [name=rs, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], vliw.c2.rd=Argument [name=rd, kind=MODE, value=mode R(i: #IMM), mode=OUT, type=Type.INT(32)], vliw.c2.rt=Argument [name=rt, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], vliw.c1.rs=Argument [name=rs, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], vliw.c1.rt=Argument [name=rt, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], vliw.c1.rd=Argument [name=rd, kind=MODE, value=mode R(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={vliw.c2.rd=00000000010111011011011111111010}]
    [apply] Creating code to assign 00000000010111011011011111111010 to mode R(i: #IMM = 23)...
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation random(min=1, max=31) for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=ADDI, testcase=random, ADDI=ADDI, ADDI.rt=R, ADDI.rt.i=#IMM, ADDI.rs=R, ADDI.rs.i=#IMM, ADDI.imm=#IMM}, bindings={ADDI.rt.i=00011, ADDI.rt=10101001110010010111000000100101, ADDI.rs.i=11010, ADDI.rs=ADDI.rs, ADDI.imm=ADDI.imm}, parameters={min=1, max=31}]
    [apply] Unknown immediate values: [ADDI.imm]
    [apply] Modes used as arguments: {ADDI.rt=Argument [name=rt, kind=MODE, value=mode R(i: #IMM), mode=OUT, type=Type.INT(32)], ADDI.rs=Argument [name=rs, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)]}
    [apply] TestData [bindings={ADDI.rs=00000000000000000000000000000001, ADDI.imm=0000000000000010}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode R(i: #IMM = 26)...
    [apply] Processing situation random(min=1, max=31) for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=ADDI, testcase=random, ADDI=ADDI, ADDI.rt=R, ADDI.rt.i=#IMM, ADDI.rs=R, ADDI.rs.i=#IMM, ADDI.imm=#IMM}, bindings={ADDI.rt.i=01100, ADDI.rt=ADDI.rt, ADDI.rs.i=00001, ADDI.rs=00101100100101001010111001101000, ADDI.imm=ADDI.imm}, parameters={min=1, max=31}]
    [apply] Unknown immediate values: [ADDI.imm]
    [apply] Modes used as arguments: {ADDI.rt=Argument [name=rt, kind=MODE, value=mode R(i: #IMM), mode=OUT, type=Type.INT(32)], ADDI.rs=Argument [name=rs, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)]}
    [apply] TestData [bindings={ADDI.rt=00000000000000000000000000010000, ADDI.imm=0000000000010010}]
    [apply] Creating code to assign 00000000000000000000000000010000 to mode R(i: #IMM = 12)...
    [apply] Processing situation null for op vliw(c1: ADDI, c2: ADDI):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] LUI 0, 2002; ADDI 0, 0, 21333;
    [apply] LUI 3, 43465; ADDI 3, 3, 28709;
    [apply] LUI 5, 59126; ADDI 5, 5, 30942;
    [apply] LUI 4, 33834; ADDI 4, 4, 17885;
    [apply] LUI 6, 11412; ADDI 6, 6, 44622;
    [apply] LUI 1, 0; ADDI 1, 1, 0;
    [apply] LUI 2, 0; ADDI 2, 2, 0;
    [apply] LUI 23, 93; ADDI 23, 23, 47098;
    [apply] LUI 26, 0; ADDI 26, 26, 1;
    [apply] LUI 12, 0; ADDI 12, 12, 16;
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] ADDI 29, 0, 26; ADDI 18, 0, 26;
    [apply] ADD 1, 3, 5; ADD 2, 4, 6;
    [apply] ADD 1, 18, 6; ADD 23, 18, 18;
    [apply] ADDI 3, 26, 2; ADDI 12, 1, 18;
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] // Initializer for R
    [apply] LUI 0, 2002; ADDI 0, 0, 21333;
    [apply] // Initializer for R
    [apply] LUI 3, 43465; ADDI 3, 3, 28709;
    [apply] // Initializer for R
    [apply] LUI 5, 59126; ADDI 5, 5, 30942;
    [apply] // Initializer for R
    [apply] LUI 4, 33834; ADDI 4, 4, 17885;
    [apply] // Initializer for R
    [apply] LUI 6, 11412; ADDI 6, 6, 44622;
    [apply] // Initializer for R
    [apply] LUI 1, 0; ADDI 1, 1, 0;
    [apply] // Initializer for R
    [apply] LUI 2, 0; ADDI 2, 2, 0;
    [apply] // Initializer for R
    [apply] LUI 23, 93; ADDI 23, 23, 47098;
    [apply] // Initializer for R
    [apply] LUI 26, 0; ADDI 26, 26, 1;
    [apply] // Initializer for R
    [apply] LUI 12, 0; ADDI 12, 12, 16;
    [apply] 
    [apply] Stimulus
    [apply] ADDI 29, 0, 26; ADDI 18, 0, 26;
    [apply] ADD 1, 3, 5; ADD 2, 4, 6;
    [apply] ADD 1, 18, 6; ADD 23, 18, 18;
    [apply] ADDI 3, 26, 2; ADDI 12, 1, 18;
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.226 seconds 
    [apply] Generation rate: 106 instructions/second
    [apply] Programs/stimuli/instructions: 1/1/24
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: vliw
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\demo\vliw\templates\int_exception.rb
    [apply] Loaded template VliwBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/vliw_base.rb
    [apply] Loaded template IntExceptionTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/int_exception.rb
    [apply] Processing template IntExceptionTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/int_exception.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: R
    [apply] Output (runtime: false): "// Initializer for R"
    [apply] Operation: LUI
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: R
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: F
    [apply] Output (runtime: false): "// Initializer for F"
    [apply] Addressing mode: R
    [apply] Operation: LUI
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Operation: MTF
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: F
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Output (runtime: true): ""
    [apply] Output (runtime: true): "GPR[%d] = %s", 1, GPR[1]
    [apply] Output (runtime: true): "GPR[%d] = %s", 2, GPR[2]
    [apply] Output (runtime: true): "GPR[%d] = %s", 3, GPR[3]
    [apply] Output (runtime: true): "GPR[%d] = %s", 4, GPR[4]
    [apply] Output (runtime: true): "GPR[%d] = %s", 5, GPR[5]
    [apply] Output (runtime: true): "GPR[%d] = %s", 6, GPR[6]
    [apply] Output (runtime: true): "GPR[%d] = %s", 7, GPR[7]
    [apply] Output (runtime: true): "GPR[%d] = %s", 8, GPR[8]
    [apply] Output (runtime: true): "GPR[%d] = %s", 9, GPR[9]
    [apply] Output (runtime: true): "GPR[%d] = %s", 10, GPR[10]
    [apply] Output (runtime: true): "GPR[%d] = %s", 11, GPR[11]
    [apply] Output (runtime: true): "GPR[%d] = %s", 12, GPR[12]
    [apply] Output (runtime: true): ""
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADD
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADD
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SUB
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SUB
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: true): ""
    [apply] Output (runtime: true): "GPR[%d] = %s", 1, GPR[1]
    [apply] Output (runtime: true): "GPR[%d] = %s", 2, GPR[2]
    [apply] Output (runtime: true): "GPR[%d] = %s", 3, GPR[3]
    [apply] Output (runtime: true): "GPR[%d] = %s", 4, GPR[4]
    [apply] Output (runtime: true): "GPR[%d] = %s", 5, GPR[5]
    [apply] Output (runtime: true): "GPR[%d] = %s", 6, GPR[6]
    [apply] Output (runtime: true): "GPR[%d] = %s", 7, GPR[7]
    [apply] Output (runtime: true): "GPR[%d] = %s", 8, GPR[8]
    [apply] Output (runtime: true): "GPR[%d] = %s", 9, GPR[9]
    [apply] Output (runtime: true): "GPR[%d] = %s", 10, GPR[10]
    [apply] Output (runtime: true): "GPR[%d] = %s", 11, GPR[11]
    [apply] Output (runtime: true): "GPR[%d] = %s", 12, GPR[12]
    [apply] Output (runtime: true): ""
    [apply] Ended building a call (empty = false, executable = false)
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation add(case=normal, size=32) for op ADD(rd: R, rs: R, rt: R):[context=null, type=ADD, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=ADD, testcase=add, ADD=ADD, ADD.rd=R, ADD.rd.i=#IMM, ADD.rs=R, ADD.rs.i=#IMM, ADD.rt=R, ADD.rt.i=#IMM}, bindings={ADD.rd.i=00001, ADD.rd=ADD.rd, ADD.rs.i=00011, ADD.rs=ADD.rs, ADD.rt.i=00101, ADD.rt=ADD.rt}, parameters={case=normal, size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {ADD.rs=Argument [name=rs, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], ADD.rt=Argument [name=rt, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], ADD.rd=Argument [name=rd, kind=MODE, value=mode R(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation add(case=overflow, size=32) for op ADD(rd: R, rs: R, rt: R):[context=null, type=ADD, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=ADD, testcase=add, ADD=ADD, ADD.rd=R, ADD.rd.i=#IMM, ADD.rs=R, ADD.rs.i=#IMM, ADD.rt=R, ADD.rt.i=#IMM}, bindings={ADD.rd.i=00010, ADD.rd=ADD.rd, ADD.rs.i=00100, ADD.rs=ADD.rs, ADD.rt.i=00110, ADD.rt=ADD.rt}, parameters={case=overflow, size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {ADD.rs=Argument [name=rs, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], ADD.rt=Argument [name=rt, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], ADD.rd=Argument [name=rd, kind=MODE, value=mode R(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: ADD, c2: ADD):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={vliw.c2.rs=10110000011101010010001001101011, vliw.c2.rt=00101000001001111011111110100011, vliw.c1.rs=10111101111001011000101110001001, vliw.c1.rt=11111010001110101110010100001000}]
    [apply] Creating code to assign 10110000011101010010001001101011 to mode R(i: #IMM = 4)...
    [apply] Creating code to assign 00101000001001111011111110100011 to mode R(i: #IMM = 6)...
    [apply] Creating code to assign 10111101111001011000101110001001 to mode R(i: #IMM = 3)...
    [apply] Creating code to assign 11111010001110101110010100001000 to mode R(i: #IMM = 5)...
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation sub(case=normal, size=32) for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=SUB, testcase=sub, SUB=SUB, SUB.rd=R, SUB.rd.i=#IMM, SUB.rs=R, SUB.rs.i=#IMM, SUB.rt=R, SUB.rt.i=#IMM}, bindings={SUB.rd.i=00111, SUB.rd=SUB.rd, SUB.rs.i=01000, SUB.rs=SUB.rs, SUB.rt.i=01001, SUB.rt=SUB.rt}, parameters={case=normal, size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {SUB.rs=Argument [name=rs, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], SUB.rd=Argument [name=rd, kind=MODE, value=mode R(i: #IMM), mode=OUT, type=Type.INT(32)], SUB.rt=Argument [name=rt, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation sub(case=overflow, size=32) for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=vliw, instruction=SUB, testcase=sub, SUB=SUB, SUB.rd=R, SUB.rd.i=#IMM, SUB.rs=R, SUB.rs.i=#IMM, SUB.rt=R, SUB.rt.i=#IMM}, bindings={SUB.rd.i=01010, SUB.rd=SUB.rd, SUB.rs.i=01011, SUB.rs=SUB.rs, SUB.rt.i=01100, SUB.rt=SUB.rt}, parameters={case=overflow, size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {SUB.rs=Argument [name=rs, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)], SUB.rd=Argument [name=rd, kind=MODE, value=mode R(i: #IMM), mode=OUT, type=Type.INT(32)], SUB.rt=Argument [name=rt, kind=MODE, value=mode R(i: #IMM), mode=IN, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: SUB, c2: SUB):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={vliw.c2.rs=11100110111101100111100011011110, vliw.c2.rt=10000100001010100100010111011101, vliw.c1.rs=00101100100101001010111001001110, vliw.c1.rt=00000000010111011011011111111010}]
    [apply] Creating code to assign 11100110111101100111100011011110 to mode R(i: #IMM = 11)...
    [apply] Creating code to assign 10000100001010100100010111011101 to mode R(i: #IMM = 12)...
    [apply] Creating code to assign 00101100100101001010111001001110 to mode R(i: #IMM = 8)...
    [apply] Creating code to assign 00000000010111011011011111111010 to mode R(i: #IMM = 9)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] LUI 4, 45173; ADDI 4, 4, 8811;
    [apply] LUI 6, 10279; ADDI 6, 6, 49059;
    [apply] LUI 3, 48613; ADDI 3, 3, 35721;
    [apply] LUI 5, 64058; ADDI 5, 5, 58632;
    [apply] LUI 11, 59126; ADDI 11, 11, 30942;
    [apply] LUI 12, 33834; ADDI 12, 12, 17885;
    [apply] LUI 8, 11412; ADDI 8, 8, 44622;
    [apply] LUI 9, 93; ADDI 9, 9, 47098;
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] 
    [apply] GPR[1] = 00000000000000000000000000000000
    [apply] GPR[2] = 00000000000000000000000000000000
    [apply] GPR[3] = 10111101111001011000101110001001
    [apply] GPR[4] = 10110000011101010010001001101011
    [apply] GPR[5] = 11111010001110101110010100001000
    [apply] GPR[6] = 00101000001001111011111110100011
    [apply] GPR[7] = 00000000000000000000000000000000
    [apply] GPR[8] = 00101100100101001010111001001110
    [apply] GPR[9] = 00000000010111011011011111111010
    [apply] GPR[10] = 00000000000000000000000000000000
    [apply] GPR[11] = 11100110111101100111100011011110
    [apply] GPR[12] = 10000100001010100100010111011101
    [apply] 
    [apply] ADD 1, 3, 5; ADD 2, 4, 6;
    [apply] SUB 7, 8, 9; SUB 10, 11, 12;
    [apply] 
    [apply] GPR[1] = 10111000001000000111000010010001
    [apply] GPR[2] = 11011000100111001110001000001110
    [apply] GPR[3] = 10111101111001011000101110001001
    [apply] GPR[4] = 10110000011101010010001001101011
    [apply] GPR[5] = 11111010001110101110010100001000
    [apply] GPR[6] = 00101000001001111011111110100011
    [apply] GPR[7] = 00101100001101101111011001010100
    [apply] GPR[8] = 00101100100101001010111001001110
    [apply] GPR[9] = 00000000010111011011011111111010
    [apply] GPR[10] = 01100010110011000011001100000001
    [apply] GPR[11] = 11100110111101100111100011011110
    [apply] GPR[12] = 10000100001010100100010111011101
    [apply] 
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] // Initializer for R
    [apply] LUI 4, 45173; ADDI 4, 4, 8811;
    [apply] // Initializer for R
    [apply] LUI 6, 10279; ADDI 6, 6, 49059;
    [apply] // Initializer for R
    [apply] LUI 3, 48613; ADDI 3, 3, 35721;
    [apply] // Initializer for R
    [apply] LUI 5, 64058; ADDI 5, 5, 58632;
    [apply] // Initializer for R
    [apply] LUI 11, 59126; ADDI 11, 11, 30942;
    [apply] // Initializer for R
    [apply] LUI 12, 33834; ADDI 12, 12, 17885;
    [apply] // Initializer for R
    [apply] LUI 8, 11412; ADDI 8, 8, 44622;
    [apply] // Initializer for R
    [apply] LUI 9, 93; ADDI 9, 9, 47098;
    [apply] 
    [apply] Stimulus
    [apply] ADD 1, 3, 5; ADD 2, 4, 6;
    [apply] SUB 7, 8, 9; SUB 10, 11, 12;
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.157 seconds 
    [apply] Generation rate: 121 instructions/second
    [apply] Programs/stimuli/instructions: 1/1/19
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: vliw
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\demo\vliw\templates\int_sqrt.rb
    [apply] Loaded template VliwBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/vliw_base.rb
    [apply] Loaded template IntSqrtTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/int_sqrt.rb
    [apply] Processing template IntSqrtTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/int_sqrt.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: R
    [apply] Output (runtime: false): "// Initializer for R"
    [apply] Operation: LUI
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: R
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: F
    [apply] Output (runtime: false): "// Initializer for F"
    [apply] Addressing mode: R
    [apply] Operation: LUI
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Operation: MTF
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: F
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Output (runtime: true): "Integer square root: Debug Output"
    [apply] Output (runtime: true): "Input parameter value: x = %d", 46
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: MOVE
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: cycle_1
    [apply] Output (runtime: true): "Current register values: $1 = %d, $2 = %d, $3 = %d", GPR[1], GPR[2], GPR[3]
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SLT
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: BEQ
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SUB
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SLT
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SUB
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADD
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: B
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: done_1
    [apply] Output (runtime: true): "sqrt of %d: %d", 46, GPR[2]
    [apply] Ended building a call (empty = false, executable = false)
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={ADDI.rs=10101010110000111111011010111110}]
    [apply] Creating code to assign 10101010110000111111011010111110 to mode R(i: #IMM = 0)...
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: ADDI, c2: ADDI):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op MOVE(rd: R, rs: R):[context=null, type=MOVE, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: MOVE, c2: ADDI):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op SLT(rd: R, rs: R, rt: R):[context=null, type=SLT, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: SLT, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op BEQ(rs: R, rt: R, offset: #IMM):[context=null, type=BEQ, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: BEQ, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: SUB, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: ADDI, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op SLT(rd: R, rs: R, rt: R):[context=null, type=SLT, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: SLT, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: SUB, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op ADD(rd: R, rs: R, rt: R):[context=null, type=ADD, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: ADD, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op B(offset: #IMM):[context=null, type=B, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: B, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] LUI 0, 43715; ADDI 0, 0, 63166;
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] Integer square root: Debug Output
    [apply] 
    [apply] Input parameter value: x = 46
    [apply] 
    [apply] ADDI 3, 0, 46; ADDI 1, 0, 1;
    [apply] MOVE 2, 0; ADDI 4, 0, 1;
    [apply] 
    [apply] Current register values: $1 = 1, $2 = 0, $3 = 46
    [apply] 
    [apply] SLT 6, 0, 3; NOP;
    [apply] BEQ 6, 0, done_1; NOP;
    [apply] SUB 3, 3, 1; NOP;
    [apply] ADDI 1, 1, 2; NOP;
    [apply] SLT 6, 3, 0; NOP;
    [apply] SUB 5, 4, 6; NOP;
    [apply] ADD 2, 2, 5; NOP;
    [apply] B cycle_1; NOP;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 3, $2 = 1, $3 = 45
    [apply] 
    [apply] SLT 6, 0, 3; NOP;
    [apply] BEQ 6, 0, done_1; NOP;
    [apply] SUB 3, 3, 1; NOP;
    [apply] ADDI 1, 1, 2; NOP;
    [apply] SLT 6, 3, 0; NOP;
    [apply] SUB 5, 4, 6; NOP;
    [apply] ADD 2, 2, 5; NOP;
    [apply] B cycle_1; NOP;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 5, $2 = 2, $3 = 42
    [apply] 
    [apply] SLT 6, 0, 3; NOP;
    [apply] BEQ 6, 0, done_1; NOP;
    [apply] SUB 3, 3, 1; NOP;
    [apply] ADDI 1, 1, 2; NOP;
    [apply] SLT 6, 3, 0; NOP;
    [apply] SUB 5, 4, 6; NOP;
    [apply] ADD 2, 2, 5; NOP;
    [apply] B cycle_1; NOP;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 7, $2 = 3, $3 = 37
    [apply] 
    [apply] SLT 6, 0, 3; NOP;
    [apply] BEQ 6, 0, done_1; NOP;
    [apply] SUB 3, 3, 1; NOP;
    [apply] ADDI 1, 1, 2; NOP;
    [apply] SLT 6, 3, 0; NOP;
    [apply] SUB 5, 4, 6; NOP;
    [apply] ADD 2, 2, 5; NOP;
    [apply] B cycle_1; NOP;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 9, $2 = 4, $3 = 30
    [apply] 
    [apply] SLT 6, 0, 3; NOP;
    [apply] BEQ 6, 0, done_1; NOP;
    [apply] SUB 3, 3, 1; NOP;
    [apply] ADDI 1, 1, 2; NOP;
    [apply] SLT 6, 3, 0; NOP;
    [apply] SUB 5, 4, 6; NOP;
    [apply] ADD 2, 2, 5; NOP;
    [apply] B cycle_1; NOP;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 11, $2 = 5, $3 = 21
    [apply] 
    [apply] SLT 6, 0, 3; NOP;
    [apply] BEQ 6, 0, done_1; NOP;
    [apply] SUB 3, 3, 1; NOP;
    [apply] ADDI 1, 1, 2; NOP;
    [apply] SLT 6, 3, 0; NOP;
    [apply] SUB 5, 4, 6; NOP;
    [apply] ADD 2, 2, 5; NOP;
    [apply] B cycle_1; NOP;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 13, $2 = 6, $3 = 10
    [apply] 
    [apply] SLT 6, 0, 3; NOP;
    [apply] BEQ 6, 0, done_1; NOP;
    [apply] SUB 3, 3, 1; NOP;
    [apply] ADDI 1, 1, 2; NOP;
    [apply] SLT 6, 3, 0; NOP;
    [apply] SUB 5, 4, 6; NOP;
    [apply] ADD 2, 2, 5; NOP;
    [apply] B cycle_1; NOP;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 15, $2 = 6, $3 = 4294967293
    [apply] 
    [apply] SLT 6, 0, 3; NOP;
    [apply] BEQ 6, 0, done_1; NOP;
    [apply] Jump to label: done_1
    [apply] 
    [apply] sqrt of 46: 6
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] // Initializer for R
    [apply] LUI 0, 43715; ADDI 0, 0, 63166;
    [apply] 
    [apply] Stimulus
    [apply] ADDI 3, 0, 46; ADDI 1, 0, 1;
    [apply] MOVE 2, 0; ADDI 4, 0, 1;
    [apply] cycle_1:
    [apply] SLT 6, 0, 3; NOP;
    [apply] BEQ 6, 0, done_1; NOP;
    [apply] SUB 3, 3, 1; NOP;
    [apply] ADDI 1, 1, 2; NOP;
    [apply] SLT 6, 3, 0; NOP;
    [apply] SUB 5, 4, 6; NOP;
    [apply] ADD 2, 2, 5; NOP;
    [apply] B cycle_1; NOP;
    [apply] done_1:
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.187 seconds 
    [apply] Generation rate: 69 instructions/second
    [apply] Programs/stimuli/instructions: 1/1/13
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: vliw
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\demo\vliw\templates\int_sqrt4.rb
    [apply] Loaded template VliwBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/vliw_base.rb
    [apply] Loaded template IntSqrt4Template defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/int_sqrt4.rb
    [apply] Processing template IntSqrt4Template defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/vliw/templates/int_sqrt4.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: R
    [apply] Output (runtime: false): "// Initializer for R"
    [apply] Operation: LUI
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: R
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: F
    [apply] Output (runtime: false): "// Initializer for F"
    [apply] Addressing mode: R
    [apply] Operation: LUI
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Operation: MTF
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: F
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Output (runtime: true): "Integer square root: Debug Output"
    [apply] Output (runtime: true): "Input parameter value: x = %d", 46
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: ADDI
    [apply] Addressing mode: R
    [apply] Operation: LUI
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: MOVE
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: cycle_1
    [apply] Output (runtime: true): "Current register values: $1 = %d, $2 = %d, $3 = %d", GPR[1], GPR[2], GPR[3]
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: BEQ
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: OR
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SRL
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SLT
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: BNE
    [apply] Operation: NOP
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SUB
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: OR
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: if_less_1
    [apply] Operation: B
    [apply] Addressing mode: R
    [apply] Addressing mode: R
    [apply] Operation: SRL
    [apply] Operation: vliw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: done_1
    [apply] Output (runtime: true): "sqrt of %d: %d", 46, GPR[2]
    [apply] Ended building a call (empty = false, executable = false)
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op ADDI(rt: R, rs: R, imm: #IMM):[context=null, type=ADDI, root=false]...
    [apply] TestData [bindings={ADDI.rs=10101010110000111111011010111110}]
    [apply] Creating code to assign 10101010110000111111011010111110 to mode R(i: #IMM = 0)...
    [apply] Processing situation null for op LUI(rt: R, offset: #IMM):[context=null, type=LUI, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: ADDI, c2: LUI):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op MOVE(rd: R, rs: R):[context=null, type=MOVE, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: MOVE, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op BEQ(rs: R, rt: R, offset: #IMM):[context=null, type=BEQ, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op OR(rd: R, rs: R, rt: R):[context=null, type=OR, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: BEQ, c2: OR):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op SRL(rd: R, rt: R, sa: #IMM):[context=null, type=SRL, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op SLT(rd: R, rs: R, rt: R):[context=null, type=SLT, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: SRL, c2: SLT):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op BNE(rs: R, rt: R, offset: #IMM):[context=null, type=BNE, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op NOP():[context=null, type=NOP, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: BNE, c2: NOP):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op SUB(rd: R, rs: R, rt: R):[context=null, type=SUB, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op OR(rd: R, rs: R, rt: R):[context=null, type=OR, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: SUB, c2: OR):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: vliw)...
    [apply] Processing situation null for op B(offset: #IMM):[context=null, type=B, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op SRL(rd: R, rt: R, sa: #IMM):[context=null, type=SRL, root=false]...
    [apply] TestData [bindings={}]
    [apply] Processing situation null for op vliw(c1: B, c2: SRL):[context=null, type=vliw, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] LUI 0, 43715; ADDI 0, 0, 63166;
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] Integer square root: Debug Output
    [apply] 
    [apply] Input parameter value: x = 46
    [apply] 
    [apply] ADDI 4, 0, 46; LUI 1, 16384;
    [apply] MOVE 2, 0; NOP;
    [apply] 
    [apply] Current register values: $1 = 1073741824, $2 = 0, $3 = 0
    [apply] 
    [apply] BEQ 1, 0, done_1; OR 3, 2, 1;
    [apply] SRL 2, 2, 1; SLT 6, 4, 3;
    [apply] BNE 6, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SRL 1, 1, 2;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 268435456, $2 = 0, $3 = 1073741824
    [apply] 
    [apply] BEQ 1, 0, done_1; OR 3, 2, 1;
    [apply] SRL 2, 2, 1; SLT 6, 4, 3;
    [apply] BNE 6, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SRL 1, 1, 2;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 67108864, $2 = 0, $3 = 268435456
    [apply] 
    [apply] BEQ 1, 0, done_1; OR 3, 2, 1;
    [apply] SRL 2, 2, 1; SLT 6, 4, 3;
    [apply] BNE 6, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SRL 1, 1, 2;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 16777216, $2 = 0, $3 = 67108864
    [apply] 
    [apply] BEQ 1, 0, done_1; OR 3, 2, 1;
    [apply] SRL 2, 2, 1; SLT 6, 4, 3;
    [apply] BNE 6, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SRL 1, 1, 2;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 4194304, $2 = 0, $3 = 16777216
    [apply] 
    [apply] BEQ 1, 0, done_1; OR 3, 2, 1;
    [apply] SRL 2, 2, 1; SLT 6, 4, 3;
    [apply] BNE 6, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SRL 1, 1, 2;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 1048576, $2 = 0, $3 = 4194304
    [apply] 
    [apply] BEQ 1, 0, done_1; OR 3, 2, 1;
    [apply] SRL 2, 2, 1; SLT 6, 4, 3;
    [apply] BNE 6, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SRL 1, 1, 2;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 262144, $2 = 0, $3 = 1048576
    [apply] 
    [apply] BEQ 1, 0, done_1; OR 3, 2, 1;
    [apply] SRL 2, 2, 1; SLT 6, 4, 3;
    [apply] BNE 6, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SRL 1, 1, 2;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 65536, $2 = 0, $3 = 262144
    [apply] 
    [apply] BEQ 1, 0, done_1; OR 3, 2, 1;
    [apply] SRL 2, 2, 1; SLT 6, 4, 3;
    [apply] BNE 6, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SRL 1, 1, 2;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 16384, $2 = 0, $3 = 65536
    [apply] 
    [apply] BEQ 1, 0, done_1; OR 3, 2, 1;
    [apply] SRL 2, 2, 1; SLT 6, 4, 3;
    [apply] BNE 6, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SRL 1, 1, 2;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 4096, $2 = 0, $3 = 16384
    [apply] 
    [apply] BEQ 1, 0, done_1; OR 3, 2, 1;
    [apply] SRL 2, 2, 1; SLT 6, 4, 3;
    [apply] BNE 6, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SRL 1, 1, 2;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 1024, $2 = 0, $3 = 4096
    [apply] 
    [apply] BEQ 1, 0, done_1; OR 3, 2, 1;
    [apply] SRL 2, 2, 1; SLT 6, 4, 3;
    [apply] BNE 6, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SRL 1, 1, 2;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 256, $2 = 0, $3 = 1024
    [apply] 
    [apply] BEQ 1, 0, done_1; OR 3, 2, 1;
    [apply] SRL 2, 2, 1; SLT 6, 4, 3;
    [apply] BNE 6, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SRL 1, 1, 2;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 64, $2 = 0, $3 = 256
    [apply] 
    [apply] BEQ 1, 0, done_1; OR 3, 2, 1;
    [apply] SRL 2, 2, 1; SLT 6, 4, 3;
    [apply] BNE 6, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SRL 1, 1, 2;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 16, $2 = 0, $3 = 64
    [apply] 
    [apply] BEQ 1, 0, done_1; OR 3, 2, 1;
    [apply] SRL 2, 2, 1; SLT 6, 4, 3;
    [apply] BNE 6, 0, if_less_1; NOP;
    [apply] SUB 4, 4, 3; OR 2, 2, 1;
    [apply] B cycle_1; SRL 1, 1, 2;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 4, $2 = 16, $3 = 16
    [apply] 
    [apply] BEQ 1, 0, done_1; OR 3, 2, 1;
    [apply] SRL 2, 2, 1; SLT 6, 4, 3;
    [apply] BNE 6, 0, if_less_1; NOP;
    [apply] SUB 4, 4, 3; OR 2, 2, 1;
    [apply] B cycle_1; SRL 1, 1, 2;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 1, $2 = 12, $3 = 20
    [apply] 
    [apply] BEQ 1, 0, done_1; OR 3, 2, 1;
    [apply] SRL 2, 2, 1; SLT 6, 4, 3;
    [apply] BNE 6, 0, if_less_1; NOP;
    [apply] Jump to label: if_less_1
    [apply] B cycle_1; SRL 1, 1, 2;
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $1 = 0, $2 = 6, $3 = 13
    [apply] 
    [apply] BEQ 1, 0, done_1; OR 3, 2, 1;
    [apply] Jump to label: done_1
    [apply] 
    [apply] sqrt of 46: 6
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] // Initializer for R
    [apply] LUI 0, 43715; ADDI 0, 0, 63166;
    [apply] 
    [apply] Stimulus
    [apply] ADDI 4, 0, 46; LUI 1, 16384;
    [apply] MOVE 2, 0; NOP;
    [apply] cycle_1:
    [apply] BEQ 1, 0, done_1; OR 3, 2, 1;
    [apply] SRL 2, 2, 1; SLT 6, 4, 3;
    [apply] BNE 6, 0, if_less_1; NOP;
    [apply] SUB 4, 4, 3; OR 2, 2, 1;
    [apply] if_less_1:
    [apply] B cycle_1; SRL 1, 1, 2;
    [apply] done_1:
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.195 seconds 
    [apply] Generation rate: 51 instructions/second
    [apply] Programs/stimuli/instructions: 1/1/10
     [echo] templates for cpu from F:\SVN\MicroTESK\microtesk\microtesk\dist/arch/demo/cpu
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: cpu
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\demo\cpu\templates\example.rb
    [apply] Loaded template CpuBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/cpu/templates/cpu_base.rb
    [apply] Loaded template ExampleTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/cpu/templates/example.rb
    [apply] Processing template ExampleTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/demo/cpu/templates/example.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Output (runtime: false): "; Initializer for REG"
    [apply] Addressing mode: IMM
    [apply] Operation: MOV
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: MEM
    [apply] Output (runtime: false): "; Initializer for MEM"
    [apply] Addressing mode: IMM
    [apply] Operation: MOV
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: MEM
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: IMM
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: IMM
    [apply] Output (runtime: true): "Initialization:"
    [apply] Output (runtime: false): "; Initialization Section Starts"
    [apply] Addressing mode: MEM
    [apply] Addressing mode: IMM
    [apply] Operation: MOV
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: false): "; Initialization Section Ends"
    [apply] Ended building a call (empty = false, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Output (runtime: true): "Finalization:"
    [apply] Output (runtime: false): "; Finalization Section Starts"
    [apply] Addressing mode: MEM
    [apply] Addressing mode: IMM
    [apply] Operation: MOV
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: false): "; Finalization Section Ends"
    [apply] Ended building a call (empty = false, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Output (runtime: true): "Main Section:"
    [apply] Output (runtime: false): "Main Section:"
    [apply] Output (runtime: true): "GPR[0] = %s, M[0] = %s", GPR[0], M[0]
    [apply] Output (runtime: false): "GPR[0] = %s, M[0] = %s", GPR[0], M[0]
    [apply] Output (runtime: false): ""
    [apply] Output (runtime: false): "; Main Section Starts"
    [apply] Output (runtime: false): "/="
    [apply] Output (runtime: false): "Multiline comment. Line 1."
    [apply] Output (runtime: false): "Multiline comment. Line 2."
    [apply] Output (runtime: false): "Multiline comment. Line 3."
    [apply] Output (runtime: false): "=/"
    [apply] Addressing mode: REG
    [apply] Addressing mode: IMM
    [apply] Operation: MOV
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: MOV
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: false): ""
    [apply] Addressing mode: REG
    [apply] Addressing mode: IMM
    [apply] Operation: MOV
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: MOV
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: false): ""
    [apply] Addressing mode: REG
    [apply] Addressing mode: IMM
    [apply] Operation: MOV
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: ADD
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: false): ""
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: ADD
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: false): ""
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: ADD
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: ADD
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: ADD
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: false): ""
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: SUB
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: SUB
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: false): ""
    [apply] Addressing mode: REG
    [apply] Addressing mode: IMM
    [apply] Operation: MOV
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: IMM
    [apply] Operation: MOV
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: start_1
    [apply] Output (runtime: true): "GPR[11] = %d", GPR[11]
    [apply] Addressing mode: REG
    [apply] Operation: JZ
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: SUB
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: J
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: end_1
    [apply] Addressing mode: REG
    [apply] Addressing mode: IMM
    [apply] Operation: MOV
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: false): ""
    [apply] Ended building a call (empty = false, executable = false)
    [apply] 
    [apply] Processing instruction call (root: MOV)...
    [apply] Processing situation null for op MOV(op1: MEM, op2: IMM):[context=#root, type=alu_instr, root=true]...
    [apply] TestData [bindings={MOV.op1=11001001}]
    [apply] Creating code to assign 11001001 to mode MEM(i: #IMM = 12)...
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] mov (12) [201]
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] Initialization:
    [apply] mov (12) [255]
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] ; Initializer for MEM
    [apply] mov (12) [201]
    [apply] 
    [apply] Stimulus
    [apply] ; Initialization Section Starts
    [apply] mov (12) [255]
    [apply] ; Initialization Section Ends
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: MOV)...
    [apply] Processing situation null for op MOV(op1: REG, op2: IMM):[context=#root, type=alu_instr, root=true]...
    [apply] TestData [bindings={MOV.op1=11110110}]
    [apply] Creating code to assign 11110110 to mode REG(i: #IMM = 0)...
    [apply] 
    [apply] Processing instruction call (root: MOV)...
    [apply] Processing situation null for op MOV(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] TestData [bindings={MOV.op1=11000011}]
    [apply] Creating code to assign 11000011 to mode REG(i: #IMM = 1)...
    [apply] 
    [apply] Processing instruction call (root: MOV)...
    [apply] Processing situation null for op MOV(op1: REG, op2: IMM):[context=#root, type=alu_instr, root=true]...
    [apply] TestData [bindings={MOV.op1=10101010}]
    [apply] Creating code to assign 10101010 to mode REG(i: #IMM = 2)...
    [apply] 
    [apply] Processing instruction call (root: MOV)...
    [apply] Processing situation null for op MOV(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] TestData [bindings={MOV.op1=10100110}]
    [apply] Creating code to assign 10100110 to mode REG(i: #IMM = 3)...
    [apply] 
    [apply] Processing instruction call (root: MOV)...
    [apply] Processing situation null for op MOV(op1: REG, op2: IMM):[context=#root, type=alu_instr, root=true]...
    [apply] TestData [bindings={MOV.op1=10010001}]
    [apply] Creating code to assign 10010001 to mode REG(i: #IMM = 14)...
    [apply] 
    [apply] Processing instruction call (root: ADD)...
    [apply] Processing situation null for op ADD(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] TestData [bindings={ADD.op1=01010101}]
    [apply] Creating code to assign 01010101 to mode REG(i: #IMM = 4)...
    [apply] 85 + 5 = 90
    [apply] 
    [apply] Processing instruction call (root: ADD)...
    [apply] Processing situation null for op ADD(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] TestData [bindings={ADD.op1=10001111}]
    [apply] Creating code to assign 10001111 to mode REG(i: #IMM = 5)...
    [apply] 143 + 5 = 148
    [apply] 
    [apply] Processing instruction call (root: ADD)...
    [apply] Processing situation zero(size=8) for op ADD(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=cpu, instruction=ADD, testcase=zero, ADD=ADD, ADD.op1=REG, ADD.op1.i=#IMM, ADD.op2=REG, ADD.op2.i=#IMM}, bindings={ADD.op1.i=0001, ADD.op1=11111111, ADD.op2.i=0010, ADD.op2=11111111}, parameters={size=8}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {ADD.op2=Argument [name=op2, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(8)], ADD.op1=Argument [name=op1, kind=MODE, value=mode REG(i: #IMM), mode=INOUT, type=Type.INT(8)]}
    [apply] TestData [bindings={}]
    [apply] 255 + 255 = 254
    [apply] 
    [apply] Processing instruction call (root: ADD)...
    [apply] Processing situation add(case=normal, size=8) for op ADD(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=cpu, instruction=ADD, testcase=add, ADD=ADD, ADD.op1=REG, ADD.op1.i=#IMM, ADD.op2=REG, ADD.op2.i=#IMM}, bindings={ADD.op1.i=0011, ADD.op1=11111111, ADD.op2.i=0100, ADD.op2=01011010}, parameters={case=normal, size=8}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {ADD.op2=Argument [name=op2, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(8)], ADD.op1=Argument [name=op1, kind=MODE, value=mode REG(i: #IMM), mode=INOUT, type=Type.INT(8)]}
    [apply] TestData [bindings={}]
    [apply] 255 + 90 = 89
    [apply] 
    [apply] Processing instruction call (root: ADD)...
    [apply] Processing situation add(case=overflow, size=8) for op ADD(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=cpu, instruction=ADD, testcase=add, ADD=ADD, ADD.op1=REG, ADD.op1.i=#IMM, ADD.op2=REG, ADD.op2.i=#IMM}, bindings={ADD.op1.i=0101, ADD.op1=10010100, ADD.op2.i=0110, ADD.op2=ADD.op2}, parameters={case=overflow, size=8}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {ADD.op2=Argument [name=op2, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(8)], ADD.op1=Argument [name=op1, kind=MODE, value=mode REG(i: #IMM), mode=INOUT, type=Type.INT(8)]}
    [apply] TestData [bindings={}]
    [apply] 148 + 0 = 148
    [apply] 
    [apply] Processing instruction call (root: SUB)...
    [apply] Processing situation sub(case=normal, size=8) for op SUB(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=cpu, instruction=SUB, testcase=sub, SUB=SUB, SUB.op1=REG, SUB.op1.i=#IMM, SUB.op2=REG, SUB.op2.i=#IMM}, bindings={SUB.op1.i=0111, SUB.op1=SUB.op1, SUB.op2.i=1000, SUB.op2=SUB.op2}, parameters={case=normal, size=8}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {SUB.op2=Argument [name=op2, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(8)], SUB.op1=Argument [name=op1, kind=MODE, value=mode REG(i: #IMM), mode=INOUT, type=Type.INT(8)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: SUB)...
    [apply] Processing situation sub(case=overflow, size=8) for op SUB(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=cpu, instruction=SUB, testcase=sub, SUB=SUB, SUB.op1=REG, SUB.op1.i=#IMM, SUB.op2=REG, SUB.op2.i=#IMM}, bindings={SUB.op1.i=1001, SUB.op1=SUB.op1, SUB.op2.i=1010, SUB.op2=SUB.op2}, parameters={case=overflow, size=8}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {SUB.op2=Argument [name=op2, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(8)], SUB.op1=Argument [name=op1, kind=MODE, value=mode REG(i: #IMM), mode=INOUT, type=Type.INT(8)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: MOV)...
    [apply] Processing situation null for op MOV(op1: REG, op2: IMM):[context=#root, type=alu_instr, root=true]...
    [apply] TestData [bindings={MOV.op1=11100000}]
    [apply] Creating code to assign 11100000 to mode REG(i: #IMM = 11)...
    [apply] 
    [apply] Processing instruction call (root: MOV)...
    [apply] Processing situation null for op MOV(op1: REG, op2: IMM):[context=#root, type=alu_instr, root=true]...
    [apply] TestData [bindings={MOV.op1=01011010}]
    [apply] Creating code to assign 01011010 to mode REG(i: #IMM = 12)...
    [apply] 
    [apply] Processing instruction call (root: JZ)...
    [apply] Processing situation null for op JZ(source: REG, target: #IMM):[context=null, type=JZ, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: SUB)...
    [apply] Processing situation null for op SUB(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: J)...
    [apply] Processing situation null for op J(target: #IMM):[context=null, type=J, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: MOV)...
    [apply] Processing situation null for op MOV(op1: REG, op2: IMM):[context=#root, type=alu_instr, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] mov R0 [246]
    [apply] mov R1 [195]
    [apply] mov R2 [170]
    [apply] mov R3 [166]
    [apply] mov R14 [145]
    [apply] mov R4 [85]
    [apply] mov R5 [143]
    [apply] mov R11 [224]
    [apply] mov R12 [90]
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] Main Section:
    [apply] GPR[0] = 11110110, M[0] = 00000000
    [apply] mov R0 [255]
    [apply] mov R1 R0
    [apply] mov R2 [255]
    [apply] mov R3 R2
    [apply] mov R14 [5]
    [apply] add R4 R14
    [apply] 85 + 5 = 90
    [apply] add R5 R14
    [apply] 143 + 5 = 148
    [apply] add R1 R2
    [apply] 255 + 255 = 254
    [apply] add R3 R4
    [apply] 255 + 90 = 89
    [apply] add R5 R6
    [apply] 148 + 0 = 148
    [apply] sub R7 R8
    [apply] sub R9 R10
    [apply] mov R11 [5]
    [apply] mov R12 [1]
    [apply] GPR[11] = 5
    [apply] jz end_1
    [apply] sub R11 R12
    [apply] j start_1
    [apply] Jump to label: start_1
    [apply] GPR[11] = 4
    [apply] jz end_1
    [apply] sub R11 R12
    [apply] j start_1
    [apply] Jump to label: start_1
    [apply] GPR[11] = 3
    [apply] jz end_1
    [apply] sub R11 R12
    [apply] j start_1
    [apply] Jump to label: start_1
    [apply] GPR[11] = 2
    [apply] jz end_1
    [apply] sub R11 R12
    [apply] j start_1
    [apply] Jump to label: start_1
    [apply] GPR[11] = 1
    [apply] jz end_1
    [apply] sub R11 R12
    [apply] j start_1
    [apply] Jump to label: start_1
    [apply] GPR[11] = 0
    [apply] jz end_1
    [apply] Jump to label: end_1
    [apply] mov R12 [0]
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] ; Initializer for REG
    [apply] mov R0 [246]
    [apply] ; Initializer for REG
    [apply] mov R1 [195]
    [apply] ; Initializer for REG
    [apply] mov R2 [170]
    [apply] ; Initializer for REG
    [apply] mov R3 [166]
    [apply] ; Initializer for REG
    [apply] mov R14 [145]
    [apply] ; Initializer for REG
    [apply] mov R4 [85]
    [apply] ; Initializer for REG
    [apply] mov R5 [143]
    [apply] ; Initializer for REG
    [apply] mov R11 [224]
    [apply] ; Initializer for REG
    [apply] mov R12 [90]
    [apply] 
    [apply] Stimulus
    [apply] Main Section:
    [apply] GPR[0] = 11111111, M[0] = 00000000
    [apply] 
    [apply] ; Main Section Starts
    [apply] /=
    [apply] Multiline comment. Line 1.
    [apply] Multiline comment. Line 2.
    [apply] Multiline comment. Line 3.
    [apply] =/
    [apply] mov R0 [255]
    [apply] mov R1 R0
    [apply] 
    [apply] mov R2 [255]
    [apply] mov R3 R2
    [apply] 
    [apply] mov R14 [5]
    [apply] add R4 R14
    [apply] 
    [apply] add R5 R14
    [apply] 
    [apply] add R1 R2
    [apply] add R3 R4
    [apply] add R5 R6
    [apply] 
    [apply] sub R7 R8
    [apply] sub R9 R10
    [apply] 
    [apply] mov R11 [5]
    [apply] mov R12 [1]
    [apply] start_1:
    [apply] jz end_1
    [apply] sub R11 R12
    [apply] j start_1
    [apply] end_1:
    [apply] mov R12 [0]
    [apply] 
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Begin block: _1
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1_1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: SUB
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: MOV
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1_1
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1_2
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: ADD
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: SUB
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: MOV
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1_2
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ----------------------- Generating Data for Test Case 0 ------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: ADD)...
    [apply] Processing situation add(case=overflow, size=8) for op ADD(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=cpu, instruction=ADD, testcase=add, ADD=ADD, ADD.op1=REG, ADD.op1.i=#IMM, ADD.op2=REG, ADD.op2.i=#IMM}, bindings={ADD.op1.i=0011, ADD.op1=ADD.op1, ADD.op2.i=0100, ADD.op2=ADD.op2}, parameters={case=overflow, size=8}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {ADD.op2=Argument [name=op2, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(8)], ADD.op1=Argument [name=op1, kind=MODE, value=mode REG(i: #IMM), mode=INOUT, type=Type.INT(8)]}
    [apply] TestData [bindings={}]
    [apply] 0 + 0 = 0
    [apply] 
    [apply] Processing instruction call (root: SUB)...
    [apply] Processing situation null for op SUB(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] TestData [bindings={SUB.op2=01000101, SUB.op1=00101010}]
    [apply] Creating code to assign 01000101 to mode REG(i: #IMM = 5)...
    [apply] Creating code to assign 00101010 to mode REG(i: #IMM = 6)...
    [apply] 
    [apply] ---------------------------- Executing Test Case 0 -----------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] mov R5 [69]
    [apply] mov R6 [42]
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add R3 R4
    [apply] 89 + 90 = 179
    [apply] sub R6 R5
    [apply] 
    [apply] ----------------------------- Printing Test Case 0 -----------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] ; Initializer for REG
    [apply] mov R5 [69]
    [apply] ; Initializer for REG
    [apply] mov R6 [42]
    [apply] 
    [apply] Stimulus
    [apply] add R3 R4
    [apply] sub R6 R5
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Generating Data for Test Case 1 ------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: SUB)...
    [apply] Processing situation null for op SUB(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] TestData [bindings={SUB.op2=00101100, SUB.op1=11111010}]
    [apply] Creating code to assign 00101100 to mode REG(i: #IMM = 5)...
    [apply] Creating code to assign 11111010 to mode REG(i: #IMM = 6)...
    [apply] 
    [apply] Processing instruction call (root: SUB)...
    [apply] Processing situation sub(case=overflow, size=8) for op SUB(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=cpu, instruction=SUB, testcase=sub, SUB=SUB, SUB.op1=REG, SUB.op1.i=#IMM, SUB.op2=REG, SUB.op2.i=#IMM}, bindings={SUB.op1.i=0011, SUB.op1=SUB.op1, SUB.op2.i=0100, SUB.op2=SUB.op2}, parameters={case=overflow, size=8}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {SUB.op2=Argument [name=op2, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(8)], SUB.op1=Argument [name=op1, kind=MODE, value=mode REG(i: #IMM), mode=INOUT, type=Type.INT(8)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------- Executing Test Case 1 -----------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] mov R5 [44]
    [apply] mov R6 [250]
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] sub R6 R5
    [apply] sub R3 R4
    [apply] 
    [apply] ----------------------------- Printing Test Case 1 -----------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] ; Initializer for REG
    [apply] mov R5 [44]
    [apply] ; Initializer for REG
    [apply] mov R6 [250]
    [apply] 
    [apply] Stimulus
    [apply] sub R6 R5
    [apply] sub R3 R4
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Generating Data for Test Case 2 ------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: SUB)...
    [apply] Processing situation null for op SUB(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] TestData [bindings={SUB.op2=10100111, SUB.op1=10101000}]
    [apply] Creating code to assign 10100111 to mode REG(i: #IMM = 5)...
    [apply] Creating code to assign 10101000 to mode REG(i: #IMM = 6)...
    [apply] 
    [apply] Processing instruction call (root: MOV)...
    [apply] Processing situation null for op MOV(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] TestData [bindings={MOV.op1=00001000, MOV.op2=00111010}]
    [apply] Creating code to assign 00001000 to mode REG(i: #IMM = 4)...
    [apply] Creating code to assign 00111010 to mode REG(i: #IMM = 3)...
    [apply] 
    [apply] ---------------------------- Executing Test Case 2 -----------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] mov R5 [167]
    [apply] mov R6 [168]
    [apply] mov R4 [8]
    [apply] mov R3 [58]
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] sub R6 R5
    [apply] mov R4 R3
    [apply] 
    [apply] ----------------------------- Printing Test Case 2 -----------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] ; Initializer for REG
    [apply] mov R5 [167]
    [apply] ; Initializer for REG
    [apply] mov R6 [168]
    [apply] ; Initializer for REG
    [apply] mov R4 [8]
    [apply] ; Initializer for REG
    [apply] mov R3 [58]
    [apply] 
    [apply] Stimulus
    [apply] sub R6 R5
    [apply] mov R4 R3
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Generating Data for Test Case 3 ------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: ADD)...
    [apply] Processing situation add(case=overflow, size=8) for op ADD(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=cpu, instruction=ADD, testcase=add, ADD=ADD, ADD.op1=REG, ADD.op1.i=#IMM, ADD.op2=REG, ADD.op2.i=#IMM}, bindings={ADD.op1.i=0011, ADD.op1=ADD.op1, ADD.op2.i=0100, ADD.op2=ADD.op2}, parameters={case=overflow, size=8}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {ADD.op2=Argument [name=op2, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(8)], ADD.op1=Argument [name=op1, kind=MODE, value=mode REG(i: #IMM), mode=INOUT, type=Type.INT(8)]}
    [apply] TestData [bindings={}]
    [apply] 0 + 0 = 0
    [apply] 
    [apply] Processing instruction call (root: MOV)...
    [apply] Processing situation null for op MOV(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] TestData [bindings={MOV.op1=00001011, MOV.op2=10110110}]
    [apply] Creating code to assign 00001011 to mode REG(i: #IMM = 7)...
    [apply] Creating code to assign 10110110 to mode REG(i: #IMM = 6)...
    [apply] 
    [apply] ---------------------------- Executing Test Case 3 -----------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] mov R7 [11]
    [apply] mov R6 [182]
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add R3 R4
    [apply] 58 + 58 = 116
    [apply] mov R7 R6
    [apply] 
    [apply] ----------------------------- Printing Test Case 3 -----------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] ; Initializer for REG
    [apply] mov R7 [11]
    [apply] ; Initializer for REG
    [apply] mov R6 [182]
    [apply] 
    [apply] Stimulus
    [apply] add R3 R4
    [apply] mov R7 R6
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Generating Data for Test Case 4 ------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: MOV)...
    [apply] Processing situation null for op MOV(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] TestData [bindings={MOV.op1=01100100, MOV.op2=10000011}]
    [apply] Creating code to assign 01100100 to mode REG(i: #IMM = 7)...
    [apply] Creating code to assign 10000011 to mode REG(i: #IMM = 6)...
    [apply] 
    [apply] Processing instruction call (root: SUB)...
    [apply] Processing situation sub(case=overflow, size=8) for op SUB(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=cpu, instruction=SUB, testcase=sub, SUB=SUB, SUB.op1=REG, SUB.op1.i=#IMM, SUB.op2=REG, SUB.op2.i=#IMM}, bindings={SUB.op1.i=0011, SUB.op1=SUB.op1, SUB.op2.i=0100, SUB.op2=SUB.op2}, parameters={case=overflow, size=8}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {SUB.op2=Argument [name=op2, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(8)], SUB.op1=Argument [name=op1, kind=MODE, value=mode REG(i: #IMM), mode=INOUT, type=Type.INT(8)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------- Executing Test Case 4 -----------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] mov R7 [100]
    [apply] mov R6 [131]
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] mov R7 R6
    [apply] sub R3 R4
    [apply] 
    [apply] ----------------------------- Printing Test Case 4 -----------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] ; Initializer for REG
    [apply] mov R7 [100]
    [apply] ; Initializer for REG
    [apply] mov R6 [131]
    [apply] 
    [apply] Stimulus
    [apply] mov R7 R6
    [apply] sub R3 R4
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Generating Data for Test Case 5 ------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: MOV)...
    [apply] Processing situation null for op MOV(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] TestData [bindings={MOV.op1=01001000, MOV.op2=01001001}]
    [apply] Creating code to assign 01001000 to mode REG(i: #IMM = 4)...
    [apply] Creating code to assign 01001001 to mode REG(i: #IMM = 3)...
    [apply] 
    [apply] Processing instruction call (root: MOV)...
    [apply] Processing situation null for op MOV(op1: REG, op2: REG):[context=#root, type=alu_instr, root=true]...
    [apply] TestData [bindings={MOV.op1=10111101, MOV.op2=11101110}]
    [apply] Creating code to assign 10111101 to mode REG(i: #IMM = 7)...
    [apply] Creating code to assign 11101110 to mode REG(i: #IMM = 6)...
    [apply] 
    [apply] ---------------------------- Executing Test Case 5 -----------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] mov R4 [72]
    [apply] mov R3 [73]
    [apply] mov R7 [189]
    [apply] mov R6 [238]
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] mov R4 R3
    [apply] mov R7 R6
    [apply] 
    [apply] ----------------------------- Printing Test Case 5 -----------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] ; Initializer for REG
    [apply] mov R4 [72]
    [apply] ; Initializer for REG
    [apply] mov R3 [73]
    [apply] ; Initializer for REG
    [apply] mov R7 [189]
    [apply] ; Initializer for REG
    [apply] mov R6 [238]
    [apply] 
    [apply] Stimulus
    [apply] mov R4 R3
    [apply] mov R7 R6
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: MOV)...
    [apply] Processing situation null for op MOV(op1: MEM, op2: IMM):[context=#root, type=alu_instr, root=true]...
    [apply] TestData [bindings={MOV.op1=00011110}]
    [apply] Creating code to assign 00011110 to mode MEM(i: #IMM = 23)...
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] mov (23) [30]
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] Finalization:
    [apply] mov (23) [23]
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] ; Initializer for MEM
    [apply] mov (23) [30]
    [apply] 
    [apply] Stimulus
    [apply] ; Finalization Section Starts
    [apply] mov (23) [23]
    [apply] ; Finalization Section Ends
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.599 seconds 
    [apply] Generation rate: 148 instructions/second
    [apply] Programs/stimuli/instructions: 1/7/89
     [echo] templates for minimips from F:\SVN\MicroTESK\microtesk\microtesk\dist/arch/minimips
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: minimips
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\minimips\templates\bubble_sort.rb
    [apply] Loaded template MiniMipsBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/minimips_base.rb
    [apply] Loaded template BubbleSortTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/bubble_sort.rb
    [apply] Processing template BubbleSortTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/bubble_sort.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Defining Type.CARD(8) as byte ('.byte')...
    [apply] Defining Type.CARD(16) as half ('.half')...
    [apply] Defining Type.CARD(32) as word ('.word')...
    [apply] Defining space as space ('.space') filled with 0...
    [apply] Defining not null-terminated ASCII string as ascii ('.ascii')...
    [apply] Defining null-terminated ASCII string as asciiz ('.asciiz')...
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: or
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Defining data...
    [apply] Label data
    [apply] Label end
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Output (runtime: false): ".text"
    [apply] Output (runtime: true): ".text"
    [apply] Output (runtime: true): "Data starts: %d", 0
    [apply] Output (runtime: true): "Data ends:   %d", 48
    [apply] Output (runtime: true): "Data count:  %d", 12
    [apply] Output (runtime: true): "Data values:"
    [apply] Output (runtime: true): "M[%d]: %d", 0, M[0]
    [apply] Output (runtime: true): "M[%d]: %d", 1, M[1]
    [apply] Output (runtime: true): "M[%d]: %d", 2, M[2]
    [apply] Output (runtime: true): "M[%d]: %d", 3, M[3]
    [apply] Output (runtime: true): "M[%d]: %d", 4, M[4]
    [apply] Output (runtime: true): "M[%d]: %d", 5, M[5]
    [apply] Output (runtime: true): "M[%d]: %d", 6, M[6]
    [apply] Output (runtime: true): "M[%d]: %d", 7, M[7]
    [apply] Output (runtime: true): "M[%d]: %d", 8, M[8]
    [apply] Output (runtime: true): "M[%d]: %d", 9, M[9]
    [apply] Output (runtime: true): "M[%d]: %d", 10, M[10]
    [apply] Output (runtime: true): "M[%d]: %d", 11, M[11]
    [apply] Output (runtime: true): ""
    [apply] Addressing mode: REG
    [apply] Operation: la
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Operation: la
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: repeat_1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: for_1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: beq
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: lw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: lw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: slt
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: beq
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sll
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: xor
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: xor
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: xor
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: next_1
    [apply] Operation: j
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: exit_for_1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: bne
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: true): "Data starts: %d", 0
    [apply] Output (runtime: true): "Data ends:   %d", 48
    [apply] Output (runtime: true): "Data count:  %d", 12
    [apply] Output (runtime: true): "Data values:"
    [apply] Output (runtime: true): "M[%d]: %d", 0, M[0]
    [apply] Output (runtime: true): "M[%d]: %d", 1, M[1]
    [apply] Output (runtime: true): "M[%d]: %d", 2, M[2]
    [apply] Output (runtime: true): "M[%d]: %d", 3, M[3]
    [apply] Output (runtime: true): "M[%d]: %d", 4, M[4]
    [apply] Output (runtime: true): "M[%d]: %d", 5, M[5]
    [apply] Output (runtime: true): "M[%d]: %d", 6, M[6]
    [apply] Output (runtime: true): "M[%d]: %d", 7, M[7]
    [apply] Output (runtime: true): "M[%d]: %d", 8, M[8]
    [apply] Output (runtime: true): "M[%d]: %d", 9, M[9]
    [apply] Output (runtime: true): "M[%d]: %d", 10, M[10]
    [apply] Output (runtime: true): "M[%d]: %d", 11, M[11]
    [apply] Output (runtime: true): ""
    [apply] Ended building a call (empty = false, executable = false)
    [apply] 
    [apply] ------------------------------ Data Declarations -------------------------------
    [apply] 
    [apply] .data
    [apply] data:
    [apply] 	.word 0x7, 0x7, 0x7, 0x9, 0x2, 0x4, 0x5, 0x1, 0x4, 0x6, 0x8, 0x3
    [apply] end:
    [apply] 	.space 1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: la)...
    [apply] Processing situation null for op la(rd: REG, addr: #IMM):[context=null, type=la, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: la)...
    [apply] Processing situation null for op la(rd: REG, addr: #IMM):[context=null, type=la, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: addi)...
    [apply] Processing situation null for op addi(rt: REG, rs: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: beq)...
    [apply] Processing situation null for op beq(rs: REG, rt: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: addi)...
    [apply] Processing situation null for op addi(rt: REG, rs: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: lw)...
    [apply] Processing situation null for op lw(rt: REG, offset: #IMM, address: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: lw)...
    [apply] Processing situation null for op lw(rt: REG, offset: #IMM, address: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: slt)...
    [apply] Processing situation null for op slt(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: beq)...
    [apply] Processing situation null for op beq(rs: REG, rt: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sll)...
    [apply] Processing situation null for op sll(rd: REG, rt: REG, sa: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: xor)...
    [apply] Processing situation null for op xor(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: xor)...
    [apply] Processing situation null for op xor(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: xor)...
    [apply] Processing situation null for op xor(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: addi)...
    [apply] Processing situation null for op addi(rt: REG, rs: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sw)...
    [apply] Processing situation null for op sw(rd: REG, offset: #IMM, address: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sw)...
    [apply] Processing situation null for op sw(rd: REG, offset: #IMM, address: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: j)...
    [apply] Processing situation null for op j(addr: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: addi)...
    [apply] Processing situation null for op addi(rt: REG, rs: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: bne)...
    [apply] Processing situation null for op bne(rs: REG, rt: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] .text
    [apply] 
    [apply] Data starts: 0
    [apply] Data ends:   48
    [apply] Data count:  12
    [apply] 
    [apply] Data values:
    [apply] M[0]: 7
    [apply] M[1]: 7
    [apply] M[2]: 7
    [apply] M[3]: 9
    [apply] M[4]: 2
    [apply] M[5]: 4
    [apply] M[6]: 5
    [apply] M[7]: 1
    [apply] M[8]: 4
    [apply] M[9]: 6
    [apply] M[10]: 8
    [apply] M[11]: 3
    [apply] 
    [apply] la $16, data
    [apply] la $17, end
    [apply] add $8, $0, $0
    [apply] addi $9, $16, 0x4
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] Jump to label: exit_for_1
    [apply] bne $8, $0, repeat_1
    [apply] add $8, $0, $0
    [apply] Jump to label: repeat_1
    [apply] addi $9, $16, 0x4
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] Jump to label: exit_for_1
    [apply] bne $8, $0, repeat_1
    [apply] add $8, $0, $0
    [apply] Jump to label: repeat_1
    [apply] addi $9, $16, 0x4
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] Jump to label: exit_for_1
    [apply] bne $8, $0, repeat_1
    [apply] add $8, $0, $0
    [apply] Jump to label: repeat_1
    [apply] addi $9, $16, 0x4
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] Jump to label: exit_for_1
    [apply] bne $8, $0, repeat_1
    [apply] add $8, $0, $0
    [apply] Jump to label: repeat_1
    [apply] addi $9, $16, 0x4
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] Jump to label: exit_for_1
    [apply] bne $8, $0, repeat_1
    [apply] add $8, $0, $0
    [apply] Jump to label: repeat_1
    [apply] addi $9, $16, 0x4
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] Jump to label: exit_for_1
    [apply] bne $8, $0, repeat_1
    [apply] add $8, $0, $0
    [apply] Jump to label: repeat_1
    [apply] addi $9, $16, 0x4
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] Jump to label: exit_for_1
    [apply] bne $8, $0, repeat_1
    [apply] add $8, $0, $0
    [apply] Jump to label: repeat_1
    [apply] addi $9, $16, 0x4
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] Jump to label: exit_for_1
    [apply] bne $8, $0, repeat_1
    [apply] add $8, $0, $0
    [apply] Jump to label: repeat_1
    [apply] addi $9, $16, 0x4
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] Jump to label: exit_for_1
    [apply] bne $8, $0, repeat_1
    [apply] add $8, $0, $0
    [apply] Jump to label: repeat_1
    [apply] addi $9, $16, 0x4
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: next_1
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] Jump to label: for_1
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] Jump to label: exit_for_1
    [apply] bne $8, $0, repeat_1
    [apply] add $8, $0, $0
    [apply] 
    [apply] Data starts: 0
    [apply] Data ends:   48
    [apply] Data count:  12
    [apply] 
    [apply] Data values:
    [apply] M[0]: 1
    [apply] M[1]: 2
    [apply] M[2]: 3
    [apply] M[3]: 4
    [apply] M[4]: 4
    [apply] M[5]: 5
    [apply] M[6]: 6
    [apply] M[7]: 7
    [apply] M[8]: 7
    [apply] M[9]: 7
    [apply] M[10]: 8
    [apply] M[11]: 9
    [apply] 
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] .text
    [apply] la $16, data
    [apply] la $17, end
    [apply] add $8, $0, $0
    [apply] repeat_1:
    [apply] addi $9, $16, 0x4
    [apply] for_1:
    [apply] beq $9, $17, exit_for_1
    [apply] addi $11, $0, 0x4
    [apply] sub $10, $9, $11
    [apply] lw $12, 0($9)
    [apply] lw $13, 0($10)
    [apply] slt $14, $12, $13
    [apply] beq $14, $0, next_1
    [apply] sll $0, $0, 0
    [apply] xor $12, $12, $13
    [apply] xor $13, $12, $13
    [apply] xor $12, $12, $13
    [apply] addi $8, $0, 0x1
    [apply] sw $12, 0($9)
    [apply] sw $13, 0($10)
    [apply] next_1:
    [apply] j for_1
    [apply] addi $9, $9, 0x4
    [apply] exit_for_1:
    [apply] bne $8, $0, repeat_1
    [apply] add $8, $0, $0
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.918 seconds 
    [apply] Generation rate: 25 instructions/second
    [apply] Programs/stimuli/instructions: 1/1/23
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: minimips
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\minimips\templates\constraint.rb
    [apply] Loaded template MiniMipsBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/minimips_base.rb
    [apply] Loaded template ConstraintTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/constraint.rb
    [apply] Processing template ConstraintTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/constraint.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Defining Type.CARD(8) as byte ('.byte')...
    [apply] Defining Type.CARD(16) as half ('.half')...
    [apply] Defining Type.CARD(32) as word ('.word')...
    [apply] Defining space as space ('.space') filled with 0...
    [apply] Defining not null-terminated ASCII string as ascii ('.ascii')...
    [apply] Defining null-terminated ASCII string as asciiz ('.asciiz')...
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: or
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation constraint_int_overflow(size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=constraint_int_overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 3.464 seconds 
    [apply] Generation rate: 28 instructions/second
    [apply] Programs/stimuli/instructions: 1/100/100
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: minimips
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\minimips\templates\coverage.rb
    [apply] Loaded template MiniMipsBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/minimips_base.rb
    [apply] Loaded template CoverageTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/coverage.rb
    [apply] Processing template CoverageTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/coverage.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Defining Type.CARD(8) as byte ('.byte')...
    [apply] Defining Type.CARD(16) as half ('.half')...
    [apply] Defining Type.CARD(32) as word ('.word')...
    [apply] Defining space as space ('.space') filled with 0...
    [apply] Defining not null-terminated ASCII string as ascii ('.ascii')...
    [apply] Defining null-terminated ASCII string as asciiz ('.asciiz')...
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: or
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.overflow for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rs=11110110101111100010111011001001, add.rt=10010001101001101010101011000011}]
    [apply] Creating code to assign 11110110101111100010111011001001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 10010001101001101010101011000011 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.normal for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.normal, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01011, add.rd=add.rd, add.rs.i=01100, add.rs=add.rs, add.rt.i=01101, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rs=00100010011010111000111101010101, add.rt=10111111101000111011000001110101}]
    [apply] Creating code to assign 00100010011010111000111101010101 to mode REG(i: #IMM = 12)...
    [apply] Creating code to assign 10111111101000111011000001110101 to mode REG(i: #IMM = 13)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $9, 0xf6be
    [apply] addi $9, $9, 0x2ec9
    [apply] lui $10, 0x91a6
    [apply] addi $10, $10, 0xaac3
    [apply] lui $12, 0x226b
    [apply] addi $12, $12, 0x8f55
    [apply] lui $13, 0xbfa3
    [apply] addi $13, $13, 0xb075
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] add $11, $12, $13
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $9, 0xf6be
    [apply] addi $9, $9, 0x2ec9
    [apply] lui $10, 0x91a6
    [apply] addi $10, $10, 0xaac3
    [apply] lui $12, 0x226b
    [apply] addi $12, $12, 0x8f55
    [apply] lui $13, 0xbfa3
    [apply] addi $13, $13, 0xb075
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] add $11, $12, $13
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.420 seconds 
    [apply] Generation rate: 33 instructions/second
    [apply] Programs/stimuli/instructions: 1/1/14
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: minimips
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\minimips\templates\dependencies.rb
    [apply] Loaded template MiniMipsBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/minimips_base.rb
    [apply] Loaded template DependenciesTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/dependencies.rb
    [apply] Processing template DependenciesTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/dependencies.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Defining Type.CARD(8) as byte ('.byte')...
    [apply] Defining Type.CARD(16) as half ('.half')...
    [apply] Defining Type.CARD(32) as word ('.word')...
    [apply] Defining space as space ('.space') filled with 0...
    [apply] Defining not null-terminated ASCII string as ascii ('.ascii')...
    [apply] Defining null-terminated ASCII string as asciiz ('.asciiz')...
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: or
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.overflow for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01000, add.rs=add.rs, add.rt.i=01001, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rs=11110110101111100010111011001001, add.rt=10010001101001101010101011000011}]
    [apply] Creating code to assign 11110110101111100010111011001001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 10010001101001101010101011000011 to mode REG(i: #IMM = 9)...
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.normal for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.normal, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=10001000011001001101100110001100, add.rs.i=01000, add.rs=10001000011001001101100110001100, add.rt.i=01010, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rt=00100010011010111000111101010101}]
    [apply] Creating code to assign 00100010011010111000111101010101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.overflow for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=10101010110100000110100011100001, add.rs.i=01000, add.rs=10101010110100000110100011100001, add.rt.i=01011, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rt=10111111101000111011000001110101}]
    [apply] Creating code to assign 10111111101000111011000001110101 to mode REG(i: #IMM = 11)...
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.normal for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.normal, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=10101010110100000110100011100001, add.rs.i=01000, add.rs=10101010110100000110100011100001, add.rt.i=01100, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rt=10001011100010010010100000100111}]
    [apply] Creating code to assign 10001011100010010010100000100111 to mode REG(i: #IMM = 12)...
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xf6be
    [apply] addi $8, $8, 0x2ec9
    [apply] lui $9, 0x91a6
    [apply] addi $9, $9, 0xaac3
    [apply] lui $10, 0x226b
    [apply] addi $10, $10, 0x8f55
    [apply] lui $11, 0xbfa3
    [apply] addi $11, $11, 0xb075
    [apply] lui $12, 0x8b89
    [apply] addi $12, $12, 0x2827
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $8, $9
    [apply] add $8, $8, $10
    [apply] add $8, $8, $11
    [apply] Exception was raised: IntegerOverflow
    [apply] add $8, $8, $12
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xf6be
    [apply] addi $8, $8, 0x2ec9
    [apply] lui $9, 0x91a6
    [apply] addi $9, $9, 0xaac3
    [apply] lui $10, 0x226b
    [apply] addi $10, $10, 0x8f55
    [apply] lui $11, 0xbfa3
    [apply] addi $11, $11, 0xb075
    [apply] lui $12, 0x8b89
    [apply] addi $12, $12, 0x2827
    [apply] 
    [apply] Stimulus
    [apply] add $8, $8, $9
    [apply] add $8, $8, $10
    [apply] add $8, $8, $11
    [apply] add $8, $8, $12
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.overflow for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01000, add.rs=add.rs, add.rt.i=01001, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rs=11100101000010001011110111100101, add.rt=01010011010101011111101000111010}]
    [apply] Creating code to assign 11100101000010001011110111100101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 01010011010101011111101000111010 to mode REG(i: #IMM = 9)...
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.normal for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.normal, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=00111000010111101011100000011111, add.rs.i=01000, add.rs=00111000010111101011100000011111, add.rt.i=01010, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rt=01011010111000000000011111010010}]
    [apply] Creating code to assign 01011010111000000000011111010010 to mode REG(i: #IMM = 10)...
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.overflow for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=00111000010111101011100000011111, add.rs.i=01000, add.rs=00111000010111101011100000011111, add.rt.i=01011, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rt=10101001110010010111000000100101}]
    [apply] Creating code to assign 10101001110010010111000000100101 to mode REG(i: #IMM = 11)...
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.normal for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.normal, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=11100010001010000010100001000100, add.rs.i=01000, add.rs=11100010001010000010100001000100, add.rt.i=01100, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rt=11100110111101100111100011011110}]
    [apply] Creating code to assign 11100110111101100111100011011110 to mode REG(i: #IMM = 12)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xe508
    [apply] addi $8, $8, 0xbde5
    [apply] lui $9, 0x5355
    [apply] addi $9, $9, 0xfa3a
    [apply] lui $10, 0x5ae0
    [apply] addi $10, $10, 0x7d2
    [apply] lui $11, 0xa9c9
    [apply] addi $11, $11, 0x7025
    [apply] lui $12, 0xe6f6
    [apply] addi $12, $12, 0x78de
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $8, $9
    [apply] add $8, $8, $10
    [apply] Exception was raised: IntegerOverflow
    [apply] add $8, $8, $11
    [apply] add $8, $8, $12
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xe508
    [apply] addi $8, $8, 0xbde5
    [apply] lui $9, 0x5355
    [apply] addi $9, $9, 0xfa3a
    [apply] lui $10, 0x5ae0
    [apply] addi $10, $10, 0x7d2
    [apply] lui $11, 0xa9c9
    [apply] addi $11, $11, 0x7025
    [apply] lui $12, 0xe6f6
    [apply] addi $12, $12, 0x78de
    [apply] 
    [apply] Stimulus
    [apply] add $8, $8, $9
    [apply] add $8, $8, $10
    [apply] add $8, $8, $11
    [apply] add $8, $8, $12
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.overflow for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01000, add.rs=add.rs, add.rt.i=01001, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rs=10000100001010100100010111011101, add.rt=00101100100101001010111001001110}]
    [apply] Creating code to assign 10000100001010100100010111011101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00101100100101001010111001001110 to mode REG(i: #IMM = 9)...
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.normal for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.normal, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=10110000101111101111010000101011, add.rs.i=01000, add.rs=10110000101111101111010000101011, add.rt.i=01010, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rt=00000000010111011011011111111010}]
    [apply] Creating code to assign 00000000010111011011011111111010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.overflow for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=10110001000111001010110000100101, add.rs.i=01000, add.rs=10110001000111001010110000100101, add.rt.i=01011, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rt=00000111111110101111110000110111}]
    [apply] Creating code to assign 00000111111110101111110000110111 to mode REG(i: #IMM = 11)...
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.normal for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.normal, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=10111001000101111010100001011100, add.rs.i=01000, add.rs=10111001000101111010100001011100, add.rt.i=01100, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rt=10101000101001111100011000010011}]
    [apply] Creating code to assign 10101000101001111100011000010011 to mode REG(i: #IMM = 12)...
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0x842a
    [apply] addi $8, $8, 0x45dd
    [apply] lui $9, 0x2c94
    [apply] addi $9, $9, 0xae4e
    [apply] lui $10, 0x5d
    [apply] addi $10, $10, 0xb7fa
    [apply] lui $11, 0x7fa
    [apply] addi $11, $11, 0xfc37
    [apply] lui $12, 0xa8a7
    [apply] addi $12, $12, 0xc613
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $8, $9
    [apply] add $8, $8, $10
    [apply] add $8, $8, $11
    [apply] add $8, $8, $12
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0x842a
    [apply] addi $8, $8, 0x45dd
    [apply] lui $9, 0x2c94
    [apply] addi $9, $9, 0xae4e
    [apply] lui $10, 0x5d
    [apply] addi $10, $10, 0xb7fa
    [apply] lui $11, 0x7fa
    [apply] addi $11, $11, 0xfc37
    [apply] lui $12, 0xa8a7
    [apply] addi $12, $12, 0xc613
    [apply] 
    [apply] Stimulus
    [apply] add $8, $8, $9
    [apply] add $8, $8, $10
    [apply] add $8, $8, $11
    [apply] add $8, $8, $12
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.overflow for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01000, add.rs=add.rs, add.rt.i=01001, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rs=10011011110000110011101000001000, add.rt=11001000000011001011000011001000}]
    [apply] Creating code to assign 10011011110000110011101000001000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11001000000011001011000011001000 to mode REG(i: #IMM = 9)...
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.normal for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.normal, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=10011011110000110011101000001000, add.rs.i=01000, add.rs=10011011110000110011101000001000, add.rt.i=01010, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rt=00001011000101110001110101010010}]
    [apply] Creating code to assign 00001011000101110001110101010010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.overflow for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=10100110110110100101011101011010, add.rs.i=01000, add.rs=10100110110110100101011101011010, add.rt.i=01011, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rt=01111101001011000010000010110110}]
    [apply] Creating code to assign 01111101001011000010000010110110 to mode REG(i: #IMM = 11)...
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.normal for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.normal, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=00100100000001100111100000010000, add.rs.i=01000, add.rs=00100100000001100111100000010000, add.rt.i=01100, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rt=00010101100000110110010001001000}]
    [apply] Creating code to assign 00010101100000110110010001001000 to mode REG(i: #IMM = 12)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0x9bc3
    [apply] addi $8, $8, 0x3a08
    [apply] lui $9, 0xc80c
    [apply] addi $9, $9, 0xb0c8
    [apply] lui $10, 0xb17
    [apply] addi $10, $10, 0x1d52
    [apply] lui $11, 0x7d2c
    [apply] addi $11, $11, 0x20b6
    [apply] lui $12, 0x1583
    [apply] addi $12, $12, 0x6448
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $8, $9
    [apply] Exception was raised: IntegerOverflow
    [apply] add $8, $8, $10
    [apply] add $8, $8, $11
    [apply] add $8, $8, $12
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0x9bc3
    [apply] addi $8, $8, 0x3a08
    [apply] lui $9, 0xc80c
    [apply] addi $9, $9, 0xb0c8
    [apply] lui $10, 0xb17
    [apply] addi $10, $10, 0x1d52
    [apply] lui $11, 0x7d2c
    [apply] addi $11, $11, 0x20b6
    [apply] lui $12, 0x1583
    [apply] addi $12, $12, 0x6448
    [apply] 
    [apply] Stimulus
    [apply] add $8, $8, $9
    [apply] add $8, $8, $10
    [apply] add $8, $8, $11
    [apply] add $8, $8, $12
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.overflow for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01000, add.rs=add.rs, add.rt.i=01001, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rs=00001010011100101001001110100101, add.rt=11100000000010011010101000011111}]
    [apply] Creating code to assign 00001010011100101001001110100101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11100000000010011010101000011111 to mode REG(i: #IMM = 9)...
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.normal for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.normal, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=11101010011111000011110111000100, add.rs.i=01000, add.rs=11101010011111000011110111000100, add.rt.i=01010, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rt=11101110101111010100100101001000}]
    [apply] Creating code to assign 11101110101111010100100101001000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.overflow for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.overflow, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=11011001001110011000011100001100, add.rs.i=01000, add.rs=11011001001110011000011100001100, add.rt.i=01011, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rt=01010000101011011101011100011110}]
    [apply] Creating code to assign 01010000101011011101011100011110 to mode REG(i: #IMM = 11)...
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add.normal for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add.normal, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=00101001111001110101111000101010, add.rs.i=01000, add.rs=00101001111001110101111000101010, add.rt.i=01100, add.rt=add.rt}, parameters={}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] Warning: Failed to execute the query. Status: ERROR. Errors: 
    [apply]   null: default test data will be used
    [apply] TestData [bindings={add.rt=10100011101110000111111011101011}]
    [apply] Creating code to assign 10100011101110000111111011101011 to mode REG(i: #IMM = 12)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xa72
    [apply] addi $8, $8, 0x93a5
    [apply] lui $9, 0xe009
    [apply] addi $9, $9, 0xaa1f
    [apply] lui $10, 0xeebd
    [apply] addi $10, $10, 0x4948
    [apply] lui $11, 0x50ad
    [apply] addi $11, $11, 0xd71e
    [apply] lui $12, 0xa3b8
    [apply] addi $12, $12, 0x7eeb
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $8, $9
    [apply] add $8, $8, $10
    [apply] add $8, $8, $11
    [apply] add $8, $8, $12
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xa72
    [apply] addi $8, $8, 0x93a5
    [apply] lui $9, 0xe009
    [apply] addi $9, $9, 0xaa1f
    [apply] lui $10, 0xeebd
    [apply] addi $10, $10, 0x4948
    [apply] lui $11, 0x50ad
    [apply] addi $11, $11, 0xd71e
    [apply] lui $12, 0xa3b8
    [apply] addi $12, $12, 0x7eeb
    [apply] 
    [apply] Stimulus
    [apply] add $8, $8, $9
    [apply] add $8, $8, $10
    [apply] add $8, $8, $11
    [apply] add $8, $8, $12
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 2.006 seconds 
    [apply] Generation rate: 47 instructions/second
    [apply] Programs/stimuli/instructions: 1/5/95
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: minimips
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\minimips\templates\endless_loop.rb
    [apply] Loaded template MiniMipsBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/minimips_base.rb
    [apply] Loaded template EndlessLoopTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/endless_loop.rb
    [apply] Processing template EndlessLoopTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/endless_loop.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Defining Type.CARD(8) as byte ('.byte')...
    [apply] Defining Type.CARD(16) as half ('.half')...
    [apply] Defining Type.CARD(32) as word ('.word')...
    [apply] Defining space as space ('.space') filled with 0...
    [apply] Defining not null-terminated ASCII string as ascii ('.ascii')...
    [apply] Defining null-terminated ASCII string as asciiz ('.asciiz')...
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: or
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Output (runtime: true): "Loop Begins"
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: repeat_1
    [apply] Output (runtime: true): "Iteration: %d", GPR[8]
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: slt
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: bne
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: true): "Loop Ends"
    [apply] Ended building a call (empty = false, executable = false)
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={add.rs=11110110101111100010111011001001, add.rt=10010001101001101010101011000011}]
    [apply] Creating code to assign 11110110101111100010111011001001 to mode REG(i: #IMM = 0)...
    [apply] mode REG(i: #IMM = 0) has already been used to set up the processor state. No initialization code will be created.
    [apply] 
    [apply] Processing instruction call (root: addi)...
    [apply] Processing situation null for op addi(rt: REG, rs: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: slt)...
    [apply] Processing situation null for op slt(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={slt.rs=00100010011010111000111101010101}]
    [apply] Creating code to assign 00100010011010111000111101010101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] Processing instruction call (root: bne)...
    [apply] Processing situation null for op bne(rs: REG, rt: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: addi)...
    [apply] Processing situation null for op addi(rt: REG, rs: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $10, 0x226b
    [apply] addi $10, $10, 0x8f55
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] Loop Begins
    [apply] add $8, $0, $0
    [apply] addi $9, $0, 0x63
    [apply] Iteration: 0
    [apply] slt $10, $10, $9
    [apply] bne $10, $0, repeat_1
    [apply] addi $8, $8, 0x1
    [apply] Loop Ends
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $10, 0x226b
    [apply] addi $10, $10, 0x8f55
    [apply] 
    [apply] Stimulus
    [apply] add $8, $0, $0
    [apply] addi $9, $0, 0x63
    [apply] repeat_1:
    [apply] slt $10, $10, $9
    [apply] bne $10, $0, repeat_1
    [apply] addi $8, $8, 0x1
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.090 seconds 
    [apply] Generation rate: 111 instructions/second
    [apply] Programs/stimuli/instructions: 1/1/10
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: minimips
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\minimips\templates\euclid.rb
    [apply] Loaded template MiniMipsBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/minimips_base.rb
    [apply] Loaded template EuclidTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/euclid.rb
    [apply] Processing template EuclidTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/euclid.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Defining Type.CARD(8) as byte ('.byte')...
    [apply] Defining Type.CARD(16) as half ('.half')...
    [apply] Defining Type.CARD(32) as word ('.word')...
    [apply] Defining space as space ('.space') filled with 0...
    [apply] Defining not null-terminated ASCII string as ascii ('.ascii')...
    [apply] Defining null-terminated ASCII string as asciiz ('.asciiz')...
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: or
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Output (runtime: true): "Euclidean Algorithm (miniMIPS): Debug Output"
    [apply] Output (runtime: true): "Input parameter values: %d, %d", 58, 33
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: cycle_1
    [apply] Output (runtime: true): "Current values: $t1($9)=%d, $t2($10)=%d", GPR[9], GPR[10]
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: beq
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: slt
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: bne
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sll
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: subu
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: j
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sll
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: if_less_1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: subu
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: j
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: done_1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: true): "Result stored in $t3($11): %d", GPR[11]
    [apply] Ended building a call (empty = false, executable = false)
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: addi)...
    [apply] Processing situation null for op addi(rt: REG, rs: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={addi.rs=10010001101001101010101011000011}]
    [apply] Creating code to assign 10010001101001101010101011000011 to mode REG(i: #IMM = 0)...
    [apply] 
    [apply] Processing instruction call (root: addi)...
    [apply] Processing situation null for op addi(rt: REG, rs: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: beq)...
    [apply] Processing situation null for op beq(rs: REG, rt: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: slt)...
    [apply] Processing situation null for op slt(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: bne)...
    [apply] Processing situation null for op bne(rs: REG, rt: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sll)...
    [apply] Processing situation null for op sll(rd: REG, rt: REG, sa: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: subu)...
    [apply] Processing situation null for op subu(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: j)...
    [apply] Processing situation null for op j(addr: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sll)...
    [apply] Processing situation null for op sll(rd: REG, rt: REG, sa: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: subu)...
    [apply] Processing situation null for op subu(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: j)...
    [apply] Processing situation null for op j(addr: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] Euclidean Algorithm (miniMIPS): Debug Output
    [apply] 
    [apply] Input parameter values: 58, 33
    [apply] 
    [apply] addi $9, $0, 0x3a
    [apply] addi $10, $0, 0x21
    [apply] 
    [apply] Current values: $t1($9)=58, $t2($10)=33
    [apply] 
    [apply] beq $9, $10, done_1
    [apply] slt $8, $9, $10
    [apply] bne $8, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] subu $9, $9, $10
    [apply] j cycle_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current values: $t1($9)=25, $t2($10)=33
    [apply] 
    [apply] beq $9, $10, done_1
    [apply] slt $8, $9, $10
    [apply] bne $8, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] subu $10, $10, $9
    [apply] j cycle_1
    [apply] add $11, $9, $0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current values: $t1($9)=25, $t2($10)=8
    [apply] 
    [apply] beq $9, $10, done_1
    [apply] slt $8, $9, $10
    [apply] bne $8, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] subu $9, $9, $10
    [apply] j cycle_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current values: $t1($9)=17, $t2($10)=8
    [apply] 
    [apply] beq $9, $10, done_1
    [apply] slt $8, $9, $10
    [apply] bne $8, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] subu $9, $9, $10
    [apply] j cycle_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current values: $t1($9)=9, $t2($10)=8
    [apply] 
    [apply] beq $9, $10, done_1
    [apply] slt $8, $9, $10
    [apply] bne $8, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] subu $9, $9, $10
    [apply] j cycle_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current values: $t1($9)=1, $t2($10)=8
    [apply] 
    [apply] beq $9, $10, done_1
    [apply] slt $8, $9, $10
    [apply] bne $8, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] subu $10, $10, $9
    [apply] j cycle_1
    [apply] add $11, $9, $0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current values: $t1($9)=1, $t2($10)=7
    [apply] 
    [apply] beq $9, $10, done_1
    [apply] slt $8, $9, $10
    [apply] bne $8, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] subu $10, $10, $9
    [apply] j cycle_1
    [apply] add $11, $9, $0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current values: $t1($9)=1, $t2($10)=6
    [apply] 
    [apply] beq $9, $10, done_1
    [apply] slt $8, $9, $10
    [apply] bne $8, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] subu $10, $10, $9
    [apply] j cycle_1
    [apply] add $11, $9, $0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current values: $t1($9)=1, $t2($10)=5
    [apply] 
    [apply] beq $9, $10, done_1
    [apply] slt $8, $9, $10
    [apply] bne $8, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] subu $10, $10, $9
    [apply] j cycle_1
    [apply] add $11, $9, $0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current values: $t1($9)=1, $t2($10)=4
    [apply] 
    [apply] beq $9, $10, done_1
    [apply] slt $8, $9, $10
    [apply] bne $8, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] subu $10, $10, $9
    [apply] j cycle_1
    [apply] add $11, $9, $0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current values: $t1($9)=1, $t2($10)=3
    [apply] 
    [apply] beq $9, $10, done_1
    [apply] slt $8, $9, $10
    [apply] bne $8, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] subu $10, $10, $9
    [apply] j cycle_1
    [apply] add $11, $9, $0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current values: $t1($9)=1, $t2($10)=2
    [apply] 
    [apply] beq $9, $10, done_1
    [apply] slt $8, $9, $10
    [apply] bne $8, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] subu $10, $10, $9
    [apply] j cycle_1
    [apply] add $11, $9, $0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current values: $t1($9)=1, $t2($10)=1
    [apply] 
    [apply] beq $9, $10, done_1
    [apply] slt $8, $9, $10
    [apply] Jump to label: done_1
    [apply] add $11, $9, $0
    [apply] 
    [apply] Result stored in $t3($11): 1
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] 
    [apply] Stimulus
    [apply] addi $9, $0, 0x3a
    [apply] addi $10, $0, 0x21
    [apply] cycle_1:
    [apply] beq $9, $10, done_1
    [apply] slt $8, $9, $10
    [apply] bne $8, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] subu $9, $9, $10
    [apply] j cycle_1
    [apply] sll $0, $0, 0
    [apply] if_less_1:
    [apply] subu $10, $10, $9
    [apply] j cycle_1
    [apply] done_1:
    [apply] add $11, $9, $0
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.165 seconds 
    [apply] Generation rate: 84 instructions/second
    [apply] Programs/stimuli/instructions: 1/1/14
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: minimips
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\minimips\templates\groups.rb
    [apply] Loaded template MiniMipsBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/minimips_base.rb
    [apply] Loaded template GroupsTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/groups.rb
    [apply] Processing template GroupsTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/groups.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Defining Type.CARD(8) as byte ('.byte')...
    [apply] Defining Type.CARD(16) as half ('.half')...
    [apply] Defining Type.CARD(32) as word ('.word')...
    [apply] Defining space as space ('.space') filled with 0...
    [apply] Defining not null-terminated ASCII string as ascii ('.ascii')...
    [apply] Defining null-terminated ASCII string as asciiz ('.asciiz')...
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: or
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: addu
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: nor
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: addu)...
    [apply] Processing situation null for op addu(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={addu.rt=10010001101001101010101011000011, addu.rs=00100010011010111000111101010101}]
    [apply] Creating code to assign 10010001101001101010101011000011 to mode REG(i: #IMM = 10)...
    [apply] Creating code to assign 00100010011010111000111101010101 to mode REG(i: #IMM = 9)...
    [apply] 
    [apply] Processing instruction call (root: nor)...
    [apply] Processing situation null for op nor(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={nor.rt=10111111101000111011000001110101, nor.rs=10001011100010010010100000100111}]
    [apply] Creating code to assign 10111111101000111011000001110101 to mode REG(i: #IMM = 13)...
    [apply] Creating code to assign 10001011100010010010100000100111 to mode REG(i: #IMM = 12)...
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={sub.rs=11100101000010001011110111100101, sub.rt=01010011010101011111101000111010}]
    [apply] Creating code to assign 11100101000010001011110111100101 to mode REG(i: #IMM = 15)...
    [apply] Creating code to assign 01010011010101011111101000111010 to mode REG(i: #IMM = 24)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $10, 0x91a6
    [apply] addi $10, $10, 0xaac3
    [apply] lui $9, 0x226b
    [apply] addi $9, $9, 0x8f55
    [apply] lui $13, 0xbfa3
    [apply] addi $13, $13, 0xb075
    [apply] lui $12, 0x8b89
    [apply] addi $12, $12, 0x2827
    [apply] lui $15, 0xe508
    [apply] addi $15, $15, 0xbde5
    [apply] lui $24, 0x5355
    [apply] addi $24, $24, 0xfa3a
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] addu $8, $9, $10
    [apply] nor $11, $12, $13
    [apply] sub $14, $15, $24
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $10, 0x91a6
    [apply] addi $10, $10, 0xaac3
    [apply] lui $9, 0x226b
    [apply] addi $9, $9, 0x8f55
    [apply] lui $13, 0xbfa3
    [apply] addi $13, $13, 0xb075
    [apply] lui $12, 0x8b89
    [apply] addi $12, $12, 0x2827
    [apply] lui $15, 0xe508
    [apply] addi $15, $15, 0xbde5
    [apply] lui $24, 0x5355
    [apply] addi $24, $24, 0xfa3a
    [apply] 
    [apply] Stimulus
    [apply] addu $8, $9, $10
    [apply] nor $11, $12, $13
    [apply] sub $14, $15, $24
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: xor
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={sub.rs=10101001110010010111000000100101, sub.rt=11100110111101100111100011011110}]
    [apply] Creating code to assign 10101001110010010111000000100101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11100110111101100111100011011110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] Processing instruction call (root: xor)...
    [apply] Processing situation null for op xor(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={xor.rs=10000100001010100100010111011101, xor.rt=00101100100101001010111001001110}]
    [apply] Creating code to assign 10000100001010100100010111011101 to mode REG(i: #IMM = 12)...
    [apply] Creating code to assign 00101100100101001010111001001110 to mode REG(i: #IMM = 13)...
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={sub.rs=00000000010111011011011111111010, sub.rt=00000111111110101111110000110111}]
    [apply] Creating code to assign 00000000010111011011011111111010 to mode REG(i: #IMM = 15)...
    [apply] Creating code to assign 00000111111110101111110000110111 to mode REG(i: #IMM = 24)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $9, 0xa9c9
    [apply] addi $9, $9, 0x7025
    [apply] lui $10, 0xe6f6
    [apply] addi $10, $10, 0x78de
    [apply] lui $12, 0x842a
    [apply] addi $12, $12, 0x45dd
    [apply] lui $13, 0x2c94
    [apply] addi $13, $13, 0xae4e
    [apply] lui $15, 0x5d
    [apply] addi $15, $15, 0xb7fa
    [apply] lui $24, 0x7fa
    [apply] addi $24, $24, 0xfc37
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] sub $8, $9, $10
    [apply] xor $11, $12, $13
    [apply] sub $14, $15, $24
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $9, 0xa9c9
    [apply] addi $9, $9, 0x7025
    [apply] lui $10, 0xe6f6
    [apply] addi $10, $10, 0x78de
    [apply] lui $12, 0x842a
    [apply] addi $12, $12, 0x45dd
    [apply] lui $13, 0x2c94
    [apply] addi $13, $13, 0xae4e
    [apply] lui $15, 0x5d
    [apply] addi $15, $15, 0xb7fa
    [apply] lui $24, 0x7fa
    [apply] addi $24, $24, 0xfc37
    [apply] 
    [apply] Stimulus
    [apply] sub $8, $9, $10
    [apply] xor $11, $12, $13
    [apply] sub $14, $15, $24
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: subu
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: nor
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: srlv
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: subu)...
    [apply] Processing situation null for op subu(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={subu.rt=10011011110000110011101000001000, subu.rs=11001000000011001011000011001000}]
    [apply] Creating code to assign 10011011110000110011101000001000 to mode REG(i: #IMM = 10)...
    [apply] Creating code to assign 11001000000011001011000011001000 to mode REG(i: #IMM = 9)...
    [apply] 
    [apply] Processing instruction call (root: nor)...
    [apply] Processing situation null for op nor(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={nor.rt=00001011000101110001110101010010, nor.rs=01111101001011000010000010110110}]
    [apply] Creating code to assign 00001011000101110001110101010010 to mode REG(i: #IMM = 13)...
    [apply] Creating code to assign 01111101001011000010000010110110 to mode REG(i: #IMM = 12)...
    [apply] 
    [apply] Processing instruction call (root: srlv)...
    [apply] Processing situation null for op srlv(rd: REG, rt: REG, rs: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={srlv.rt=00010101100000110110010001001000, srlv.rs=00001010011100101001001110100101}]
    [apply] Creating code to assign 00010101100000110110010001001000 to mode REG(i: #IMM = 15)...
    [apply] Creating code to assign 00001010011100101001001110100101 to mode REG(i: #IMM = 24)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $10, 0x9bc3
    [apply] addi $10, $10, 0x3a08
    [apply] lui $9, 0xc80c
    [apply] addi $9, $9, 0xb0c8
    [apply] lui $13, 0xb17
    [apply] addi $13, $13, 0x1d52
    [apply] lui $12, 0x7d2c
    [apply] addi $12, $12, 0x20b6
    [apply] lui $15, 0x1583
    [apply] addi $15, $15, 0x6448
    [apply] lui $24, 0xa72
    [apply] addi $24, $24, 0x93a5
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] subu $8, $9, $10
    [apply] nor $11, $12, $13
    [apply] srlv $14, $15, $24
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $10, 0x9bc3
    [apply] addi $10, $10, 0x3a08
    [apply] lui $9, 0xc80c
    [apply] addi $9, $9, 0xb0c8
    [apply] lui $13, 0xb17
    [apply] addi $13, $13, 0x1d52
    [apply] lui $12, 0x7d2c
    [apply] addi $12, $12, 0x20b6
    [apply] lui $15, 0x1583
    [apply] addi $15, $15, 0x6448
    [apply] lui $24, 0xa72
    [apply] addi $24, $24, 0x93a5
    [apply] 
    [apply] Stimulus
    [apply] subu $8, $9, $10
    [apply] nor $11, $12, $13
    [apply] srlv $14, $15, $24
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: subu
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: nor
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: and
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: subu)...
    [apply] Processing situation null for op subu(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={subu.rt=11101110101111010100100101001000, subu.rs=01010000101011011101011100011110}]
    [apply] Creating code to assign 11101110101111010100100101001000 to mode REG(i: #IMM = 10)...
    [apply] Creating code to assign 01010000101011011101011100011110 to mode REG(i: #IMM = 9)...
    [apply] 
    [apply] Processing instruction call (root: nor)...
    [apply] Processing situation null for op nor(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={nor.rt=10100011101110000111111011101011, nor.rs=11011011101011111111000010100110}]
    [apply] Creating code to assign 10100011101110000111111011101011 to mode REG(i: #IMM = 13)...
    [apply] Creating code to assign 11011011101011111111000010100110 to mode REG(i: #IMM = 12)...
    [apply] 
    [apply] Processing instruction call (root: and)...
    [apply] Processing situation null for op and(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={and.rt=00101101111100100010010000001100, and.rs=01010011000011001011010011010011}]
    [apply] Creating code to assign 00101101111100100010010000001100 to mode REG(i: #IMM = 24)...
    [apply] Creating code to assign 01010011000011001011010011010011 to mode REG(i: #IMM = 15)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $10, 0xeebd
    [apply] addi $10, $10, 0x4948
    [apply] lui $9, 0x50ad
    [apply] addi $9, $9, 0xd71e
    [apply] lui $13, 0xa3b8
    [apply] addi $13, $13, 0x7eeb
    [apply] lui $12, 0xdbaf
    [apply] addi $12, $12, 0xf0a6
    [apply] lui $24, 0x2df2
    [apply] addi $24, $24, 0x240c
    [apply] lui $15, 0x530c
    [apply] addi $15, $15, 0xb4d3
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] subu $8, $9, $10
    [apply] nor $11, $12, $13
    [apply] and $14, $15, $24
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $10, 0xeebd
    [apply] addi $10, $10, 0x4948
    [apply] lui $9, 0x50ad
    [apply] addi $9, $9, 0xd71e
    [apply] lui $13, 0xa3b8
    [apply] addi $13, $13, 0x7eeb
    [apply] lui $12, 0xdbaf
    [apply] addi $12, $12, 0xf0a6
    [apply] lui $24, 0x2df2
    [apply] addi $24, $24, 0x240c
    [apply] lui $15, 0x530c
    [apply] addi $15, $15, 0xb4d3
    [apply] 
    [apply] Stimulus
    [apply] subu $8, $9, $10
    [apply] nor $11, $12, $13
    [apply] and $14, $15, $24
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: and
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: or
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={sub.rs=00011000011010000001001001000000, sub.rt=10010001101100001110101011001011}]
    [apply] Creating code to assign 00011000011010000001001001000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 10010001101100001110101011001011 to mode REG(i: #IMM = 10)...
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] Processing instruction call (root: and)...
    [apply] Processing situation null for op and(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={and.rt=11101001110110101000011111100111, and.rs=00100101011101110101000001011100}]
    [apply] Creating code to assign 11101001110110101000011111100111 to mode REG(i: #IMM = 13)...
    [apply] Creating code to assign 00100101011101110101000001011100 to mode REG(i: #IMM = 12)...
    [apply] 
    [apply] Processing instruction call (root: or)...
    [apply] Processing situation null for op or(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={or.rs=10110100111110010001011101111011, or.rt=11011000011110111101101010111001}]
    [apply] Creating code to assign 10110100111110010001011101111011 to mode REG(i: #IMM = 15)...
    [apply] Creating code to assign 11011000011110111101101010111001 to mode REG(i: #IMM = 24)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $9, 0x1868
    [apply] addi $9, $9, 0x1240
    [apply] lui $10, 0x91b0
    [apply] addi $10, $10, 0xeacb
    [apply] lui $13, 0xe9da
    [apply] addi $13, $13, 0x87e7
    [apply] lui $12, 0x2577
    [apply] addi $12, $12, 0x505c
    [apply] lui $15, 0xb4f9
    [apply] addi $15, $15, 0x177b
    [apply] lui $24, 0xd87b
    [apply] addi $24, $24, 0xdab9
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] sub $8, $9, $10
    [apply] Exception was raised: IntegerOverflow
    [apply] and $11, $12, $13
    [apply] or $14, $15, $24
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $9, 0x1868
    [apply] addi $9, $9, 0x1240
    [apply] lui $10, 0x91b0
    [apply] addi $10, $10, 0xeacb
    [apply] lui $13, 0xe9da
    [apply] addi $13, $13, 0x87e7
    [apply] lui $12, 0x2577
    [apply] addi $12, $12, 0x505c
    [apply] lui $15, 0xb4f9
    [apply] addi $15, $15, 0x177b
    [apply] lui $24, 0xd87b
    [apply] addi $24, $24, 0xdab9
    [apply] 
    [apply] Stimulus
    [apply] sub $8, $9, $10
    [apply] and $11, $12, $13
    [apply] or $14, $15, $24
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: xor
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={sub.rs=01111011001001011100101100000000, sub.rt=11000000000010100010010011111110}]
    [apply] Creating code to assign 01111011001001011100101100000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11000000000010100010010011111110 to mode REG(i: #IMM = 10)...
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] Processing instruction call (root: xor)...
    [apply] Processing situation null for op xor(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={xor.rs=01001111101110100001100011011110, xor.rt=11010000110100001100011001111011}]
    [apply] Creating code to assign 01001111101110100001100011011110 to mode REG(i: #IMM = 12)...
    [apply] Creating code to assign 11010000110100001100011001111011 to mode REG(i: #IMM = 13)...
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={add.rs=00110110000011000001010001101101, add.rt=01001010111010110001101111010110}]
    [apply] Creating code to assign 00110110000011000001010001101101 to mode REG(i: #IMM = 15)...
    [apply] Creating code to assign 01001010111010110001101111010110 to mode REG(i: #IMM = 24)...
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $9, 0x7b25
    [apply] addi $9, $9, 0xcb00
    [apply] lui $10, 0xc00a
    [apply] addi $10, $10, 0x24fe
    [apply] lui $12, 0x4fba
    [apply] addi $12, $12, 0x18de
    [apply] lui $13, 0xd0d0
    [apply] addi $13, $13, 0xc67b
    [apply] lui $15, 0x360c
    [apply] addi $15, $15, 0x146d
    [apply] lui $24, 0x4aeb
    [apply] addi $24, $24, 0x1bd6
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] sub $8, $9, $10
    [apply] Exception was raised: IntegerOverflow
    [apply] xor $11, $12, $13
    [apply] add $14, $15, $24
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $9, 0x7b25
    [apply] addi $9, $9, 0xcb00
    [apply] lui $10, 0xc00a
    [apply] addi $10, $10, 0x24fe
    [apply] lui $12, 0x4fba
    [apply] addi $12, $12, 0x18de
    [apply] lui $13, 0xd0d0
    [apply] addi $13, $13, 0xc67b
    [apply] lui $15, 0x360c
    [apply] addi $15, $15, 0x146d
    [apply] lui $24, 0x4aeb
    [apply] addi $24, $24, 0x1bd6
    [apply] 
    [apply] Stimulus
    [apply] sub $8, $9, $10
    [apply] xor $11, $12, $13
    [apply] add $14, $15, $24
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: and
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: srlv
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={add.rs=00000111001011101100110011011000, add.rt=01100110010001111110101110000100}]
    [apply] Creating code to assign 00000111001011101100110011011000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 01100110010001111110101110000100 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] Processing instruction call (root: and)...
    [apply] Processing situation null for op and(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={and.rt=00110100110010011111100010100010, and.rs=00100001010110010110001100010101}]
    [apply] Creating code to assign 00110100110010011111100010100010 to mode REG(i: #IMM = 13)...
    [apply] Creating code to assign 00100001010110010110001100010101 to mode REG(i: #IMM = 12)...
    [apply] 
    [apply] Processing instruction call (root: srlv)...
    [apply] Processing situation null for op srlv(rd: REG, rt: REG, rs: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={srlv.rt=11101111110110110000000011000001, srlv.rs=01110001100101101000011100001110}]
    [apply] Creating code to assign 11101111110110110000000011000001 to mode REG(i: #IMM = 15)...
    [apply] Creating code to assign 01110001100101101000011100001110 to mode REG(i: #IMM = 24)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $9, 0x72e
    [apply] addi $9, $9, 0xccd8
    [apply] lui $10, 0x6647
    [apply] addi $10, $10, 0xeb84
    [apply] lui $13, 0x34c9
    [apply] addi $13, $13, 0xf8a2
    [apply] lui $12, 0x2159
    [apply] addi $12, $12, 0x6315
    [apply] lui $15, 0xefdb
    [apply] addi $15, $15, 0xc1
    [apply] lui $24, 0x7196
    [apply] addi $24, $24, 0x870e
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] and $11, $12, $13
    [apply] srlv $14, $15, $24
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $9, 0x72e
    [apply] addi $9, $9, 0xccd8
    [apply] lui $10, 0x6647
    [apply] addi $10, $10, 0xeb84
    [apply] lui $13, 0x34c9
    [apply] addi $13, $13, 0xf8a2
    [apply] lui $12, 0x2159
    [apply] addi $12, $12, 0x6315
    [apply] lui $15, 0xefdb
    [apply] addi $15, $15, 0xc1
    [apply] lui $24, 0x7196
    [apply] addi $24, $24, 0x870e
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] and $11, $12, $13
    [apply] srlv $14, $15, $24
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: subu
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: and
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: subu
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: subu)...
    [apply] Processing situation null for op subu(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={subu.rt=01000100001010100100010011001011, subu.rs=11010010000010011000001011111110}]
    [apply] Creating code to assign 01000100001010100100010011001011 to mode REG(i: #IMM = 10)...
    [apply] Creating code to assign 11010010000010011000001011111110 to mode REG(i: #IMM = 9)...
    [apply] 
    [apply] Processing instruction call (root: and)...
    [apply] Processing situation null for op and(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={and.rt=00111111000101000010100111111101, and.rs=01011000001101111011000010000011}]
    [apply] Creating code to assign 00111111000101000010100111111101 to mode REG(i: #IMM = 13)...
    [apply] Creating code to assign 01011000001101111011000010000011 to mode REG(i: #IMM = 12)...
    [apply] 
    [apply] Processing instruction call (root: subu)...
    [apply] Processing situation null for op subu(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={subu.rt=00000011010000001000001100010010, subu.rs=11100111110001001010111101011010}]
    [apply] Creating code to assign 00000011010000001000001100010010 to mode REG(i: #IMM = 24)...
    [apply] Creating code to assign 11100111110001001010111101011010 to mode REG(i: #IMM = 15)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $10, 0x442a
    [apply] addi $10, $10, 0x44cb
    [apply] lui $9, 0xd209
    [apply] addi $9, $9, 0x82fe
    [apply] lui $13, 0x3f14
    [apply] addi $13, $13, 0x29fd
    [apply] lui $12, 0x5837
    [apply] addi $12, $12, 0xb083
    [apply] lui $24, 0x340
    [apply] addi $24, $24, 0x8312
    [apply] lui $15, 0xe7c4
    [apply] addi $15, $15, 0xaf5a
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] subu $8, $9, $10
    [apply] and $11, $12, $13
    [apply] subu $14, $15, $24
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $10, 0x442a
    [apply] addi $10, $10, 0x44cb
    [apply] lui $9, 0xd209
    [apply] addi $9, $9, 0x82fe
    [apply] lui $13, 0x3f14
    [apply] addi $13, $13, 0x29fd
    [apply] lui $12, 0x5837
    [apply] addi $12, $12, 0xb083
    [apply] lui $24, 0x340
    [apply] addi $24, $24, 0x8312
    [apply] lui $15, 0xe7c4
    [apply] addi $15, $15, 0xaf5a
    [apply] 
    [apply] Stimulus
    [apply] subu $8, $9, $10
    [apply] and $11, $12, $13
    [apply] subu $14, $15, $24
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: subu
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: nor
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: subu)...
    [apply] Processing situation null for op subu(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={subu.rt=11110010000000001010010011000010, subu.rs=01100101010100100110010011010100}]
    [apply] Creating code to assign 11110010000000001010010011000010 to mode REG(i: #IMM = 10)...
    [apply] Creating code to assign 01100101010100100110010011010100 to mode REG(i: #IMM = 9)...
    [apply] 
    [apply] Processing instruction call (root: nor)...
    [apply] Processing situation null for op nor(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={nor.rt=10111101110010111000100100011011, nor.rs=01001100101000001101010010010001}]
    [apply] Creating code to assign 10111101110010111000100100011011 to mode REG(i: #IMM = 13)...
    [apply] Creating code to assign 01001100101000001101010010010001 to mode REG(i: #IMM = 12)...
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={add.rs=10100101100101110110101001111010, add.rt=01011011011000101110100011010110}]
    [apply] Creating code to assign 10100101100101110110101001111010 to mode REG(i: #IMM = 15)...
    [apply] Creating code to assign 01011011011000101110100011010110 to mode REG(i: #IMM = 24)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $10, 0xf200
    [apply] addi $10, $10, 0xa4c2
    [apply] lui $9, 0x6552
    [apply] addi $9, $9, 0x64d4
    [apply] lui $13, 0xbdcb
    [apply] addi $13, $13, 0x891b
    [apply] lui $12, 0x4ca0
    [apply] addi $12, $12, 0xd491
    [apply] lui $15, 0xa597
    [apply] addi $15, $15, 0x6a7a
    [apply] lui $24, 0x5b62
    [apply] addi $24, $24, 0xe8d6
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] subu $8, $9, $10
    [apply] nor $11, $12, $13
    [apply] add $14, $15, $24
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $10, 0xf200
    [apply] addi $10, $10, 0xa4c2
    [apply] lui $9, 0x6552
    [apply] addi $9, $9, 0x64d4
    [apply] lui $13, 0xbdcb
    [apply] addi $13, $13, 0x891b
    [apply] lui $12, 0x4ca0
    [apply] addi $12, $12, 0xd491
    [apply] lui $15, 0xa597
    [apply] addi $15, $15, 0x6a7a
    [apply] lui $24, 0x5b62
    [apply] addi $24, $24, 0xe8d6
    [apply] 
    [apply] Stimulus
    [apply] subu $8, $9, $10
    [apply] nor $11, $12, $13
    [apply] add $14, $15, $24
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: nor
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: or
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={sub.rs=01100010000111100101111010010000, sub.rt=10111010000010011001111010111001}]
    [apply] Creating code to assign 01100010000111100101111010010000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 10111010000010011001111010111001 to mode REG(i: #IMM = 10)...
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] Processing instruction call (root: nor)...
    [apply] Processing situation null for op nor(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={nor.rt=01000011011001111011100010111010, nor.rs=01010111010010110010000110111010}]
    [apply] Creating code to assign 01000011011001111011100010111010 to mode REG(i: #IMM = 13)...
    [apply] Creating code to assign 01010111010010110010000110111010 to mode REG(i: #IMM = 12)...
    [apply] 
    [apply] Processing instruction call (root: or)...
    [apply] Processing situation null for op or(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={or.rs=11110001111001010111101101010001, or.rt=11001100101011101111111000110001}]
    [apply] Creating code to assign 11110001111001010111101101010001 to mode REG(i: #IMM = 15)...
    [apply] Creating code to assign 11001100101011101111111000110001 to mode REG(i: #IMM = 24)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $9, 0x621e
    [apply] addi $9, $9, 0x5e90
    [apply] lui $10, 0xba09
    [apply] addi $10, $10, 0x9eb9
    [apply] lui $13, 0x4367
    [apply] addi $13, $13, 0xb8ba
    [apply] lui $12, 0x574b
    [apply] addi $12, $12, 0x21ba
    [apply] lui $15, 0xf1e5
    [apply] addi $15, $15, 0x7b51
    [apply] lui $24, 0xccae
    [apply] addi $24, $24, 0xfe31
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] sub $8, $9, $10
    [apply] Exception was raised: IntegerOverflow
    [apply] nor $11, $12, $13
    [apply] or $14, $15, $24
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $9, 0x621e
    [apply] addi $9, $9, 0x5e90
    [apply] lui $10, 0xba09
    [apply] addi $10, $10, 0x9eb9
    [apply] lui $13, 0x4367
    [apply] addi $13, $13, 0xb8ba
    [apply] lui $12, 0x574b
    [apply] addi $12, $12, 0x21ba
    [apply] lui $15, 0xf1e5
    [apply] addi $15, $15, 0x7b51
    [apply] lui $24, 0xccae
    [apply] addi $24, $24, 0xfe31
    [apply] 
    [apply] Stimulus
    [apply] sub $8, $9, $10
    [apply] nor $11, $12, $13
    [apply] or $14, $15, $24
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={add.rs=11110111100000100111110110100100, add.rt=11011000000101100010111000100101}]
    [apply] Creating code to assign 11110111100000100111110110100100 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011000000101100010111000100101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={sub.rs=01110100101110001110001111001110, sub.rt=10101001101110110110110101100000}]
    [apply] Creating code to assign 01110100101110001110001111001110 to mode REG(i: #IMM = 12)...
    [apply] Creating code to assign 10101001101110110110110101100000 to mode REG(i: #IMM = 13)...
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={add.rs=11000011111000010010111101100111, add.rt=11011001110001011110110111110010}]
    [apply] Creating code to assign 11000011111000010010111101100111 to mode REG(i: #IMM = 15)...
    [apply] Creating code to assign 11011001110001011110110111110010 to mode REG(i: #IMM = 24)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $9, 0xf782
    [apply] addi $9, $9, 0x7da4
    [apply] lui $10, 0xd816
    [apply] addi $10, $10, 0x2e25
    [apply] lui $12, 0x74b8
    [apply] addi $12, $12, 0xe3ce
    [apply] lui $13, 0xa9bb
    [apply] addi $13, $13, 0x6d60
    [apply] lui $15, 0xc3e1
    [apply] addi $15, $15, 0x2f67
    [apply] lui $24, 0xd9c5
    [apply] addi $24, $24, 0xedf2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] sub $11, $12, $13
    [apply] Exception was raised: IntegerOverflow
    [apply] add $14, $15, $24
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $9, 0xf782
    [apply] addi $9, $9, 0x7da4
    [apply] lui $10, 0xd816
    [apply] addi $10, $10, 0x2e25
    [apply] lui $12, 0x74b8
    [apply] addi $12, $12, 0xe3ce
    [apply] lui $13, 0xa9bb
    [apply] addi $13, $13, 0x6d60
    [apply] lui $15, 0xc3e1
    [apply] addi $15, $15, 0x2f67
    [apply] lui $24, 0xd9c5
    [apply] addi $24, $24, 0xedf2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] sub $11, $12, $13
    [apply] add $14, $15, $24
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: xor
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: xor)...
    [apply] Processing situation null for op xor(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={xor.rs=10111010000010000010100010110101, xor.rt=10000110101000010110110101110011}]
    [apply] Creating code to assign 10111010000010000010100010110101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 10000110101000010110110101110011 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={add.rs=01010100001000101000110110101110, add.rt=00110010001010001100100010110101}]
    [apply] Creating code to assign 01010100001000101000110110101110 to mode REG(i: #IMM = 12)...
    [apply] Creating code to assign 00110010001010001100100010110101 to mode REG(i: #IMM = 13)...
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={add.rs=00011010111000100000110001100011, add.rt=10110000000101110000110110101010}]
    [apply] Creating code to assign 00011010111000100000110001100011 to mode REG(i: #IMM = 15)...
    [apply] Creating code to assign 10110000000101110000110110101010 to mode REG(i: #IMM = 24)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $9, 0xba08
    [apply] addi $9, $9, 0x28b5
    [apply] lui $10, 0x86a1
    [apply] addi $10, $10, 0x6d73
    [apply] lui $12, 0x5422
    [apply] addi $12, $12, 0x8dae
    [apply] lui $13, 0x3228
    [apply] addi $13, $13, 0xc8b5
    [apply] lui $15, 0x1ae2
    [apply] addi $15, $15, 0xc63
    [apply] lui $24, 0xb017
    [apply] addi $24, $24, 0xdaa
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] xor $8, $9, $10
    [apply] add $11, $12, $13
    [apply] Exception was raised: IntegerOverflow
    [apply] add $14, $15, $24
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $9, 0xba08
    [apply] addi $9, $9, 0x28b5
    [apply] lui $10, 0x86a1
    [apply] addi $10, $10, 0x6d73
    [apply] lui $12, 0x5422
    [apply] addi $12, $12, 0x8dae
    [apply] lui $13, 0x3228
    [apply] addi $13, $13, 0xc8b5
    [apply] lui $15, 0x1ae2
    [apply] addi $15, $15, 0xc63
    [apply] lui $24, 0xb017
    [apply] addi $24, $24, 0xdaa
    [apply] 
    [apply] Stimulus
    [apply] xor $8, $9, $10
    [apply] add $11, $12, $13
    [apply] add $14, $15, $24
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: nor
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: and
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={sub.rs=01111000111011110100100000111011, sub.rt=10111000001001100110101001100011}]
    [apply] Creating code to assign 01111000111011110100100000111011 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 10111000001001100110101001100011 to mode REG(i: #IMM = 10)...
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] Processing instruction call (root: nor)...
    [apply] Processing situation null for op nor(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={nor.rt=00000000000011100011110010100000, nor.rs=11110000010001010101111110001111}]
    [apply] Creating code to assign 00000000000011100011110010100000 to mode REG(i: #IMM = 13)...
    [apply] Creating code to assign 11110000010001010101111110001111 to mode REG(i: #IMM = 12)...
    [apply] 
    [apply] Processing instruction call (root: and)...
    [apply] Processing situation null for op and(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={and.rt=10110011101000100101001001100110, and.rs=00000011011101101010001101000000}]
    [apply] Creating code to assign 10110011101000100101001001100110 to mode REG(i: #IMM = 24)...
    [apply] Creating code to assign 00000011011101101010001101000000 to mode REG(i: #IMM = 15)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $9, 0x78ef
    [apply] addi $9, $9, 0x483b
    [apply] lui $10, 0xb826
    [apply] addi $10, $10, 0x6a63
    [apply] lui $13, 0xe
    [apply] addi $13, $13, 0x3ca0
    [apply] lui $12, 0xf045
    [apply] addi $12, $12, 0x5f8f
    [apply] lui $24, 0xb3a2
    [apply] addi $24, $24, 0x5266
    [apply] lui $15, 0x376
    [apply] addi $15, $15, 0xa340
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] sub $8, $9, $10
    [apply] Exception was raised: IntegerOverflow
    [apply] nor $11, $12, $13
    [apply] and $14, $15, $24
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $9, 0x78ef
    [apply] addi $9, $9, 0x483b
    [apply] lui $10, 0xb826
    [apply] addi $10, $10, 0x6a63
    [apply] lui $13, 0xe
    [apply] addi $13, $13, 0x3ca0
    [apply] lui $12, 0xf045
    [apply] addi $12, $12, 0x5f8f
    [apply] lui $24, 0xb3a2
    [apply] addi $24, $24, 0x5266
    [apply] lui $15, 0x376
    [apply] addi $15, $15, 0xa340
    [apply] 
    [apply] Stimulus
    [apply] sub $8, $9, $10
    [apply] nor $11, $12, $13
    [apply] and $14, $15, $24
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: xor
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={add.rs=01001101101010011101011101010111, add.rt=01110101010111000100101000000001}]
    [apply] Creating code to assign 01001101101010011101011101010111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 01110101010111000100101000000001 to mode REG(i: #IMM = 10)...
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] Processing instruction call (root: xor)...
    [apply] Processing situation null for op xor(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={xor.rs=11101000110010101111011101100101, xor.rt=01010111010011011100010010001110}]
    [apply] Creating code to assign 11101000110010101111011101100101 to mode REG(i: #IMM = 12)...
    [apply] Creating code to assign 01010111010011011100010010001110 to mode REG(i: #IMM = 13)...
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={sub.rs=00001000000000001100110101011110, sub.rt=10100111101000010101110010100011}]
    [apply] Creating code to assign 00001000000000001100110101011110 to mode REG(i: #IMM = 15)...
    [apply] Creating code to assign 10100111101000010101110010100011 to mode REG(i: #IMM = 24)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $9, 0x4da9
    [apply] addi $9, $9, 0xd757
    [apply] lui $10, 0x755c
    [apply] addi $10, $10, 0x4a01
    [apply] lui $12, 0xe8ca
    [apply] addi $12, $12, 0xf765
    [apply] lui $13, 0x574d
    [apply] addi $13, $13, 0xc48e
    [apply] lui $15, 0x800
    [apply] addi $15, $15, 0xcd5e
    [apply] lui $24, 0xa7a1
    [apply] addi $24, $24, 0x5ca3
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] Exception was raised: IntegerOverflow
    [apply] xor $11, $12, $13
    [apply] sub $14, $15, $24
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $9, 0x4da9
    [apply] addi $9, $9, 0xd757
    [apply] lui $10, 0x755c
    [apply] addi $10, $10, 0x4a01
    [apply] lui $12, 0xe8ca
    [apply] addi $12, $12, 0xf765
    [apply] lui $13, 0x574d
    [apply] addi $13, $13, 0xc48e
    [apply] lui $15, 0x800
    [apply] addi $15, $15, 0xcd5e
    [apply] lui $24, 0xa7a1
    [apply] addi $24, $24, 0x5ca3
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] xor $11, $12, $13
    [apply] sub $14, $15, $24
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={add.rs=11000100011101001111100101101100, add.rt=11101110110111010000001111011100}]
    [apply] Creating code to assign 11000100011101001111100101101100 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11101110110111010000001111011100 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={sub.rs=01000101010010100100101010011011, sub.rt=10110000000101101111110111010110}]
    [apply] Creating code to assign 01000101010010100100101010011011 to mode REG(i: #IMM = 12)...
    [apply] Creating code to assign 10110000000101101111110111010110 to mode REG(i: #IMM = 13)...
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={sub.rs=00010000100011100111000110010010, sub.rt=10011100111111101100110000100011}]
    [apply] Creating code to assign 00010000100011100111000110010010 to mode REG(i: #IMM = 15)...
    [apply] Creating code to assign 10011100111111101100110000100011 to mode REG(i: #IMM = 24)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $9, 0xc474
    [apply] addi $9, $9, 0xf96c
    [apply] lui $10, 0xeedd
    [apply] addi $10, $10, 0x3dc
    [apply] lui $12, 0x454a
    [apply] addi $12, $12, 0x4a9b
    [apply] lui $13, 0xb016
    [apply] addi $13, $13, 0xfdd6
    [apply] lui $15, 0x108e
    [apply] addi $15, $15, 0x7192
    [apply] lui $24, 0x9cfe
    [apply] addi $24, $24, 0xcc23
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] sub $11, $12, $13
    [apply] Exception was raised: IntegerOverflow
    [apply] sub $14, $15, $24
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $9, 0xc474
    [apply] addi $9, $9, 0xf96c
    [apply] lui $10, 0xeedd
    [apply] addi $10, $10, 0x3dc
    [apply] lui $12, 0x454a
    [apply] addi $12, $12, 0x4a9b
    [apply] lui $13, 0xb016
    [apply] addi $13, $13, 0xfdd6
    [apply] lui $15, 0x108e
    [apply] addi $15, $15, 0x7192
    [apply] lui $24, 0x9cfe
    [apply] addi $24, $24, 0xcc23
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] sub $11, $12, $13
    [apply] sub $14, $15, $24
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: or
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: or)...
    [apply] Processing situation null for op or(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={or.rs=00110011000101101111001000101011, or.rt=11001010000011101111110011111000}]
    [apply] Creating code to assign 00110011000101101111001000101011 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11001010000011101111110011111000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={add.rs=10111011101101001110010001001111, add.rt=01111011010110110010110100000100}]
    [apply] Creating code to assign 10111011101101001110010001001111 to mode REG(i: #IMM = 12)...
    [apply] Creating code to assign 01111011010110110010110100000100 to mode REG(i: #IMM = 13)...
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={sub.rs=10001100000001100011000111000101, sub.rt=10000111011111001111000101111111}]
    [apply] Creating code to assign 10001100000001100011000111000101 to mode REG(i: #IMM = 15)...
    [apply] Creating code to assign 10000111011111001111000101111111 to mode REG(i: #IMM = 24)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $9, 0x3316
    [apply] addi $9, $9, 0xf22b
    [apply] lui $10, 0xca0e
    [apply] addi $10, $10, 0xfcf8
    [apply] lui $12, 0xbbb4
    [apply] addi $12, $12, 0xe44f
    [apply] lui $13, 0x7b5b
    [apply] addi $13, $13, 0x2d04
    [apply] lui $15, 0x8c06
    [apply] addi $15, $15, 0x31c5
    [apply] lui $24, 0x877c
    [apply] addi $24, $24, 0xf17f
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] or $8, $9, $10
    [apply] add $11, $12, $13
    [apply] sub $14, $15, $24
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $9, 0x3316
    [apply] addi $9, $9, 0xf22b
    [apply] lui $10, 0xca0e
    [apply] addi $10, $10, 0xfcf8
    [apply] lui $12, 0xbbb4
    [apply] addi $12, $12, 0xe44f
    [apply] lui $13, 0x7b5b
    [apply] addi $13, $13, 0x2d04
    [apply] lui $15, 0x8c06
    [apply] addi $15, $15, 0x31c5
    [apply] lui $24, 0x877c
    [apply] addi $24, $24, 0xf17f
    [apply] 
    [apply] Stimulus
    [apply] or $8, $9, $10
    [apply] add $11, $12, $13
    [apply] sub $14, $15, $24
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={add.rs=11000110011110001111000010110011, add.rt=00100110110000010011001000001110}]
    [apply] Creating code to assign 11000110011110001111000010110011 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00100110110000010011001000001110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={add.rs=00000000110110111100101000100110, add.rt=10010101001000111101011000011001}]
    [apply] Creating code to assign 00000000110110111100101000100110 to mode REG(i: #IMM = 12)...
    [apply] Creating code to assign 10010101001000111101011000011001 to mode REG(i: #IMM = 13)...
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={sub.rs=00010100111010110000110000100010, sub.rt=11111011011010001111000001011010}]
    [apply] Creating code to assign 00010100111010110000110000100010 to mode REG(i: #IMM = 15)...
    [apply] Creating code to assign 11111011011010001111000001011010 to mode REG(i: #IMM = 24)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $9, 0xc678
    [apply] addi $9, $9, 0xf0b3
    [apply] lui $10, 0x26c1
    [apply] addi $10, $10, 0x320e
    [apply] lui $12, 0xdb
    [apply] addi $12, $12, 0xca26
    [apply] lui $13, 0x9523
    [apply] addi $13, $13, 0xd619
    [apply] lui $15, 0x14eb
    [apply] addi $15, $15, 0xc22
    [apply] lui $24, 0xfb68
    [apply] addi $24, $24, 0xf05a
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] add $11, $12, $13
    [apply] sub $14, $15, $24
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $9, 0xc678
    [apply] addi $9, $9, 0xf0b3
    [apply] lui $10, 0x26c1
    [apply] addi $10, $10, 0x320e
    [apply] lui $12, 0xdb
    [apply] addi $12, $12, 0xca26
    [apply] lui $13, 0x9523
    [apply] addi $13, $13, 0xd619
    [apply] lui $15, 0x14eb
    [apply] addi $15, $15, 0xc22
    [apply] lui $24, 0xfb68
    [apply] addi $24, $24, 0xf05a
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] add $11, $12, $13
    [apply] sub $14, $15, $24
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: xor
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={add.rs=11101101111101111011111111111001, add.rt=11000110110011011100111010101110}]
    [apply] Creating code to assign 11101101111101111011111111111001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11000110110011011100111010101110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] Processing instruction call (root: xor)...
    [apply] Processing situation null for op xor(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={xor.rs=00001100100100111110101001000100, xor.rt=11011011011001100011100101100010}]
    [apply] Creating code to assign 00001100100100111110101001000100 to mode REG(i: #IMM = 12)...
    [apply] Creating code to assign 11011011011001100011100101100010 to mode REG(i: #IMM = 13)...
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={sub.rs=01000011110101011010000100110011, sub.rt=10010001100101110101110101000110}]
    [apply] Creating code to assign 01000011110101011010000100110011 to mode REG(i: #IMM = 15)...
    [apply] Creating code to assign 10010001100101110101110101000110 to mode REG(i: #IMM = 24)...
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $9, 0xedf7
    [apply] addi $9, $9, 0xbff9
    [apply] lui $10, 0xc6cd
    [apply] addi $10, $10, 0xceae
    [apply] lui $12, 0xc93
    [apply] addi $12, $12, 0xea44
    [apply] lui $13, 0xdb66
    [apply] addi $13, $13, 0x3962
    [apply] lui $15, 0x43d5
    [apply] addi $15, $15, 0xa133
    [apply] lui $24, 0x9197
    [apply] addi $24, $24, 0x5d46
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] xor $11, $12, $13
    [apply] sub $14, $15, $24
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $9, 0xedf7
    [apply] addi $9, $9, 0xbff9
    [apply] lui $10, 0xc6cd
    [apply] addi $10, $10, 0xceae
    [apply] lui $12, 0xc93
    [apply] addi $12, $12, 0xea44
    [apply] lui $13, 0xdb66
    [apply] addi $13, $13, 0x3962
    [apply] lui $15, 0x43d5
    [apply] addi $15, $15, 0xa133
    [apply] lui $24, 0x9197
    [apply] addi $24, $24, 0x5d46
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] xor $11, $12, $13
    [apply] sub $14, $15, $24
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={add.rs=10010111001000011000111010100000, add.rt=10001101101010111001001001001000}]
    [apply] Creating code to assign 10010111001000011000111010100000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 10001101101010111001001001001000 to mode REG(i: #IMM = 10)...
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={add.rs=10100010000111001010010000100110, add.rt=01001110100001000010000110110000}]
    [apply] Creating code to assign 10100010000111001010010000100110 to mode REG(i: #IMM = 12)...
    [apply] Creating code to assign 01001110100001000010000110110000 to mode REG(i: #IMM = 13)...
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={sub.rs=10001111001011000100001000100001, sub.rt=01100001010101001111110111111111}]
    [apply] Creating code to assign 10001111001011000100001000100001 to mode REG(i: #IMM = 15)...
    [apply] Creating code to assign 01100001010101001111110111111111 to mode REG(i: #IMM = 24)...
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $9, 0x9721
    [apply] addi $9, $9, 0x8ea0
    [apply] lui $10, 0x8dab
    [apply] addi $10, $10, 0x9248
    [apply] lui $12, 0xa21c
    [apply] addi $12, $12, 0xa426
    [apply] lui $13, 0x4e84
    [apply] addi $13, $13, 0x21b0
    [apply] lui $15, 0x8f2c
    [apply] addi $15, $15, 0x4221
    [apply] lui $24, 0x6154
    [apply] addi $24, $24, 0xfdff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] Exception was raised: IntegerOverflow
    [apply] add $11, $12, $13
    [apply] sub $14, $15, $24
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $9, 0x9721
    [apply] addi $9, $9, 0x8ea0
    [apply] lui $10, 0x8dab
    [apply] addi $10, $10, 0x9248
    [apply] lui $12, 0xa21c
    [apply] addi $12, $12, 0xa426
    [apply] lui $13, 0x4e84
    [apply] addi $13, $13, 0x21b0
    [apply] lui $15, 0x8f2c
    [apply] addi $15, $15, 0x4221
    [apply] lui $24, 0x6154
    [apply] addi $24, $24, 0xfdff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] add $11, $12, $13
    [apply] sub $14, $15, $24
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: and
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: or
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={sub.rs=01110000101110100001001011010001, sub.rt=10011100111111001101000100010010}]
    [apply] Creating code to assign 01110000101110100001001011010001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 10011100111111001101000100010010 to mode REG(i: #IMM = 10)...
    [apply] Exception was raised: IntegerOverflow
    [apply] 
    [apply] Processing instruction call (root: and)...
    [apply] Processing situation null for op and(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={and.rt=00000111001111100011001111011011, and.rs=00001010110000101100010101101111}]
    [apply] Creating code to assign 00000111001111100011001111011011 to mode REG(i: #IMM = 13)...
    [apply] Creating code to assign 00001010110000101100010101101111 to mode REG(i: #IMM = 12)...
    [apply] 
    [apply] Processing instruction call (root: or)...
    [apply] Processing situation null for op or(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={or.rs=01100001001000001011100110110110, or.rt=01001110011100101110011011010011}]
    [apply] Creating code to assign 01100001001000001011100110110110 to mode REG(i: #IMM = 15)...
    [apply] Creating code to assign 01001110011100101110011011010011 to mode REG(i: #IMM = 24)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $9, 0x70ba
    [apply] addi $9, $9, 0x12d1
    [apply] lui $10, 0x9cfc
    [apply] addi $10, $10, 0xd112
    [apply] lui $13, 0x73e
    [apply] addi $13, $13, 0x33db
    [apply] lui $12, 0xac2
    [apply] addi $12, $12, 0xc56f
    [apply] lui $15, 0x6120
    [apply] addi $15, $15, 0xb9b6
    [apply] lui $24, 0x4e72
    [apply] addi $24, $24, 0xe6d3
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] sub $8, $9, $10
    [apply] Exception was raised: IntegerOverflow
    [apply] and $11, $12, $13
    [apply] or $14, $15, $24
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $9, 0x70ba
    [apply] addi $9, $9, 0x12d1
    [apply] lui $10, 0x9cfc
    [apply] addi $10, $10, 0xd112
    [apply] lui $13, 0x73e
    [apply] addi $13, $13, 0x33db
    [apply] lui $12, 0xac2
    [apply] addi $12, $12, 0xc56f
    [apply] lui $15, 0x6120
    [apply] addi $15, $15, 0xb9b6
    [apply] lui $24, 0x4e72
    [apply] addi $24, $24, 0xe6d3
    [apply] 
    [apply] Stimulus
    [apply] sub $8, $9, $10
    [apply] and $11, $12, $13
    [apply] or $14, $15, $24
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 1.376 seconds 
    [apply] Generation rate: 305 instructions/second
    [apply] Programs/stimuli/instructions: 1/20/420
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: minimips
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\minimips\templates\insertion_sort.rb
    [apply] Loaded template MiniMipsBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/minimips_base.rb
    [apply] Loaded template InsertionSortTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/insertion_sort.rb
    [apply] Processing template InsertionSortTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/insertion_sort.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Defining Type.CARD(8) as byte ('.byte')...
    [apply] Defining Type.CARD(16) as half ('.half')...
    [apply] Defining Type.CARD(32) as word ('.word')...
    [apply] Defining space as space ('.space') filled with 0...
    [apply] Defining not null-terminated ASCII string as ascii ('.ascii')...
    [apply] Defining null-terminated ASCII string as asciiz ('.asciiz')...
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: or
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Defining data...
    [apply] Label data
    [apply] Label end
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Output (runtime: false): ".text"
    [apply] Output (runtime: true): ".text"
    [apply] Output (runtime: true): "Data starts: %d", 0
    [apply] Output (runtime: true): "Data ends:   %d", 48
    [apply] Output (runtime: true): "Data count:  %d", 12
    [apply] Output (runtime: true): "Data values:"
    [apply] Output (runtime: true): "M[%d]: %d", 0, M[0]
    [apply] Output (runtime: true): "M[%d]: %d", 1, M[1]
    [apply] Output (runtime: true): "M[%d]: %d", 2, M[2]
    [apply] Output (runtime: true): "M[%d]: %d", 3, M[3]
    [apply] Output (runtime: true): "M[%d]: %d", 4, M[4]
    [apply] Output (runtime: true): "M[%d]: %d", 5, M[5]
    [apply] Output (runtime: true): "M[%d]: %d", 6, M[6]
    [apply] Output (runtime: true): "M[%d]: %d", 7, M[7]
    [apply] Output (runtime: true): "M[%d]: %d", 8, M[8]
    [apply] Output (runtime: true): "M[%d]: %d", 9, M[9]
    [apply] Output (runtime: true): "M[%d]: %d", 10, M[10]
    [apply] Output (runtime: true): "M[%d]: %d", 11, M[11]
    [apply] Output (runtime: true): ""
    [apply] Addressing mode: REG
    [apply] Operation: la
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Operation: la
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: for_1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: beq
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: lw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: while_1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: beq
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: lw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: slt
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: beq
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sll
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: j
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: exit_while_1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: j
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: exit_for_1
    [apply] Output (runtime: true): "Data starts: %d", 0
    [apply] Output (runtime: true): "Data ends:   %d", 48
    [apply] Output (runtime: true): "Data count:  %d", 12
    [apply] Output (runtime: true): "Data values:"
    [apply] Output (runtime: true): "M[%d]: %d", 0, M[0]
    [apply] Output (runtime: true): "M[%d]: %d", 1, M[1]
    [apply] Output (runtime: true): "M[%d]: %d", 2, M[2]
    [apply] Output (runtime: true): "M[%d]: %d", 3, M[3]
    [apply] Output (runtime: true): "M[%d]: %d", 4, M[4]
    [apply] Output (runtime: true): "M[%d]: %d", 5, M[5]
    [apply] Output (runtime: true): "M[%d]: %d", 6, M[6]
    [apply] Output (runtime: true): "M[%d]: %d", 7, M[7]
    [apply] Output (runtime: true): "M[%d]: %d", 8, M[8]
    [apply] Output (runtime: true): "M[%d]: %d", 9, M[9]
    [apply] Output (runtime: true): "M[%d]: %d", 10, M[10]
    [apply] Output (runtime: true): "M[%d]: %d", 11, M[11]
    [apply] Output (runtime: true): ""
    [apply] Ended building a call (empty = false, executable = false)
    [apply] 
    [apply] ------------------------------ Data Declarations -------------------------------
    [apply] 
    [apply] .data
    [apply] data:
    [apply] 	.word 0x7, 0x7, 0x7, 0x9, 0x2, 0x4, 0x5, 0x1, 0x4, 0x6, 0x8, 0x3
    [apply] end:
    [apply] 	.space 1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: la)...
    [apply] Processing situation null for op la(rd: REG, addr: #IMM):[context=null, type=la, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: la)...
    [apply] Processing situation null for op la(rd: REG, addr: #IMM):[context=null, type=la, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: addi)...
    [apply] Processing situation null for op addi(rt: REG, rs: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: beq)...
    [apply] Processing situation null for op beq(rs: REG, rt: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: lw)...
    [apply] Processing situation null for op lw(rt: REG, offset: #IMM, address: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: beq)...
    [apply] Processing situation null for op beq(rs: REG, rt: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: lw)...
    [apply] Processing situation null for op lw(rt: REG, offset: #IMM, address: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: slt)...
    [apply] Processing situation null for op slt(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: beq)...
    [apply] Processing situation null for op beq(rs: REG, rt: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sll)...
    [apply] Processing situation null for op sll(rd: REG, rt: REG, sa: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sw)...
    [apply] Processing situation null for op sw(rd: REG, offset: #IMM, address: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: j)...
    [apply] Processing situation null for op j(addr: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sw)...
    [apply] Processing situation null for op sw(rd: REG, offset: #IMM, address: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: j)...
    [apply] Processing situation null for op j(addr: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] .text
    [apply] 
    [apply] Data starts: 0
    [apply] Data ends:   48
    [apply] Data count:  12
    [apply] 
    [apply] Data values:
    [apply] M[0]: 7
    [apply] M[1]: 7
    [apply] M[2]: 7
    [apply] M[3]: 9
    [apply] M[4]: 2
    [apply] M[5]: 4
    [apply] M[6]: 5
    [apply] M[7]: 1
    [apply] M[8]: 4
    [apply] M[9]: 6
    [apply] M[10]: 8
    [apply] M[11]: 3
    [apply] 
    [apply] la $16, data
    [apply] la $17, end
    [apply] addi $18, $0, 0x4
    [apply] add $8, $16, $18
    [apply] beq $8, $17, exit_for_1
    [apply] add $9, $0, $8
    [apply] lw $19, 0($8)
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: exit_while_1
    [apply] sw $19, 0($9)
    [apply] j for_1
    [apply] add $8, $8, $18
    [apply] Jump to label: for_1
    [apply] beq $8, $17, exit_for_1
    [apply] add $9, $0, $8
    [apply] lw $19, 0($8)
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: exit_while_1
    [apply] sw $19, 0($9)
    [apply] j for_1
    [apply] add $8, $8, $18
    [apply] Jump to label: for_1
    [apply] beq $8, $17, exit_for_1
    [apply] add $9, $0, $8
    [apply] lw $19, 0($8)
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: exit_while_1
    [apply] sw $19, 0($9)
    [apply] j for_1
    [apply] add $8, $8, $18
    [apply] Jump to label: for_1
    [apply] beq $8, $17, exit_for_1
    [apply] add $9, $0, $8
    [apply] lw $19, 0($8)
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] Jump to label: exit_while_1
    [apply] sw $19, 0($9)
    [apply] j for_1
    [apply] add $8, $8, $18
    [apply] Jump to label: for_1
    [apply] beq $8, $17, exit_for_1
    [apply] add $9, $0, $8
    [apply] lw $19, 0($8)
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: exit_while_1
    [apply] sw $19, 0($9)
    [apply] j for_1
    [apply] add $8, $8, $18
    [apply] Jump to label: for_1
    [apply] beq $8, $17, exit_for_1
    [apply] add $9, $0, $8
    [apply] lw $19, 0($8)
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: exit_while_1
    [apply] sw $19, 0($9)
    [apply] j for_1
    [apply] add $8, $8, $18
    [apply] Jump to label: for_1
    [apply] beq $8, $17, exit_for_1
    [apply] add $9, $0, $8
    [apply] lw $19, 0($8)
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] Jump to label: exit_while_1
    [apply] sw $19, 0($9)
    [apply] j for_1
    [apply] add $8, $8, $18
    [apply] Jump to label: for_1
    [apply] beq $8, $17, exit_for_1
    [apply] add $9, $0, $8
    [apply] lw $19, 0($8)
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: exit_while_1
    [apply] sw $19, 0($9)
    [apply] j for_1
    [apply] add $8, $8, $18
    [apply] Jump to label: for_1
    [apply] beq $8, $17, exit_for_1
    [apply] add $9, $0, $8
    [apply] lw $19, 0($8)
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: exit_while_1
    [apply] sw $19, 0($9)
    [apply] j for_1
    [apply] add $8, $8, $18
    [apply] Jump to label: for_1
    [apply] beq $8, $17, exit_for_1
    [apply] add $9, $0, $8
    [apply] lw $19, 0($8)
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: exit_while_1
    [apply] sw $19, 0($9)
    [apply] j for_1
    [apply] add $8, $8, $18
    [apply] Jump to label: for_1
    [apply] beq $8, $17, exit_for_1
    [apply] add $9, $0, $8
    [apply] lw $19, 0($8)
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] Jump to label: while_1
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: exit_while_1
    [apply] sw $19, 0($9)
    [apply] j for_1
    [apply] add $8, $8, $18
    [apply] Jump to label: for_1
    [apply] beq $8, $17, exit_for_1
    [apply] add $9, $0, $8
    [apply] Jump to label: exit_for_1
    [apply] 
    [apply] Data starts: 0
    [apply] Data ends:   48
    [apply] Data count:  12
    [apply] 
    [apply] Data values:
    [apply] M[0]: 1
    [apply] M[1]: 2
    [apply] M[2]: 3
    [apply] M[3]: 4
    [apply] M[4]: 4
    [apply] M[5]: 5
    [apply] M[6]: 6
    [apply] M[7]: 7
    [apply] M[8]: 7
    [apply] M[9]: 7
    [apply] M[10]: 8
    [apply] M[11]: 9
    [apply] 
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] .text
    [apply] la $16, data
    [apply] la $17, end
    [apply] addi $18, $0, 0x4
    [apply] add $8, $16, $18
    [apply] for_1:
    [apply] beq $8, $17, exit_for_1
    [apply] add $9, $0, $8
    [apply] lw $19, 0($8)
    [apply] while_1:
    [apply] beq $9, $16, exit_while_1
    [apply] sub $11, $9, $18
    [apply] lw $20, 0($11)
    [apply] slt $10, $19, $20
    [apply] beq $10, $0, exit_while_1
    [apply] sll $0, $0, 0
    [apply] sw $20, 0($9)
    [apply] j while_1
    [apply] sub $9, $9, $18
    [apply] exit_while_1:
    [apply] sw $19, 0($9)
    [apply] j for_1
    [apply] add $8, $8, $18
    [apply] exit_for_1:
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.457 seconds 
    [apply] Generation rate: 43 instructions/second
    [apply] Programs/stimuli/instructions: 1/1/20
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: minimips
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\minimips\templates\int_divide.rb
    [apply] Loaded template MiniMipsBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/minimips_base.rb
    [apply] Loaded template IntDivideTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/int_divide.rb
    [apply] Processing template IntDivideTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/int_divide.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Defining Type.CARD(8) as byte ('.byte')...
    [apply] Defining Type.CARD(16) as half ('.half')...
    [apply] Defining Type.CARD(32) as word ('.word')...
    [apply] Defining space as space ('.space') filled with 0...
    [apply] Defining not null-terminated ASCII string as ascii ('.ascii')...
    [apply] Defining null-terminated ASCII string as asciiz ('.asciiz')...
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: or
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Output (runtime: true): "Division: Debug Output"
    [apply] Output (runtime: true): "Input parameter values: dividend = %d, divisor = %d", 46, 33
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: cycle_1
    [apply] Output (runtime: true): "Current register values: $8 = %d, $9 = %d, $10 = %d", GPR[8], GPR[9], GPR[10]
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: slt
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: bne
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sll
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: j
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sll
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: done_1
    [apply] Output (runtime: true): "Result: quotient ($8) = %d, remainder ($9) = %d", GPR[8], GPR[9]
    [apply] Ended building a call (empty = false, executable = false)
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: addi)...
    [apply] Processing situation null for op addi(rt: REG, rs: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={addi.rs=10010001101001101010101011000011}]
    [apply] Creating code to assign 10010001101001101010101011000011 to mode REG(i: #IMM = 0)...
    [apply] 
    [apply] Processing instruction call (root: addi)...
    [apply] Processing situation null for op addi(rt: REG, rs: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: slt)...
    [apply] Processing situation null for op slt(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: bne)...
    [apply] Processing situation null for op bne(rs: REG, rt: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sll)...
    [apply] Processing situation null for op sll(rd: REG, rt: REG, sa: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: addi)...
    [apply] Processing situation null for op addi(rt: REG, rs: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: j)...
    [apply] Processing situation null for op j(addr: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sll)...
    [apply] Processing situation null for op sll(rd: REG, rt: REG, sa: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] Division: Debug Output
    [apply] 
    [apply] Input parameter values: dividend = 46, divisor = 33
    [apply] 
    [apply] addi $16, $0, 0x2e
    [apply] addi $17, $0, 0x21
    [apply] add $8, $0, $0
    [apply] add $9, $0, $16
    [apply] 
    [apply] Current register values: $8 = 0, $9 = 46, $10 = 0
    [apply] 
    [apply] sub $10, $9, $17
    [apply] slt $11, $10, $0
    [apply] bne $11, $0, done_1
    [apply] sll $0, $0, 0
    [apply] add $9, $0, $10
    [apply] addi $8, $8, 0x1
    [apply] j cycle_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 1, $9 = 13, $10 = 13
    [apply] 
    [apply] sub $10, $9, $17
    [apply] slt $11, $10, $0
    [apply] bne $11, $0, done_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: done_1
    [apply] 
    [apply] Result: quotient ($8) = 1, remainder ($9) = 13
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] 
    [apply] Stimulus
    [apply] addi $16, $0, 0x2e
    [apply] addi $17, $0, 0x21
    [apply] add $8, $0, $0
    [apply] add $9, $0, $16
    [apply] cycle_1:
    [apply] sub $10, $9, $17
    [apply] slt $11, $10, $0
    [apply] bne $11, $0, done_1
    [apply] sll $0, $0, 0
    [apply] add $9, $0, $10
    [apply] addi $8, $8, 0x1
    [apply] j cycle_1
    [apply] sll $0, $0, 0
    [apply] done_1:
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.107 seconds 
    [apply] Generation rate: 130 instructions/second
    [apply] Programs/stimuli/instructions: 1/1/14
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: minimips
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\minimips\templates\int_exception.rb
    [apply] Loaded template MiniMipsBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/minimips_base.rb
    [apply] Loaded template IntExceptionTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/int_exception.rb
    [apply] Processing template IntExceptionTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/int_exception.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Defining Type.CARD(8) as byte ('.byte')...
    [apply] Defining Type.CARD(16) as half ('.half')...
    [apply] Defining Type.CARD(32) as word ('.word')...
    [apply] Defining space as space ('.space') filled with 0...
    [apply] Defining not null-terminated ASCII string as ascii ('.ascii')...
    [apply] Defining null-terminated ASCII string as asciiz ('.asciiz')...
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: or
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1_1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1_1
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1_2
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1_2
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ----------------------- Generating Data for Test Case 0 ------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation sub(case=normal, size=32) for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=sub, testcase=sub, sub=sub, sub.rd=REG, sub.rd.i=#IMM, sub.rs=REG, sub.rs.i=#IMM, sub.rt=REG, sub.rt.i=#IMM}, bindings={sub.rd.i=01011, sub.rd=sub.rd, sub.rs.i=01100, sub.rs=sub.rs, sub.rt.i=01101, sub.rt=sub.rt}, parameters={case=normal, size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {sub.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], sub.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)], sub.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add(case=normal, size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={case=normal, size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------- Executing Test Case 0 -----------------------------
    [apply] 
    [apply] sub $11, $12, $13
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------- Printing Test Case 0 -----------------------------
    [apply] 
    [apply] sub $11, $12, $13
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Generating Data for Test Case 1 ------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation sub(case=overflow, size=32) for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=sub, testcase=sub, sub=sub, sub.rd=REG, sub.rd.i=#IMM, sub.rs=REG, sub.rs.i=#IMM, sub.rt=REG, sub.rt.i=#IMM}, bindings={sub.rd.i=01011, sub.rd=sub.rd, sub.rs.i=01100, sub.rs=sub.rs, sub.rt.i=01101, sub.rt=sub.rt}, parameters={case=overflow, size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {sub.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], sub.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)], sub.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add(case=normal, size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={case=normal, size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------- Executing Test Case 1 -----------------------------
    [apply] 
    [apply] sub $11, $12, $13
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------- Printing Test Case 1 -----------------------------
    [apply] 
    [apply] sub $11, $12, $13
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Generating Data for Test Case 2 ------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add(case=overflow, size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={case=overflow, size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation sub(case=normal, size=32) for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=sub, testcase=sub, sub=sub, sub.rd=REG, sub.rd.i=#IMM, sub.rs=REG, sub.rs.i=#IMM, sub.rt=REG, sub.rt.i=#IMM}, bindings={sub.rd.i=01011, sub.rd=sub.rd, sub.rs.i=01100, sub.rs=sub.rs, sub.rt.i=01101, sub.rt=sub.rt}, parameters={case=normal, size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {sub.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], sub.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)], sub.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------- Executing Test Case 2 -----------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] sub $11, $12, $13
    [apply] 
    [apply] ----------------------------- Printing Test Case 2 -----------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] sub $11, $12, $13
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Generating Data for Test Case 3 ------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation add(case=overflow, size=32) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=add, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={case=overflow, size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation sub(case=overflow, size=32) for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=sub, testcase=sub, sub=sub, sub.rd=REG, sub.rd.i=#IMM, sub.rs=REG, sub.rs.i=#IMM, sub.rt=REG, sub.rt.i=#IMM}, bindings={sub.rd.i=01011, sub.rd=sub.rd, sub.rs.i=01100, sub.rs=sub.rs, sub.rt.i=01101, sub.rt=sub.rt}, parameters={case=overflow, size=32}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {sub.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], sub.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)], sub.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)]}
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------- Executing Test Case 3 -----------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] sub $11, $12, $13
    [apply] 
    [apply] ----------------------------- Printing Test Case 3 -----------------------------
    [apply] 
    [apply] add $8, $9, $10
    [apply] sub $11, $12, $13
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.217 seconds 
    [apply] Generation rate: 36 instructions/second
    [apply] Programs/stimuli/instructions: 1/4/8
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: minimips
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\minimips\templates\int_sqrt.rb
    [apply] Loaded template MiniMipsBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/minimips_base.rb
    [apply] Loaded template IntSqrtTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/int_sqrt.rb
    [apply] Processing template IntSqrtTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/int_sqrt.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Defining Type.CARD(8) as byte ('.byte')...
    [apply] Defining Type.CARD(16) as half ('.half')...
    [apply] Defining Type.CARD(32) as word ('.word')...
    [apply] Defining space as space ('.space') filled with 0...
    [apply] Defining not null-terminated ASCII string as ascii ('.ascii')...
    [apply] Defining null-terminated ASCII string as asciiz ('.asciiz')...
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: or
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Output (runtime: true): "Integer square root: Debug Output"
    [apply] Output (runtime: true): "Input parameter value: x = %d", 46
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: cycle_1
    [apply] Output (runtime: true): "Current register values: $8 = %d, $9 = %d, $10 = %d", GPR[8], GPR[9], GPR[10]
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: slt
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: beq
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sll
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: slt
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: j
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sll
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: done_1
    [apply] Output (runtime: true): "Integer square root of %d: %d", 46, GPR[10]
    [apply] Ended building a call (empty = false, executable = false)
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: addi)...
    [apply] Processing situation null for op addi(rt: REG, rs: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={addi.rs=10101010110000111111011010111110}]
    [apply] Creating code to assign 10101010110000111111011010111110 to mode REG(i: #IMM = 0)...
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: addi)...
    [apply] Processing situation null for op addi(rt: REG, rs: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: addi)...
    [apply] Processing situation null for op addi(rt: REG, rs: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: slt)...
    [apply] Processing situation null for op slt(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: beq)...
    [apply] Processing situation null for op beq(rs: REG, rt: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sll)...
    [apply] Processing situation null for op sll(rd: REG, rt: REG, sa: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: addi)...
    [apply] Processing situation null for op addi(rt: REG, rs: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: slt)...
    [apply] Processing situation null for op slt(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: j)...
    [apply] Processing situation null for op j(addr: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sll)...
    [apply] Processing situation null for op sll(rd: REG, rt: REG, sa: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] Integer square root: Debug Output
    [apply] 
    [apply] Input parameter value: x = 46
    [apply] 
    [apply] addi $16, $0, 0x2e
    [apply] add $8, $0, $16
    [apply] addi $9, $0, 0x1
    [apply] add $10, $0, $0
    [apply] addi $11, $0, 0x1
    [apply] 
    [apply] Current register values: $8 = 46, $9 = 1, $10 = 0
    [apply] 
    [apply] slt $12, $0, $8
    [apply] beq $12, $0, done_1
    [apply] sll $0, $0, 0
    [apply] sub $8, $8, $9
    [apply] addi $9, $9, 0x2
    [apply] slt $12, $8, $0
    [apply] sub $13, $11, $12
    [apply] add $10, $10, $13
    [apply] j cycle_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 45, $9 = 3, $10 = 1
    [apply] 
    [apply] slt $12, $0, $8
    [apply] beq $12, $0, done_1
    [apply] sll $0, $0, 0
    [apply] sub $8, $8, $9
    [apply] addi $9, $9, 0x2
    [apply] slt $12, $8, $0
    [apply] sub $13, $11, $12
    [apply] add $10, $10, $13
    [apply] j cycle_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 42, $9 = 5, $10 = 2
    [apply] 
    [apply] slt $12, $0, $8
    [apply] beq $12, $0, done_1
    [apply] sll $0, $0, 0
    [apply] sub $8, $8, $9
    [apply] addi $9, $9, 0x2
    [apply] slt $12, $8, $0
    [apply] sub $13, $11, $12
    [apply] add $10, $10, $13
    [apply] j cycle_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 37, $9 = 7, $10 = 3
    [apply] 
    [apply] slt $12, $0, $8
    [apply] beq $12, $0, done_1
    [apply] sll $0, $0, 0
    [apply] sub $8, $8, $9
    [apply] addi $9, $9, 0x2
    [apply] slt $12, $8, $0
    [apply] sub $13, $11, $12
    [apply] add $10, $10, $13
    [apply] j cycle_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 30, $9 = 9, $10 = 4
    [apply] 
    [apply] slt $12, $0, $8
    [apply] beq $12, $0, done_1
    [apply] sll $0, $0, 0
    [apply] sub $8, $8, $9
    [apply] addi $9, $9, 0x2
    [apply] slt $12, $8, $0
    [apply] sub $13, $11, $12
    [apply] add $10, $10, $13
    [apply] j cycle_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 21, $9 = 11, $10 = 5
    [apply] 
    [apply] slt $12, $0, $8
    [apply] beq $12, $0, done_1
    [apply] sll $0, $0, 0
    [apply] sub $8, $8, $9
    [apply] addi $9, $9, 0x2
    [apply] slt $12, $8, $0
    [apply] sub $13, $11, $12
    [apply] add $10, $10, $13
    [apply] j cycle_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 10, $9 = 13, $10 = 6
    [apply] 
    [apply] slt $12, $0, $8
    [apply] beq $12, $0, done_1
    [apply] sll $0, $0, 0
    [apply] sub $8, $8, $9
    [apply] addi $9, $9, 0x2
    [apply] slt $12, $8, $0
    [apply] sub $13, $11, $12
    [apply] add $10, $10, $13
    [apply] j cycle_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 4294967293, $9 = 15, $10 = 6
    [apply] 
    [apply] slt $12, $0, $8
    [apply] beq $12, $0, done_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: done_1
    [apply] 
    [apply] Integer square root of 46: 6
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] 
    [apply] Stimulus
    [apply] addi $16, $0, 0x2e
    [apply] add $8, $0, $16
    [apply] addi $9, $0, 0x1
    [apply] add $10, $0, $0
    [apply] addi $11, $0, 0x1
    [apply] cycle_1:
    [apply] slt $12, $0, $8
    [apply] beq $12, $0, done_1
    [apply] sll $0, $0, 0
    [apply] sub $8, $8, $9
    [apply] addi $9, $9, 0x2
    [apply] slt $12, $8, $0
    [apply] sub $13, $11, $12
    [apply] add $10, $10, $13
    [apply] j cycle_1
    [apply] sll $0, $0, 0
    [apply] done_1:
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.182 seconds 
    [apply] Generation rate: 93 instructions/second
    [apply] Programs/stimuli/instructions: 1/1/17
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: minimips
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\minimips\templates\int_sqrt4.rb
    [apply] Loaded template MiniMipsBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/minimips_base.rb
    [apply] Loaded template IntSqrt4Template defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/int_sqrt4.rb
    [apply] Processing template IntSqrt4Template defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/int_sqrt4.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Defining Type.CARD(8) as byte ('.byte')...
    [apply] Defining Type.CARD(16) as half ('.half')...
    [apply] Defining Type.CARD(32) as word ('.word')...
    [apply] Defining space as space ('.space') filled with 0...
    [apply] Defining not null-terminated ASCII string as ascii ('.ascii')...
    [apply] Defining null-terminated ASCII string as asciiz ('.asciiz')...
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: or
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Output (runtime: true): "Integer square root: Debug Output"
    [apply] Output (runtime: true): "Input parameter value: x = %d", 46
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: cycle_1
    [apply] Output (runtime: true): "Current register values: $8 = %d, $9 = %d, $10 = %d", GPR[8], GPR[9], GPR[10]
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: beq
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: or
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: srlv
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: slt
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: bne
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sll
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sub
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: or
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: if_less_1
    [apply] Operation: j
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: srlv
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: done_1
    [apply] Output (runtime: true): "Integer square root of %d: %d", 46, GPR[9]
    [apply] Ended building a call (empty = false, executable = false)
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: addi)...
    [apply] Processing situation null for op addi(rt: REG, rs: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={addi.rs=10101010110000111111011010111110}]
    [apply] Creating code to assign 10101010110000111111011010111110 to mode REG(i: #IMM = 0)...
    [apply] 
    [apply] Processing instruction call (root: addi)...
    [apply] Processing situation null for op addi(rt: REG, rs: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: addi)...
    [apply] Processing situation null for op addi(rt: REG, rs: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: lui)...
    [apply] Processing situation null for op lui(rt: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: beq)...
    [apply] Processing situation null for op beq(rs: REG, rt: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: or)...
    [apply] Processing situation null for op or(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: srlv)...
    [apply] Processing situation null for op srlv(rd: REG, rt: REG, rs: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: slt)...
    [apply] Processing situation null for op slt(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: bne)...
    [apply] Processing situation null for op bne(rs: REG, rt: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sll)...
    [apply] Processing situation null for op sll(rd: REG, rt: REG, sa: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sub)...
    [apply] Processing situation null for op sub(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: or)...
    [apply] Processing situation null for op or(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: j)...
    [apply] Processing situation null for op j(addr: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: srlv)...
    [apply] Processing situation null for op srlv(rd: REG, rt: REG, rs: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] Integer square root: Debug Output
    [apply] 
    [apply] Input parameter value: x = 46
    [apply] 
    [apply] addi $16, $0, 0x2e
    [apply] addi $17, $0, 0x1
    [apply] addi $18, $0, 0x2
    [apply] add $11, $0, $16
    [apply] lui $8, 0x4000
    [apply] add $9, $0, $0
    [apply] 
    [apply] Current register values: $8 = 1073741824, $9 = 0, $10 = 0
    [apply] 
    [apply] beq $8, $0, done_1
    [apply] or $10, $9, $8
    [apply] srlv $9, $9, $17
    [apply] slt $12, $11, $10
    [apply] bne $12, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] j cycle_1
    [apply] srlv $8, $8, $18
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 268435456, $9 = 0, $10 = 1073741824
    [apply] 
    [apply] beq $8, $0, done_1
    [apply] or $10, $9, $8
    [apply] srlv $9, $9, $17
    [apply] slt $12, $11, $10
    [apply] bne $12, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] j cycle_1
    [apply] srlv $8, $8, $18
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 67108864, $9 = 0, $10 = 268435456
    [apply] 
    [apply] beq $8, $0, done_1
    [apply] or $10, $9, $8
    [apply] srlv $9, $9, $17
    [apply] slt $12, $11, $10
    [apply] bne $12, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] j cycle_1
    [apply] srlv $8, $8, $18
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 16777216, $9 = 0, $10 = 67108864
    [apply] 
    [apply] beq $8, $0, done_1
    [apply] or $10, $9, $8
    [apply] srlv $9, $9, $17
    [apply] slt $12, $11, $10
    [apply] bne $12, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] j cycle_1
    [apply] srlv $8, $8, $18
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 4194304, $9 = 0, $10 = 16777216
    [apply] 
    [apply] beq $8, $0, done_1
    [apply] or $10, $9, $8
    [apply] srlv $9, $9, $17
    [apply] slt $12, $11, $10
    [apply] bne $12, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] j cycle_1
    [apply] srlv $8, $8, $18
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 1048576, $9 = 0, $10 = 4194304
    [apply] 
    [apply] beq $8, $0, done_1
    [apply] or $10, $9, $8
    [apply] srlv $9, $9, $17
    [apply] slt $12, $11, $10
    [apply] bne $12, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] j cycle_1
    [apply] srlv $8, $8, $18
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 262144, $9 = 0, $10 = 1048576
    [apply] 
    [apply] beq $8, $0, done_1
    [apply] or $10, $9, $8
    [apply] srlv $9, $9, $17
    [apply] slt $12, $11, $10
    [apply] bne $12, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] j cycle_1
    [apply] srlv $8, $8, $18
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 65536, $9 = 0, $10 = 262144
    [apply] 
    [apply] beq $8, $0, done_1
    [apply] or $10, $9, $8
    [apply] srlv $9, $9, $17
    [apply] slt $12, $11, $10
    [apply] bne $12, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] j cycle_1
    [apply] srlv $8, $8, $18
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 16384, $9 = 0, $10 = 65536
    [apply] 
    [apply] beq $8, $0, done_1
    [apply] or $10, $9, $8
    [apply] srlv $9, $9, $17
    [apply] slt $12, $11, $10
    [apply] bne $12, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] j cycle_1
    [apply] srlv $8, $8, $18
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 4096, $9 = 0, $10 = 16384
    [apply] 
    [apply] beq $8, $0, done_1
    [apply] or $10, $9, $8
    [apply] srlv $9, $9, $17
    [apply] slt $12, $11, $10
    [apply] bne $12, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] j cycle_1
    [apply] srlv $8, $8, $18
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 1024, $9 = 0, $10 = 4096
    [apply] 
    [apply] beq $8, $0, done_1
    [apply] or $10, $9, $8
    [apply] srlv $9, $9, $17
    [apply] slt $12, $11, $10
    [apply] bne $12, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] j cycle_1
    [apply] srlv $8, $8, $18
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 256, $9 = 0, $10 = 1024
    [apply] 
    [apply] beq $8, $0, done_1
    [apply] or $10, $9, $8
    [apply] srlv $9, $9, $17
    [apply] slt $12, $11, $10
    [apply] bne $12, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] j cycle_1
    [apply] srlv $8, $8, $18
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 64, $9 = 0, $10 = 256
    [apply] 
    [apply] beq $8, $0, done_1
    [apply] or $10, $9, $8
    [apply] srlv $9, $9, $17
    [apply] slt $12, $11, $10
    [apply] bne $12, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] j cycle_1
    [apply] srlv $8, $8, $18
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 16, $9 = 0, $10 = 64
    [apply] 
    [apply] beq $8, $0, done_1
    [apply] or $10, $9, $8
    [apply] srlv $9, $9, $17
    [apply] slt $12, $11, $10
    [apply] bne $12, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] sub $11, $11, $10
    [apply] or $9, $9, $8
    [apply] j cycle_1
    [apply] srlv $8, $8, $18
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 4, $9 = 16, $10 = 16
    [apply] 
    [apply] beq $8, $0, done_1
    [apply] or $10, $9, $8
    [apply] srlv $9, $9, $17
    [apply] slt $12, $11, $10
    [apply] bne $12, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] sub $11, $11, $10
    [apply] or $9, $9, $8
    [apply] j cycle_1
    [apply] srlv $8, $8, $18
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 1, $9 = 12, $10 = 20
    [apply] 
    [apply] beq $8, $0, done_1
    [apply] or $10, $9, $8
    [apply] srlv $9, $9, $17
    [apply] slt $12, $11, $10
    [apply] bne $12, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: if_less_1
    [apply] j cycle_1
    [apply] srlv $8, $8, $18
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] Current register values: $8 = 0, $9 = 6, $10 = 13
    [apply] 
    [apply] beq $8, $0, done_1
    [apply] or $10, $9, $8
    [apply] Jump to label: done_1
    [apply] 
    [apply] Integer square root of 46: 6
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] 
    [apply] Stimulus
    [apply] addi $16, $0, 0x2e
    [apply] addi $17, $0, 0x1
    [apply] addi $18, $0, 0x2
    [apply] add $11, $0, $16
    [apply] lui $8, 0x4000
    [apply] add $9, $0, $0
    [apply] cycle_1:
    [apply] beq $8, $0, done_1
    [apply] or $10, $9, $8
    [apply] srlv $9, $9, $17
    [apply] slt $12, $11, $10
    [apply] bne $12, $0, if_less_1
    [apply] sll $0, $0, 0
    [apply] sub $11, $11, $10
    [apply] or $9, $9, $8
    [apply] if_less_1:
    [apply] j cycle_1
    [apply] srlv $8, $8, $18
    [apply] done_1:
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.197 seconds 
    [apply] Generation rate: 91 instructions/second
    [apply] Programs/stimuli/instructions: 1/1/18
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: minimips
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\minimips\templates\load_store.rb
    [apply] Loaded template MiniMipsBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/minimips_base.rb
    [apply] Loaded template LoadStoreTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/load_store.rb
    [apply] Processing template LoadStoreTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/load_store.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Defining Type.CARD(8) as byte ('.byte')...
    [apply] Defining Type.CARD(16) as half ('.half')...
    [apply] Defining Type.CARD(32) as word ('.word')...
    [apply] Defining space as space ('.space') filled with 0...
    [apply] Defining not null-terminated ASCII string as ascii ('.ascii')...
    [apply] Defining null-terminated ASCII string as asciiz ('.asciiz')...
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: or
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Defining data...
    [apply] Label data1
    [apply] Label data2
    [apply] Label data3
    [apply] Label hello
    [apply] Label world
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Output (runtime: false): ".text"
    [apply] Output (runtime: true): "--------------------------------------------------------------------------------"
    [apply] Output (runtime: true): "Memory state:"
    [apply] Output (runtime: true): ""
    [apply] Output (runtime: true): "%x: %x", 0, M[0]
    [apply] Output (runtime: true): "%x: %x", 4, M[1]
    [apply] Output (runtime: true): "%x: %x", 8, M[2]
    [apply] Output (runtime: true): "%x: %x", 12, M[3]
    [apply] Output (runtime: true): "%x: %x", 16, M[4]
    [apply] Output (runtime: true): "%x: %x", 20, M[5]
    [apply] Output (runtime: true): "%x: %x", 24, M[6]
    [apply] Output (runtime: true): "--------------------------------------------------------------------------------"
    [apply] Output (runtime: true): "Labels:"
    [apply] Output (runtime: true): ""
    [apply] Output (runtime: true): "data1 address: %x", 0
    [apply] Output (runtime: true): "data2 address: %x", 4
    [apply] Output (runtime: true): "data3 address: %x", 8
    [apply] Output (runtime: true): "hello address: %x", 12
    [apply] Output (runtime: true): "world address: %x", 17
    [apply] Output (runtime: true): "--------------------------------------------------------------------------------"
    [apply] Output (runtime: true): "Reading from memory:"
    [apply] Output (runtime: true): ""
    [apply] Addressing mode: REG
    [apply] Operation: la
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: true): "address in t0: %x", GPR[8]
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: lw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: true): "value in t1: %x", GPR[9]
    [apply] Addressing mode: REG
    [apply] Operation: la
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: true): "address in t2: %x", GPR[10]
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: lw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: true): "value in t3: %x", GPR[11]
    [apply] Addressing mode: REG
    [apply] Operation: la
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: true): "address in t4: %x", GPR[12]
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: lw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: true): "value in t5: %x", GPR[13]
    [apply] Output (runtime: true): "--------------------------------------------------------------------------------"
    [apply] Output (runtime: true): "Writing to memory:"
    [apply] Output (runtime: true): ""
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: true): "--------------------------------------------------------------------------------"
    [apply] Output (runtime: true): "Memory state:"
    [apply] Output (runtime: true): ""
    [apply] Output (runtime: true): "%x: %x", 0, M[0]
    [apply] Output (runtime: true): "%x: %x", 4, M[1]
    [apply] Output (runtime: true): "%x: %x", 8, M[2]
    [apply] Output (runtime: true): "%x: %x", 12, M[3]
    [apply] Output (runtime: true): "%x: %x", 16, M[4]
    [apply] Output (runtime: true): "%x: %x", 20, M[5]
    [apply] Output (runtime: true): "%x: %x", 24, M[6]
    [apply] Ended building a call (empty = false, executable = false)
    [apply] 
    [apply] ------------------------------ Data Declarations -------------------------------
    [apply] 
    [apply] .data
    [apply] data1:
    [apply] 	.byte 0x1, 0x2, 0x3, 0x4
    [apply] data2:
    [apply] 	.half 0xdead, 0xbeef
    [apply] data3:
    [apply] 	.word 0xdeadbeef
    [apply] hello:
    [apply] 	.ascii "Hello"
    [apply] world:
    [apply] 	.asciiz "World"
    [apply] 	.space 6
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: la)...
    [apply] Processing situation null for op la(rd: REG, addr: #IMM):[context=null, type=la, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: lw)...
    [apply] Processing situation null for op lw(rt: REG, offset: #IMM, address: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: la)...
    [apply] Processing situation null for op la(rd: REG, addr: #IMM):[context=null, type=la, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: lw)...
    [apply] Processing situation null for op lw(rt: REG, offset: #IMM, address: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: la)...
    [apply] Processing situation null for op la(rd: REG, addr: #IMM):[context=null, type=la, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: lw)...
    [apply] Processing situation null for op lw(rt: REG, offset: #IMM, address: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sw)...
    [apply] Processing situation null for op sw(rd: REG, offset: #IMM, address: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sw)...
    [apply] Processing situation null for op sw(rd: REG, offset: #IMM, address: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] Memory state:
    [apply] 
    [apply] 0: 4030201
    [apply] 4: beefdead
    [apply] 8: deadbeef
    [apply] c: 6c6c6548
    [apply] 10: 726f576f
    [apply] 14: 646c
    [apply] 18: 0
    [apply] --------------------------------------------------------------------------------
    [apply] Labels:
    [apply] 
    [apply] data1 address: 0
    [apply] data2 address: 4
    [apply] data3 address: 8
    [apply] hello address: c
    [apply] world address: 11
    [apply] --------------------------------------------------------------------------------
    [apply] Reading from memory:
    [apply] 
    [apply] la $8, data1
    [apply] address in t0: 0
    [apply] lw $9, 0($8)
    [apply] value in t1: 4030201
    [apply] la $10, data2
    [apply] address in t2: 4
    [apply] lw $11, 0($10)
    [apply] value in t3: beefdead
    [apply] la $12, data3
    [apply] address in t4: 8
    [apply] lw $13, 0($12)
    [apply] value in t5: deadbeef
    [apply] --------------------------------------------------------------------------------
    [apply] Writing to memory:
    [apply] 
    [apply] sw $13, 0($8)
    [apply] sw $9, 0($12)
    [apply] --------------------------------------------------------------------------------
    [apply] Memory state:
    [apply] 
    [apply] 0: deadbeef
    [apply] 4: beefdead
    [apply] 8: 4030201
    [apply] c: 6c6c6548
    [apply] 10: 726f576f
    [apply] 14: 646c
    [apply] 18: 0
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] .text
    [apply] la $8, data1
    [apply] lw $9, 0($8)
    [apply] la $10, data2
    [apply] lw $11, 0($10)
    [apply] la $12, data3
    [apply] lw $13, 0($12)
    [apply] sw $13, 0($8)
    [apply] sw $9, 0($12)
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.138 seconds 
    [apply] Generation rate: 65 instructions/second
    [apply] Programs/stimuli/instructions: 1/1/9
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: minimips
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\minimips\templates\min_max.rb
    [apply] Loaded template MiniMipsBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/minimips_base.rb
    [apply] Loaded template MinMaxTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/min_max.rb
    [apply] Processing template MinMaxTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/min_max.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Defining Type.CARD(8) as byte ('.byte')...
    [apply] Defining Type.CARD(16) as half ('.half')...
    [apply] Defining Type.CARD(32) as word ('.word')...
    [apply] Defining space as space ('.space') filled with 0...
    [apply] Defining not null-terminated ASCII string as ascii ('.ascii')...
    [apply] Defining null-terminated ASCII string as asciiz ('.asciiz')...
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: or
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Defining data...
    [apply] Label data
    [apply] Label end
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Output (runtime: false): ".text"
    [apply] Output (runtime: true): ".text"
    [apply] Output (runtime: true): "Data starts: %d", 0
    [apply] Output (runtime: true): "Data ends:   %d", 20
    [apply] Output (runtime: true): "Data count:  %d", 5
    [apply] Output (runtime: true): "Data values:"
    [apply] Output (runtime: true): "M[%d]: %d", 0, M[0]
    [apply] Output (runtime: true): "M[%d]: %d", 1, M[1]
    [apply] Output (runtime: true): "M[%d]: %d", 2, M[2]
    [apply] Output (runtime: true): "M[%d]: %d", 3, M[3]
    [apply] Output (runtime: true): "M[%d]: %d", 4, M[4]
    [apply] Output (runtime: true): ""
    [apply] Addressing mode: REG
    [apply] Operation: la
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Operation: la
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: lw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Output (runtime: true): ""
    [apply] Label: cycle_1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: beq
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: lw
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: slt
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: beq
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sll
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: test_max_1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: slt
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: beq
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sll
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: j
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: sll
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Label: done_1
    [apply] Output (runtime: true): "s0(min)=%d, s1(max)=%d", GPR[16], GPR[17]
    [apply] Ended building a call (empty = false, executable = false)
    [apply] 
    [apply] ------------------------------ Data Declarations -------------------------------
    [apply] 
    [apply] .data
    [apply] data:
    [apply] 	.word 0x3, 0x4, 0x2, 0x8, 0x9
    [apply] end:
    [apply] 	.space 1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: la)...
    [apply] Processing situation null for op la(rd: REG, addr: #IMM):[context=null, type=la, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: la)...
    [apply] Processing situation null for op la(rd: REG, addr: #IMM):[context=null, type=la, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: lw)...
    [apply] Processing situation null for op lw(rt: REG, offset: #IMM, address: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: addi)...
    [apply] Processing situation null for op addi(rt: REG, rs: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: beq)...
    [apply] Processing situation null for op beq(rs: REG, rt: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: lw)...
    [apply] Processing situation null for op lw(rt: REG, offset: #IMM, address: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: slt)...
    [apply] Processing situation null for op slt(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: beq)...
    [apply] Processing situation null for op beq(rs: REG, rt: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sll)...
    [apply] Processing situation null for op sll(rd: REG, rt: REG, sa: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: slt)...
    [apply] Processing situation null for op slt(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: beq)...
    [apply] Processing situation null for op beq(rs: REG, rt: REG, imm: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sll)...
    [apply] Processing situation null for op sll(rd: REG, rt: REG, sa: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation null for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: j)...
    [apply] Processing situation null for op j(addr: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] Processing instruction call (root: sll)...
    [apply] Processing situation null for op sll(rd: REG, rt: REG, sa: #IMM):[context=#root, type=instruction, root=true]...
    [apply] TestData [bindings={}]
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] .text
    [apply] 
    [apply] Data starts: 0
    [apply] Data ends:   20
    [apply] Data count:  5
    [apply] 
    [apply] Data values:
    [apply] M[0]: 3
    [apply] M[1]: 4
    [apply] M[2]: 2
    [apply] M[3]: 8
    [apply] M[4]: 9
    [apply] 
    [apply] la $8, data
    [apply] la $9, end
    [apply] lw $10, 0($8)
    [apply] add $16, $0, $10
    [apply] add $17, $0, $10
    [apply] 
    [apply] addi $8, $8, 0x4
    [apply] beq $8, $9, done_1
    [apply] lw $10, 0($8)
    [apply] slt $11, $10, $16
    [apply] beq $11, $0, test_max_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: test_max_1
    [apply] slt $12, $17, $10
    [apply] beq $12, $0, cycle_1
    [apply] sll $0, $0, 0
    [apply] add $17, $0, $10
    [apply] j cycle_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] addi $8, $8, 0x4
    [apply] beq $8, $9, done_1
    [apply] lw $10, 0($8)
    [apply] slt $11, $10, $16
    [apply] beq $11, $0, test_max_1
    [apply] sll $0, $0, 0
    [apply] add $16, $0, $10
    [apply] slt $12, $17, $10
    [apply] beq $12, $0, cycle_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] addi $8, $8, 0x4
    [apply] beq $8, $9, done_1
    [apply] lw $10, 0($8)
    [apply] slt $11, $10, $16
    [apply] beq $11, $0, test_max_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: test_max_1
    [apply] slt $12, $17, $10
    [apply] beq $12, $0, cycle_1
    [apply] sll $0, $0, 0
    [apply] add $17, $0, $10
    [apply] j cycle_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] addi $8, $8, 0x4
    [apply] beq $8, $9, done_1
    [apply] lw $10, 0($8)
    [apply] slt $11, $10, $16
    [apply] beq $11, $0, test_max_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: test_max_1
    [apply] slt $12, $17, $10
    [apply] beq $12, $0, cycle_1
    [apply] sll $0, $0, 0
    [apply] add $17, $0, $10
    [apply] j cycle_1
    [apply] sll $0, $0, 0
    [apply] Jump to label: cycle_1
    [apply] 
    [apply] addi $8, $8, 0x4
    [apply] beq $8, $9, done_1
    [apply] lw $10, 0($8)
    [apply] Jump to label: done_1
    [apply] 
    [apply] s0(min)=2, s1(max)=9
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] .text
    [apply] la $8, data
    [apply] la $9, end
    [apply] lw $10, 0($8)
    [apply] add $16, $0, $10
    [apply] add $17, $0, $10
    [apply] cycle_1:
    [apply] addi $8, $8, 0x4
    [apply] beq $8, $9, done_1
    [apply] lw $10, 0($8)
    [apply] slt $11, $10, $16
    [apply] beq $11, $0, test_max_1
    [apply] sll $0, $0, 0
    [apply] add $16, $0, $10
    [apply] test_max_1:
    [apply] slt $12, $17, $10
    [apply] beq $12, $0, cycle_1
    [apply] sll $0, $0, 0
    [apply] add $17, $0, $10
    [apply] j cycle_1
    [apply] sll $0, $0, 0
    [apply] done_1:
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 0.179 seconds 
    [apply] Generation rate: 106 instructions/second
    [apply] Programs/stimuli/instructions: 1/1/19
    [apply] Home: F:\SVN\MicroTESK\microtesk\microtesk\dist
    [apply] Current directory: F:\SVN\MicroTESK\microtesk\microtesk
    [apply] Model name: minimips
    [apply] Template file: F:\SVN\MicroTESK\microtesk\microtesk\dist\arch\minimips\templates\random.rb
    [apply] Loaded template MiniMipsBaseTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/minimips_base.rb
    [apply] Loaded template RandomTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/random.rb
    [apply] Processing template RandomTemplate defined in F:/SVN/MicroTESK/microtesk/microtesk/dist/arch/minimips/templates/random.rb...
    [apply] 
    [apply] ------------------------- Started Processing Template --------------------------
    [apply] 
    [apply] 
    [apply] ------------------ Started Processing Initialization Section -------------------
    [apply] 
    [apply] Defining Type.CARD(8) as byte ('.byte')...
    [apply] Defining Type.CARD(16) as half ('.half')...
    [apply] Defining Type.CARD(32) as word ('.word')...
    [apply] Defining space as space ('.space') filled with 0...
    [apply] Defining not null-terminated ASCII string as ascii ('.ascii')...
    [apply] Defining null-terminated ASCII string as asciiz ('.asciiz')...
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: or
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Addressing mode: REG
    [apply] Operation: addi
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin preparator: REG
    [apply] Operation: lui
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End preparator: REG
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------- Ended Processing Initialization Section --------------------
    [apply] 
    [apply] 
    [apply] ------------------- Started Processing Finalization Section --------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] -------------------- Ended Processing Finalization Section ---------------------
    [apply] 
    [apply] 
    [apply] ----------------------- Started Processing Main Section ------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@e856758) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@e856758}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11011110101011011011111011101111, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@382bd791) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@382bd791}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000010, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4b4a8192) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4b4a8192}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00001011101011011111000000001101, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2e759230) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2e759230}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11011110101011011011111011101111, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@64cb2f35) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@64cb2f35}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5472184f) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5472184f}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000000, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] or $9, $0, $0
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] or $9, $0, $0
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4f9bc78) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4f9bc78}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000010, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@738defde) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@738defde}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=00000000000000000000000000000000, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] or $9, $0, $0
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] or $9, $0, $0
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1c2859eb) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1c2859eb}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00000000000000000000000000000010, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4c289660) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4c289660}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=00000000000000000000000000000000, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3b3e0204) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3b3e0204}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11011110101011011011111011101111, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5b4878e6) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5b4878e6}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=00000000000000000000000000000010, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] addi $9, $0, 0x2
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] addi $9, $0, 0x2
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@778aadc8) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@778aadc8}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=00001011101011011111000000001101, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@173d3492) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@173d3492}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00001011101011011111000000001101, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4d217168) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4d217168}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11111111111111111111111111111110, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1629aeb2) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1629aeb2}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00001011101011011111000000001101, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2b4dca04) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2b4dca04}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=11011110101011011011111011101111, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@562eaa46) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@562eaa46}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=11011110101011011011111011101111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@f507e67) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@f507e67}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111110, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@71484698) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@71484698}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=11111111111111111111111111111110, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1934d131) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1934d131}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00001011101011011111000000001101, add.rs=11111111111111111111111111111110, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3e838f3b) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3e838f3b}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11011110101011011011111011101111, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1a65e186) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1a65e186}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@193051e4) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@193051e4}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1e835f05) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1e835f05}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11011110101011011011111011101111, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1cb24b4b) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1cb24b4b}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=00000000000000000000000000000000, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3ae3f711) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3ae3f711}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=11011110101011011011111011101111, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2d0dd3d) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2d0dd3d}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00001011101011011111000000001101, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5d474abb) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5d474abb}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11011110101011011011111011101111, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@67afe177) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@67afe177}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00001011101011011111000000001101, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@166db69b) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@166db69b}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000010, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2456f37e) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2456f37e}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11011110101011011011111011101111, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3ba472fd) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3ba472fd}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00001011101011011111000000001101, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@677d39b5) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@677d39b5}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=00000000000000000000000000000010, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] addi $9, $0, 0x2
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] addi $9, $0, 0x2
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@254a3cc1) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@254a3cc1}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00001011101011011111000000001101, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@37f86333) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@37f86333}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=00000000000000000000000000000001, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@68d93a9e) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@68d93a9e}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=11011110101011011011111011101111, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2b714bf9) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2b714bf9}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111110, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4e790cea) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4e790cea}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1454a16a) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1454a16a}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11111111111111111111111111111110, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2a089813) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2a089813}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@6b2685fb) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@6b2685fb}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000001, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2385558) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2385558}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=00000000000000000000000000000000, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1f9f200d) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1f9f200d}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=11011110101011011011111011101111, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1c4635d9) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1c4635d9}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=00001011101011011111000000001101, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@6782685f) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@6782685f}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=00000000000000000000000000000010, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] addi $9, $0, 0x2
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] addi $9, $0, 0x2
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5d2e0422) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5d2e0422}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11111111111111111111111111111110, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@133c82f4) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@133c82f4}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111110, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@70ecdea2) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@70ecdea2}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000001, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@21b1ab40) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@21b1ab40}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000001, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3a7c4526) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3a7c4526}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5bbb2804) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5bbb2804}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=00000000000000000000000000000000, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] or $9, $0, $0
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] or $9, $0, $0
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@50d7da99) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@50d7da99}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00001011101011011111000000001101, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@6a2cd73e) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@6a2cd73e}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@6d68681e) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@6d68681e}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=11011110101011011011111011101111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@463b1057) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@463b1057}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00001011101011011111000000001101, add.rs=00000000000000000000000000000000, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] or $9, $0, $0
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] or $9, $0, $0
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3f6a0833) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3f6a0833}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=11011110101011011011111011101111, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@33a85a34) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@33a85a34}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@e39f6f1) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@e39f6f1}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@666f5678) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@666f5678}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111110, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@47ae68f8) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@47ae68f8}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@26df3c83) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@26df3c83}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=00001011101011011111000000001101, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4e3a6f94) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4e3a6f94}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00001011101011011111000000001101, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5e506d2d) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5e506d2d}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=11011110101011011011111011101111, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@229d7c57) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@229d7c57}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4f3cb3fc) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4f3cb3fc}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000000, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@163e0873) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@163e0873}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@48c7402e) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@48c7402e}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00001011101011011111000000001101, add.rs=00000000000000000000000000000000, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] or $9, $0, $0
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] or $9, $0, $0
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@68aa419e) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@68aa419e}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00001011101011011111000000001101, add.rs=11111111111111111111111111111110, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4f18179d) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4f18179d}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11111111111111111111111111111110, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4a986a61) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4a986a61}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@100e74b1) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@100e74b1}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00001011101011011111000000001101, add.rs=00000000000000000000000000000001, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] addi $9, $0, 0x1
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] addi $9, $0, 0x1
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@7c0e843) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@7c0e843}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@729c1e43) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@729c1e43}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4314e1bd) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4314e1bd}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@22b1cf31) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@22b1cf31}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@25703a98) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@25703a98}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00001011101011011111000000001101, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@35d2e49d) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@35d2e49d}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111110, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@6756ea9b) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@6756ea9b}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000010, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x2
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x2
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@7c6172b5) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@7c6172b5}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000000, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] or $9, $0, $0
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] or $9, $0, $0
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@62facbec) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@62facbec}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000001, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4622fec1) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4622fec1}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=00000000000000000000000000000010, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@171de1b) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@171de1b}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00000000000000000000000000000000, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] or $9, $0, $0
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] or $9, $0, $0
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2ae5b5a3) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2ae5b5a3}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11011110101011011011111011101111, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3a4136ac) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3a4136ac}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00001011101011011111000000001101, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@36665b29) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@36665b29}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000000, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@377c0e2a) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@377c0e2a}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00000000000000000000000000000000, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4833c6df) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4833c6df}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@714ed0b9) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@714ed0b9}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4d23cfb4) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4d23cfb4}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000001, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@70adfda3) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@70adfda3}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000001, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5ad52fed) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5ad52fed}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=00001011101011011111000000001101, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@88775b) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@88775b}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@6d8611d5) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@6d8611d5}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=00000000000000000000000000000010, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] addi $9, $0, 0x2
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] addi $9, $0, 0x2
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@59f66488) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@59f66488}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11011110101011011011111011101111, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@25f9ffaf) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@25f9ffaf}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000010, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@50d3c695) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@50d3c695}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=11011110101011011011111011101111, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@31123984) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@31123984}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00000000000000000000000000000010, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x2
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x2
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@53bd822b) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@53bd822b}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00001011101011011111000000001101, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@7bff0922) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@7bff0922}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@a80bf6d) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@a80bf6d}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=00000000000000000000000000000000, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5fc431e1) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5fc431e1}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000001, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@431e34c7) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@431e34c7}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00001011101011011111000000001101, add.rs=00000000000000000000000000000000, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1e4bac35) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1e4bac35}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11011110101011011011111011101111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@7deb98f6) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@7deb98f6}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@43999ca0) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@43999ca0}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000000, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2351449c) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2351449c}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00000000000000000000000000000001, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2949784b) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2949784b}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000001, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2230ebff) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2230ebff}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00000000000000000000000000000001, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x1
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x1
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@11655d63) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@11655d63}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1d6b9fa5) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1d6b9fa5}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00000000000000000000000000000000, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@11786ce6) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@11786ce6}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000001, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5f9627fd) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5f9627fd}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00000000000000000000000000000010, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x2
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x2
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@6d44826c) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@6d44826c}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00001011101011011111000000001101, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@6ab1aae) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@6ab1aae}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000001, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@70335e88) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@70335e88}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@7d61623d) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@7d61623d}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=00001011101011011111000000001101, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4482d3a3) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4482d3a3}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00001011101011011111000000001101, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@43925b62) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@43925b62}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000001, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3d373366) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3d373366}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000001, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@76b98152) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@76b98152}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@36fe468f) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@36fe468f}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111110, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@79aa3359) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@79aa3359}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111110, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@671ec07c) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@671ec07c}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11111111111111111111111111111110, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@29166e80) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@29166e80}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000000, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@52ade1c2) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@52ade1c2}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@d25375e) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@d25375e}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@62514433) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@62514433}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=00000000000000000000000000000000, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] or $9, $0, $0
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] or $9, $0, $0
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3176aba9) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3176aba9}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=00000000000000000000000000000001, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@6476fff7) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@6476fff7}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000000, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@6549f211) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@6549f211}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00001011101011011111000000001101, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@65cd7629) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@65cd7629}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000000, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5a28ac4e) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5a28ac4e}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=11111111111111111111111111111110, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@599cf3f6) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@599cf3f6}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00000000000000000000000000000010, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@51d1d995) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@51d1d995}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@12dbdff) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@12dbdff}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@78fd9232) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@78fd9232}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00001011101011011111000000001101, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@33a76e2e) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@33a76e2e}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111110, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@42f1b388) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@42f1b388}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111110, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5ad6945c) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5ad6945c}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00001011101011011111000000001101, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@caf5a3e) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@caf5a3e}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=11011110101011011011111011101111, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3f98f94c) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3f98f94c}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@46a49a5f) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@46a49a5f}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00001011101011011111000000001101, add.rs=00000000000000000000000000000010, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5a15c79f) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5a15c79f}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=00000000000000000000000000000000, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] or $9, $0, $0
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] or $9, $0, $0
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@7190e324) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@7190e324}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@15a74f84) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@15a74f84}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=00001011101011011111000000001101, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@380910bc) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@380910bc}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00000000000000000000000000000001, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@62fe9f60) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@62fe9f60}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11011110101011011011111011101111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@296bfd4) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@296bfd4}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@7e1888b2) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@7e1888b2}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11111111111111111111111111111110, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@747946a4) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@747946a4}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111110, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2ba7492e) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2ba7492e}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@689d87a0) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@689d87a0}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=11011110101011011011111011101111, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@25bdf16e) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@25bdf16e}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5f2c8190) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5f2c8190}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2dd90a2c) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2dd90a2c}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111110, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@657dbad2) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@657dbad2}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00000000000000000000000000000000, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@7e84d99c) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@7e84d99c}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000010, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@16c1fc61) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@16c1fc61}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1fb084a) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1fb084a}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000001, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@64651002) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@64651002}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00000000000000000000000000000001, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@623a61ff) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@623a61ff}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@54144b42) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@54144b42}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000000, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] or $9, $0, $0
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] or $9, $0, $0
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@593bbd58) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@593bbd58}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11011110101011011011111011101111, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@31a1743) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@31a1743}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=00000000000000000000000000000000, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] or $9, $0, $0
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] or $9, $0, $0
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3bd24b4f) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3bd24b4f}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@43b56307) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@43b56307}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=11111111111111111111111111111110, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5ff7176f) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5ff7176f}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000010, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@23d8058b) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@23d8058b}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000010, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@79cec2c0) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@79cec2c0}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4bbbcc27) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4bbbcc27}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2e27f9d0) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2e27f9d0}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000010, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1457e85c) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1457e85c}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111110, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@60bd218d) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@60bd218d}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00001011101011011111000000001101, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@16663a54) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@16663a54}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=11011110101011011011111011101111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@7b22bfc2) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@7b22bfc2}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2c48d1fc) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2c48d1fc}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000001, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1bef0f08) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1bef0f08}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@72e9108f) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@72e9108f}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000001, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@540eabe7) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@540eabe7}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00000000000000000000000000000001, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x1
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x1
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5ee08586) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5ee08586}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=11111111111111111111111111111110, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@443f36e4) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@443f36e4}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111110, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@55f805f6) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@55f805f6}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000001, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@41dc7621) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@41dc7621}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000000, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4f966198) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4f966198}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3f7476bd) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3f7476bd}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=00000000000000000000000000000000, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@7d6dcf80) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@7d6dcf80}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=00001011101011011111000000001101, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1a5e9dcc) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1a5e9dcc}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00000000000000000000000000000010, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x2
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x2
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@73dc2acd) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@73dc2acd}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2629644f) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2629644f}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@e196fe0) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@e196fe0}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=00000000000000000000000000000001, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@6fde3fab) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@6fde3fab}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00001011101011011111000000001101, add.rs=00000000000000000000000000000001, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1a193bee) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1a193bee}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@732961e6) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@732961e6}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00001011101011011111000000001101, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@fc3b79c) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@fc3b79c}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000000, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3ab6ebd9) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3ab6ebd9}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=00000000000000000000000000000010, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@313d6965) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@313d6965}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111110, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@39a6645) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@39a6645}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11111111111111111111111111111110, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@fb04321) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@fb04321}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=00000000000000000000000000000010, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@132367fa) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@132367fa}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000000, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4e65ad52) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4e65ad52}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00001011101011011111000000001101, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@31b9c19c) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@31b9c19c}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=00000000000000000000000000000001, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5830d5d0) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5830d5d0}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3f961f13) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3f961f13}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3105e269) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3105e269}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11011110101011011011111011101111, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1c04b84c) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1c04b84c}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000010, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2a6e69ac) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2a6e69ac}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=11111111111111111111111111111110, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@368e2bf1) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@368e2bf1}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=00000000000000000000000000000001, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] addi $9, $0, 0x1
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] addi $9, $0, 0x1
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@42b96163) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@42b96163}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00001011101011011111000000001101, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1ca34126) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1ca34126}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=00000000000000000000000000000010, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] addi $9, $0, 0x2
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] addi $9, $0, 0x2
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2276517f) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2276517f}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@783589e6) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@783589e6}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00001011101011011111000000001101, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@396b544c) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@396b544c}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11011110101011011011111011101111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@39f213ac) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@39f213ac}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=11111111111111111111111111111110, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@436774a2) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@436774a2}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11011110101011011011111011101111, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4da3dc1d) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4da3dc1d}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00001011101011011111000000001101, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@34239072) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@34239072}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5c585f5b) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5c585f5b}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000010, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@55d3e052) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@55d3e052}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=00000000000000000000000000000010, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] addi $9, $0, 0x2
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] addi $9, $0, 0x2
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@ec04efd) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@ec04efd}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@16e3f7a2) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@16e3f7a2}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000010, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@28f43e9d) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@28f43e9d}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00000000000000000000000000000000, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@750a531a) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@750a531a}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000001, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1130ed80) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1130ed80}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000000, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2d3de6b8) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2d3de6b8}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=11011110101011011011111011101111, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3e834538) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3e834538}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11011110101011011011111011101111, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@73f1f461) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@73f1f461}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3d162405) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3d162405}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=11111111111111111111111111111110, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5137cd80) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5137cd80}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=00001011101011011111000000001101, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@41f4a67e) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@41f4a67e}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00001011101011011111000000001101, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@24147818) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@24147818}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111110, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5a568cad) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5a568cad}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000000, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5237515) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5237515}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@c859af3) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@c859af3}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@30a49218) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@30a49218}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000000, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@57693cba) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@57693cba}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00000000000000000000000000000000, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1006ff23) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1006ff23}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=00000000000000000000000000000000, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@7ccc6fd4) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@7ccc6fd4}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00001011101011011111000000001101, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@6f621b2a) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@6f621b2a}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111111, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@636ab40a) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@636ab40a}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3d41d07f) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3d41d07f}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=11111111111111111111111111111110, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@27b0fecf) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@27b0fecf}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=00000000000000000000000000000001, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] addi $9, $0, 0x1
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] addi $9, $0, 0x1
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@ee45691) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@ee45691}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00001011101011011111000000001101, add.rs=00000000000000000000000000000010, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3c02750b) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3c02750b}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000001, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@426f736c) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@426f736c}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=00000000000000000000000000000010, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@8815140) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@8815140}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00001011101011011111000000001101, add.rs=00000000000000000000000000000000, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] or $9, $0, $0
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] or $9, $0, $0
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@49c03579) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@49c03579}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11011110101011011011111011101111, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1d1d8ccb) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1d1d8ccb}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000000, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4bffe94c) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4bffe94c}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@36bbb2f5) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@36bbb2f5}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@43b7547d) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@43b7547d}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000010, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@17e10d57) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@17e10d57}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000001, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@54762599) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@54762599}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000001, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@480592e3) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@480592e3}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5db04644) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5db04644}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=11011110101011011011111011101111, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1de54f07) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1de54f07}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00000000000000000000000000000000, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2d585836) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2d585836}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=11111111111111111111111111111110, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@fd02b57) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@fd02b57}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00000000000000000000000000000000, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1aa2b502) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1aa2b502}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=00000000000000000000000000000001, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2d913d11) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2d913d11}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00001011101011011111000000001101, add.rs=11111111111111111111111111111110, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@c2ffff) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@c2ffff}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=11111111111111111111111111111110, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@36e8f73d) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@36e8f73d}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=11011110101011011011111011101111, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@29935953) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@29935953}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@c8ff072) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@c8ff072}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1579d7dd) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1579d7dd}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00001011101011011111000000001101, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4ef11b42) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4ef11b42}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1c589d49) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1c589d49}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111110, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@309824aa) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@309824aa}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=00000000000000000000000000000010, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@23eb54ea) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@23eb54ea}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00001011101011011111000000001101, add.rs=00001011101011011111000000001101, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@35b0b7f) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@35b0b7f}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2860d9c) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2860d9c}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5a094258) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5a094258}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000001, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@38839ad7) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@38839ad7}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11011110101011011011111011101111, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1decdf9d) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1decdf9d}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000000, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5c2a3f7a) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5c2a3f7a}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3f794b56) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3f794b56}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111111, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xffff
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@6c9dd8be) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@6c9dd8be}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00001011101011011111000000001101, add.rs=11111111111111111111111111111110, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@42d795d2) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@42d795d2}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4f43d53c) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4f43d53c}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111111, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2ec0a42b) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2ec0a42b}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=11111111111111111111111111111111, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@355d5435) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@355d5435}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=00000000000000000000000000000010, add.rt=11011110101011011011111011101111}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xdead
    [apply] addi $10, $10, 0xbeef
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@748ede42) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@748ede42}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=11111111111111111111111111111110, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3c9740d8) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3c9740d8}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00001011101011011111000000001101, add.rt=00000000000000000000000000000010}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xbad
    [apply] addi $9, $9, 0xf00d
    [apply] addi $10, $0, 0x2
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@7617f67f) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@7617f67f}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=00000000000000000000000000000000, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] or $9, $0, $0
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] or $9, $0, $0
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@48b4721b) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@48b4721b}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=11011110101011011011111011101111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@50ed98e6) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@50ed98e6}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000001, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] addi $9, $0, 0x1
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@17d64c2) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@17d64c2}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@115faadb) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@115faadb}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000000, add.rt=11111111111111111111111111111110}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xfffe
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@853b148) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@853b148}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000000, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] or $9, $0, $0
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@5d34cc05) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@5d34cc05}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000001, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x1
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2c7c6b8e) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2c7c6b8e}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11111111111111111111111111111110, add.rs=00000000000000000000000000000000, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xffff
    [apply] addi $8, $8, 0xfffe
    [apply] or $9, $0, $0
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@17282f92) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@17282f92}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=11011110101011011011111011101111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xdead
    [apply] addi $9, $9, 0xbeef
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@4c9a65ca) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@4c9a65ca}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00001011101011011111000000001101, add.rs=11111111111111111111111111111110, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xbad
    [apply] addi $8, $8, 0xf00d
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1da16e0b) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1da16e0b}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000010, add.rt=00001011101011011111000000001101}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00001011101011011111000000001101 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xbad
    [apply] addi $10, $10, 0xf00d
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@2ea32eba) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@2ea32eba}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=11111111111111111111111111111111, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xffff
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@1ed9adbc) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@1ed9adbc}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000000, add.rs=00000000000000000000000000000010, add.rt=11111111111111111111111111111111}]
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 11111111111111111111111111111111 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] or $8, $0, $0
    [apply] addi $9, $0, 0x2
    [apply] lui $10, 0xffff
    [apply] addi $10, $10, 0xffff
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@3c30ed50) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@3c30ed50}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=00000000000000000000000000000001, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] addi $9, $0, 0x1
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] addi $9, $0, 0x1
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@6385b08b) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@6385b08b}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000001, add.rs=11111111111111111111111111111110, add.rt=00000000000000000000000000000000}]
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 11111111111111111111111111111110 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x1
    [apply] lui $9, 0xffff
    [apply] addi $9, $9, 0xfffe
    [apply] or $10, $0, $0
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@56b865c5) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@56b865c5}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=00000000000000000000000000000010, add.rs=00000000000000000000000000000000, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 00000000000000000000000000000010 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] addi $8, $0, 0x2
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] addi $8, $0, 0x2
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] Begin block: _1
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Addressing mode: REG
    [apply] Operation: add
    [apply] Ended building a call (empty = false, executable = true)
    [apply] Ended building a call (empty = true, executable = false)
    [apply] End block: _1
    [apply] 
    [apply] 
    [apply] ------------------------------- Generating Data --------------------------------
    [apply] 
    [apply] 
    [apply] Processing instruction call (root: add)...
    [apply] Processing situation random_biased(dist=ru.ispras.fortress.randomizer.VariateComposite@36a0448e) for op add(rd: REG, rs: REG, rt: REG):[context=#root, type=instruction, root=true]...
    [apply] Query to TestBase: TestBaseQuery [context={processor=minimips, instruction=add, testcase=random_biased, add=add, add.rd=REG, add.rd.i=#IMM, add.rs=REG, add.rs.i=#IMM, add.rt=REG, add.rt.i=#IMM}, bindings={add.rd.i=01000, add.rd=add.rd, add.rs.i=01001, add.rs=add.rs, add.rt.i=01010, add.rt=add.rt}, parameters={dist=ru.ispras.fortress.randomizer.VariateComposite@36a0448e}]
    [apply] Unknown immediate values: []
    [apply] Modes used as arguments: {add.rs=Argument [name=rs, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rt=Argument [name=rt, kind=MODE, value=mode REG(i: #IMM), mode=IN, type=Type.INT(32)], add.rd=Argument [name=rd, kind=MODE, value=mode REG(i: #IMM), mode=OUT, type=Type.INT(32)]}
    [apply] TestData [bindings={add.rd=11011110101011011011111011101111, add.rs=00000000000000000000000000000000, add.rt=00000000000000000000000000000001}]
    [apply] Creating code to assign 11011110101011011011111011101111 to mode REG(i: #IMM = 8)...
    [apply] Creating code to assign 00000000000000000000000000000000 to mode REG(i: #IMM = 9)...
    [apply] Creating code to assign 00000000000000000000000000000001 to mode REG(i: #IMM = 10)...
    [apply] 
    [apply] ---------------------------------- Executing -----------------------------------
    [apply] 
    [apply] Initialization:
    [apply] 
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Main Code:
    [apply] 
    [apply] add $8, $9, $10
    [apply] 
    [apply] ----------------------------------- Printing -----------------------------------
    [apply] 
    [apply] 
    [apply] Preparation
    [apply] lui $8, 0xdead
    [apply] addi $8, $8, 0xbeef
    [apply] or $9, $0, $0
    [apply] addi $10, $0, 0x1
    [apply] 
    [apply] Stimulus
    [apply] add $8, $9, $10
    [apply] 
    [apply] --------------------------------------------------------------------------------
    [apply] 
    [apply] Ended building a call (empty = true, executable = false)
    [apply] 
    [apply] ------------------------ Ended Processing Main Section -------------------------
    [apply] 
    [apply] 
    [apply] -------------------------- Ended Processing Template ---------------------------
    [apply] 
    [apply] Generation Statistics
    [apply] Generation time: 15.229 seconds 
    [apply] Generation rate: 172 instructions/second
    [apply] Programs/stimuli/instructions: 3/300/2625
    [apply] Error: Generation rate is too slow. At least 500 is expected.
