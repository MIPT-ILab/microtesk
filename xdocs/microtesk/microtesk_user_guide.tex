%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[oneside,final,12pt]{extreport}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english]{babel}
\usepackage{vmargin}
\setpapersize{A4}
\usepackage{indentfirst}
\usepackage{graphicx}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Page Headers

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\lhead{MicroTESK User Guide [Draft]}
\rfoot{\thepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Listing Style

\usepackage{listings}
\usepackage[dvipsnames]{xcolor}

\lstset{
 language=C,
 frame=single,
 basicstyle=\ttfamily\scriptsize,
 commentstyle=\itshape,
 emph={op, mode, reg, alias, mem, type, let, card, int, syntax, image, format, action,
       if, then, else, elif, endif, coerce, exception, address, segment, buffer, register,
       memory, mmu, range, ways, sets, match, tag, index, entry, policy, read, write,
       var, hit, path, transition, guard},
 emphstyle={\bfseries}}

\usepackage{listings}
\lstloadlanguages{Ruby}
\lstset{
basicstyle=\ttfamily\footnotesize\color{black},
commentstyle = \ttfamily\color{green},
keywordstyle=\bfseries\color{blue},
stringstyle=\color{blue},
basewidth={.48em}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Links and References

\usepackage{hyperref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{titlepage}
\begin{center}
\Large{Institute for System Programming of the Russian Academy of Sciences}

\vfill


\bf\Large{MicroTESK User Guide}

(UNDER DEVELOPMENT)

\vfill

\bf
Moscow 2016
\end{center}
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\stepcounter{page} % Increase page counter by one
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Overview}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Installation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{System Requirements}

MicroTESK is a set of Java-based utilities that are run from the command line.
It can be used on \textbf{\textit{Windows}}, \textbf{\textit{Linux}} and
\textbf{\textit{OS X}} machines that have \textbf{\textit{JDK 1.7 or later}}
installed. To build MicroTESK from source code or to build the generated
Java models, \textbf{\textit{Apache Ant version 1.8 or later}} is required.
To generate test data based on constraints, MicroTESK needs
the \textbf{\textit{Microsoft Research Z3}} or \textbf{\textit{CVC4}} solver that
can work on the corresponding operating system.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Installation Steps}

To install MicroTESK, the following steps should be performed:

\begin{enumerate}
  \item Download from \url{http://forge.ispras.ru/projects/microtesk/files} and unpack
        the MicroTESK installation package (the \texttt{.tar.gz} file, latest release) to your
        computer. The folder to which it was unpacked will be further referred to as
        the installation directory (\texttt{<installation dir>}).

  \item Declare the \texttt{MICROTESK{\_}HOME} environment variable and set its value to the path to
        the installation directory (see the \hyperref[Setting_Environment_Variables]
        {Setting Environment Variables} section).

  \item Set the \texttt{<installation dir>/bin} folder as the working directory (add the path to
        the \texttt{PATH} environment variable) to be able to run MicroTESK utilities from any path.

  \item Note: Required for constraint-based generation. Download and install constraint
        solver tools to the \texttt{<installation dir>/tools} directory (see the
        \hyperref[Installing_Constraint_Solvers]{Installing Constraint Solvers} section).
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Setting Environment Variables}
\label{Setting_Environment_Variables}

\paragraph{Windows}

\begin{enumerate}
  \item Open the \texttt{System Properties} window.
  \item Switch to the \texttt{Advanced} tab.
  \item Click on \texttt{Environment Variables}.
  \item Click \texttt{New..} under \texttt{System Variables}.
  \item In the \texttt{New System Variable} dialog, specify variable name as
        \texttt{MICROTESK{\_}HOME} and variable value as \texttt{<installation dir>}.
  \item Click \texttt{OK} on all open windows.
  \item Reopen the command prompt window.
\end{enumerate}

\paragraph{Linux and OS X} ~\\

Add the command below to the \texttt{\textasciitilde{}.bash{\_}profile} file
(\textbf{\textit{Linux}}) or the \texttt{\textasciitilde{}/.profile} file (\textbf{\textit{OS X}}):

\begin{lstlisting}[language=bash]
export MICROTESK_HOME=<installation dir>
\end{lstlisting}

To start editing the file, type \texttt{vi \textasciitilde{}/.bash{\_}profile}
(or \texttt{vi \textasciitilde{}/.profile}).
Changes will be applied after restarting the command-line terminal or reboot. You can also
run the command in your command-line terminal to make temporary changes.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Installing Constraint Solvers}
\label{Installing_Constraint_Solvers}

To generate test data based on constraints, MicroTESK requires external constraint solvers.
The current version supports the \href{https://github.com/z3prover}{Z3} and
\href{http://cvc4.cs.nyu.edu}{CVC4} constraint solvers. Constraint executables should be
downloaded and placed to the \texttt{<installation dir>/tools} directory.

\paragraph{Using Environment Variables} ~\\

If solvers are already installed in another directory, to let MicroTESK find them, the following
environment variables can be used: \texttt{Z3{\_}PATH} and \texttt{CVC4{\_}PATH}. They specify
the paths to the Z3 and CVC4 excutables correspondingly.

\paragraph{Installing Z3}

\begin{itemize}
\item \textbf{\textit{Windows}} users should download Z3 (32 or 64-bit version) from the following
       page:\url{http://z3.codeplex.com/releases} and unpack the archive to the
      \texttt{<installation dir>/tools/z3/windows} directory. Note: the executable file path
      is \texttt{<windows>/z3/bin/z3.exe}.

\item \textbf{\textit{UNIX}} and \textbf{\textit{Linux}} users should use one of the links below
      and and unpack the archive to the \texttt{<installation dir>/tools/z3/unix} directory.
      Note: the executable file path is \texttt{<unix>/z3/bin/z3}.

      \begin{tabular} {| l | r |} \hline
      Debian  x64 & \url{http://z3.codeplex.com/releases/view/101916} \\ \hline
      Ubuntu  x86 & \url{http://z3.codeplex.com/releases/view/101913} \\ \hline
      Ubuntu  x64 & \url{http://z3.codeplex.com/releases/view/101911} \\ \hline
      FreeBSD x64 & \url{http://z3.codeplex.com/releases/view/101907} \\ \hline
      \end{tabular}

\item \textbf{\textit{OS X}} users should download Z3 from
      \url{http://z3.codeplex.com/releases/view/101918} and unpack the archive to the
      \texttt{<installation dir>/z3/osx} directory. Note: the executable file path is
      \texttt{<osx>/z3/bin/z3}.

\end{itemize}

\paragraph{Installing CVC4}

\begin{itemize}
\item \textbf{\textit{Windows}} users should download the latest version of CVC4 binary from
      \url{http://cvc4.cs.nyu.edu/builds/win32-opt/} and save it to the
      \texttt{<installation dir>/tools/cvc4/windows} directory as \texttt{cvc4.exe}.

\item \textbf{\textit{Linux}} users download the latest version of CVC4 binary from
      \url{http://cvc4.cs.nyu.edu/builds/i386-linux-opt/unstable/} (32-bit version) or
      \url{http://cvc4.cs.nyu.edu/builds/x86_64-linux-opt/unstable/} (64-bit version) and
      save it to the \texttt{<installation dir>/tools/cvc4/unix} directory as \texttt{cvc4}.

\item \textbf{\textit{OS X}} users should download the latest version of CVC4 distribution
      package from \url{http://cvc4.cs.nyu.edu/builds/macos/} and install it.
      The CVC4 binary should be copied to \texttt{<installation dir>/tools/cvc4/osx} as
      \texttt{cvc4} or linked to this file name via a symbolic link.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Installation Directory Structure}

The MicroTESK installation directory contains the following subdirectories: \\

\begin{tabular}{ | l | l |}
  \hline
  \textbf{arch} & Microprocessor specifications and test templates \\ \hline
  \textbf{bin}  & Scripts to run modeling and test generation tasks \\ \hline
  \textbf{doc}  & Documentation \\ \hline
  \textbf{etc}  & Configuration files \\ \hline
  \textbf{gen}  & Generated code of microprocessor models \\ \hline
  \textbf{lib}  & JAR files and Ruby scripts to perform modeling and \\
  ~             & test generation tasks \\ \hline
  \textbf{src}  & Source code of MicroTESK \\ \hline
\end{tabular}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Running}

To generate a Java model of a microprocessor from its nML specification, a user
needs to run the \texttt{compile.sh} script (Unix, Linux, OS X) or the \texttt{compile.bat}
script (Windows). For example, the following command generates a model for the miniMIPS
specification:

\begin{lstlisting}[language=bash]
sh bin/compile.sh arch/minimips/model/minimips.nml
\end{lstlisting}

NOTE: Models for all demo specifications are already built and included in the
MicroTESK distribution package. So a user can start working with MicroTESK from
generating test programs for these models.

To generate a test program, a user needs to use the \texttt{generate.sh} script
(Unix, Linux, OS X) or the \texttt{generate.bat} script (Windows). The scripts
require the following parameters:

\begin{itemize}
\item model name;
\item test template file;
\item target test program source code file.
\end{itemize}

For example, the command below runs the \texttt{euclid.rb} test template for
the miniMIPS model generated by the command from the previous example and saves
the generated test program to an assembler file. The file name is based on values
of the \texttt{--code-file-prefix} and \texttt{--code-file-extension} options.

\begin{lstlisting}[language=bash]
sh bin/generate.sh minimips arch/minimips/templates/euclid.rb
\end{lstlisting}

To specify whether Z3 or CVC4 should be used to solve constraints,
a user needs to specify the \texttt{-s} or \texttt{--solver} command-line option as \texttt{z3}
or \texttt{cvc4} respectively. By default, Z3 will be used. Here is an example:

\begin{lstlisting}[language=bash]
sh bin/generate.sh -s cvc4 minimips arch/minimips/templates/constraint.rb
\end{lstlisting}

More information on command-line options can be found on the
\hyperref[Command_Line_Options]{Command-Line Options} section.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Command-Line Options}
\label{Command_Line_Options}

MicroTESK works in two modes: \emph{specification translation} and \emph{test generation},
which are enabled with the \texttt{--translate} (used by default) and \texttt{--generate} keys
correspondingly. In addition, the \texttt{--help} key prints information on the command-line format.

The \texttt{--translate} and \texttt{--generate} keys are inserted into the command-line by
\texttt{compile.sh}/\texttt{compile.bat} and \texttt{generate.sh}/\texttt{generate.bat} scripts
correspondingly. Other options should be specified explicitly to customize the behavior of MicroTESK.
Here is the list of options:\\

\begin{tabular}{ | p{4cm} | p{1cm} | p{5cm} | p{2.5cm} |}
  \hline
  \textbf{Full name} & \textbf{Short name} & \textbf{Description} & \textbf{Requires} \\ \hline
  --help & -h & Shows help message & \\ \hline
  --verbose & -v & Enables printing diagnostic messages & \\ \hline
  --translate & -t & Translates formal specifications & \\ \hline
  --generate & -g & Generates test programs & \\ \hline
  --output-dir <arg> & -od & Sets where to place generated files & \\ \hline
  --include <arg> & -i & Sets include files directories & --translate \\ \hline
  --extension-dir <arg> & -ed & Sets directory that stores user-defined Java code & --translate \\ \hline
  --random-seed <arg> & -rs & Sets seed for randomizer & --generate \\ \hline
  --solver <arg> & -s & Sets constraint solver engine to be used & --generate \\ \hline
  --branch-exec-limit <arg> & -bel & Sets the limit on control transfers to detect endless loops & --generate \\ \hline
  --solver-debug & -sd & Enables debug mode for SMT solvers & --generate \\ \hline
  --tarmac-log & -tl & Saves simulator log in Tarmac format & --generate \\ \hline
  --self-checks & -sc & Inserts self-checking code into test programs & --generate \\ \hline
  --arch-dirs <arg> & -ad & Home directories for tested architectures & --generate \\ \hline
  --rate-limit <arg> & -rl & Generation rate limit, causes error when broken & --generate \\ \hline
  --code-file-extension <arg> & -cfe & The output file extension & --generate \\ \hline
\end{tabular}

\begin{tabular}{ | p{4cm} | p{1cm} | p{5cm} | p{2.5cm} |}
  \hline
  --code-file-prefix <arg> & -cfp & The output file prefix (file names are as follows prefix{\_}xxxx.ext, where xxxx is a 4-digit decimal number) & --generate \\ \hline
  --data-file-extension <arg> & -dfe & The data file extension & --generate \\ \hline
  --data-file-prefix <arg> & -dfp & The data file prefix & --generate \\ \hline
  --exception-file-prefix <arg> & -efp & The exception handler file prefix & --generate \\ \hline
  --program-length-limit <arg> & -pll & The maximum number of instructions in output programs & --generate \\ \hline
  --trace-length-limit <arg> & -tll & The maximum length of execution traces of output programs & --generate \\ \hline
  --comments-enabled & -ce & Enables printing comments; if not specified no comments are printed & --generate \\ \hline
  --comments-debug & -cd & Enables printing detailed comments; must be used together with --comments-enabled  & --generate \\ \hline
\end{tabular}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Settings File}

Default values of options are stored in the \texttt{<MICROTESK{\_}HOME>/etc/settings.xml}
configururation file that has the following format:

\begin{lstlisting}[language=ruby]
<?xml version="1.0" encoding="utf-8"?>
<settings>
  <setting name="random-seed" value="0"/>
  <setting name="branch-exec-limit" value="1000"/>
  <setting name="code-file-extension" value="asm"/>
  <setting name="code-file-prefix" value="test"/>
  <setting name="data-file-extension" value="dat"/>
  <setting name="data-file-prefix" value="test"/>
  <setting name="exception-file-prefix" value="test_except"/>
  <setting name="program-length-limit" value="1000"/>
  <setting name="trace-length-limit" value="1000"/>
  <setting name="comments-enabled" value=""/>
  <setting name="comments-debug" value=""/>
  <setting
    name="arch-dirs" 
    value="cpu=arch/demo/cpu/settings.xml:minimips=arch/minimips/settings.xml"
  />
</settings>
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Test Templates}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

MicroTESK generates test programs on the basis of \emph{test templates} that describe
test programs to be generated in an abstract way. Test templates are created using
special Ruby-based test template description language. The language is implemented as
a library that includes provides facilities for describing test cases.

MicroTESK uses the JRuby interpreter to process test templates. This allows Ruby libraries
to interact with other components of MicroTESK written in Java.

Test templates are processed in two stages:
\begin{enumerate}
\item \label{ttp_stage_1} Ruby code is executed to build the internal representation (a hierarchy
      of Java objects) of the test template.
\item \label{ttp_stage_2} The internal representation is processed with various engines to 
      generate test cases which are then simulated on the reference model and printed to files.
\end{enumerate}

This chapter describes facilities of the test template description language and supported test
generation engines.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hyphenation{Template}

\section{Test Template Structure}

A test template is implemented as a class inherited from the \texttt{Template} library class
that provides access to all features of the library. Information on the location of
the \texttt{Template} class is stored in the \texttt{TEMPLATE} environment variable.
Thus, the definition of a test template class looks like this:

\begin{lstlisting}[language=ruby]
require ENV['TEMPLATE']

class MyTemplate < Template
\end{lstlisting}

Test template classes should contain implementations of the following methods:

\begin{enumerate}
  \item \texttt{initialize} (optional) - specifies settings for the given test template;
  \item \texttt{pre} (optional) - specifies the initialization code for test programs;
  \item \texttt{post} (optional) - specifies the finalization code for test programs;
  \item \texttt{run} - specifies the main code of test programs (test cases).
\end{enumerate}

The definitions of optional methods can be skipped. In this case, the default
implementations provided by the parent class will be used. The default implementation
of the \texttt{initialize} method initializes the settings with default values. The default
implementations of the \texttt{pre} and \texttt{post} methods do nothing.

The full interface of a test template looks as follows:

\begin{lstlisting}[language=ruby]
require ENV['TEMPLATE']

class MyTemplate < Template

  def initialize
    super
    # Initialize settings here 
  end

  def pre
    # Place your initialization code here
  end

  def post
    # Place your finalization code here
  end

  def run
    # Place your test problem description here
  end

end
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Reusing Test Templates}

It is possible to reuse code of existing test templates in other test templates.
To do this, you need to subclass the template you want to reuse instead of the
\texttt{Template} class. For example, the \texttt{MyTemplate} class below reuses code from
the \texttt{MyPrepost} class that provides initialization and finalization code for similar
test templates.

\begin{lstlisting}[language=ruby]
require ENV['TEMPLATE']
require_relative 'MyPrepost'

class MyTemplate < MyPrepost

  def run
    ... 
  end

end
\end{lstlisting}

Another way to reuse code is creating code libraries with methods that can be called
by test templates. A code library is defined as a Ruby module file and has the following
structure:

\begin{lstlisting}[language=ruby]
module MyLibrary

  def method1
    ...
  end

  def method2(arg1, arg2)
    ...
  end

  def method3(arg1, arg2, arg3)
    ...
  end

end
\end{lstlisting}

To be able to use utility methods \texttt{method1}, \texttt{method2} and \texttt{method3}
in a test template, the \texttt{MyLibrary} module must be included in that test template as a mixin.
Once this is done, all methods of the library are available in the test template.
Here is an example:

\begin{lstlisting}[language=ruby]
require ENV['TEMPLATE']
require_relative 'my_library'

class MyTemplate < Template
  include MyLibrary

  def run
    method1
    method2 arg1, arg2
    method3 arg1, arg2, arg3
  end

end
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Test Template Settings}

Test templates use the following settings that set up the format of generated 
test programs:

\begin{itemize}
\item \texttt{sl{\_}comment{\_}starts{\_}with} - starting characters for single-line comments;
\item \texttt{ml{\_}comment{\_}starts{\_}with} - starting characters for multi-line comments;
\item \texttt{ml{\_}comment{\_}ends{\_}with} - terminating characters for multi-line comments;
\item \texttt{indent{\_}token} - indentation token;
\item \texttt{separator{\_}token} - token used in separator lines.
\end{itemize}

Here is how these settings are initialized with default values in
the \texttt{Template} class:

\begin{lstlisting}[language=ruby]
@sl_comment_starts_with = "//"
@ml_comment_starts_with = "/*"
@ml_comment_ends_with   = "*/"

@indent_token    = "\t"
@separator_token = "="
\end{lstlisting}

The settings can be overridden in the \texttt{initialize} method of a test template.
For example:

\begin{lstlisting}[language=ruby]
class MyTemplate < Template

  def initialize
    super

    @sl_comment_starts_with = ";" 
    @ml_comment_starts_with = "/="
    @ml_comment_ends_with = "=/"

    @indent_token = "  "
    @separator_token = "*" 
  end
  ...
end
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Text Printing}

The test template description language provides facilities for printing text messages.
Text messages are printed either into the generated source code or into the simulator log.
Here is the list of functions that print text:

\begin{itemize}
\item \texttt{newline} - adds the new line character into the test program;
\item \texttt{text(format, *args)} - adds text into the test program;
\item \texttt{trace(format, *args)} - prints text into the simulator execution log;
\item \texttt{comment(format, *args)} - adds a comment into the test program;
\item \texttt{start{\_}comment} - starts a multi-line comment;
\item \texttt{end{\_}comment} - ends a multi-line comment.
\end{itemize}

\paragraph{Formatted Printing} ~\\

Functions \texttt{text}, \texttt{trace} and \texttt{comment} print formatted text.
They take a format string and a variable list of arguments that provide data to be
printed.

Supported argument types:
\begin{itemize}
\item constants;
\item locations.
\end{itemize}

To specify locations to be printed (registers, memory), the \texttt{location(name, index)}
function should be used. It takes the name of the memory array and the index of the selected
element.

Supported format characters:
\begin{itemize}
\item \texttt{d} - decimal format;
\item \texttt{x} or \texttt{X} - hexadecimal format (lowercase or uppercase letters);
\item \texttt{s} - decimal format for constants and binary format for locations.
\end{itemize}

For example, the code below prints the \texttt{0xDEADBEEF} value as a constant and as
a value stored in a register using different format characters:

\begin{lstlisting}[language=ruby]
prepare reg(1), 0xDEADBEEF
reg1 = location('GPR', 1)
text 'Constants: dec=%d, hex=0x%X, str=%s', 0xDEADBEEF, 0xDEADBEEF, 0xDEADBEEF
text 'Locations: dec=%d, hex=0x%X, str=%s', reg1, reg1, reg1
\end{lstlisting}

Here is how it will be printed:

\begin{lstlisting}
Constants: dec=3735928559, hex=0xDEADBEEF, str=3735928559
Locations: dec=3735928559, hex=0xDEADBEEF, str=11011110101011011011111011101111
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Data Definitions}

\subsection{Configuration}

Defining data requires the use of assembler-specific directives. Information on
these directives is not included in ISA specifications and should be provided in test
templates. It includes textual format of data directives and mappings between nML and
assembler data types used by these directives. Configuration information on data
directives is specified in the \texttt{data{\_}config} block, which is usually placed
in the \texttt{pre} method. Only one such block per a test template is allowed.
Here is an example:

\begin{lstlisting}[language=ruby]
data_config(:text => '.data', :target => 'M') {
  define_type :id => :byte, :text => '.byte', :type => type('card', 8)
  define_type :id => :half, :text => '.half', :type => type('card', 16)
  define_type :id => :word, :text => '.word', :type => type('card', 32)

  define_space :id => :space, :text => '.space', :fillWith => 0
  define_ascii_string :id => :ascii, :text => '.ascii', :zeroTerm => false
  define_ascii_string :id => :asciiz, :text => '.asciiz', :zeroTerm => true
}
\end{lstlisting}

The block takes the following parameters:

\begin{itemize}
  \item \texttt{text} (compulsory) - specifies the keyword that marks the beginning of
        the data section in the generated test program;

  \item \texttt{target} (compulsory) - specifies the memory array defined in the nML
        specification to which data will be placed during simulation;

  \item \texttt{base{\_}virtual{\_}address} (optional) - specifies the base virtual
        address where data allocation starts. Default value is 0;

  \item \texttt{item{\_}size} (optional) - specifies the size of a memory location unit
        pointed by address. Default value is 8 bits (or 1 byte).
\end{itemize}

To set up particular directives, the language provides special methods that must
be called inside the block. All the methods share two common parameters:
\texttt{id} and \texttt{text}. The first specifies the keyword to be used in a
test template to address the directive and the second specifies how it will be
printed in the test program. The current version of MicroTESK provides the following methods:

\begin{enumerate}
  \item \texttt{define{\_}type} - defines a directive to allocate memory for a data element
        of an nML data type specified by the type parameter;

  \item \texttt{define{\_}space} - defines a directive to allocate memory (one or more
        addressable locations) filled with a default value specified by the
        fillWith parameter;

  \item \texttt{define{\_}ascii{\_}string} - defines a directive to allocate memory for an
        ASCII string terminated or not terminated with zero depending on the
        \texttt{zeroTerm} parameter.
\end{enumerate}

The above example defines the directives \texttt{byte}, \texttt{half}, \texttt{word},
\texttt{ascii} (non-zero terminated string) and \texttt{asciiz} (zero terminated string)
that place data in the memory array \texttt{M} (specified in nML using the \texttt{mem} keyword).
The size of an addressable memory location is 1 byte.

\subsection{Definitions}

Data are defined using the \texttt{data} construct. Data definitions can be added to the test
program source code file or placed into a separate source code file. There are two types of
data definitions:

\begin{itemize}
\item \textbf{\textit{Global}} - defined in the beginning of a test template and can be used by
      all test cases generated by the test template. Global data definitions can be placed in
      the root of the \texttt{pre} or \texttt{run} methods or methods called from these methods.
      Memory allocation is performed during inital processing of a test template (see
      \hyperref[ttp_stage_1]{stage 1} of template processing).

\item \textbf{\textit{Test case level}} - defined and used by specific test cases. Such definitions
      can be applied multiple times (e.g. when defined in preparators).
      Memory allocation is performed when a test case is generated (see
      \hyperref[ttp_stage_2]{stage 2} of template processing).
\end{itemize}

The \texttt{data} construct has two optional parameters:

\begin{itemize}
\item \texttt{global} - a boolean value that states that the data definition should be
      treated as global regardless of where it is defined.
\item \texttt{separate{\_}file} - a boolean value that states that the generated data
      definitions should be placed into a separate source code file.
\end{itemize}

Here is the list of methods that can be used in \texttt{data} sections:

\begin{itemize}
\item \texttt{align}
\item \texttt{org}
\item \texttt{space}
\end{itemize}

Here is an example:

\begin{lstlisting}[language=ruby]
data {
  org 0x00001000

  label :data1
  byte 1, 2, 3, 4

  label :data2
  half 0xDEAD, 0xBEEF

  label :data3
  word 0xDEADBEEF

  label :hello
  ascii  'Hello'

  label :world
  asciiz 'World'

  space 6
}
\end{lstlisting}

In this example, data is placed into memory. Data items are aligned by their size
(1 byte, 2 bytes, 4 bytes). Strings are allocated at the byte border (addressable
unit). For simplicity, in the current version of MicroTESK, memory is allocated
starting from the address 0 (in the memory array of the executable model).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Preparators}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Test Engine Branch}

\section{Parameters}

\begin{itemize}
\item \emph{branch{\_}exec{\_}limit} is an upper bound for the number of executions of a single branch instruction;
\item \emph{trace{\_}count{\_}limit} is an upper bound for the number of execution traces to be returned.
\end{itemize}

More information on the parameters is given in the “Execution Traces Enumeration” section.

\section{Description}

Functioning of the \emph{branch} test engine includes the following steps:

\begin{enumerate}
  \item construction of a \emph{branch structure} of an abstract test sequence;
  \item enumeration of \emph{execution traces} of the branch structure;
  \item concretization of the test sequence for each execution trace:
  \begin{enumerate}
    \item construction of a \emph{control} code;
    \item construction of an \emph{initialization} code.
  \end{enumerate}
\end{enumerate}

Let \emph{D} be the size of the delay slot for an architecture under scrutiny (e.g., \emph{D}=1
for MIPS, and \emph{D}=0 for ARM).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Appendixes}

\section{References}

% Related nML publications/documents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\addcontentsline{toc}{section}{\numberline{}Bibliography}
\begin{thebibliography}{1}

\bibitem{freericks}
M.~Freericks.
\emph{The nML Machine Description Formalism}.
Technical Report TR SM-IMP/DIST/08, TU Berlin CS Department, 1993.

\end{thebibliography}

\end{document}
