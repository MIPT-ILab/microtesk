%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[oneside,final,14pt]{extreport}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english]{babel}
\usepackage{vmargin}
\setpapersize{A4}
\usepackage{indentfirst}
\usepackage{graphicx}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Page Headers

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\lhead{MicroTESK User Guide [Draft]}
\rfoot{\thepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Listing Style

\usepackage{listings}
\usepackage[dvipsnames]{xcolor}

\lstset{
 language=C,
 frame=single,
 basicstyle=\ttfamily\scriptsize,
 commentstyle=\itshape,
 emph={op, mode, reg, alias, mem, type, let, card, int, syntax, image, format, action,
       if, then, else, elif, endif, coerce, exception, address, segment, buffer, register,
       memory, mmu, range, ways, sets, match, tag, index, entry, policy, read, write,
       var, hit, path, transition, guard},
 emphstyle={\bfseries}}

\usepackage{listings}
\lstloadlanguages{Ruby}
\lstset{
basicstyle=\ttfamily\footnotesize\color{black},
commentstyle = \ttfamily\color{green},
keywordstyle=\bfseries\color{blue},
stringstyle=\color{blue},
basewidth = {.48em}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Links and References

\usepackage{hyperref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{titlepage}
\begin{center}
\Large{Institute for System Programming of the Russian Academy of Sciences}

\vfill


\bf\Large{MicroTESK User Guide}

(UNDER DEVELOPMENT)

\vfill

\bf
Moscow 2016
\end{center}
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\stepcounter{page} % Increase page counter by one
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Installation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{System Requirements}

MicroTESK is a set of Java-based utilities that are run from the command line.
It can be used on \textbf{\textit{Windows}}, \textbf{\textit{Linux}} and
\textbf{\textit{OS X}} machines that have \textbf{\textit{JDK 1.7 or later}}
installed. To build MicroTESK from source code or to build the generated
Java models, \textbf{\textit{Apache Ant version 1.8 or later}} is required.
To generate test data based on constraints, MicroTESK needs
the \textbf{\textit{Microsoft Research Z3}} or \textbf{\textit{CVC4}} solver that
can work on the corresponding operating system.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Installation Steps}

To install MicroTESK, the following steps should be performed:

\begin{enumerate}
  \item Download from \url{http://forge.ispras.ru/projects/microtesk/files} and unpack
        the MicroTESK installation package (the .tar.gz file, latest release) to your
        computer. The folder to which it was unpacked will be further referred to as
        the installation directory (<installation dir>).

  \item Declare the \textbf{MICROTESK{\_}HOME} environment variable and set its value to the path to
        the installation directory (see the Setting Environment Variables section).

  \item Set the <installation dir>/bin folder as the working directory (add the path to
        the PATH environment variable) to be able to run MicroTESK utilities from any path.

  \item Note: Required for constraint-based generation. Download and install constraint
        solver tools to the <installation dir>/tools directory (see the Installing
        Constraint Solvers section).
\end{enumerate}

% Now you can run the @compile.sh@ (or @.bat@) script to create a microprocessor
% model and the @generate.sh@ (or @.bat@) script to generate test for this model.

\subsection{Setting Environment Variables}

\paragraph{Windows}

\begin{enumerate}
  \item Open the "System Properties" window.
  \item Switch to the "Advanced" tab.
  \item Click on Environment Variables.
  \item Click "New.." under "System Variables".
  \item In the "New System Variable" dialog specify variable name as
        MICROTESK{\_}HOME and variable value as <installation dir>.
  \item Click "OK" on all open windows.
  \item Reopen the command prompt window.
\end{enumerate}

\paragraph{Linux and OS X}

Add the command below to the ~.bash{\_}profile file (Linux) or the ~/.profile
file (OS X):

\begin{lstlisting}[language=bash]
export MICROTESK_HOME=<installation dir>
\end{lstlisting}

To start editing the file, type vi ~/.bash{\_}profile (or vi ~/.profile). Changes
will be applied after restarting the command-line terminal or reboot. You can also
execute the command in your command-line terminal to make temporary changes.

\subsection{Installing Constraint Solvers}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Installation Directory Structure}

The MicroTESK installation directory contains the following subdirectories:

\begin{tabular}{ | l | p{12.5cm} |}
  \hline
  \textbf{arch} & Microprocessor specifications and test templates \\ \hline
  \textbf{bin}  & Scripts to run modeling and test generation tasks \\ \hline
  \textbf{doc}  & Documentation \\ \hline
  \textbf{etc}  & Configuration files \\ \hline
  \textbf{gen}  & Generated code of microprocessor models \\ \hline
  \textbf{lib}  & JAR files and Ruby scripts to perform modeling and test generation 
                  tasks \\ \hline
  \textbf{src}  & Source code of MicroTESK \\ \hline
\end{tabular}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Running}

To generate a Java model of a microprocessor from its nML specification, a user
needs to run the compile.sh script (Unix, Linux, OS X) or the compile.bat script
(Windows). For example, the following command generates a model for the miniMIPS
specification:

\begin{lstlisting}[language=bash]
sh bin/compile.sh arch/minimips/model/minimips.nml
\end{lstlisting}

NOTE: Models for all demo specifications are already built and included in the
MicroTESK distribution package. So a user can start working with MicroTESK from
generating test programs for these models.

To generate a test program, a user needs to use the generate.sh script
(Unix, Linux, OS X) or the generate.bat script (Windows). The scripts
require the following parameters:

\begin{enumerate}
  \item model name
  \item test template file
  \item target test program source code file
\end{enumerate}

For example, the command below runs the euclid.rb test template for
the miniMIPS model generated by the command from the previous example and saves
the generated test program to an assembler file. The file name is based on values
of the --code-file-prefix and --code-file-extension options.

\begin{lstlisting}[language=bash]
sh bin/generate.sh minimips arch/minimips/templates/euclid.rb
\end{lstlisting}

To specify whether Z3 or CVC4 should be used to solve constraints,
a user needs to specify the -s or --solver command-line option as z3
or cvc4 respectively. By default, Z3 will be used. Here is an example:

\begin{lstlisting}[language=bash]
sh bin/generate.sh -s cvc4 minimips arch/minimips/templates/constraint.rb
\end{lstlisting}

More information on command-line options can be found on the Command-Line Options
section.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Command-Line Options}

MicroTESK works in two modes: specification translation and test generation,
which are enabled with the --translate (used by default) and --generate keys
correspondingly. In addition, the --help key prints information on the command-line format.

The --translate and --generate keys are inserted into the command-line by
compile.sh/compile.bat and generate.sh/generate.bat scripts correspondingly.
Other options should be specified explicitly to customize the behavior of MicroTESK.
Here is the list of options:

\begin{tabular}{ | p{4cm} | p{1cm} | p{5cm} | p{3cm} |}
  \hline
  Full name & Short name & Description & Requires \\ \hline
  --help & -h & Shows help message & \\ \hline
  --verbose & -v & Enables printing diagnostic messages & \\ \hline
  --translate & -t & Translates formal specifications & \\ \hline
  --generate & -g & Generates test programs & \\ \hline
  --output-dir <arg> & -od & Sets where to place generated files & \\ \hline
  --include <arg> & -i & Sets include files directories & --translate \\ \hline
  --extension-dir <arg> & -ed & Sets directory that stores user-defined Java code & --translate \\ \hline
  --random-seed <arg> & -rs & Sets seed for randomizer & --generate \\ \hline
  --solver <arg> & -s & Sets constraint solver engine to be used & --generate \\ \hline
  --branch-exec-limit <arg> & -bel & Sets the limit on control transfers to detect endless loops & --generate \\ \hline
  --solver-debug & -sd & Enables debug mode for SMT solvers & --generate \\ \hline
  --tarmac-log  & -tl & Saves simulator log in Tarmac format & --generate \\ \hline
  --self-checks & -sc & Inserts self-checking code into test programs & --generate \\ \hline
  --arch-dirs <arg> & -ad & Home directories for tested architectures & --generate \\ \hline
  --rate-limit <arg> & -rl & Generation rate limit, causes error when broken & --generate \\ \hline
  --code-file-extension <arg> & -cfe & The output file extension & --generate \\ \hline
  --code-file-prefix <arg> & -cfp & The output file prefix (file names are as follows prefix{\_}xxxx.ext, where xxxx is a 4-digit decimal number) & --generate \\ \hline
  --data-file-extension <arg> & -dfe & The data file extension & --generate \\ \hline
  --data-file-prefix <arg> & -dfp & The data file prefix & --generate \\ \hline
  --exception-file-prefix <arg> & -efp & The exception handler file prefix & --generate \\ \hline
  --program-length-limit <arg> & -pll & The maximum number of instructions in output programs & --generate \\ \hline
  --trace-length-limit <arg> make& -tll & The maximum length of execution traces of output programs & --generate \\ \hline
  --comments-enabled & -ce & Enables printing comments; if not specified no comments are printed & --generate \\ \hline
  --comments-debug & -cd & Enables printing detailed comments; must be used together with --comments-enabled  & --generate \\ \hline
\end{tabular}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Test Templates}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

MicroTESK generates test programs on the basis of \emph{test templates} that describe
test programs to be generated in an abstract way. Test templates are created using
special Ruby-based test template description language. The language is implemented as
a library that includes provides facilities for describing test cases.

MicroTESK uses the JRuby interpreter to process test templates. This allows Ruby libraries
to interact with other components of MicroTESK written in Java.

Test templates are processed in two stages:
\begin{itemize}
\item Ruby code is executed to build the internal representation (a hierarchy of Java objects)
      of the test template.
\item The internal representation is processed with various engines to generate test cases which
      are then simulated on the reference model and printed to files.
\end{itemize}

This chapter describes facilities of the test template description language and supported test
generation engines.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hyphenation{Template}

\section{Test Template Structure}

A test template is implemented as a class inherited from the \texttt{Template} library class
that provides access to all features of the library. Information on the location of
the \texttt{Template} class is stored in the \texttt{TEMPLATE} environment variable.
Thus, the definition of a test template class looks like this:

\begin{lstlisting}[language=ruby]
require ENV['TEMPLATE']

class MyTemplate < Template
\end{lstlisting}

Test template classes should contain implementations of the following methods:

\begin{enumerate}
  \item \textbf{initialize} (optional) - specifies settings for the given test template;
  \item \textbf{pre} (optional) - specifies the initialization code for test programs;
  \item \textbf{post} (optional) - specifies the finalization code for test programs;
  \item \textbf{run} - specifies the main code of test programs (test cases).
\end{enumerate}

The definitions of optional methods can be skipped. In this case, the default
implementations provided by the parent class will be used. The default implementation
of the \texttt{initialize} method initializes the settings with default values. The default
implementations of the \texttt{pre} and \texttt{post} methods do nothing.

The full interface of a test template looks as follows:

\begin{lstlisting}[language=ruby]
require ENV['TEMPLATE']

class MyTemplate < Template

  def initialize
    super
    # Initialize settings here 
  end

  def pre
    # Place your initialization code here
  end

  def post
    # Place your finalization code here
  end

  def run
    # Place your test problem description here
  end

end
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Reusing Test Templates}

It is possible to reuse code of existing test templates in other test templates.
To do this, you need to subclass the template you want to reuse instead of the
\texttt{Template} class. For example, the \texttt{MyTemplate} class below reuses code from
the \texttt{MyPrepost} class that provides initialization and finalization code for similar
test templates.

\begin{lstlisting}[language=ruby]
require ENV['TEMPLATE']
require_relative 'MyPrepost'

class MyTemplate < MyPrepost

  def run
    ... 
  end

end
\end{lstlisting}

Another way to reuse code is creating code libraries with methods that can be called
by test templates. A code library is defined as a Ruby module file and has the following
structure:

\begin{lstlisting}[language=ruby]
module MyLibrary

  def method1
    ...
  end

  def method2(arg1, arg2)
    ...
  end

  def method3(arg1, arg2, arg3)
    ...
  end

end
\end{lstlisting}

To be able to use utility methods \texttt{method1}, \texttt{method2} and \texttt{method3}
in a test template, the \texttt{MyLibrary} module must be included in that test template as a mixin.
Once this is done, all methods of the library are available in the test template.
Here is an example:

\begin{lstlisting}[language=ruby]
require ENV['TEMPLATE']
require_relative 'my_library'

class MyTemplate < Template
  include MyLibrary

  def run
    method1
    method2 arg1, arg2
    method3 arg1, arg2, arg3
  end

end
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Test Template Settings}

Test templates use the following settings:

\begin{enumerate}
  \item Starting characters for single-line comments;
  \item Starting characters for multi-line comments;
  \item Terminating characters for multi-line comments;
  \item Indentation token;
  \item Token used in separator lines.
\end{enumerate}

Here is how these settings are initialized with default values in
the \texttt{Template} class:

\begin{lstlisting}[language=ruby]
@sl_comment_starts_with = "//"
@ml_comment_starts_with = "/*"
@ml_comment_ends_with   = "*/"

@indent_token    = "\t"
@separator_token = "="
\end{lstlisting}

The settings can be overridden in the \texttt{initialize} method of a test template.
For example:

\begin{lstlisting}[language=ruby]
class MyTemplate < Template

  def initialize
    super

    @sl_comment_starts_with = ";" 
    @ml_comment_starts_with = "/="
    @ml_comment_ends_with = "=/"

    @indent_token = "  "
    @separator_token = "*" 
  end
  ...
end
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Data Definitions}

Describing data requires the use of assembler-specific directives. Information on
these directives is not included in ISA specifications and should be provided in test
templates. It includes textual format of data directives and mappings between nML and
assembler data types used by these directives. Configuration information on data
directives is specified in the \texttt{data{\_}config} block, which is usually placed
in the \texttt{pre} method. Only one such block per a template is allowed.
Here is an example:

\begin{lstlisting}[language=ruby]
data_config(:text => '.data', :target => 'M') {
  define_type :id => :byte, :text => '.byte', :type => type('card', 8)
  define_type :id => :half, :text => '.half', :type => type('card', 16)
  define_type :id => :word, :text => '.word', :type => type('card', 32)

  define_space :id => :space, :text => '.space', :fillWith => 0
  define_ascii_string :id => :ascii, :text => '.ascii', :zeroTerm => false
  define_ascii_string :id => :asciiz, :text => '.asciiz', :zeroTerm => true
}
\end{lstlisting}

The block takes the following parameters:

\begin{itemize}
  \item \texttt{text} (compulsory) - specifies the keyword that marks the beginning of
        the data section in the generated test program;

  \item \texttt{target} (compulsory) - specifies the memory array defined in the nML
        specification to which data will be placed during simulation;

  \item \texttt{base{\_}virtual{\_}address} (optional) - specifies the base virtual
        address where data allocation starts. Default value is 0;

  \item \texttt{item{\_}size} (optional) - specifies the size of a memory location unit
        pointed by address. Default value is 8 bits (or 1 byte).
\end{itemize}

To set up particular directives, the language provides special methods that must
be called inside the block. All the methods share two common parameters:
\texttt{id} and \texttt{text}. The first specifies the keyword to be used in a
test template to address the directive and the second specifies how it will be
printed in the test program. The current version of MicroTESK provides the following methods:

\begin{enumerate}
  \item \texttt{define{\_}type} - defines a directive to allocate memory for a data element
        of an nML data type specified by the type parameter;

  \item \texttt{define{\_}space} - defines a directive to allocate memory (one or more
        addressable locations) filled with a default value specified by the
        fillWith parameter;

  \item \texttt{define{\_}ascii{\_}string} - defines a directive to allocate memory for an
        ASCII string terminated or not terminated with zero depending on the
        \texttt{zeroTerm} parameter.
\end{enumerate}

The above example defines the directives \texttt{byte}, \texttt{half}, \texttt{word},
\texttt{ascii} (non-zero terminated string) and \texttt{asciiz} (zero terminated string)
that place data in the memory array \texttt{M} (specified in nML using the \texttt{mem} keyword).
The size of an addressable memory location is 1 byte.

After all data directives are configured, data can be defined using the \texttt{data} block,
which has two optional parameters:

\begin{itemize}
\item \texttt{global} - a boolean value that states that the data definition should be
      treated as global.
\item \texttt{separate{\_}file} - a boolean value that states that the generated data
      definitions should be placed in a separate source code file.
\end{itemize}

\begin{lstlisting}[language=ruby]
data {
  label :data1
  byte 1, 2, 3, 4

  label :data2
  half 0xDEAD, 0xBEEF

  label :data3
  word 0xDEADBEEF

  label :hello
  ascii  'Hello'

  label :world
  asciiz 'World'

  space 6
}
\end{lstlisting}

In this example, data is placed into memory. Data items are aligned by their size
(1 byte, 2 bytes, 4 bytes). Strings are allocated at the byte border (addressable
unit). For simplicity, in the current version of MicroTESK, memory is allocated
starting from the address 0 (in the memory array of the executable model).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Appendixes}

\section{References}

% Related nML publications/documents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\addcontentsline{toc}{section}{\numberline{}Bibliography}
\begin{thebibliography}{1}

\bibitem{freericks}
M.~Freericks.
\emph{The nML Machine Description Formalism}.
Technical Report TR SM-IMP/DIST/08, TU Berlin CS Department, 1993.

\end{thebibliography}

\end{document}
