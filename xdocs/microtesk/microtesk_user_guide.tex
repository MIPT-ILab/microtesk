\documentclass[oneside,final,14pt]{extreport}

\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english]{babel}
\usepackage{vmargin}
\usepackage{listings}
\setpapersize{A4}
\usepackage{indentfirst}
\usepackage{graphicx}

\lstset{
 language=C,
 frame=single,
 basicstyle=\ttfamily\scriptsize,
 commentstyle=\itshape,
 emph={op, mode, reg, alias, mem, type, let, card, int, syntax, image, format, action,
       if, then, else, elif, endif, coerce, exception, address, segment, buffer, register,
       memory, mmu, range, ways, sets, match, tag, index, entry, policy, read, write,
       var, hit, path, transition, guard},
 emphstyle={\bfseries}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{titlepage}
\begin{center}
\Large{Institute for System Programming of the Russian Academy of Sciences}

\vfill


\bf\Large{MicroTESK User Guide}

(UNDER DEVELOPMENT)

\vfill

\bf
Moscow 2016
\end{center}
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\stepcounter{page} % Increase page counter by one
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Installation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{System Requirements}

MicroTESK is a set of Java-based utilities that are run from the command line.
It can be used on \textbf{\textit{Windows}}, \textbf{\textit{Linux}} and
\textbf{\textit{OS X}} machines that have \textbf{\textit{JDK 1.7 or later}}
installed. To build MicroTESK from source code or to build the generated
Java models, \textbf{\textit{Apache Ant version 1.8 or later}} is required.
To generate test data based on constraints, MicroTESK needs
the \textbf{\textit{Microsoft Research Z3}} or \textbf{\textit{CVC4}} solver that
can work under the corresponding operating system.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Running MicroTESK}

To generate a Java model of a microprocessor from its nML specification, a user
needs to run the compile.sh script (Unix, Linux, OS X) or the compile.bat script
(Windows). For example, the following command generates a model for the miniMIPS
specification:

\begin{lstlisting}[language=bash]
sh bin/compile.sh arch/minimips/model/minimips.nml
\end{lstlisting}

NOTE: Models for all demo specifications are already built and included in the
MicroTESK distribution package. So a user can start working with MicroTESK from
generating test programs for these models.

To generate a test program, a user needs to use the generate.sh script
(Unix, Linux, OS X) or the generate.bat script (Windows). The scripts
require the following parameters:

\begin{enumerate}
  \item model name
  \item test template file
  \item target test program source code file
\end{enumerate}

For example, the command below runs the euclid.rb test template for
the miniMIPS model generated by the command from the previous example and saves
the generated test program to an assembler file. The file name is based on values
of the --code-file-prefix and --code-file-extension options.

\begin{lstlisting}[language=bash]
sh bin/generate.sh minimips arch/minimips/templates/euclid.rb
\end{lstlisting}

To specify whether Z3 or CVC4 should be used to solve constraints,
a user needs to specify the -s or --solver command-line option as z3
or cvc4 respectively. By default, Z3 will be used. Here is an example:

\begin{lstlisting}[language=bash]
sh bin/generate.sh -s cvc4 minimips arch/minimips/templates/constraint.rb
\end{lstlisting}

More information on command-line options can be found on the Command-Line Options
section.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Command-Line Options}

MicroTESK works in two modes: specification translation and test generation,
which are enabled with the --translate (used by default) and --generate keys
correspondingly. In addition, the --help key prints information on the command-line format.

The --translate and --generate keys are inserted into the command-line by
compile.sh/compile.bat and generate.sh/generate.bat scripts correspondingly.
Other options should be specified explicitly to customize the behavior of MicroTESK.
Here is the list of options:

\begin{tabular}{ | p{4cm} | p{1cm} | p{5cm} | p{3cm} |}
  \hline
  Full name & Short name & Description & Requires \\ \hline
  --help & -h & Shows help message & \\ \hline
  --verbose & -v & Enables printing diagnostic messages & \\ \hline
  --translate & -t & Translates formal specifications & \\ \hline
  --generate & -g & Generates test programs & \\ \hline
  --output-dir <arg> & -od & Sets where to place generated files & \\ \hline
  --include <arg> & -i & Sets include files directories & --translate \\ \hline
  --extension-dir <arg> & -ed & Sets directory that stores user-defined Java code & --translate \\ \hline
  --random-seed <arg> & -rs & Sets seed for randomizer & --generate \\ \hline
  --solver <arg> & -s & Sets constraint solver engine to be used & --generate \\ \hline
  --branch-exec-limit <arg> & -bel & Sets the limit on control transfers to detect endless loops & --generate \\ \hline
  --solver-debug & -sd & Enables debug mode for SMT solvers & --generate \\ \hline
  --tarmac-log  & -tl & Saves simulator log in Tarmac format & --generate \\ \hline
  --self-checks & -sc & Inserts self-checking code into test programs & --generate \\ \hline
  --arch-dirs <arg> & -ad & Home directories for tested architectures & --generate \\ \hline
  --rate-limit <arg> & -rl & Generation rate limit, causes error when broken & --generate \\ \hline
  --code-file-extension <arg> & -cfe & The output file extension & --generate \\ \hline
  --code-file-prefix <arg> & -cfp & The output file prefix (file names are as follows prefix{\_}xxxx.ext, where xxxx is a 4-digit decimal number) & --generate \\ \hline
  --data-file-extension <arg> & -dfe & The data file extension & --generate \\ \hline
  --data-file-prefix <arg> & -dfp & The data file prefix & --generate \\ \hline
  --exception-file-prefix <arg> & -efp & The exception handler file prefix & --generate \\ \hline
  --program-length-limit <arg> & -pll & The maximum number of instructions in output programs & --generate \\ \hline
  --trace-length-limit <arg> make& -tll & The maximum length of execution traces of output programs & --generate \\ \hline
  --comments-enabled & -ce & Enables printing comments; if not specified no comments are printed & --generate \\ \hline
  --comments-debug & -cd & Enables printing detailed comments; must be used together with --comments-enabled  & --generate \\ \hline
\end{tabular}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Overview}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Test Templates}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

MicroTESK generates test programs on the basis of test templates that provide
an abstract description of scenarios to be reproduced by the generated programs.
Test templates are created using the test template description language. It is
a Ruby-based domain-specific language that provides facilities to describe test
cases using symbolic names (that refer to a set of data satisfying certain
conditions) instead of concrete input data and to manage the structure of the
generated test programs. The language is implemented as a library that includes
functionality for describing test templates and for further processing these test
templates to produce a test program. MicroTESK uses the JRuby interpreter to process
Ruby files. This allows Ruby libraries to interact with other components of MicroTESK
written in Java.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Test Template Structure}

A test template is implemented as a class inherited from the Template library class
that provides access to all features of the library. Information on the location of
the Template class is stored in the TEMPLATE environment variable. So, the definition
of a test template class looks like this:

\begin{lstlisting}[language=ruby]
require ENV['TEMPLATE']

class MyTemplate < Template
\end{lstlisting}

Test template classes should contain implementations of the following methods:

\begin{enumerate}
  \item initialize (optional) - specifies settings for the given test template;
  \item pre (optional) - specifies the initialization code for the test program;
  \item post (optional) - specifies the finalization code for the test program;
  \item run - specifies the main code of the test program (test cases).
\end{enumerate}

The definitions of optional methods can be skipped. In this case, the default
implementations provided by the parent class will be used. The default implementation
of the initialize method initializes the settings with default values. The default
implementations of the pre and post methods do nothing.

The full interface of a test template looks as follows:

\begin{lstlisting}[language=ruby]
require ENV['TEMPLATE']

class MyTemplate < Template

  def initialize
    super
    # Initialize settings here 
  end

  def pre
    # Place your initialization code here
  end

  def post
    # Place your finalization code here
  end

  def run
    # Place your test problem description here
  end

end
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Reusing Test Templates}

It is possible to reuse code of existing test templates in other test templates.
To do this, you need to subclass the template you want to reuse instead of the
Template class. For example, the MyTemplate class below reuses code from the
MyPrepost class that provides initialization and finalization code for similar
test templates.

\begin{lstlisting}[language=ruby]
require ENV['TEMPLATE']
require_relative 'MyPrepost'

class MyTemplate < MyPrepost

  def run
  ... 
  end

end
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Test Template Settings}

Test templates use the following settings:

\begin{enumerate}
  \item Starting characters for single-line comments in the test program;
  \item Starting characters for multi-line comments in the test program;
  \item Terminating characters for multi-line comments in the test program;
  \item Indentation token;
  \item Token used in separator lines.
\end{enumerate}

Here is how these settings are initialized with default values in the Template class:

\begin{lstlisting}[language=ruby]
@sl_comment_starts_with = "//"
@ml_comment_starts_with = "/*"
@ml_comment_ends_with   = "*/"

@indent_token    = "\t"
@separator_token = "="
\end{lstlisting}

The settings can be overridden in the initialize method of a test template. For example:

\begin{lstlisting}[language=ruby]
class MyTemplate < Template

  def initialize
    super
    @sl_comment_starts_with = ";" 
    @ml_comment_starts_with = "/="
    @ml_comment_ends_with   = "=/"

    @indent_token    = "  "
    @separator_token = "*" 
  end
  ...
end
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Appendixes}

\section{References}

% Related nML publications/documents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\addcontentsline{toc}{section}{\numberline{}Bibliography}
\begin{thebibliography}{1}

\bibitem{freericks}
M.~Freericks.
\emph{The nML Machine Description Formalism}.
Technical Report TR SM-IMP/DIST/08, TU Berlin CS Department, 1993.

\end{thebibliography}

\end{document}
