let proc	= "sparc"	// sparc V8 embedded, leon3-FT
let bit_order	= "uppermost"
let gliss_isize = "32"




type reg_idx	= card(5)
type wim_size	= card(5)
type opcode	= card(6)
type _asi_or_simm= int(13)
type asi	= card(8)
type address	= int(32)
type condition	= card(4)
type opcode_fp	= card(9)

type f32	= float(23, 9)
type f64	= float(52, 12)
type f128	= float(112, 16)

type u1		= card(1)
type u2		= card(2)
type u3		= card(3)
type u4		= card(4)
type u5		= card(5)
type u8		= card(8)
type s8		= int(8)
type u16	= card(16)
type s16	= int(16)
type u32	= card(32)
type s32	= int(32)
type u64	= card(64)
type s64	= int(64)

let NWINDOWS		= 8
let NUM_GLOB_REG	= 8
let MEM_ADDR_SIZE	= 32

mem M	[ MEM_ADDR_SIZE, u8 ]
mem M16 [ MEM_ADDR_SIZE >> 1, u16 ] alias = M[0]
mem M32 [ MEM_ADDR_SIZE >> 2, u32 ] alias = M[0]
mem M64 [ MEM_ADDR_SIZE >> 3, u64 ] alias = M[0]

// global registers (from 0 to 7)
// windowed registers (from 8 upto the end)
// in 1 bank
reg R	[ NUM_GLOB_REG + (NWINDOWS << 4), u32 ]
reg F	[ 32, f32 ]
reg PC	[ 1, u32 ]	pc = 1
reg nPC	[ 1, u32 ]	npc = 1
reg Y	[ 1, u32 ]
reg WIM	[ 1, u32 ]

// Processor state register
reg PSR [ 1, u32 ]
// aliases for subparts
reg CWP [ 1, u5 ]	alias = PSR<4..0>
reg PSR_ET [ 1, u1 ]	alias = PSR[5]
reg PSR_PS [ 1, u1 ]	alias = PSR[6]
reg PSR_S [ 1, u1 ]	alias = PSR[7]
reg PSR_PIL [ 1, u4 ]	alias = PSR<8..11>
reg PSR_EF [ 1, u1 ]	alias = PSR[12]
reg PSR_EC [ 1, u1 ]	alias = PSR[13]
reg ICC [ 1, u4 ]	alias = PSR<23..20>
reg ICC_C [ 1, u1 ]	alias = ICC[0]
reg ICC_V [ 1, u1 ]	alias = ICC[1]
reg ICC_Z [ 1, u1 ]	alias = ICC[2]
reg ICC_N [ 1, u1 ]	alias = ICC[3]
reg PSR_ver [ 1, u4 ]	alias = PSR<27..24>
reg PSR_impl [ 1, u4 ]	alias = PSR<31..28>

// Floating-point state register
reg FSR [ 1, u32 ]
// aliases for subparts
reg FSR_RD [ 1, u2 ]	alias = FSR<31..30>
reg FSR_TEM [ 1, u5 ]	alias = FSR<27..23>
reg FSR_NS [ 1, u1 ]	alias = FSR[22]
reg FSR_VER [ 1, u3 ]	alias = FSR<19..17>
reg FSR_FTT [ 1, u3 ]	alias = FSR<16..14>
reg FSR_QNE [ 1, u1 ]	alias = FSR[13]

reg FSR_FCC [ 1, u2 ]	alias = FSR<11..10>
// fcc value macros
macro FCC_E = (FSR_FCC == 0) \
macro FCC_L = (FSR_FCC == 1) \
macro FCC_G = (FSR_FCC == 2) \
macro FCC_U = (FSR_FCC == 3) \
macro test(x) = if (x) then 1 else 0 endif \

reg FSR_AEXC [ 1, u5 ]	alias = FSR<9..5>
reg FSR_CEXC [ 1, u5 ]	alias = FSR<4..0>
// fields of tem, aexc and cexc
let f_nx = 0
let f_dz = 1
let f_uf = 2
let f_of = 3
let f_nv = 4

// Ancillary state registers (%asr1 ... %asr31)
reg ASR	[32, u32]


// Flags to indicate certain conditions encountered during excution
// set to 1 if the current instr is an annulling branch
reg ANNUL_BIT		[ 1, u1 ]
reg BRANCH_EXECUTED	[ 1, u1 ]


// Trap base register
reg TBR	[ 1, u32]
// Flag to indicate if a trap is pending
reg TRAP	[ 1, u1 ]
// Type of trap
reg TT		[ 1, u8 ]	alias = TBR<11..4>
reg TMP_TT	[ 1, u8 ]

macro EXECUTE_TRAP = \
	// only the last IT is in TMP_TT \
	// !!TODO!! improve to take into account the priorities between multiple ITs if disabled a long time \
	TT = TMP_TT; \
	TRAP = 0; \
	if PSR_ET == 0 then \
		"gliss_error"("ERROR: trying to execute a trap but traps are not enabled."); \
	else \
		PSR_ET = 0; \
		PSR_PS = PSR_S; \
		CWP = (CWP - 1) % NWINDOWS; \
		\
		if ANNUL_BIT == 0 then \
			SET_WIN_REG(17, PC); \
			SET_WIN_REG(18, nPC); \
		else \
			SET_WIN_REG(17, nPC); \
			SET_WIN_REG(18, nPC + 4); \
			ANNUL_BIT = 0; \
		endif; \
		\
		PSR_S = 1; \
		PC = TBR; \
		nPC = TBR + 4; \
	endif; \

// trap types (with constant tt values)
let DATA_STORE_ERROR			= 0b0010011
let INSTRUCTION_ACCESS_ERROR		= 0b0100001
let R_REGISTER_ACCESS_ERROR		= 0b0010000
let INSTRUCTION_ACCESS_EXCEPTION	= 1
let PRIVILEGED_INSTRUCTION		= 3
let ILLEGAL_INSTRUCTION			= 2
let FP_DISABLED				= 4
let CP_DISABLED				= 0b00100100
let UNIMPLEMENTED_FLUSH			= 0b00100101
let WINDOW_OVERFLOW			= 5
let WINDOW_UNDERFLOW			= 6
let MEM_ADDRESS_NOT_ALIGNED		= 7
let FP_EXCEPTION			= 8
let CP_EXCEPTION			= 0b00101000
let DATA_ACCESS_ERROR			= 0b00101001
let DATA_ACCESS_EXCEPTION		= 9
let TAG_OVERFLOW			= 10
let DIVISION_BY_ZERO			= 0b00101010
// trap instruction and interrupts have a non constant tt



// ASIs

// AT697F ASIs
let ASI_FORCED_CACHE_MISS_REPL0   = 0
let ASI_FORCED_CACHE_MISS_REPL1   = 1
let ASI_FORCED_CACHE_MISS_REPL2   = 2
let ASI_FORCED_CACHE_MISS_REPL3   = 3
let ASI_FORCED_CACHE_MISS_UPDATE0 = 4
let ASI_FORCED_CACHE_MISS_UPDATE1 = 7
let ASI_FLUSH_I_CACHE		  = 5
let ASI_FLUSH_D_CACHE		  = 6
let ASI_I_CACHE_TAGS		  = 0xC
let ASI_I_CACHE_DATA		  = 0xD
let ASI_D_CACHE_TAGS		  = 0xE
let ASI_D_CACHE_DATA		  = 0xF

// Sparc standard
let ASI_USER_INSTR		  = 8
let ASI_SUPRV_INSTR		  = 9
let ASI_USER_DATA		  = 0xA
let ASI_SUPRV_DATA		  = 0xB


// windowed registers access macros

macro GET_WIN_REG(idx) = \
	if (idx) < 8 then \
		if (idx) == 0 then \
			0 \
		else \
			R[idx] \
		endif \
	else \
		R[((coerce(u32, CWP) << 4) + (idx) - 8) % (NWINDOWS << 4) + 8] \
	endif \

macro SET_WIN_REG(idx, val) = \
	if (idx) < 8 then \
		if (idx) != 0 then \
			R[idx] = (val); \
		endif; \
	else \
		R[((coerce(u32, CWP) << 4) + (idx) - 8) % (NWINDOWS << 4) + 8] = (val); \
	endif \

macro WIN_REG_SYNTAX(idx) = \
	if (idx) < 8 then \
		format("%%g%d", (idx)) \
	else \
		if (idx) < 16 then \
			if (idx) == 14 then \
				"%%sp" \
			else \
				format("%%o%d", (idx) - 8) \
			endif \
		else \
			if (idx) < 24 then \
				format("%%l%d", (idx) - 16) \
			else \
				if (idx) == 30 then \
					"%%fp" \
				else \
					format("%%i%d", (idx) - 24) \
				endif \
			endif \
		endif \
	endif \


// memory access with asi
// !!TODO!! to change to take asi's into account

macro MEM_ASI8(addr, asi) = \
	M[addr] \

macro MEM_ASI16(addr, asi) = \
	M16[addr] \

macro MEM_ASI32(addr, asi) = \
	M32[addr] \

macro MEM_ASI64(addr, asi) = \
	M64[addr] \


// condition code update macros

macro ICC_clean = \
	ICC = 0; \

macro N_update(res) = \
	ICC_N = (res)<31..31> \

macro Z_update(res) = \
	ICC_Z = if (res) == 0 then 1 else 0 endif \

macro V_update(op1, op2, res) =\
	ICC_V = (((op1<31..31>) & (op2<31..31>) & ~(res<31..31>)) | (~(op1<31..31>) & ~(op2<31..31>) & (res<31..31>))) \

macro C_update(op1, op2, res) = \
	ICC_C = (((op1<31..31>) & (op2<31..31>)) | (~(res<31..31>) & ((op1<31..31>) | (op2<31..31>)))) \

macro logical_update_icc(res) = \
	N_update(res); \
	Z_update(res); \
	ICC_V = 0; \
	ICC_C = 0; \

macro add_integer_update_icc(op1, op2, res) = \
	N_update(res); \
	Z_update(res); \
	V_update(op1, op2, res); \
	C_update(op1, op2, res); \

macro tagged_get_V(op1, op2, res) = \
	(((op1<31..31>) & (op2<31..31>) & ~(res<31..31>)) | (~(op1<31..31>) & ~(op2<31..31>) & (res<31..31>))) \
	| if (op1<1..0>) != 0 || (op2<1..0>) != 0 then 1 else 0 endif \

macro add_tagged_update_icc(op1, op2, res) = \
	N_update(res); \
	Z_update(res); \
	V_update(op1, op2, res); \
	C_update(op1, op2, res); \
	ICC_V = ICC_V | if (op1<1..0>) != 0 || (op2<1..0>) != 0 then 1 else 0 endif; \

macro sub_integer_update_icc(op1, op2, res) = \
	N_update(res); \
	Z_update(res); \
	V_update(op1, ~op2, res); \
	C_update(~op1, op2, ~res); \

macro sub_tagged_update_icc(op1, op2, res) = \
	N_update(res); \
	Z_update(res); \
	V_update(op1, ~op2, res); \
	C_update(~op1, op2, ~res); \
	ICC_V = ICC_V | if (op1<1..0>) != 0 || (op2<1..0>) != 0 then 1 else 0 endif; \

macro multiply_step_update_icc(op1, op2, res) = \
	N_update(res); \
	Z_update(res); \
	V_update(op1, op2, res); \
	C_update(op1, op2, res); \

macro multiply_integer_update_icc(res) = \
	N_update(res); \
	Z_update(res); \
	ICC_V = 0; \
	ICC_C = 0; \

macro divide_integer_update_icc(res, sign) = \
	N_update(res); \
	Z_update(res); \
	ICC_C = 0; \
	ICC_V = \
		if (sign) then \
			// if res<63..31> == 0 or == 2^33 -1 (all bits set) \
			if (res<63..31>) == 0 || ~res<63..31> == 0 then 0 else 1 endif \
		else \
			if (res<63..32>) == 0 then 0 else 1 endif \
		endif; \



// !!WARNING!! cannot be used as a lvalue (if..then..else invalid as lvalue with this case)
mode reg_mode_0(idx : reg_idx) = GET_WIN_REG(idx)
syntax = WIN_REG_SYNTAX(idx)
image  = format("%5b", idx)
value  = idx


mode asi_or_simm(val : _asi_or_simm) = GET_WIN_REG(val<4..0>)
syntax = WIN_REG_SYNTAX(val<4..0>)
image  = format("%13b", val)
value  = val
idx    = val<4..0>
asi    = val<12..5>


mode freg_mode(idx : reg_idx) = F[idx]
syntax = format("%%f%d", idx)
image  = format("%5b", idx)
value  = idx



mode int_cond(c : condition) =
	switch (c)
	{
		case 5:		ICC_C
		case 6:		ICC_N
		case 7:		ICC_V
		case 8:		coerce(u1,1)
		case 9:		~ICC_Z
		case 0xa:	~(ICC_Z | (ICC_N ^ ICC_V))
		case 0xb:	~(ICC_N ^ ICC_V)
		case 0xc:	~(ICC_C | ICC_Z)
		case 0xd:	~(ICC_C)
		case 0xe:	~(ICC_N)
		case 0xf:	~(ICC_V)
		case 0:		coerce(u1,0)				// !!TODO!! why only "0" does not work
		case 1:		ICC_Z
		case 2:		ICC_Z | (ICC_N ^ ICC_V)
		case 3:		ICC_N ^ ICC_V
		case 4:		ICC_C | ICC_Z
	}
syntax =
	switch (c)
	{
		case 0:		"n"
		case 1:		"e"
		case 2:		"le"
		case 3:		"l"
		case 4:		"leu"
		case 5:		"cs"
		case 6:		"neg"
		case 7:		"vs"
		case 8:		"a"
		case 9:		"ne"
		case 0xa:	"g"
		case 0xb:	"ge"
		case 0xc:	"gu"
		case 0xd:	"cc"
		case 0xe:	"pos"
		case 0xf:	"vc"
	}
image = format("%4b", c)
value = c

mode float_cond(c : condition) =
	switch (c)
	{
		case 0:		0
		case 1:		test(FCC_L || FCC_G || FCC_U)
		case 2: 	test(FCC_G || FCC_L)
		case 3: 	test(FCC_U || FCC_L)
		case 4: 	test(FCC_L)
		case 5: 	test(FCC_G || FCC_U)
		case 6: 	test(FCC_G)
		case 7: 	test(FCC_U)
		case 8: 	1
		case 9: 	test(FCC_E)
		case 0xa:	test(FCC_E || FCC_U)
		case 0xb:	test(FCC_E || FCC_G)
		case 0xc:	test(FCC_E || FCC_G || FCC_U)
		case 0xd:	test(FCC_E || FCC_L)
		case 0xe:	test(FCC_L || FCC_E || FCC_U)
		case 0xf:	test(FCC_L || FCC_G || FCC_E)
	}
syntax =
	switch (c)
	{
		case 0:		"n"
		case 1:		"ne"
		case 2:		"lg"
		case 3:		"ul"
		case 4:		"l"
		case 5:		"ug"
		case 6:		"g"
		case 7:		"u"
		case 8:		"a"
		case 9:		"e"
		case 0xa:	"ue"
		case 0xb:	"ge"
		case 0xc:	"uge"
		case 0xd:	"le"
		case 0xe:	"ule"
		case 0xf:	"o"
	}
image = format("%4b", c)
value = c



var TMP_ADDR	[1, address]
var TMP_ASI	[1, asi]
var TMP_IDX	[1, reg_idx]
var TMP_CWP	[1, u5]
var TMP_MASK32	[1, u32]
var TMP_U8	[1, u8]
var TMP_S8	[1, s8]
var TMP_U16	[1, u16]
var TMP_S16	[1, s16]
var TMP_S16a	[1, s16]
var TMP_U32	[1, u32]
var TMP_U32a	[1, u32]
var TMP_U32b	[1, u32]
var TMP_S32	[1, s32]
var TMP_S32a	[1, s32]
var TMP_S32b	[1, s32]
var TMP_F32	[1, f32]
var TMP_U64	[1, u64]
var TMP_U64a	[1, u64]
var TMP_U64b	[1, u64]
var TMP_S64	[1, s64]
var TMP_S64a	[1, s64]
var TMP_S64b	[1, s64]

//test
type s13 = int(13)
var TMP_S13 [1, s13]




// initialization, LEON3 specific.
op init()
action =
	{
		// let's put to 0 all undefined bits in PSR
		PSR = 0;
		PSR_impl = 0xF;
		PSR_ver = 3;
		// no coprocesor present
		PSR_EC = 0;
		// FPU present, doc says EF is undefined but let's enable FPU by default
		PSR_EF = 1;
		// supervisor mode
		PSR_S = 1;
		PSR_PS = 1;
		// traps enabled
		PSR_ET = 1;
		// begin at window 0
		CWP = 0;

		// 2nd window invalid
		WIM = 2;
		// due to address constraints, these 4 bits must remain null
		TBR<3..0> = 0;
		// doc says PC is 0 and nPC is 4 at reset, useless from our point (pcs will be properly init at exec loading)
		PC = 0;
		nPC = 4;

		// used ASR
		// watch point address registers, only the 2 low bits must be 0, others undefined
		ASR[24] = 0;
		ASR[26] = 0;
		ASR[28] = 0;
		ASR[30] = 0;
		// watch point mask registers, 2 low bits null, others undefined
		ASR[25] = 0;
		ASR[27] = 0;
		ASR[29] = 0;
		ASR[31] = 0;
		
		// asr17 holds proc config
		ASR[17] = 0xB07;

		FSR = 0;
		FSR_VER = 1;
		FSR_CEXC = 0;
	}



op instruction (x : allinstr)
syntax = x.syntax
image = x.image
action =
	{
		if ANNUL_BIT == 0 then
			x.action;
			if BRANCH_EXECUTED == 1 then
				BRANCH_EXECUTED = 0;
				// do not increment Pcs
			else
				PC = nPC;
				nPC = nPC + 4;
			endif;
		else
			ANNUL_BIT = 0;
			PC = nPC;
			nPC = nPC + 4;
		endif;

		// is there a trap pending?
		if TRAP == 1 then
			// only set PC and nPC and change window to branch on the trap on the next inst
			// this is what we get:
			// t0, addr0: inst produces a trap => TRAP set to 1 in action, CWP, PC, nPC are then set to accomodate trap
			// t1, addr_trap, trap subprogram begins execution
			EXECUTE_TRAP;
		endif;
	}


op allinstr  =
		format1
		| format2
		| format3



op format1 = call

op call(disp30 : card(30))
syntax = format("call 0x%08x", __IADDR + (coerce(s32, disp30) << 2))
image = format("01 %30b", disp30)
action =
	{
		SET_WIN_REG(15, PC);
		PC = nPC;
		nPC = __IADDR + (coerce(s32, disp30) << 2);
		BRANCH_EXECUTED = 1;
	}



op format2(x : format2_instr)
syntax = x.syntax
image = format("00 %s", x.image)
action = { x.action; }



op format2_instr =
		format2_rd
		| format2_cond

op format2_rd =
		sethi
		// nop is a special case of sethi => just modify sethi syntax
		| unimp



op sethi(rd : reg_mode_0, imm22 : card(22))
syntax =
	if rd.value == 0 && imm22 == 0 then
		"nop"
	else
		format("sethi %d, %s", imm22, rd.syntax)
	endif
image = format("%s 100 %22b", rd.image, imm22)
action =
	{
		if rd.value != 0 then
			SET_WIN_REG(rd.value, coerce(s32, imm22) << 10);
		endif;
	}



op unimp()
syntax = "unimp"
image = "XXXXX  000  XXXXX XXXXX XXXXX XXXXX XX"
action =
	{
		TRAP = 1;
		TMP_TT = ILLEGAL_INSTRUCTION;
		"gliss_error"("unimp: illegal instruction trap\n");
	}




op format2_cond =
		bicc
		| fbfcc
//		| cbccc



op bicc(a : u1, cond : int_cond, disp22 : int(22))
syntax =
	format("b%s%s 0x%08x",
		cond.syntax,
		if a == 0 then "" else ",a" endif,
		__IADDR + (coerce(s32, disp22) << 2))
image = format("%1b %s 010 %22b", a, cond.image, disp22)
action =
	{
		PC = nPC;

		if cond then
			nPC = __IADDR + (coerce(s32, disp22) << 2);
			if cond.value == 8 && a == 1 then
				// ba annulation
				ANNUL_BIT = 1;
			endif;
		else
			nPC = nPC + 4;
			if a == 1 then
				// annulation of branch other than ba
				ANNUL_BIT = 1;
			endif;
		endif;

		BRANCH_EXECUTED = 1;
	}



op fbfcc(a : u1, cond : float_cond, disp22 : int(22))
syntax =
	format("fb%s%s 0x%08x",
		cond.syntax,
		if a == 0 then "" else ",a" endif,
		__IADDR + (coerce(s32, disp22) << 2))
image = format("%1b %s 110 %22b", a, cond.image, disp22)
action =
	{
		PC = nPC;

		if cond then
			nPC = __IADDR + (coerce(s32, disp22) << 2);
			if cond.value == 8 && a == 1 then
				// fba annulation
				ANNUL_BIT = 1;
			endif;
		else
			nPC = nPC + 4;
			if a == 1 then
				// annulation of branch other than fba
				ANNUL_BIT = 1;
			endif;
		endif;

		BRANCH_EXECUTED = 1;
	}



op format3 =
		format3_op2
		| format3_op3


op format3_op2(x : format3_op2_instr)
syntax = x.syntax
image = format("10 %s", x.image)
action = { x.action ; }


op format3_op3(x : format3_op3_instr)
syntax = x.syntax
image = format("11 %s", x.image)
action = { x.action ; }



op format3_op2_instr =
		format3_op2_asi_simm_instr
		| format3_fpop_instr

op format3_op2_asi_simm_instr =
		logical
		| shift
		| save_restore
		| jmpl
		| add_integer
		| tagged_add
		| sub_integer
		| tagged_sub
		| multiply_integer
		| divide_integer
		| read_write_state_register
		| flush
		| ticc
		| rett
		| ft_extensions

op format3_op3_instr =
		load_store_integer
		| load_store_float
		| swap_atomic_load_store



op load_store_integer =
		load_integer
		| load_integer_asi
		| store_integer
		| store_integer_asi

op load_integer =
		ldsb
		| ldub
		| ldsh
		| lduh
		| ld
		| ldd



op ldsb(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("ldsb [%s+%s], %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("ldsb [%s]+%d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 001001 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_ADDR = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		TMP_ASI = if PSR_S == 0 then ASI_USER_DATA else ASI_SUPRV_DATA endif;
		TMP_S8 = MEM_ASI8(TMP_ADDR, TMP_ASI);
		if rd.value != 0 then
			SET_WIN_REG(rd.value, coerce(int(32), TMP_S8));
		endif;
	}



op ldub(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("ldub [%s+%s], %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("ldub [%s]+%d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 000001 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_ADDR = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		TMP_ASI = if PSR_S == 0 then ASI_USER_DATA else ASI_SUPRV_DATA endif;
		TMP_U8 = MEM_ASI8(TMP_ADDR, TMP_ASI);
		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_U8);
		endif;
	}



op ldsh(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("ldsh [%s+%s], %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("ldsh [%s]+%d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 001010 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_ADDR = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		TMP_ASI = if PSR_S == 0 then ASI_USER_DATA else ASI_SUPRV_DATA endif;

		if TMP_ADDR<0..0> != 0 then
			TRAP = 1;
			TMP_TT = MEM_ADDRESS_NOT_ALIGNED;
			"gliss_error"("ldsh: misaligned address.\n");
		else
			TMP_S16 = MEM_ASI16(TMP_ADDR, TMP_ASI);
			if rd.value != 0 then
				SET_WIN_REG(rd.value, coerce(int(32), TMP_S16));
			endif;
		endif;
	}



op lduh(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("lduh [%s+%s], %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("lduh [%s]+%d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 000010 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_ADDR = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		TMP_ASI = if PSR_S == 0 then ASI_USER_DATA else ASI_SUPRV_DATA endif;

		if TMP_ADDR<0..0> != 0 then
			TRAP = 1;
			TMP_TT = MEM_ADDRESS_NOT_ALIGNED;
			"gliss_error"("lduh: misaligned address.\n");
		else
			TMP_U16 = MEM_ASI16(TMP_ADDR, TMP_ASI);
			if rd.value != 0 then
				SET_WIN_REG(rd.value, TMP_U16);
			endif;
		endif;
	}



op ld(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("ld [%s+%s], %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("ld [%s]+%d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 000000 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_ADDR = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		TMP_ASI = if PSR_S == 0 then ASI_USER_DATA else ASI_SUPRV_DATA endif;
		if TMP_ADDR<1..0> != 0 then
			TRAP = 1;
			TMP_TT = MEM_ADDRESS_NOT_ALIGNED;
			"gliss_error"("ld: misaligned address.\n");
		else
			TMP_U32 = MEM_ASI32(TMP_ADDR, TMP_ASI);
			if rd.value != 0 then
				SET_WIN_REG(rd.value, TMP_U32);
			endif;
		endif;
	}



op ldd(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("ldd [%s+%s], %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("ldd [%s]+%d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 000011 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_ADDR = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		TMP_ASI = if PSR_S == 0 then ASI_USER_DATA else ASI_SUPRV_DATA endif;
		if TMP_ADDR<2..0> != 0 then
			TRAP = 1;
			TMP_TT = MEM_ADDRESS_NOT_ALIGNED;
			"gliss_error"("ldd: misaligned address.\n");
		else
			TMP_U32 = MEM_ASI32(TMP_ADDR, TMP_ASI);
			if rd.value != 0 then
				// fill the even register with the 1st word
				SET_WIN_REG(rd.value & 0x1E, TMP_U32);
			endif;

			TMP_ADDR = TMP_ADDR + 4;

			TMP_U32 = MEM_ASI32(TMP_ADDR, TMP_ASI);
			if rd.value != 0 then
				// fill the odd register with the next word
				SET_WIN_REG(rd.value | 1, TMP_U32);
			endif;
		endif;
	}



op load_integer_asi =
		ldsba
		| lduba
		| ldsha
		| lduha
		| lda
		| ldda



op ldsba(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax = format("ldsba [%s+%s]%d, %s", rs1.syntax, rs2.syntax, rs2.asi, rd.syntax)
image = format("%s 011001 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if PSR_S == 0 then
			TRAP = 1;
			TMP_TT = PRIVILEGED_INSTRUCTION;
			"gliss_error"("ldsba: not in supervisor mode.\n");
		else if i == 1 then
			TRAP = 1;
			TMP_TT = ILLEGAL_INSTRUCTION;
			"gliss_error"("ldsba: illegal instr (i=1).\n");
		else
			TMP_ADDR = rs1 + rs2;
			TMP_ASI = rs2.asi;
			TMP_S8 = MEM_ASI8(TMP_ADDR, TMP_ASI);
			if rd.value != 0 then
				SET_WIN_REG(rd.value, coerce(int(32), TMP_S8));
			endif;
		endif;
		endif;
	}



op lduba(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax = format("lduba [%s+%s]%d, %s", rs1.syntax, rs2.syntax, rs2.asi, rd.syntax)
image = format("%s 010001 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if PSR_S == 0 then
			TRAP = 1;
			TMP_TT = PRIVILEGED_INSTRUCTION;
			"gliss_error"("lduba: not in supervisor mode.\n");
		else if i == 1 then
			TRAP = 1;
			TMP_TT = ILLEGAL_INSTRUCTION;
			"gliss_error"("lduba: illegal instr (i=1).\n");
		else
			TMP_ADDR = rs1 + rs2;
			TMP_ASI = rs2.asi;
			TMP_U8 = MEM_ASI8(TMP_ADDR, TMP_ASI);
			if rd.value != 0 then
				SET_WIN_REG(rd.value, TMP_U8);
			endif;
		endif;
		endif;
	}



op ldsha(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax = format("ldsha [%s+%s]%d, %s", rs1.syntax, rs2.syntax, rs2.asi, rd.syntax)
image = format("%s 011010 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if PSR_S == 0 then
			TRAP = 1;
			TMP_TT = PRIVILEGED_INSTRUCTION;
			"gliss_error"("ldsha: not in supervisor mode.\n");
		else if i == 1 then
			TRAP = 1;
			TMP_TT = ILLEGAL_INSTRUCTION;
			"gliss_error"("ldsha: illegal instr (i=1).\n");
		else
			TMP_ADDR = rs1 + rs2;
			if TMP_ADDR<0..0> != 0 then
				TRAP = 1;
				TMP_TT = MEM_ADDRESS_NOT_ALIGNED;
				"gliss_error"("ldsha: misaligned address.\n");
			else
				TMP_ASI = rs2.asi;
				TMP_S16 = MEM_ASI16(TMP_ADDR, TMP_ASI);
				if rd.value != 0 then
					SET_WIN_REG(rd.value, coerce(int(32), TMP_S16));
				endif;
			endif;
		endif;
		endif;
	}



op lduha(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax = format("lduha [%s+%s]%d, %s", rs1.syntax, rs2.syntax, rs2.asi, rd.syntax)
image = format("%s 010010 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if PSR_S == 0 then
			TRAP = 1;
			TMP_TT = PRIVILEGED_INSTRUCTION;
			"gliss_error"("lduha: not in supervisor mode.\n");
		else if i == 1 then
			TRAP = 1;
			TMP_TT = ILLEGAL_INSTRUCTION;
			"gliss_error"("lduha: illegal instr (i=1).\n");
		else
			TMP_ADDR = rs1 + rs2;
			if TMP_ADDR<0..0> != 0 then
				TRAP = 1;
				TMP_TT = MEM_ADDRESS_NOT_ALIGNED;
				"gliss_error"("lduha: misaligned address.\n");
			else
				TMP_ASI = rs2.asi;
				TMP_U16 = MEM_ASI16(TMP_ADDR, TMP_ASI);
				if rd.value != 0 then
					SET_WIN_REG(rd.value, TMP_U16);
				endif;
			endif;
		endif;
		endif;
	}



op lda(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax = format("lda [%s+%s]%d, %s", rs1.syntax, rs2.syntax, rs2.asi, rd.syntax)
image = format("%s 010000 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if PSR_S == 0 then
			TRAP = 1;
			TMP_TT = PRIVILEGED_INSTRUCTION;
			"gliss_error"("lda: not in supervisor mode.\n");
		else if i == 1 then
			TRAP = 1;
			TMP_TT = ILLEGAL_INSTRUCTION;
			"gliss_error"("lda: illegal instr (i=1).\n");
		else
			TMP_ADDR = rs1 + rs2;
			if TMP_ADDR<1..0> != 0 then
				TRAP = 1;
				TMP_TT = MEM_ADDRESS_NOT_ALIGNED;
				"gliss_error"("lda: misaligned address.\n");
			else
				TMP_ASI = rs2.asi;
				TMP_U32 = MEM_ASI32(TMP_ADDR, TMP_ASI);
				if rd.value != 0 then
					SET_WIN_REG(rd.value, TMP_U32);
				endif;
			endif;
		endif;
		endif;
	}



op ldda(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax = format("lda [%s+%s]%d, %s", rs1.syntax, rs2.syntax, rs2.asi, rd.syntax)
image = format("%s 010011 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if PSR_S == 0 then
			TRAP = 1;
			TMP_TT = PRIVILEGED_INSTRUCTION;
			"gliss_error"("ldda: not in supervisor mode.\n");
		else if i == 1 then
			TRAP = 1;
			TMP_TT = ILLEGAL_INSTRUCTION;
			"gliss_error"("ldda: illegal instr (i=1).\n");
		else
			TMP_ADDR = rs1 + rs2;
			if TMP_ADDR<2..0> != 0 then
				TRAP = 1;
				TMP_TT = MEM_ADDRESS_NOT_ALIGNED;
				"gliss_error"("ldda: misaligned address.\n");
			else
				TMP_ASI = rs2.asi;
				TMP_U32 = MEM_ASI32(TMP_ADDR, TMP_ASI);
				if rd.value != 0 then
					// fill the even register with the 1st word
					SET_WIN_REG(rd.value & 0x1E, TMP_U32);
				endif;
				TMP_ADDR = TMP_ADDR + 4;
				TMP_U32 = MEM_ASI32(TMP_ADDR, TMP_ASI);
				if rd.value != 0 then
					// fill the odd register with the next word
					SET_WIN_REG(rd.value | 1, TMP_U32);
				endif;
			endif;
		endif;
		endif;
	}



op store_integer =
		stb
		| sth
		| st
		| std



op stb(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("stb [%s+%s], %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("stb [%s]+%d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 000101 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_ADDR = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		TMP_ASI = if PSR_S == 0 then ASI_USER_DATA else ASI_SUPRV_DATA endif;

		MEM_ASI8(TMP_ADDR, TMP_ASI) = rd;
	}



op sth(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("sth [%s+%s], %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("sth [%s]+%d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 000110 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_ADDR = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		if TMP_ADDR<0..0> != 0 then
			TRAP = 1;
			TMP_TT = MEM_ADDRESS_NOT_ALIGNED;
			"gliss_error"("sth: misaligned address.\n");
		else
			TMP_ASI = if PSR_S == 0 then ASI_USER_DATA else ASI_SUPRV_DATA endif;
			MEM_ASI16(TMP_ADDR, TMP_ASI) = rd;
		endif;
	}



op st(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("st [%s+%s], %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("st [%s]+%d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 000100 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_ADDR = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		if TMP_ADDR<1..0> != 0 then
			TRAP = 1;
			TMP_TT = MEM_ADDRESS_NOT_ALIGNED;
			"gliss_error"("st: misaligned address.\n");
		else
			TMP_ASI = if PSR_S == 0 then ASI_USER_DATA else ASI_SUPRV_DATA endif;
			MEM_ASI32(TMP_ADDR, TMP_ASI) = rd;
		endif;
	}



op std(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("std [%s+%s], %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("std [%s]+%d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 000111 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_ADDR = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		if TMP_ADDR<2..0> != 0 then
			TRAP = 1;
			TMP_TT = MEM_ADDRESS_NOT_ALIGNED;
			"gliss_error"("st: misaligned address.\n");
		else
			TMP_ASI = if PSR_S == 0 then ASI_USER_DATA else ASI_SUPRV_DATA endif;
			TMP_IDX = rd.value & 0x1e;
			// fill the 1st word with the even register
			TMP_U32 = GET_WIN_REG(TMP_IDX);
			MEM_ASI32(TMP_ADDR, TMP_ASI) = TMP_U32;

			TMP_ADDR = TMP_ADDR + 4;
			TMP_IDX = rd.value | 1;
			// fill the next word with the odd register
			TMP_U32 = GET_WIN_REG(TMP_IDX);
			MEM_ASI32(TMP_ADDR, TMP_ASI) = TMP_U32;
		endif;
	}



op store_integer_asi =
		stba
		| stha
		| sta
		| stda



op stba(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax = format("stba [%s+%s]%d, %s", rs1.syntax, rs2.syntax, rs2.asi, rd.syntax)
image = format("%s 010101 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if PSR_S == 0 then
			TRAP = 1;
			TMP_TT = PRIVILEGED_INSTRUCTION;
			"gliss_error"("stba: not in supervisor mode.\n");
		else if i == 1 then
			TRAP = 1;
			TMP_TT = ILLEGAL_INSTRUCTION;
			"gliss_error"("stba: illegal instr (i=1).\n");
		else
			TMP_ADDR = rs1 + rs2;
			TMP_ASI = rs2.asi;
			MEM_ASI8(TMP_ADDR, TMP_ASI) = rd;
		endif;
		endif;
	}



op stha(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax = format("stha [%s+%s]%d, %s", rs1.syntax, rs2.syntax, rs2.asi, rd.syntax)
image = format("%s 010110 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if PSR_S == 0 then
			TRAP = 1;
			TMP_TT = PRIVILEGED_INSTRUCTION;
			"gliss_error"("stha: not in supervisor mode.\n");
		else if i == 1 then
			TRAP = 1;
			TMP_TT = ILLEGAL_INSTRUCTION;
			"gliss_error"("stha: illegal instr (i=1).\n");
		else
			TMP_ADDR = rs1 + rs2;
			TMP_ASI = rs2.asi;
			MEM_ASI16(TMP_ADDR, TMP_ASI) = rd;
		endif;
		endif;
	}



op sta(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax = format("sta [%s+%s]%d, %s", rs1.syntax, rs2.syntax, rs2.asi, rd.syntax)
image = format("%s 010100 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if PSR_S == 0 then
			TRAP = 1;
			TMP_TT = PRIVILEGED_INSTRUCTION;
			"gliss_error"("sta: not in supervisor mode.\n");
		else if i == 1 then
			TRAP = 1;
			TMP_TT = ILLEGAL_INSTRUCTION;
			"gliss_error"("sta: illegal instr (i=1).\n");
		else
			TMP_ADDR = rs1 + rs2;
			TMP_ASI = rs2.asi;
			MEM_ASI32(TMP_ADDR, TMP_ASI) = rd;
		endif;
		endif;
	}



op stda(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax = format("stda [%s+%s]%d, %s", rs1.syntax, rs2.syntax, rs2.asi, rd.syntax)
image = format("%s 010111 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if PSR_S == 0 then
			TRAP = 1;
			TMP_TT = PRIVILEGED_INSTRUCTION;
			"gliss_error"("stda: not in supervisor mode.\n");
		else if i == 1 then
			TRAP = 1;
			TMP_TT = ILLEGAL_INSTRUCTION;
			"gliss_error"("stda: illegal instr (i=1).\n");
		else
			TMP_ADDR = rs1 + rs2;
			TMP_ASI = rs2.asi;
			TMP_IDX = rd.value & 0x1e;
			// fill the 1st word with the even register
			TMP_U32 = GET_WIN_REG(TMP_IDX);
			MEM_ASI32(TMP_ADDR, TMP_ASI) = TMP_U32;

			TMP_ADDR = TMP_ADDR + 4;
			TMP_IDX = rd.value | 1;
			// fill the next word with the odd register
			TMP_U32 = GET_WIN_REG(TMP_IDX);
			MEM_ASI32(TMP_ADDR, TMP_ASI) = TMP_U32;
		endif;
		endif;
	}



op load_store_float =
		load_float
		| store_float



op load_float =
		ldf
		| lddf
		| ldfsr



op ldf(rd : freg_mode, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("ldf [%s+%s], %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("ldf [%s]+%d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 100000 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if PSR_EF == 0 then
			TRAP = 1;
			TMP_TT = FP_DISABLED;
			"gliss_error"("ldf: floats not enabled.\n");
		else
			TMP_ADDR = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
			TMP_ASI = if PSR_S == 0 then ASI_USER_DATA else ASI_SUPRV_DATA endif;
			if TMP_ADDR<1..0> != 0 then
				TRAP = 1;
				TMP_TT = MEM_ADDRESS_NOT_ALIGNED;
				"gliss_error"("ldf: misaligned address.\n");
			else
				TMP_F32<31..0> = MEM_ASI32(TMP_ADDR, TMP_ASI);
				F[rd.value] = TMP_F32;
			endif;
		endif;
	}



op lddf(rd : freg_mode, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("lddf [%s+%s], %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("lddf [%s]+%d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 100011 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if PSR_EF == 0 then
			TRAP = 1;
			TMP_TT = FP_DISABLED;
			"gliss_error"("lddf: floats not enabled.\n");
		else if (rd.value & 1) != 0 then
			TRAP = 1;
			TMP_TT = FP_EXCEPTION;
			//FTT = invalid_fp_register;
			"gliss_error"("lddf: odd rd not allowed.\n");
		else
			TMP_ADDR = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
			TMP_ASI = if PSR_S == 0 then ASI_USER_DATA else ASI_SUPRV_DATA endif;
			if TMP_ADDR<2..0> != 0 then
				TRAP = 1;
				TMP_TT = MEM_ADDRESS_NOT_ALIGNED;
				"gliss_error"("lddf: misaligned address.\n");
			else
				// even reg
				TMP_F32<31..0> = MEM_ASI32(TMP_ADDR, TMP_ASI);
				F[rd.value & 0x1e] = TMP_F32;
				// odd reg
				TMP_ADDR = TMP_ADDR + 4;
				TMP_F32<31..0> = MEM_ASI32(TMP_ADDR, TMP_ASI);
				F[rd.value | 1] = TMP_F32;
			endif;
		endif;
		endif;
	}



op ldfsr(rd : freg_mode, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("ldfsr [%s+%s], %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("ldfsr [%s]+%d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 100001 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if PSR_EF == 0 then
			TRAP = 1;
			TMP_TT = FP_DISABLED;
			"gliss_error"("ldfsr: floats not enabled.\n");
		else
			TMP_ADDR = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
			TMP_ASI = if PSR_S == 0 then ASI_USER_DATA else ASI_SUPRV_DATA endif;
			if TMP_ADDR<2..0> != 0 then
				TRAP = 1;
				TMP_TT = MEM_ADDRESS_NOT_ALIGNED;
				"gliss_error"("ldfsr: misaligned address.\n");
			else
				FSR = MEM_ASI32(TMP_ADDR, TMP_ASI);
			endif;
		endif;
	}


op store_float =
		stf
		| stdf
		| stfsr
	//	| stdfq



op stf(rd : freg_mode, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("stf [%s+%s], %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("stf [%s]+%d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 100100 %s %1b %s", rd.image, rs1.image, i, rs2.image)

action =
	{
		if PSR_EF == 0 then
			TRAP = 1;
			TMP_TT = FP_DISABLED;
			"gliss_error"("stf: floats not enabled.\n");
		else
			TMP_ADDR = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
			TMP_ASI = if PSR_S == 0 then ASI_USER_DATA else ASI_SUPRV_DATA endif;
			if TMP_ADDR<1..0> != 0 then
				TRAP = 1;
				TMP_TT = MEM_ADDRESS_NOT_ALIGNED;
				"gliss_error"("stf: misaligned address.\n");
			else
				MEM_ASI32(TMP_ADDR, TMP_ASI) = F[rd.value]<31..0>;
			endif;
		endif;
	}



op stdf(rd : freg_mode, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("stdf [%s+%s], %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("stdf [%s]+%d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 100111 %s %1b %s", rd.image, rs1.image, i, rs2.image)

action =
	{
		if PSR_EF == 0 then
			TRAP = 1;
			TMP_TT = FP_DISABLED;
			"gliss_error"("stdf: floats not enabled.\n");
		else
			TMP_ADDR = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
			TMP_ASI = if PSR_S == 0 then ASI_USER_DATA else ASI_SUPRV_DATA endif;
			if TMP_ADDR<2..0> != 0 then
				TRAP = 1;
				TMP_TT = MEM_ADDRESS_NOT_ALIGNED;
				"gliss_error"("stdf: misaligned address.\n");
			else
				MEM_ASI32(TMP_ADDR, TMP_ASI) = F[rd.value & 0x1e]<31..0>;
				MEM_ASI32(TMP_ADDR + 4, TMP_ASI) = F[rd.value | 1]<31..0>;
			endif;
		endif;
	}



op stfsr(rd : freg_mode, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("stfsr [%s+%s], %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("stfsr [%s]+%d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 100101 %s %1b %s", rd.image, rs1.image, i, rs2.image)

action =
	{
		if PSR_EF == 0 then
			TRAP = 1;
			TMP_TT = FP_DISABLED;
			"gliss_error"("stfsr: floats not enabled.\n");
		else
			TMP_ADDR = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
			TMP_ASI = if PSR_S == 0 then ASI_USER_DATA else ASI_SUPRV_DATA endif;
			if TMP_ADDR<1..0> != 0 then
				TRAP = 1;
				TMP_TT = MEM_ADDRESS_NOT_ALIGNED;
				"gliss_error"("stfsr: misaligned address.\n");
			else
				// while (PSR_QNE == 1)
				// wait for pending float instr to complete
				MEM_ASI32(TMP_ADDR, TMP_ASI) = FSR;
			endif;
		endif;
	}



op logical =
		and
		| andcc
		| andn
		| andncc
		| or
		| orcc
		| orn
		| orncc
		| xor
		| xorcc
		| xnor
		| xnorcc


op and(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("and %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("and %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 000001 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if rd.value != 0 then
			SET_WIN_REG(rd.value, rs1 & (if i == 0 then rs2 else coerce(int(32), rs2.value) endif));
		endif;
	}


op andcc(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("andcc %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("andcc %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 010001 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32 = rs1 & (if i == 0 then rs2 else coerce(int(32), rs2.value) endif);
		logical_update_icc(TMP_U32);

		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_U32);
		endif;

	}


op andn(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("andn %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("andn %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 000101 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if rd.value != 0 then
			SET_WIN_REG(rd.value, rs1 & ~(if i == 0 then rs2 else coerce(int(32), rs2.value) endif));
		endif;
	}


op andncc(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("andncc %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("andncc %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 010101 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32 = rs1 & ~(if i == 0 then rs2 else coerce(int(32), rs2.value) endif);
		logical_update_icc(TMP_U32);

		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_U32);
		endif;
	}


op or(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("or %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		if rs1.value == 0 then
			format("mov %d, %s", rs2.value, rd.syntax)
		else
			format("or %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
		endif
	endif
image = format("%s 000010 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if rd.value != 0 then
			SET_WIN_REG(rd.value, rs1 | (if i == 0 then rs2 else coerce(int(32), rs2.value) endif));
		endif;
	}


op orcc(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("orcc %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("orcc %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 010010 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32 = rs1 | (if i == 0 then rs2 else coerce(int(32), rs2.value) endif);
		logical_update_icc(TMP_U32);

		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_U32);
		endif;
	}


op orn(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("orn %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("orn %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 000110 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if rd.value != 0 then
			SET_WIN_REG(rd.value, rs1 | ~(if i == 0 then rs2 else coerce(int(32), rs2.value) endif));
		endif;
	}


op orncc(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("orncc %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("orncc %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 010110 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32 = rs1 | ~(if i == 0 then rs2 else coerce(int(32), rs2.value) endif);
		logical_update_icc(TMP_U32);

		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_U32);
		endif;
	}


op xor(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("xor %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("xor %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 000011 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if rd.value != 0 then
			SET_WIN_REG(rd.value, rs1 ^ (if i == 0 then rs2 else coerce(int(32), rs2.value) endif));
		endif;
	}


op xorcc(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("xorcc %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("xorcc %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 010011 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32 = rs1 ^ (if i == 0 then rs2 else coerce(int(32), rs2.value) endif);
		logical_update_icc(TMP_U32);

		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_U32);
		endif;
	}


op xnor(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("xnor %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("xnor %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 000111 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if rd.value != 0 then
			SET_WIN_REG(rd.value, rs1 ^ ~(if i == 0 then rs2 else coerce(int(32), rs2.value) endif));
		endif;
	}


op xnorcc(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("xnorcc %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("xnorcc %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 010111 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32 = rs1 ^ ~(if i == 0 then rs2 else coerce(int(32), rs2.value) endif);
		logical_update_icc(TMP_U32);

		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_U32);
		endif;
	}



op shift =
		sll
		| srl
		| sra



op sll(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("sll %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("sll %s, %d, %s", rs1.syntax, rs2.idx, rd.syntax)
	endif
image = format("%s 100101 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if rd.value != 0 then
			TMP_U32 = if i == 0 then rs2 else rs2.idx endif;
			SET_WIN_REG(rd.value, rs1 << TMP_U32<4..0>);
		endif;
	}



op srl(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("srl %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("srl %s, %d, %s", rs1.syntax, rs2.idx, rd.syntax)
	endif
image = format("%s 100110 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32 =
			if i == 0 then
				rs2
			else
				coerce(u32, rs2.idx)
			endif;
		TMP_U32 = TMP_U32<4..0>;

		//TMP_MASK32 = (1 << (32 - TMP_U32)) - 1;
		if rd.value != 0 then
			SET_WIN_REG(rd.value, (rs1 >> TMP_U32));// & TMP_MASK32);
		endif;
	}



op sra(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("sra %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("sra %s, %d, %s", rs1.syntax, rs2.idx, rd.syntax)
	endif
image = format("%s 100111 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if rd.value != 0 then
			TMP_U32 = if i == 0 then rs2 else coerce(u32, rs2.idx) endif;
			SET_WIN_REG(rd.value, coerce(s32, rs1) >> TMP_U32<4..0>);
		endif;
	}



op swap_atomic_load_store =
		swap
		| swapa
		| ldstub
		| ldstuba



op swap(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("swap [%s+%s], %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("swap [%s]+%d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 001111 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_ADDR = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		if TMP_ADDR<1..0> != 0 then
			TRAP = 1;
			TMP_TT = MEM_ADDRESS_NOT_ALIGNED;
			"gliss_error"("swap: misaligned address.\n");
		else
			TMP_ASI = if PSR_S == 0 then ASI_USER_DATA else ASI_SUPRV_DATA endif;
			TMP_U32 = MEM_ASI32(TMP_ADDR, TMP_ASI);
			MEM_ASI32(TMP_ADDR, TMP_ASI) = rd;
			if rd.value != 0 then
				SET_WIN_REG(rd.value, TMP_U32);
			endif;
		endif;
	}



op swapa(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax = format("swapa [%s+%s]%d, %s", rs1.syntax, rs2.syntax, rs2.asi, rd.syntax)
image = format("%s 011111 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if PSR_S == 0 then
			TRAP = 1;
			TMP_TT = PRIVILEGED_INSTRUCTION;
			"gliss_error"("swapa: not in supervisor mode.\n");
		else if i == 1 then
			TRAP = 1;
			TMP_TT = ILLEGAL_INSTRUCTION;
			"gliss_error"("swapa: illegal instr (i=1).\n");
		else
			TMP_ADDR = rs1 + rs2;
			if TMP_ADDR<1..0> != 0 then
				TRAP = 1;
				TMP_TT = MEM_ADDRESS_NOT_ALIGNED;
				"gliss_error"("swapa: misaligned address.\n");
			else
				TMP_ASI = rs2.asi;
				TMP_U32 = MEM_ASI32(TMP_ADDR, TMP_ASI);
				MEM_ASI32(TMP_ADDR, TMP_ASI) = rd;
				if rd.value != 0 then
					SET_WIN_REG(rd.value, TMP_U32);
				endif;
			endif;
		endif;
		endif;
	}



op ldstub(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("ldstub [%s+%s], %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("ldstub [%s]+%d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 001101 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_ADDR = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		TMP_ASI = if PSR_S == 0 then ASI_USER_DATA else ASI_SUPRV_DATA endif;

		TMP_U8 = MEM_ASI8(TMP_ADDR, TMP_ASI);
		MEM_ASI8(TMP_ADDR, TMP_ASI) = 0xFF;
		if rd.value != 0 then
			SET_WIN_REG(rd.value, MEM_ASI8(TMP_ADDR, TMP_ASI));
		endif;
	}



op ldstuba(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax = format("ldstuba [%s+%s]%d, %s", rs1.syntax, rs2.syntax, rs2.asi, rd.syntax)
image = format("%s 011101 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if PSR_S == 0 then
			TRAP = 1;
			TMP_TT = PRIVILEGED_INSTRUCTION;
			"gliss_error"("ldstuba: not in supervisor mode.\n");
		else if i == 1 then
			TRAP = 1;
			TMP_TT = ILLEGAL_INSTRUCTION;
			"gliss_error"("ldstuba: illegal instr (i=1).\n");
		else
			TMP_ADDR = rs1 + rs2;
			TMP_ASI = rs2.asi;
			TMP_U8 = MEM_ASI8(TMP_ADDR, TMP_ASI);
			MEM_ASI8(TMP_ADDR, TMP_ASI) = 0xFF;
			if rd.value != 0 then
				SET_WIN_REG(rd.value, MEM_ASI8(TMP_ADDR, TMP_ASI));
			endif;
		endif;
		endif;
	}



op save_restore =
		save
		| restore



op save(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("save %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("save %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 111100 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_CWP = (CWP - 1) % NWINDOWS;
		if (WIM & (1 << TMP_CWP)) != 0 then
			TRAP = 1;
			TMP_TT = WINDOW_OVERFLOW;
			"gliss_error"("save: trap (window overflow).\n");
		else
			TMP_U32 = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
			CWP = TMP_CWP;
			if rd.value != 0 then
				SET_WIN_REG(rd.value, TMP_U32);
			endif;
		endif;
	}



op restore(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("restore %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("restore %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 111101 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_CWP = (CWP + 1) % NWINDOWS;
		if (WIM & (1 << TMP_CWP)) != 0 then
			TRAP = 1;
			TMP_TT = WINDOW_UNDERFLOW;
			"gliss_error"("restore: invalid new CWP (window underflow).\n");
		else
			TMP_U32 = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
			CWP = TMP_CWP;
			if rd.value != 0 then
				SET_WIN_REG(rd.value, TMP_U32);
			endif;
		endif;
	}



op jmpl(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)

	syntax =
		if i != 0 && rd.value == 0 then
			if rs2.value == 8 && rs1.value == 31 then "ret"
			else
				if rs2.value == 8 && rs1.value == 15 then "retl"
				else
					format("jmp [%s + %d]", rs1.syntax, rs2.value)
				endif
			endif
		else
			if i != 0 && rd.value == 0 then
				format("jmp [%s + %s]", rs1.syntax, rs2.syntax)
			else
				format("jmpl [%s + %d], %s", rs1.syntax, rs2.value, rd.syntax)
			endif
		endif
	
	image = format("%s 111000 %s %1b %s", rd.image, rs1.image, i, rs2.image)

	action = {
		TMP_ADDR = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		if TMP_ADDR<1..0> != 0 then
				TRAP = 1;
				TMP_TT = MEM_ADDRESS_NOT_ALIGNED;
				"gliss_error"("jmpl: misaligned address.\n");
			else
				if rd.value != 0 then
					SET_WIN_REG(rd.value, PC);
				endif;
				PC = nPC;
				nPC = TMP_ADDR;
				BRANCH_EXECUTED = 1;
			endif;
	}



op add_integer =
		add
		| addcc
		| addx
		| addxcc



op add(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("add %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("add %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 000000 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32 = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif;

		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_U32);
		endif;
	}



op addcc(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("addcc %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("addcc %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 010000 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32a = if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		TMP_U32 = rs1 + TMP_U32a;

		add_integer_update_icc(rs1, TMP_U32a, TMP_U32);

		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_U32);
		endif;
	}



op addx(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("addx %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("addx %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 001000 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32 = rs1 + if i == 0 then rs2 else coerce(int(32), rs2.value) endif + ICC_C;

		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_U32);
		endif;
	}



op addxcc(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("addxcc %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("addxcc %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 011000 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32a = if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		TMP_U32 = rs1 + TMP_U32a + ICC_C;

		add_integer_update_icc(rs1, TMP_U32a, TMP_U32);
		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_U32);
		endif;
	}



op tagged_add =
	taddcc
	| taddcctv



op taddcc(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("taddcc %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("taddcc %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 100000 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32a = if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		TMP_U32 = rs1 + TMP_U32a;

		add_tagged_update_icc(rs1, TMP_U32a, TMP_U32);
		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_U32);
		endif;
	}



op taddcctv(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("taddcctv %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("taddcctv %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 100010 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32a = if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		TMP_U32 = rs1 + TMP_U32a;

		if tagged_get_V(rs1, TMP_U32a, TMP_U32) == 1 then
			TRAP = 1;
			TMP_TT = TAG_OVERFLOW;
			"gliss_error"("taddcctv: trap tag overflow generated.\n");
		else
			add_tagged_update_icc(rs1, TMP_U32a, TMP_U32);
			if rd.value != 0 then
				SET_WIN_REG(rd.value, TMP_U32);
			endif;
		endif;
	}



op sub_integer =
		sub
		| subcc
		| subx
		| subxcc



op sub(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("sub %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("sub %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 000100 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32 = rs1 - if i == 0 then rs2 else coerce(int(32), rs2.value) endif;

		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_U32);
		endif;
	}



op subcc(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("subcc %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("subcc %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 010100 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32a = if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		TMP_U32 = rs1 - TMP_U32a;

		sub_integer_update_icc(rs1, TMP_U32a, TMP_U32);

		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_U32);
		endif;
	}



op subx(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("subx %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("subx %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 001100 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32 = rs1 - if i == 0 then rs2 else coerce(int(32), rs2.value) endif - ICC_C;

		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_U32);
		endif;
	}



op subxcc(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("subxcc %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("subxcc %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 011100 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32a = if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		TMP_U32 = rs1 - TMP_U32a - ICC_C;

		sub_integer_update_icc(rs1, TMP_U32a, TMP_U32);
		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_U32);
		endif;
	}



op tagged_sub =
		tsubcc
		| tsubcctv



op tsubcc(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("tsubcc %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("tsubcc %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 100001 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32a = if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		TMP_U32 = rs1 - TMP_U32a;

		sub_tagged_update_icc(rs1, TMP_U32a, TMP_U32);
		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_U32);
		endif;
	}



op tsubcctv(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("tsubcctv %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("tsubcctv %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 100011 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32a = if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		TMP_U32 = rs1 - TMP_U32a;

		if tagged_get_V(rs1, ~TMP_U32a, TMP_U32) == 1 then
			TRAP = 1;
			TMP_TT = TAG_OVERFLOW;
			"gliss_error"("tsubcctv: trap tag overflow generated.\n");
		else
			sub_tagged_update_icc(rs1, TMP_U32a, TMP_U32);
			if rd.value != 0 then
				SET_WIN_REG(rd.value, TMP_U32);
			endif;
		endif;
	}



op multiply_integer =
	mulscc
	| umul
	| smul
	| umulcc
	| smulcc



op mulscc(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("mulscc %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("mulscc %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 100100 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32 = (coerce(u32, ICC_N ^ ICC_V) << 31) | rs1<31..1>;
		TMP_U32a =
			if Y<0..0> == 0 then
				0
			else
				if i == 0 then rs2 else coerce(int(32), rs2.value) endif
			endif;
		TMP_U32b = TMP_U32 + TMP_U32a;
		// Y = rs1[0]||Y<31..1>
		Y = (rs1 << 31) | Y<31..1>;

		multiply_step_update_icc(TMP_U32, TMP_U32a, TMP_U32b);
		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_U32b);
		endif;
	}



op umul(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("umul %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("umul %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 001010 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U64b = if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		TMP_U64a = rs1;
		TMP_U64 = TMP_U64a * TMP_U64b;

		Y = TMP_U64<63..32>;
		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_U64<31..0>);
		endif;
	}



op smul(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("smul %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("smul %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 001011 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_S32 = if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		TMP_S64b = TMP_S32;
		TMP_S32 = rs1;
		TMP_S64a = TMP_S32;
		TMP_S64 = TMP_S64a * TMP_S64b;

		Y = TMP_S64<63..32>;
		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_S64<31..0>);
		endif;
	}



op umulcc(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("umulcc %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("umulcc %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 011010 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U64b = if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		TMP_U64a = rs1;
		TMP_U64 = TMP_U64a * TMP_U64b;

		Y = TMP_U64<63..32>;

		multiply_integer_update_icc(TMP_U64);
		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_U64<31..0>);
		endif;
	}



op smulcc(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("smulcc %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("smulcc %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 011011 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_S32 = if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		TMP_S64b = TMP_S32;
		TMP_S32 = rs1;
		TMP_S64a = TMP_S32;
		TMP_S64 = TMP_S64a * TMP_S64b;

		Y = TMP_S64<63..32>;

		multiply_integer_update_icc(TMP_S64);
		if rd.value != 0 then
			SET_WIN_REG(rd.value, TMP_S64<31..0>);
		endif;
	}



op divide_integer =
		udiv
		| sdiv
		| udivcc
		| sdivcc



op udiv(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("udiv %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("udiv %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 001110 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U64b = if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		if TMP_U64b == 0 then
			TRAP = 1;
			TMP_TT = DIVISION_BY_ZERO;
			"gliss_error"("udiv: division by zero.\n");
		else
			TMP_U64a<63..32> = Y;
			TMP_U64a<31..0> = rs1;
			TMP_U64 = TMP_U64a / TMP_U64b;
			if rd.value != 0 then
				if TMP_U64<63..32> != 0 then
					// res overflowed 32 bits
					SET_WIN_REG(rd.value, 0xFFFFFFFF);
				else
					SET_WIN_REG(rd.value, TMP_U64<31..0>);
				endif;
			endif;
		endif;
	}



op sdiv(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("sdiv %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("sdiv %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 001111 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_S64b = if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		if TMP_S64b == 0 then
			TRAP = 1;
			TMP_TT = DIVISION_BY_ZERO;
			"gliss_error"("sdiv: division by zero.");
		else
			TMP_S64a<63..32> = Y;
			TMP_S64a<31..0> = rs1;
			TMP_S64 = TMP_S64a / TMP_S64b;
			if rd.value != 0 then
				if TMP_S64<63..31> == 0 || ~TMP_S64<63..31> == 0  then
					SET_WIN_REG(rd.value, TMP_S64<31..0>);
				else
					// res overflowed 32 bits
					if TMP_S64 > 0 then
						SET_WIN_REG(rd.value, 0x7FFFFFFF);
					else
						SET_WIN_REG(rd.value, 0x80000000);
					endif;
				endif;
			endif;
		endif;
	}



op udivcc(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("udivcc %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("udivcc %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 011110 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U64b = if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		if TMP_U64b == 0 then
			TRAP = 1;
			TMP_TT = DIVISION_BY_ZERO;
			"gliss_error"("udivcc: division by zero.\n");
		else
			TMP_U64a<63..32> = Y;
			TMP_U64a<31..0> = rs1;
			TMP_U64 = TMP_U64a / TMP_U64b;
			divide_integer_update_icc(TMP_U64, 0);
			if rd.value != 0 then
				if TMP_U64<63..32> != 0 then
					// res overflowed 32 bits
					SET_WIN_REG(rd.value, 0xFFFFFFFF);
				else
					SET_WIN_REG(rd.value, TMP_U64<31..0>);
				endif;
			endif;
		endif;
	}



op sdivcc(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("sdivcc %s, %s, %s", rs1.syntax, rs2.syntax, rd.syntax)
	else
		format("sdivcc %s, %d, %s", rs1.syntax, rs2.value, rd.syntax)
	endif
image = format("%s 011111 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_S64b = if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		if TMP_S64b == 0 then
			TRAP = 1;
			TMP_TT = DIVISION_BY_ZERO;
			"gliss_error"("sdivcc: division by zero.\n");
		else
			TMP_S64a<63..32> = Y;
			TMP_S64a<31..0> = rs1;
			TMP_S64 = TMP_S64a / TMP_S64b;
			divide_integer_update_icc(TMP_S64, 0);
			if rd.value != 0 then
				if TMP_S64<63..31> == 0 || ~TMP_S64<63..31> == 0  then
					SET_WIN_REG(rd.value, TMP_S64<31..0>);
				else
					// res overflowed 32 bits
					if TMP_S64 > 0 then
						SET_WIN_REG(rd.value, 0x7FFFFFFF);
					else
						SET_WIN_REG(rd.value, 0x80000000);
					endif;
				endif;
			endif;
		endif;
	}



op read_write_state_register =
		read_state_register
		| write_state_register


op read_state_register =
		rdasr
		| rdpsr
		| rdwim
		| rdtbr


// rdasr, stbar, rdy have the same opcode
op rdasr(rd : reg_mode_0, rs1 : reg_mode_0)
syntax =
	if rs1.value == 0 then
		format("rd %%y , %s", rd.syntax)
	else
		if rs1.value == 15 && rd.value == 0 then
			"stbar"
		else
			format("rd %%asr%d, %s", rs1.value, rd.syntax)
		endif
	endif
image = format("%s 101000 %s X X XXXX XXXX XXXX", rd.image, rs1.image)
action =
	{
		if rs1.value == 0 then
			// read Y register
			SET_WIN_REG(rd.value, Y);
		else
			if rs1.value == 15 && rd.value == 0 then
				// stbar
				// nothing to be emulated here
			else
				// read a asr
				if PSR_S == 0 then
					TRAP = 1;
					TMP_TT = PRIVILEGED_INSTRUCTION;
					"gliss_error"("rdasr: privileged instruction.\n");
				else
					if rs1.value >= 15 then
						SET_WIN_REG(rd.value, ASR[rs1.value]);
					endif;
				endif;
			endif;

		endif;
	}



op rdpsr(rd : reg_mode_0)
syntax = format("rd %%psr , %s", rd.syntax)
image = format("%s 101001 XXXXX X X XXXX XXXX XXXX", rd.image)
action =
	{
		if PSR_S == 0 then
			TRAP = 1;
			TMP_TT = PRIVILEGED_INSTRUCTION;
			"gliss_error"("rdpsr: privileged instruction.\n");
		else
			SET_WIN_REG(rd.value, PSR);
		endif;
	}



op rdwim(rd : reg_mode_0)
syntax = format("rd %%wim , %s", rd.syntax)
image = format("%s 101010 XXXXX X X XXXX XXXX XXXX", rd.image)
action =
	{
		if PSR_S == 0 then
			TRAP = 1;
			TMP_TT = PRIVILEGED_INSTRUCTION;
			"gliss_error"("rdwim: privileged instruction.\n");
		else
			SET_WIN_REG(rd.value, WIM);
		endif;
	}



op rdtbr(rd : reg_mode_0)
syntax = format("rd %%tbr , %s", rd.syntax)
image = format("%s 101011 XXXXX X X XXXX XXXX XXXX", rd.image)
action =
	{
		if PSR_S == 0 then
			TRAP = 1;
			TMP_TT = PRIVILEGED_INSTRUCTION;
			"gliss_error"("rdtbr: privileged instruction.\n");
		else
			SET_WIN_REG(rd.value, TBR);
		endif;
	}



op write_state_register =
		wrasr
		| wrpsr
		| wrwim
		| wrtbr



op wrasr(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if rd.value == 0 then
		if i==0 then
			format("wr %s, %s, %%y", rs1.syntax, rs2.syntax)
		else
			format("wr %s, %d, %%y", rs1.syntax, rs2.value)
		endif
	else
		if i==0 then
			format("wr %s, %s, %%asr%d", rs1.syntax, rs2.syntax, rd.value)
		else
			format("wr %s, %d, %%asr%d", rs1.syntax, rs2.value, rd.value)
		endif
	endif
image = format("%s 110000 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32 = if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
		TMP_U32a = rs1 ^ TMP_U32;

		if rd.value == 0 then
			// write Y register
			Y = TMP_U32a;
		else
			// write a asr
			if PSR_S == 0 then
				TRAP = 1;
				TMP_TT = PRIVILEGED_INSTRUCTION;
				"gliss_error"("wrasr: privileged instruction.\n");
			else
				if rd.value >= 15 then
					ASR[rd.value] = TMP_U32a;
				endif;
			endif;
		endif;
	}



op wrpsr(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i==0 then
		format("wr %s, %s, %%psr", rs1.syntax, rs2.syntax)
	else
		format("wr %s, %d, %%psr", rs1.syntax, rs2.value)
	endif
image = format("%s 110001 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if PSR_S == 0 then
			TRAP = 1;
			TMP_TT = PRIVILEGED_INSTRUCTION;
			"gliss_error"("wrpsr: privileged instruction.\n");
		else
			TMP_U32 = if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
			TMP_U32a = rs1 ^ TMP_U32;
			if TMP_U32a<4..0> >= NWINDOWS then
				TRAP = 1;
				TMP_TT = ILLEGAL_INSTRUCTION;
				"gliss_error"("wrpsr: illegal instruction.\n");
			else
				PSR = TMP_U32a;
			endif;
		endif;
	}



op wrwim(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i==0 then
		format("wr %s, %s, %%wim", rs1.syntax, rs2.syntax)
	else
		format("wr %s, %d, %%wim", rs1.syntax, rs2.value)
	endif
image = format("%s 110010 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if PSR_S == 0 then
			TRAP = 1;
			TMP_TT = PRIVILEGED_INSTRUCTION;
			"gliss_error"("wrwim: privileged instruction.\n");
		else
			TMP_U32 = if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
			TMP_U32a = rs1 ^ TMP_U32;
			WIM = TMP_U32a;
		endif;
	}



op wrtbr(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i==0 then
		format("wr %s, %s, %%tbr", rs1.syntax, rs2.syntax)
	else
		format("wr %s, %d, %%tbr", rs1.syntax, rs2.value)
	endif
image = format("%s 110011 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		if PSR_S == 0 then
			TRAP = 1;
			TMP_TT = PRIVILEGED_INSTRUCTION;
			"gliss_error"("wrtbr: privileged instruction.\n");
		else
			TMP_U32 = if i == 0 then rs2 else coerce(int(32), rs2.value) endif;
			TMP_U32a = rs1 ^ TMP_U32;
			TBR<31..12> = TMP_U32a<31..12>;
			// don't care about TT, ensure low bits always null
			TBR<3..0> = 0;
		endif;
	}



op flush(rd : reg_mode_0, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if rs1.value == 0 then
		format("flush %s, %s", rs1.syntax, rs2.syntax)
	else
		format("flush %s, %d", rs1.syntax, rs2.value)
	endif
image = format("%s 111011 %s %1b %s", rd.image, rs1.image, i, rs2.image)
action =
	{
		// it can be unimplemented or illegal instruction (implementation dependent)
		// let's make it a nop
	}



op ticc(cond : int_cond, rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("t%s %s", cond.syntax, rs2.syntax)
	else
		format("t%s %d", cond.syntax, rs2.value<6..0>)
	endif
image = format("X %s 111010 %s %1b %s", cond.image, rs1.image, i, rs2.image)
action =
	{
		TMP_U32 = rs1 + if i == 0 then rs2 else coerce(u32, rs2.value<6..0>) endif;

		if cond then
			TRAP = 1;
			TMP_TT = 0x80 | TMP_U32<6..0>;
		else
			PC = nPC;
			nPC = nPC + 4;
		endif;

		BRANCH_EXECUTED = 1;
	}



op rett(rs1 : reg_mode_0, i : u1, rs2 : asi_or_simm)
syntax =
	if i == 0 then
		format("rett %s+%s", rs1.syntax, rs2.syntax)
	else
		format("rett %s+%d", rs1.syntax, coerce(s32, rs2.value))
	endif
image = format("XXXXX 111001 %s %1b %s", rs1.image, i, rs2.image)
action =
	{
		TMP_CWP = (CWP + 1) % NWINDOWS;
		TMP_U32 = rs1 + if i == 0 then rs2 else coerce(s32, rs2.value) endif;

		if PSR_ET == 1 then
			TRAP = 1;
			TMP_TT = if PSR_S == 0 then PRIVILEGED_INSTRUCTION else ILLEGAL_INSTRUCTION endif;
		else if PSR_S == 0 then
			TRAP = 1;
			TT = PRIVILEGED_INSTRUCTION;
			// the leon puts itself in error mode, only a reset can restart it
			"gliss_error"("rett: ERROR, privileged instruction, cannot continue.");
		else if (WIM & (1<<TMP_CWP)) != 0 then
			TRAP = 1;
			TT = WINDOW_UNDERFLOW;
			// the leon puts itself in error mode, only a reset can restart it
			"gliss_error"("rett: ERROR, window underflow, cannot continue.");
		else if TMP_U32<1..0> != 0 then
			TRAP = 1;
			TT = MEM_ADDRESS_NOT_ALIGNED;
			// the leon puts itself in error mode, only a reset can restart it
			"gliss_error"("rett: ERROR, address not aligned, cannot continue.");
		else
			PSR_ET = 1;
			PC = nPC;
			nPC = TMP_U32;
			CWP = TMP_CWP;
			PSR_S = PSR_PS;
			BRANCH_EXECUTED = 1;
		endif;
		endif;
		endif;
		endif;
	}



// definitions of floating point operations
include "fp.nmp"
// fault tolerant extensions
include "ft.nmp"

