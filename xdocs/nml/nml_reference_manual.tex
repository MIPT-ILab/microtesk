\documentclass[oneside,final,14pt]{extreport}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english]{babel}
\usepackage{vmargin}
\usepackage{listings}
\setpapersize{A4}
\usepackage{indentfirst}


\lstset{
 language=C,
 frame=single,
 basicstyle=\ttfamily\scriptsize,
 commentstyle=\itshape,
 emph={op, mode, reg, alias, mem, type, let, card, int, syntax, image, format, action,
       if, then, else, elif, endif, coerce, exception, address, segment, buffer, register,
       memory, mmu, range, ways, sets, match, tag, index, entry, policy, read, write,
       var, hit, path, transition, guard},
 emphstyle={\bfseries}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{titlepage}
\begin{center}
\Large{Institute for System Programming of the Russian Academy of Sciences}

\vfill


\bf\Large{nML Reference Manual}

(UNDER DEVELOPMENT)

\vfill

\bf
Moscow 2016
\end{center}
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\stepcounter{page} % Increase page counter by one
\tableofcontents

\newpage


\chapter{Introduction}

\section{Disclaimer}

This reference manual describes syntax and semantics of the nML architecture
description language. It covers only language facilities supported by the ISP RAS
version of nML. It may differ from documentation provided by other vendors as
there are differences in language implementations.

\section{Overview}

nML is an architecture description language (ADL) used to describe the
instruction set architecture (ISA) of an arbitrary microprocessor. It is a
flexible and easy-to-use language based on attribute grammar. nML was designed
to provide a retargetable way to specify microprocessor architecture for
various microprocessor-related software tools including instruction-set
simulators, assemblers, disassemblers, compiler back-ends etc. It works at
the instruction-set level concentrating on behavioral properties and hiding
implementation details. An nML specification represents a programmer's model
of the microprocessor which covers the following aspects:

\begin{itemize}
\item supported data types;
\item registers and memory;
\item addressing modes;
\item syntax and semantics of instructions.
\end{itemize}

nML uses a hierarchical tree-like structure to describe an instruction set.
Such a structure facilitates grouping related instructions and sharing their
common parts. An instruction is described as a path in the tree from the root
node to a leaf node. The set of all possible paths represents an instruction
set. A node describes a primitive operation responsible for some task within
an instruction. Each node has certain attributes that can be shared with its
descendants. Actions performed by instructions are described as operations
with registers and memory represented by bit vectors of arbitrary size.

A specification in nML starts with definitions of types and global constants.
For example, a type definition for a 32-bit unsigned integer looks as follows:

\begin{lstlisting}
let WORD_SIZE = 32
type WORD = card(WORD_SIZE)
\end{lstlisting}

Type definitions and constants can be used to describe registers and memory.
In addition to registers and memory, it is also possible to define temporary
variables that are internal abstractions provided by nML to store intermediate
results of operations. They do not correspond to any data storage in real
hardware and do not save their data across instruction calls. Also, there is
often a need to specify some properties of the described model. For this
purpose, special constants are used. For example, the code below defines
general-purpose registers, memory and a temporary variable. Also, it includes
a special constant to establish a correspondence between the general purpose
register number 15 and the program counter (PC). Here is the code:

\section{Constants}

A declaration like

\begin{lstlisting}
let A=100
\end{lstlisting}

declares a global constant A to have the value 100. Such a constant might be used in every context
its value could stand. Any constant may be defined only once. Constants may be used to extend nML:
Any information about a machine that can be given with a single number or string can easily be
defined as a constant (with a default value, so that standard nML descriptions still work).

In core nML, there is just one such constant (or global parameter).
This is the pipeline factor. On machines with an instruction pipeline visible to the programmer,
there are delay slots whenever a jump occurs. Usually, there is one such slot, but two are not
unheard of. A declaration

\begin{lstlisting}
let pipeline_factor=1
\end{lstlisting}

introduces one delay slot after each instruction that changes the program counter. The default
value is 0.

\section{Data Types}

A data type specifies the format of values stored in registers or memory. nML supports
the following data types: 

\begin{itemize}

\item int(N): N-bit signed integer data type. Negative numbers are stored in two's 
complement form. The range of possible values is [-2n-1 ... 2n-1 - 1].

\item card(N): N-bit unsigned integer data type. The range of possible values is [0 ... 2n - 1].

\item float(N, M): IEEE 754 floating point number, where fraction size is N and exponent size is M.
The resulting type size is N + M +1 bits, where 1 is an implicitly added bit for store the sign.
Supported floating-point formats include:

\begin{itemize}
\item 32-bit single-precision. Defined as float(23, 8).
\item 64-bit double-precision. Defined as float(52, 11).
\item 80-bit double-extended-precision. Defined as float(64, 15).
\item 128-bit quadruple-precision. Defined as float(112, 15).
\end{itemize}

\end{itemize}

nML allows declaring aliases for data types. Here is a simple type declaration:

\begin{lstlisting}
type DWORD = card(32)
\end{lstlisting}

In this example, type is a reserved word, DWORD is the declared alias type name, the card(32) is
the actual data type.

\subsection{Converting Data Types}

In nML, type conversion is performed explicitly using the following functions:

\begin{itemize}
\item sign{\_}extend(type, value).
Sign-extends the value to the specified type. Applied to any types. Requires
the new type to be larger or equal to the original type.

\item zero{\_}extend(type, value).
Zero-extends the value to the specified type. Applied to any types. Requires the new type to be larger or equal to the original type.

\item coerce(type, value).
Converts an integer value to another integer type. For smaller types the value is truncated, for larger types it is extended. If the original type is a signed integer, sign extension is performed. Otherwise, zero-extension is performed.

\item cast(type, value).
Reinterprets the value as the specified type. Applied to any types. The new type must be of the same size as the original type.

\item int{\_}to{\_}float(type, value).
Converts 32 and 64-bit integers into 32, 64, 80 and 128-bit floating-point values (IEEE 754).

\item float{\_}to{\_}int(type, value).
Converts 32, 64, 80 and 128-bit floating-point values (IEEE 754) into 32 and 64-bit integers.

\item float{\_}to{\_}float(type, value).
Converts 32, 64, 80 and 128-bit floating-point values (IEEE 754) into each other.

\end{itemize}


\lstinputlisting{examples/test.nml}

\addcontentsline{toc}{section}{\numberline{}Introduction}


\chapter{Appendixes}

\section{Grammar of nML}

\section{References}

% Related nML publications/documents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{thebibliography}{1}

\bibitem{freericks}
M.~Freericks.
\emph{The nML Machine Description Formalism}.
Technical Report TR SM-IMP/DIST/08, TU Berlin CS Department, 1993.

\end{thebibliography}

\end{document}
