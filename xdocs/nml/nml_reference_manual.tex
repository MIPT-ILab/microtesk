\documentclass[oneside,final,14pt]{extreport}

\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english]{babel}
\usepackage{vmargin}
\usepackage{listings}
\setpapersize{A4}
\usepackage{indentfirst}
\usepackage{graphicx}

\lstset{
 language=C,
 frame=single,
 basicstyle=\ttfamily\scriptsize,
 commentstyle=\itshape,
 emph={op, mode, reg, alias, mem, type, let, card, int, syntax, image, format, action,
       if, then, else, elif, endif, coerce, exception, address, segment, buffer, register,
       memory, mmu, range, ways, sets, match, tag, index, entry, policy, read, write,
       var, hit, path, transition, guard},
 emphstyle={\bfseries}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{titlepage}
\begin{center}
\Large{Institute for System Programming of the Russian Academy of Sciences}

\vfill


\bf\Large{nML Reference Manual}

(UNDER DEVELOPMENT)

\vfill

\bf
Moscow 2016
\end{center}
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\stepcounter{page} % Increase page counter by one
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Disclaimer}

This reference manual describes syntax and semantics of the nML architecture
description language. It covers only language facilities supported by the ISP RAS
version of nML. It may differ from documentation provided by other vendors as
there are differences in language implementations.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Overview}

nML is an architecture description language (ADL) used to describe the
instruction set architecture (ISA) of an arbitrary microprocessor. It is a
flexible and easy-to-use language based on attribute grammar. nML was designed
to provide a retargetable way to specify microprocessor architecture for
various microprocessor-related software tools including instruction-set
simulators, assemblers, disassemblers, compiler back-ends etc. It works at
the instruction-set level concentrating on behavioral properties and hiding
implementation details. An nML specification represents a programmer's model
of the microprocessor which covers the following aspects:

\begin{itemize}
\item supported data types;
\item registers and memory;
\item addressing modes;
\item syntax and semantics of instructions.
\end{itemize}

nML uses a hierarchical tree-like structure to describe an instruction set.
Such a structure facilitates grouping related instructions and sharing their
common parts. An instruction is described as a path in the tree from the root
node to a leaf node. The set of all possible paths represents an instruction
set. A node describes a primitive operation responsible for some task within
an instruction. Each node has certain attributes that can be shared with its
descendants. Actions performed by instructions are described as operations
with registers and memory represented by bit vectors of arbitrary size.

A specification in nML starts with definitions of types and global constants.
For example, a type definition for a 32-bit unsigned integer looks as follows:

\begin{lstlisting}
let WORD_SIZE = 32
type WORD = card(WORD_SIZE)
\end{lstlisting}

Type definitions and constants can be used to describe registers and memory.
In addition to registers and memory, it is also possible to define temporary
variables that are internal abstractions provided by nML to store intermediate
results of operations. They do not correspond to any data storage in real
hardware and do not save their data across instruction calls. Also, there is
often a need to specify some properties of the described model. For this
purpose, special constants are used. For example, the code below defines
general-purpose registers, memory and a temporary variable. Also, it includes
a special constant to establish a correspondence between the general purpose
register number 15 and the program counter (PC). Here is the code:

\begin{lstlisting}
reg GPR[32, WORD]
mem M[2 ** 20, BYTE]
var carry[1, BIT]
let PC = "GPR[15]"
\end{lstlisting}

As stated above, an instruction set is described as a tree of primitive
operations. There two kinds of primitives: operations and addressing modes.
Operations describe parts of instructions responsible for specific tasks and
can be used as leaf and root nodes. Addressing modes are aimed to customize
operations (for example, they encapsulate rules for accessing microprocessor
resources). They can only be used as leaf nodes. For example, here are
simplified examples of operation and addressing mode specifications:

\begin{lstlisting}
mode REG(i: nibble) = R[i]
syntax = format("R%d", i)
image  = format("01%4b", i)
\end{lstlisting}

\begin{lstlisting}
op Add()
syntax = "add" 
image  = "00" 
action = { DEST = SRC1 + SRC2; }
\end{lstlisting}

Operations and addressing modes have three standard attributes: syntax, image
and action. The first two specify textual and binary syntax. The third
describes semantics of the primitive. In addition, addressing modes have
a return expression that enables them to be used as variables in various
expressions. Attributes can be used by parent primitives referring to a given
primitive to describe more complex abstractions.

Primitives are arranged into a tree using production rules. There are two kinds
of production rules: AND rules and OR rules. AND rules specify parent-child
relationships where a child primitive is described as a parameter of its
parent. Here is an example of an AND rule:

\begin{lstlisting}
op arith_inst(act: Add, op1: OPRND, op2: OPRND)
\end{lstlisting}

This is the header of the "arith{\_}inst" operation that states that the
"arith{\_}inst" operation node has three child nodes: the "act" operation and the
"op1" and "op2" addressing modes. The syntax of an operation header is similar
to a function where parameter types specify the primitives the rule refers to.
Parameter can be, in turn, parameterized with other primitives (they will be
encapsulated behind attributes). For this reason child nodes represent
independent instances that are accessed from their parent node via parameters.
OR rules specify alternatives. This means that a group of primitives is united
under some alias so that each of them can used when this alias is specified in
an AND rule. An OR rule looks as follows:

\begin{lstlisting}
op Add_Sub_Mov = Add | Sub | Mov
\end{lstlisting}

Figure 1 displays a tree path describing the "mov" instruction from an
imaginary instruction set. This instruction copies data from one register to
another. The root operation of the instruction is called "instruction".
According to nML conventions, the root operation is always called "instruction"
and it specifies the point from which all paths describing specific
instructions start. The "instruction" operation can be defined either as AND or
OR rule. In the latter case, there are several starting points. Usually root
operations holds some common properties and perform common actions (such as
increment of the program counter). In the given example, the root operation is
linked to the "Arithm" operation with the help of an AND rule. This operation
describes a group of arithmetic operations. It is parameterized with the
"Add{\_}Mov{\_}Sub" and "OPRND" primitives. Both of them are specified as OR rules.
The first one describes arithmetic operations that can be performed by the
"Arithm" primitive while the second one specifies supported addressing modes.
Dashed lines that connect OR-rules with their child primitives specify possible
alternative paths. Instructions are identified by the terminal operation node of
the path (in this example, it is the "Mov" node). An important note is that, to
avoid ambiguity, nodes can have only one child operation.

\begin{figure}
\centering
\includegraphics [width=0.8\textwidth]
{figures/figure1.png}
\caption{Operation tree for the Mov instruction}
\label{nml-instruction-tree}
\end{figure}

The syntax of nML resembles the syntax of the pseudocode used in microprocessor
architecture manuals to describe instruction semantics. For example, here is the
description of instruction ADD from the MIPS64 manual:

%\begin{lstlisting}
%if NotWordValue(GPR[rs]) or NotWordValue(GPR[rt]) then
%    UNPREDICTABLE
%endif
%temp ← GPR[rs]31||GPR[rs]31..0) + (GPR[rt]31||GPR[rt]31..0)
%if temp32 ≠ temp31 then
%    SignalException(IntegerOverflow)
%else
%    GPR[rd] ← sign_extend(temp31..0)
%endif
%\end{lstlisting}

Such a description can be translated to nML with minimal effort. Providing that
all needed data types, resources and operations describing common functionality
of instructions have already been specified, the specification of the ADD
instruction (or, to be more precise, the terminal operation that distinguishes 
it from other similar instructions) will look as follows:

\begin{lstlisting}
op ADD(rd: GPR, rs: GPR, rt: GPR)
action = {
  if (NotWordValue(rs) || NotWordValue(rt)) then
    UNPREDICTABLE();
  endif;
  tmp_word = rs<31>::rs<31..0> + rs<31>::rt<31..0>;
  if(tmp_word<32> != tmp_word<31>) then
    SignalException("IntegerOverflow");
  else
    rd = sign_extend(tmp_word<31..0>);
  endif;
}
\end{lstlisting}

As we can see, describing an instruction based on an instruction set manual is
a relatively easy task that can be performed by a verification engineer who
does not have significant programming skills.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Constants}

A declaration like

\begin{lstlisting}
let A=100
\end{lstlisting}

declares a global constant A to have the value 100. Such a constant might be used in every context
its value could stand. Any constant may be defined only once. Constants may be used to extend nML:
Any information about a machine that can be given with a single number or string can easily be
defined as a constant (with a default value, so that standard nML descriptions still work).

In core nML, there is just one such constant (or global parameter).
This is the pipeline factor. On machines with an instruction pipeline visible to the programmer,
there are delay slots whenever a jump occurs. Usually, there is one such slot, but two are not
unheard of. A declaration

\begin{lstlisting}
let pipeline_factor=1
\end{lstlisting}

introduces one delay slot after each instruction that changes the program counter. The default
value is 0.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Data Types}

A data type specifies the format of values stored in registers or memory. nML supports
the following data types: 

\begin{itemize}

\item int(N):
N-bit signed integer data type. Negative numbers are stored in two's complement
form. The range of possible values is [-2$^{n-1}$ ... 2$^{n-1}$ - 1].

\item card(N):
N-bit unsigned integer data type. The range of possible values is [0 ... 2$^n$ - 1].

\item float(N, M): IEEE 754 floating point number, where fraction size is N and exponent size is M.
The resulting type size is N + M +1 bits, where 1 is an implicitly added bit for store the sign.
Supported floating-point formats include:

\begin{itemize}
\item 32-bit single-precision. Defined as float(23, 8).
\item 64-bit double-precision. Defined as float(52, 11).
\item 80-bit double-extended-precision. Defined as float(64, 15).
\item 128-bit quadruple-precision. Defined as float(112, 15).
\end{itemize}

\end{itemize}

nML allows declaring aliases for data types. Here is a simple type declaration:

\begin{lstlisting}
type DWORD = card(32)
\end{lstlisting}

In this example, type is a reserved word, DWORD is the declared alias type name, the card(32) is
the actual data type.

\subsection{Converting Data Types}

In nML, type conversion is performed explicitly using the following functions:

\begin{itemize}
\item sign{\_}extend(type, value).
Sign-extends the value to the specified type. Applied to any types. Requires
the new type to be larger or equal to the original type.

\item zero{\_}extend(type, value).
Zero-extends the value to the specified type. Applied to any types. Requires the new type to be larger or equal to the original type.

\item coerce(type, value).
Converts an integer value to another integer type. For smaller types the value is truncated, for larger types it is extended. If the original type is a signed integer, sign extension is performed. Otherwise, zero-extension is performed.

\item cast(type, value).
Reinterprets the value as the specified type. Applied to any types. The new type must be of the same size as the original type.

\item int{\_}to{\_}float(type, value).
Converts 32 and 64-bit integers into 32, 64, 80 and 128-bit floating-point values (IEEE 754).

\item float{\_}to{\_}int(type, value).
Converts 32, 64, 80 and 128-bit floating-point values (IEEE 754) into 32 and 64-bit integers.

\item float{\_}to{\_}float(type, value).
Converts 32, 64, 80 and 128-bit floating-point values (IEEE 754) into each other.

\end{itemize}


\lstinputlisting{examples/test.nml}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Appendixes}

\section{Grammar of nML}

\section{References}

% Related nML publications/documents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\addcontentsline{toc}{section}{\numberline{}Bibliography}
\begin{thebibliography}{1}

\bibitem{freericks}
M.~Freericks.
\emph{The nML Machine Description Formalism}.
Technical Report TR SM-IMP/DIST/08, TU Berlin CS Department, 1993.

\end{thebibliography}

\end{document}
